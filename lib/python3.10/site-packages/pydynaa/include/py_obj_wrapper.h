/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * 
 * File: py_obj_wrapper.h
 * 
 * This file is part of the PyDynAA package.
 * It is subject to the NetSquid Software End User License Conditions.
 * A copy of these conditions can be found in the LICENSE.md file of this package.
 * 
 * Authors
 * =======
 * 
 * - Julio de Oliveira Filho
 * - Rob Knegjens
 * - Coen van Leeuwen
 * - Joost Adriaanse
 * 
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */
// NOTE: a guard with license and author info is auto added to package distributions (see setup.py)
#ifndef _INCLUDED_PY_OBJ_WRAPPER_
#define _INCLUDED_PY_OBJ_WRAPPER_
/* Wrapper class that holds a PyObject* and defines operator(). By defining the latter
 * it can be converted to std::function. Most of this class is just reference counting.
 * See https://stackoverflow.com/questions/39044063/pass-a-closure-from-cython-to-c
 */

#include <Python.h>
#include "event.h"
#include "eventexpression.h"
#include <memory>

extern "C" void _call_obj(PyObject *, dynaa::Event ev);
extern "C" void _call_obj_expr(PyObject *, std::shared_ptr<dynaa::EventExpression> evExpr);

namespace dynaa {

class PyObjWrapper {
public:
    // constructors and destructors mostly do reference counting
    PyObjWrapper(PyObject* o): held(o) {
        Py_XINCREF(o);
    }

    PyObjWrapper(const PyObjWrapper& rhs): PyObjWrapper(rhs.held) { // C++11 onwards only
    }

    PyObjWrapper(PyObjWrapper&& rhs): held(rhs.held) {
        rhs.held = 0;
    }

    // need no-arg constructor to stack allocate in Cython
    PyObjWrapper(): PyObjWrapper(nullptr) {
    }

    ~PyObjWrapper() {
        Py_XDECREF(held);
    }

    PyObjWrapper& operator=(const PyObjWrapper& rhs) {
        PyObjWrapper tmp = rhs;
        return (*this = std::move(tmp));
    }

    PyObjWrapper& operator=(PyObjWrapper&& rhs) {
        held = rhs.held;
        rhs.held = 0;
        return *this;
    }

    void operator()(dynaa::Event ev) {
        if (held) { // nullptr check 
            _call_obj(held, ev); // note, no way of checking for errors until you return to Python
            //PyErr_CheckSignals();
        }
    }

    void operator()(std::shared_ptr<dynaa::EventExpression> evExpr) {
        if (held) { // nullptr check 
            _call_obj_expr(held, evExpr); // note, no way of checking for errors until you return to Python
        }
    }

private:
    PyObject* held;
};

}
#endif
