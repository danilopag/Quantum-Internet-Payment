# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: constrainedmap.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt
"""
Classes to constrain a value or variable within a mapping.
For example to check for type, make it mutable or set some bounds.

Used in the :obj:`~netsquid.components.component.Component` class to restrict
users to input incorrect values or modify them during a run

"""
from collections.abc import Mapping
from inspect import signature

__all__ = [
    "ConstrainedMap",
    "ConstrainedMapView",
    "ValueConstraint",
    "positive_constr",
    "negative_constr",
    "nonnegative_constr",
    "nonpositive_constr",
    "not_none_constr",
    "integer_constr",
    "ConstraintError",
    "ImmutabilityError",
]


class ConstrainedMap(Mapping):
    """A mapping used for storing key-value pairs subject to constraints.

    Functions similarly to a dict except that items can only be *set* if they
    are already present and, where applicable, are mutable, have the correct type,
    and pass any set constraints.

    Parameters
    ----------
    data : dict or None, optional
        Key-value pairs to initialize map with. None if map is empty.
    mutability : dict or None, optional
        Whether each key is mutable.
    types : dict or None, optional
        Type of each key. None indicates no fixed type.
    value_constraints : dict or None, optional
        :obj:`~netsquid.util.constrainedmap.ValueConstraint`\\s for each key. None indicates no extra constraints
    global_constraints : list, optional
        :obj:`~netsquid.util.constrainedmap.ValueConstraint`\\s that act on all keys.

    """

    def __init__(self, data=None, mutability=None, types=None, value_constraints=None, global_constraints=None):
        self._data = {}
        self._type = {}
        self._mutable = {}
        self._constraints = {}
        if global_constraints is not None and not isinstance(global_constraints, list):
            global_constraints = [global_constraints]
        self._global_constraints = global_constraints or []  # List of ValueConstraints that act on all keys
        if data is None:
            data = {}
        for key, value in data.items():
            if mutability is not None and key in mutability:
                mutable = mutability[key]
            else:
                mutable = True
            if types is not None:
                value_type = types.get(key)
            else:
                value_type = None
            if value_constraints is not None:
                constraints = value_constraints.get(key)
            else:
                constraints = None
            self.internal_add(key,
                              value=value,
                              mutable=mutable,
                              value_type=value_type,
                              value_constraints=constraints)

    def __getitem__(self, key):
        return self._data[key]

    def __len__(self):
        return len(self._data)

    def __iter__(self):
        return iter(self._data)

    def __setitem__(self, key, value):
        if key not in self:
            self.internal_add(key, value)
            return
        if key in self._mutable and not self._mutable[key]:
            raise ImmutabilityError("Key {} is an immutable item".format(key))
        if self._type[key] is not None and value is not None and not isinstance(value, self._type.get(key)):
            raise TypeError("Value {} for key {} is a {}, not a {}".format(value, key, type(value), self._type[key]))
        if self._constraints[key] is not None:
            for constraint in self._constraints[key]:
                if not constraint.check(value):
                    raise ConstraintError("Value {} did not pass constraint checks".format(value))
        for map_constraint in self._global_constraints:
            if not map_constraint.check(value):
                raise ConstraintError("Value {} did not pass constraint checks".format(value))
        self._data[key] = value

    def __delitem__(self, key):
        del self._data[key]

    def get_type(self, key):
        """tuple of type or None: get the type(s) of item corresponding to a key."""
        return self._type[key]

    def get_mutable(self, key):
        """bool: get whether the item corresponding to a key is mutable."""
        return self._mutable[key]

    def get_global_constraints(self):
        """list of :obj:`~netsquid.util.constrainedmap.ValueConstraint`: get the global constraints of this map"""
        return self._global_constraints

    def get_constraints(self, key):
        """list of :obj:`~netsquid.util.constrainedmap.ValueConstraint`: get the list of constraints of this key"""
        return self._constraints[key]

    def update(self, items):
        if items is self:
            return
        if isinstance(items, (dict, ConstrainedMap)):
            items = items.items()
        for key, value in items:
            self[key] = value

    def internal_add(self, key, value=None, mutable=True, value_type=None, value_constraints=None):
        """Add an item to this mapping.

        This is an internal method that is not intended to be called by users
        of this mapping.

        Parameters
        ----------
        key : hashable
            Key of item.
        value : Any
            Value of item.
        mutable : bool, optional
            Whether item is mutable.
        value_type : type, tuple of type or None, optional
            Type of item or None if no type.
        value_constraints : :obj:`~netsquid.util.constrainedmap.ValueConstraint` or\
                list of `~netsquid.util.constrainedmap.ValueConstraint` , optional
            Constraint check such as type and bounds

        Raises
        ------
        KeyError
            If the key already exists in the mapping.

        """
        if value_constraints is None:
            value_constraints = []
        # if not isinstance(key, str):
        #    raise TypeError("Key {} is not a valid string.".format(key))
        if value_type is None:
            pass
        elif isinstance(value_type, tuple):
            for v_type in value_type:
                if not isinstance(v_type, type):
                    raise TypeError(f"value types {v_type} in a tuple must be a type, not {type(v_type)}.")
        elif not isinstance(value_type, type):
            raise TypeError(f"value_type {value_type} must be None, a type, or a tuple of types.")
        if isinstance(value_constraints, ValueConstraint):
            value_constraints = [value_constraints]
        if not isinstance(value_constraints, list):
            raise TypeError("value_constraints should be ValueConstraint or a list of ValueConstraint")
        for value_constraint in value_constraints:
            if not isinstance(value_constraint, ValueConstraint):
                raise TypeError("value_constraint is not a ValueConstraint but a {}".format(type(value_constraint)))
        if key in self._data:
            raise KeyError("Key {} already exists in this mapping, cannot add it again.".format(key))
        # TODO, remove below code. Is already checked when doing self[key] = value
        # # Check global constraints
        # for constraint in self._global_constraints:
        #     if not constraint.check(value):
        #         raise ConstraintError("Value {} did not pass global constraint checks".format(value))
        self._type[key] = value_type
        self._constraints[key] = value_constraints
        # Need to set it twice so it will call the correct check the first time
        self._data[key] = None
        self[key] = value
        self._mutable[key] = mutable

    def internal_del(self, key):
        """Remove an item from the mapping.

        This is an internal method that is not intended to be called by users
        of this mapping.

        Parameters
        ----------
        key : str
            Key of item.

        """
        if key in self:
            del self._data[key]
            del self._constraints[key]
            del self._type[key]
            del self._mutable[key]

    def filter_by_type(self, value_type):
        """Get the keys of this map which values are of the given type

        Parameters
        ----------
        value_type : type
            type or class of items to filter the mapping on

        Returns
        -------
        :class:`~netsquid.util.constrainedmap.ConstrainedMapView`
            A view of this constrained map containing only key value pairs of the given type.

        Notes
        -----
        The returned object is immutable; changing the map doesn't change the returned object.

        """
        if not isinstance(value_type, type):
            raise TypeError("value_type must be an object or class")
        return ConstrainedMapView(self, [ValueConstraint(lambda value: isinstance(value, value_type))])

    def __repr__(self):
        # return "ConstrainedMap(data={}, mutability={}, constraints={})".format(
        #    repr(self._data), repr(self._mutable), repr(self._constraints))
        return "ConstrainedMap({})".format(repr(self._data))


class ConstrainedMapView(Mapping):
    """Mapping that filters out values of a dict or constrained map.

    When iterating over this view or getting items from this view it will filter out the items that
    do not pass the constraints.

    Parameters
    ----------
    constrained_map : :obj:`~netsquid.util.constrainedmap.ConstrainedMap`
        Constrained map to filter based on constraints.
    constraints : list of :obj:`~netsquid.util.constrainedmap.ValueConstraint`
        The constraints to filter on.

    Example
    -------

    >>> from netsquid.util.constrainedmap import (ConstrainedMap,
    ...                                           ConstrainedMapView,
    ...                                           ValueConstraint)
    ...
    >>> cm = ConstrainedMap({"a": 4, "b":-5, "c": 1000, "d": 42})
    >>> map_view = ConstrainedMapView(cm, [ValueConstraint(lambda x: x > 0),
    ...                                    ValueConstraint(lambda x : x < 100)])
    >>> len(map_view)
    2
    >>> print(map_view)
    ConstrainedMapView({'a': 4, 'd': 42})
    >>> for i in map_view:
    ...     print(i)
    a
    d
    >>> "a" in map_view
    True
    >>> "b" in map_view
    False
    >>> cm["b"] = 34
    >>> "b" in map_view
    True
    >>> map_view["b"]
    34
    >>> for k, v in map_view.items():
    ...     print(k, v)
    a 4
    b 34
    d 42
    >>> print([k for k in map_view.keys()])
    ['a', 'b', 'd']
    >>> print([v for v in map_view.values()])
    [4, 34, 42]

    """

    def __init__(self, constrained_map, constraints):
        if not isinstance(constrained_map, ConstrainedMap):
            raise TypeError
        if not all(isinstance(c, ValueConstraint) for c in constraints):
            raise TypeError
        self._map = constrained_map
        self.constraints = constraints

    @property
    def map(self):
        """:obj:`~netsquid.util.constrainedmap.ConstrainedMap`: constrained map this is a view of."""
        return self._map

    def __getitem__(self, key):
        item = self._map.__getitem__(key)
        if all(constraint.check(item, False) for constraint in self.constraints):
            return item
        raise KeyError(key)

    def __len__(self):
        return sum(1 for __ in self)

    def __iter__(self):
        for key in self._map.__iter__():
            if key in self:
                yield key

    def __repr__(self):
        res = {f'{k}': v for k, v in self.items()}
        return f"ConstrainedMapView({res})"


class ValueConstraint:
    """An object used by constrained maps to set constraints for its values.

    Values that are changed on runtime (if they are mutable) should still be valid.
    By using a list of value constraints in a :obj:`~netsquid.util.constrainedmap.ConstrainedMap`
    these values can be validated.

    Parameters
    ----------
    constraint_function : callable
        A lambda, method, function or any other callable with 1 argument that should return True
        if the value passes the constraint test
    error_message : str, optional
        Error message to show when value is not valid
    error_type : Exception, optional
        Exception to raise when value is not valid, default is a ValueError

    """

    def __init__(self, constraint_function, error_message=None, error_type=None):
        if constraint_function:
            if not callable(constraint_function):
                raise TypeError("constraint_function should be a callable (function, lambda, etc.")
            if len(signature(constraint_function).parameters) != 1:
                raise ValueError("constraint_function should take 1 argument")
        if error_type is not None and not issubclass(error_type, Exception):
            raise TypeError("error type should be an exception class")
        self._constraint = constraint_function
        self.error_message = error_message or "Value did not pass constraint check"
        self._constraint_exception = error_type or ValueError

    def check(self, value, throw_error=True):
        """Checks if value passes the constraint, if not raises the specified error.

        Parameters
        ----------
        value : object
            object to check the constraints on
        throw_error : bool, optional
            whether an error should be thrown (true) or False should be returned.
            Default True

        Returns
        -------
        bool
            True if value passes the constraint check
            False if it does not pass and throw_error is False
        """
        if self._constraint:
            if not self._constraint(value):
                if throw_error:
                    raise self._constraint_exception(str(value) + ": " + self.error_message)
                else:
                    return False
        return True

    def constr_not(self, error_message=None, error_type=None):
        """Negates the current constraint.

        Parameters
        ----------
        error_message : str, optional
            Error message to show when value is not valid, None will keep error message of self
        error_type : Exception, optional
            Exception to raise when value is not valid, default is error of self

        Returns
        -------
        :obj:`~netsquid.util.constrainedmap.ValueConstraint`
            A new ValueConstraint that passes value if and only if self would not pass the value

        """
        return ValueConstraint(lambda x: not self._constraint(x),
                               error_message=error_message,
                               error_type=error_type or self._constraint_exception)

    def constr_and(self, other):
        """Combines two constraints, where both should be true
        Parameters
        ----------
        other: :obj:`~netsquid.util.constrainedmap.ValueConstraint`
            constraint to combine this constraint with

        Returns
        -------
        :obj:`~netsquid.util.constrainedmap.ValueConstraint`
            A new ValueConstraint that passes value if both constraints are true

        Notes
        -----
            Obsolete, can also pass a list of ValueConstraints into the map, or rewrite the value constraint

        """
        # # This message will only show if a check returns False instead of raising an error
        # # (Should we allow that behaviour?)
        # if error_message is None and self.error_message is not None and other.error_message is not None:
        #     error_message = "(" + self.error_message + " and " + other.error_message + ")"
        return ValueConstraint(constraint_function=lambda x: self.check(x) and other.check(x))


class ConstraintError(Exception):
    pass


class ImmutabilityError(ConstraintError):
    pass


positive_constr = ValueConstraint(constraint_function=lambda x: x > 0, error_message="Value should be positive")
"""Constrain a value to be positive."""

negative_constr = ValueConstraint(constraint_function=lambda x: x < 0, error_message="Value should be negative")
"""Constrain a value to be negative."""

nonnegative_constr = negative_constr.constr_not(error_message="Value should be non-negative")
"""Constrain a value to be non-negative."""

nonpositive_constr = positive_constr.constr_not(error_message="Value should be non-positive")
"""Constrain a value to be non-positive."""

not_none_constr = ValueConstraint(constraint_function=lambda x: x is not None, error_message="Value can't be None")
"""Constrain a value to not be None."""


def _is_int(x):
    try:
        return int(x) == x
    except Exception:
        return False


integer_constr = ValueConstraint(constraint_function=_is_int,
                                 error_message="Value should be integer",
                                 error_type=TypeError)
"""Constrain a value to be integer valued."""
