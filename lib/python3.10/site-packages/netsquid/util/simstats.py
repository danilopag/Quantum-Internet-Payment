# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: simstats.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt
"""Defines a class for collecting simulation statistics.

Examples
--------
Some of the functions provide example code snippets.
These snippets should run unedited if you set up a Python
interpreter with the following imports:

>>> import netsquid as ns
>>> from netsquid.util.simstats import *

"""
from time import time
from operator import itemgetter
import datetime
from collections import Counter
from contextlib import contextmanager
from pydynaa import SimulationEngine
__all__ = [
    "SimStats",
]

# Counters for quantum operations and quantum state size
counter_qops = Counter()
counter_qsize = Counter()


class SimStats:
    """Collector of simulation statistics.

    Will collect statistics such as wall-time and simulation-time,
    quantum operations, triggered events and called handlers, etc.

    Examples
    --------

    >>> stats = SimStats()
    >>> stats.start()
    >>> q1, q2 = ns.qubits.create_qubits(2)
    >>> ns.qubits.operate([q1, q2], ns.CNOT)
    >>> stats.end()
    >>> print(stats.data["quantum_ops_total"])
    1
    >>> print(stats.summary())
    ...

    """
    # Reference to singleton
    simengine = SimulationEngine()

    def __init__(self):
        self._startdata = {}
        self._enddata = {}
        self.start()

    def start(self):
        """Start the collection of simulation statistics.

        Resets any previous data collection.

        """
        self._startdata.clear()
        self._enddata.clear()
        self._startdata["wall_time"] = time()
        self._startdata["sim_time"] = self.simengine.current_time
        self._startdata["qops"] = counter_qops.copy()
        self._startdata["qsize"] = counter_qsize.copy()
        self._startdata["sim_info"] = self.simengine.get_diagnostic_info()

    def end(self):
        """Finalise the collection of simulation statistics.

        """
        self._enddata = self.data

    @property
    def ended(self):
        """bool: whether collection has ended."""
        return len(self._enddata) > 0

    @property
    def data(self):
        """dict: accumulated simulation statistics."""
        if len(self._enddata) > 0:
            return self._enddata
        data = {}
        sim_info = self.simengine.get_diagnostic_info()
        data["elapsed_wall_time"] = time() - self._startdata["wall_time"]
        data["elapsed_sim_time"] = self.simengine.current_time - self._startdata["sim_time"]
        data["events_triggered"] = sim_info["num_past_events"] - self._startdata["sim_info"]["num_past_events"]
        data["handled_callbacks"] = sim_info["num_handler_calls"] - self._startdata["sim_info"]["num_handler_calls"]
        diff_qops = counter_qops - self._startdata["qops"]
        qops = [(opname, count) for opname, count in diff_qops.items()]
        qops.sort(key=itemgetter(1, 0), reverse=True)
        data["quantum_ops_total"] = sum(diff_qops.values())
        data["quantum_ops_freq"] = qops
        diff_qsize = counter_qsize - self._startdata["qsize"]
        if len(diff_qsize):
            data["qstate_max_size"] = max(diff_qsize.keys())
            data["qstate_avg_size"] = sum([size * freq for size, freq in diff_qsize.items()]) / sum(diff_qsize.values())
        else:
            data["qstate_max_size"] = 0
            data["qstate_avg_size"] = 0
        return data

    def summary(self):
        """str: a printable summary of the accumulated data."""
        data = self.data
        summary = "\nSimulation summary\n"
        summary += "==================\n\n"
        summary += "Elapsed wallclock time: {}\n".format(datetime.timedelta(seconds=data["elapsed_wall_time"]))
        summary += "Elapsed simulation time: {:.2e} [ns]\n".format(data["elapsed_sim_time"])
        summary += "Triggered events: {}\n".format(data["events_triggered"])
        summary += "Handled callbacks: {}\n".format(data["handled_callbacks"])
        summary += "Total quantum operations: {}\n".format(data["quantum_ops_total"])
        num_freq_qops = 5
        qops_freq = "; ".join(["{} = {}".format(qop[0], qop[1]) for qop in data["quantum_ops_freq"][:num_freq_qops]])
        if len(data["quantum_ops_freq"]) > num_freq_qops:
            qops_freq += ", ..."
        summary += "Frequent quantum operations: {}\n".format(qops_freq)
        summary += "Max qstate size: {} qubits\n".format(data["qstate_max_size"])
        summary += "Mean qstate size: {:.2f} qubits\n".format(data["qstate_avg_size"])
        return summary

    @classmethod
    def timeline_status(cls):
        """str: status of simulation timeline."""
        return "Timeline status: {:e} [ns]; {} events scheduled; {} handlers waiting.".format(
            cls.simengine.current_time, cls.simengine.num_events, cls.simengine.num_handlers)

    def __repr__(self):
        return "SimStats()"

    def __str__(self):
        return self.summary()

    @contextmanager
    def record(self):
        """Context manager for recording simulation statistics.

        Starts and ends this object.

        Used by the :func:`~netsquid.util.simtools.sim_run` function
        to record simulation run statistics.

        Example
        -------

        >>> stats = SimStats()
        >>> with stats.record():
        ...     q1, q2 = ns.qubits.create_qubits(2)
        ...     ns.qubits.operate([q1, q2], ns.CNOT)
        >>> assert(stats.ended)
        >>> print(stats)
        ...

        """
        self.start()
        yield
        self.end()
