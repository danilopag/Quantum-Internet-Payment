# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_cycache.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"""Unit tests for the cycache module.

"""
import unittest
from netsquid.util.cycache import LruCache


class TestCycache(unittest.TestCase):
    """Unit tests for the cycache module.

    """

    def setUp(self):
        self.SIZE_LIMIT = 3
        self.cache = LruCache(size_limit=self.SIZE_LIMIT)

    def test_LruCache_init(self):
        """Test initialization of an LruCache"""
        self.assertEqual(self.cache.size_limit, self.SIZE_LIMIT)
        self.assertEqual(len(self.cache), 0)

        # max_size should be >= 1 and int
        for size in [-1, 0]:
            with self.assertRaises(ValueError):
                LruCache(size_limit=size)
        for size in ['a', None]:
            with self.assertRaises(TypeError):
                LruCache(size_limit=size)

    def test_LruCache_caching(self):
        """Test if caching capability works"""
        # check if data is stored on cache
        for i in range(5):
            self.cache[i] = i**2
            self.assertEqual(self.cache[i], i**2)
        # check if key error is raised when requesting a wrong key
        with self.assertRaises(KeyError):
            self.cache[10]

    def test_LruCache_lru(self):
        """Test if the least recently used item is removed from cache."""
        # test using get
        # fill cache
        self.cache.size_limit = 6
        for i in range(6):
            self.cache[i] = i**2
        # use get
        for key in [0, 2, 4]:
            self.cache[key]
        # add items and check if the correct items are removed
        self.cache[6] = 6**2
        self.cache[7] = 7**2
        for key in [0, 2, 4, 5]:
            self.assertEqual(self.cache[key], key**2)
        for key in [1, 3]:
            with self.assertRaises(KeyError):
                self.cache[key]

        # test using set
        # fill cache
        self.cache.size_limit = 6
        for i in range(6):
            self.cache[i] = i**2
        # use set
        for key in [0, 2, 4]:
            self.cache[key] = key**2
        # add items and check if the correct items are removed
        self.cache[6] = 6**2
        self.cache[7] = 7**2
        for key in [0, 2, 4, 5]:
            self.assertEqual(self.cache[key], key**2)
        for key in [1, 3]:
            with self.assertRaises(KeyError):
                self.cache[key]

    def test_LruCache_clear(self):
        """Test if the clear function clears the cache"""
        self.cache[1] = 99
        self.assertEqual(self.cache[1], 99)
        self.cache.clear()
        with self.assertRaises(KeyError):
            self.cache[1]
        self.assertEqual(len(self.cache), 0)

    def test_LruCache_get(self):
        """Test if the get function returns the correct value"""
        self.cache[1] = 99
        self.assertEqual(self.cache[1], 99)
        # test if the correct value is returned
        self.assertEqual(self.cache.get(1, 'default'), self.cache[1])
        # test if the default value is returned
        self.assertEqual(self.cache.get(2), None)
        self.assertEqual(self.cache.get(2, 'default'), 'default')
        self.assertEqual(self.cache.get(None, 'default'), 'default')


if __name__ == "__main__":
    unittest.main()
