# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_constrainedmap.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import unittest

from netsquid.util.constrainedmap import ConstrainedMap, ImmutabilityError, ValueConstraint


class TestConstrainedMap(unittest.TestCase):
    """Unit tests for the constrained map class.

    """

    def test_basic_mapping(self):
        """Test basic mapping methods."""
        cont = ConstrainedMap()
        mutable = {'a': 1, 'b': 2, 'c': 3}
        immutable = {'d': 4, 'e': 5, 'f': 6}
        typed = {'g': 7.0, 'h': 8, 'i': 'nine'}
        for key, value in mutable.items():
            cont.internal_add(key, value, mutable=True)
        for key, value in immutable.items():
            cont.internal_add(key, value, mutable=False)
        for key, value in typed.items():
            cont.internal_add(key, value, value_type=type(value))
        self.assertEqual(cont["a"], 1)
        self.assertEqual(cont["e"], 5)
        self.assertEqual(cont["i"], 'nine')
        self.assertEqual(len(cont), len(mutable) + len(immutable) + len(typed))
        for key, value in cont.items():
            self.assertTrue(key in mutable or key in immutable or key in typed)
            self.assertEqual(not cont.get_mutable(key), key in immutable)
            if key in typed:
                self.assertEqual(cont.get_type(key), type(value))
        with self.assertRaises(KeyError):
            cont["foo"]
        cont["a"] = 4.0
        cont["h"] = 9
        self.assertEqual(cont["a"], 4.0)
        self.assertEqual(cont["h"], 9)
        with self.assertRaises(ImmutabilityError):
            cont["d"] = 44
        with self.assertRaises(TypeError):
            cont["h"] = 9.0
        with self.assertRaises(TypeError):
            cont["i"] = 0

    def test_update(self):
        """Test updating."""
        cont = ConstrainedMap()
        dict1 = {'a': 1, 'b': 2, 'c': 3}
        dict2 = {'a': 2, 'b': 4}
        for key, value in dict1.items():
            cont.internal_add(key, value, mutable=True)
        dict1.update(dict2)
        cont.update(dict2)
        self.assertEqual(cont, dict1)
        cont2 = ConstrainedMap()
        dict4 = {'c': 12}
        for key, value in dict4.items():
            cont2.internal_add(key, value, mutable=True)
        dict1.update(dict4)
        cont.update(cont2)
        self.assertEqual(cont, dict1)

    def test_delete(self):
        """Test deleting."""
        cont = ConstrainedMap()
        dict1 = {'a': 1.0, 'b': 2, 'c': 'three'}
        for key, value in dict1.items():
            cont.internal_add(key, value, mutable=False, value_type=type(value))
        keys = list(cont.keys())
        for key in keys:
            cont.internal_del(key)
            self.assertTrue(key not in cont)
            with self.assertRaises(KeyError):
                cont.get_type(key)
            with self.assertRaises(KeyError):
                cont.get_mutable(key)

    def test_filter_by_type(self):
        cmap = ConstrainedMap()
        cmap.internal_add("key1", "key1")
        cmap.internal_add("key2", 1)
        int_filter = cmap.filter_by_type(int)
        self.assertIn("key2", int_filter)
        self.assertNotIn("key1", int_filter)
        cmap.internal_add("key3", 4)
        self.assertIn("key3", int_filter)
        del cmap["key2"]
        self.assertNotIn("key2", int_filter)
        self.assertTrue(int_filter["key3"], 4)
        cmap["key3"] = 23
        self.assertTrue(int_filter["key3"], 23)


class TestValueConstraint(unittest.TestCase):
    """unit tests for the constraint classes"""

    def test_init(self):
        vc = ValueConstraint(lambda x: x < 1)
        self.assertTrue(callable(vc._constraint))
        self.assertTrue(isinstance(vc.error_message, str))
        self.assertTrue(isinstance(vc._constraint_exception(), ValueError))
        with self.assertRaises(TypeError):
            ValueConstraint(5)
        with self.assertRaises(ValueError):
            ValueConstraint(lambda x, y: x == y)
        with self.assertRaises(ValueError):
            ValueConstraint(lambda: True)

    def test_check(self):
        error_message = "value should be 0 or smaller"
        vc = ValueConstraint(lambda x: x < 1, error_message=error_message, error_type=TestException)
        self.assertTrue(vc.check(0))
        self.assertTrue(vc.check(-1))
        with self.assertRaises(TestException):
            self.assertFalse(vc.check(1))
        try:
            vc.check(1)
        except TestException as e:
            self.assertTrue(error_message in str(e))
        with self.assertRaises(TypeError):
            vc.check("hi")
        with self.assertRaises(TypeError):
            vc.check(None)
        self.assertTrue(vc.check(False))
        with self.assertRaises(TestException):
            vc.check(True)

    def test_not(self):
        error_message = "value should be 0 or smaller"
        vc = ValueConstraint(lambda x: x < 1, error_message=error_message, error_type=TestException).constr_not()

        self.assertTrue(vc.check(1))
        self.assertTrue(vc.check(2))
        with self.assertRaises(TestException):
            vc.check(0)
        self.assertFalse(error_message in vc.error_message)

        error_message2 = "value should not not be 0 or smaller"
        vc2 = vc.constr_not(error_message=error_message2, error_type=TestException2)
        with self.assertRaises(TestException2):
            vc2.check(5)
        try:
            vc2.check(5)
        except TestException2 as e:
            self.assertTrue(error_message2 in str(e))

    def test_and(self):
        error_message1 = "value should be less than 10"
        error_message2 = "value should be bigger than or equal to 4"
        error_message3 = "value can't be 7"
        error_message4 = "value should be less than 11"
        vc1 = ValueConstraint(lambda x: x < 10, error_message=error_message1, error_type=TestException)
        vc2 = ValueConstraint(lambda x: x >= 4, error_message=error_message2, error_type=TestException2)
        vc3 = ValueConstraint(lambda x: x != 7,
                              error_message=error_message3,
                              error_type=TestException3)
        vc4 = ValueConstraint(lambda x: x < 11, error_message=error_message4, error_type=TestException2)

        vc_and = vc1.constr_and(vc2)
        self.assertTrue(vc_and.check(4))
        self.assertTrue(vc_and.check(6))
        self.assertTrue(vc_and.check(7))
        self.assertTrue(vc_and.check(9))
        with self.assertRaises(TestException):
            vc_and.check(11)
        try:
            vc_and.check(11)
        except Exception as e:
            self.assertTrue(error_message1 in str(e))
            self.assertFalse(error_message2 in str(e))
            self.assertNotEqual(type(e), TestException2)
        with self.assertRaises(TestException2):
            vc_and.check(3)
        with self.assertRaises(TestException2):
            vc_and.check(-10)
        try:
            vc_and.check(-10)
        except Exception as e:
            self.assertNotEqual(type(e), TestException)
        with self.assertRaises(TestException2):
            vc_and.check(False)
        with self.assertRaises(TestException2):
            vc_and.check(True)

        vc_ands = [vc3.constr_and(vc_and), vc_and.constr_and(vc3)]
        for vc_and in vc_ands:
            self.assertTrue(vc_and.check(4))
            self.assertTrue(vc_and.check(6))
            self.assertTrue(vc_and.check(9))
            with self.assertRaises(TestException):
                self.assertTrue(vc_and.check(11))
            with self.assertRaises(TestException2):
                vc_and.check(3)
            with self.assertRaises(TestException3):
                vc_and.check(7)
            try:
                vc_and.check(11)
            except TestException as e:
                self.assertTrue(error_message1 in str(e))
                self.assertFalse(error_message2 in str(e))
                self.assertFalse(error_message3 in str(e))
            try:
                vc_and.check(3)
            except TestException2 as e:
                self.assertFalse(error_message1 in str(e))
                self.assertTrue(error_message2 in str(e))
                self.assertFalse(error_message3 in str(e))
            try:
                vc_and.check(7)
            except TestException3 as e:
                self.assertFalse(error_message1 in str(e))
                self.assertFalse(error_message2 in str(e))
                self.assertTrue(error_message3 in str(e))

        # Only one constraint is checked in an and constraint
        vc_and1 = vc1.constr_and(vc4)
        vc_and2 = vc4.constr_and(vc4)

        try:
            vc_and1.check(9)
        except TestException as e:
            self.assertTrue(error_message1 in str(e))
            self.assertFalse(error_message4 in str(e))
        try:
            vc_and2.check(9)
        except TestException2 as e:
            self.assertFalse(error_message1 in str(e))
            self.assertTrue(error_message4 in str(e))


class TestException(Exception):
    pass


class TestException2(Exception):
    pass


class TestException3(Exception):
    pass


if __name__ == "__main__":
    unittest.main()
