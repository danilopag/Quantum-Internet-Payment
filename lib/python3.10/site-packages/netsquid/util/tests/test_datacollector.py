# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_datacollector.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the datacollector module.

"""
import itertools
import unittest
import pandas as pd
import netsquid as ns
import pydynaa as pydynaa
from netsquid.util.datacollector import DataCollector


class TestEntity(pydynaa.Entity):
    def __init__(self, value):
        super().__init__()
        self.value = value


class CallableObject():
    def __init__(self, value):
        self.value = value

    def __call__(self, evexpr):
        event = evexpr.triggered_events[-1]
        return {"source_id": event.source.uid, "value": self.value}


class TestDataCollector(unittest.TestCase):
    """Unit tests for the datacollector module.

    """
    TEST_INT_VALUE = 999

    def setUp(self):
        """Initializion for a test fixture"""
        self.eventType1 = pydynaa.EventType("Storm", "Storm event type")
        self.eventType2 = pydynaa.EventType("Rain", "Rain event type")
        self.entity1 = TestEntity(value=self.TEST_INT_VALUE)
        self.entity2 = TestEntity(value=self.TEST_INT_VALUE)
        ns.sim_reset()

    def _get_source_value(self, evexpr):
        # Get value of the source triggering this event.
        event = evexpr.triggered_events[-1]
        return {"value": event.source.value}

    def _get_dummy_value(self, evexpr):
        # Get a dummy value unrelated to the event.
        # event = evexpr.triggered_events[-1]
        return {"value": 99}

    def test_initialization(self):
        """Test DataCollector initialization."""
        dc = DataCollector(get_data_function=self._get_source_value)
        self.assertEqual(dc.priority, 3)
        self.assertTrue(isinstance(dc.dataframe, pd.DataFrame))
        self.assertEqual(["time_stamp", "entity_name"], [c for c in dc.dataframe.columns])
        self.assertEqual(len(dc.dataframe), 0)
        with self.assertRaises(TypeError):
            dc = DataCollector(get_data_function=None)
        with self.assertRaises(TypeError):
            dc = DataCollector(get_data_function=5)
        # NOTE removed below check  because can now be event or evexpr [Rob]
        # with self.assertRaises(ValueError):
        #    def foo(bar):
        #        return {}

        #    dc = DataCollector(get_data_function=foo)

    def test_get_data_with_callable_object(self):
        """Test using a callable object as get_data_function."""
        callable_object = CallableObject(value=self.TEST_INT_VALUE)
        dc = DataCollector(get_data_function=callable_object)

        def dummy_callback_1(event):
            pass

        eh1 = pydynaa.EventHandler(dummy_callback_1)
        self.entity1._schedule_now(self.eventType1)
        self.entity1._wait(eh1, event_type=self.eventType1)
        dc.collect_on([(self.entity1, self.eventType1)])
        ns.sim_run()
        self.assertEqual(len(dc.databuffer), 1)
        self.assertEqual(dc.databuffer[0], {'entity_name': str(self.entity1),
                                            'time_stamp': 0.0,
                                            'source_id': self.entity1.uid,
                                            'value': self.TEST_INT_VALUE})
        df = dc.dataframe
        self.assertEqual(len(df), 1)
        self.assertEqual(len(dc.databuffer), 0)
        # This also checks if the added 'entity_name' is str(entity)
        self.assertEqual(df.iloc[0].tolist(), [0, str(self.entity1), self.entity1.uid, self.TEST_INT_VALUE])

    def test_collect_on_interface(self):
        """Test interface of collect_on()."""
        dc = DataCollector(get_data_function=self._get_dummy_value)
        with self.assertRaises(TypeError):
            dc.collect_on()
        with self.assertRaises(TypeError):
            dc.collect_on(1)
        with self.assertRaises(ValueError):
            dc.collect_on([])
        with self.assertRaises(ValueError):
            dc.collect_on([(self.entity1, self.eventType1), (self.entity2, self.eventType2)])
        with self.assertRaises(ValueError):
            dc.collect_on([(self.entity1, self.eventType1), (self.entity2, self.eventType2)], 'a')

    def test_collecting_priority(self):
        """Test priority settings of DataCollector"""
        def dummy_callback_1(event):
            event.source.value += 1
        # Check if data collection occurs before another callback triggered by the same event
        dc = DataCollector(get_data_function=self._get_source_value)
        eh1 = pydynaa.EventHandler(dummy_callback_1)
        dc.collect_on([(self.entity1, self.eventType1)])
        self.entity1._schedule_now(self.eventType1)
        self.entity1._wait(eh1, event_type=self.eventType1)
        ns.sim_run()
        self.assertEqual(dc.dataframe.iloc[0][2], self.TEST_INT_VALUE)

        # Check if data collection can occur after another callback triggered by the same event
        ns.sim_reset()
        dc_after = DataCollector(get_data_function=self._get_source_value)
        eh2 = pydynaa.EventHandler(dummy_callback_1, priority=dc_after.priority - 1)
        dc_after.collect_on([(self.entity2, self.eventType1)])
        self.entity2._schedule_now(self.eventType1)
        self.entity2._wait(eh2, event_type=self.eventType1)
        ns.sim_run()
        self.assertEqual(dc_after.dataframe.iloc[0][2], self.TEST_INT_VALUE + 1)

    def test_collect_on_combine_rule(self):
        """Test if data is collected according to the combine rule."""
        def get_value_from_entity(event=None, entity=self.entity1):
            # Get value of entity when event is triggered
            return {"value": entity.value}
        possible_combinations = [[0, 0], [0, 1], [1, 0], [1, 1]]
        combine_rules = ["AND", "OR"]
        for combine_rule in combine_rules:
            for combination in possible_combinations:
                dc = DataCollector(get_data_function=get_value_from_entity)
                ns.sim_reset()
                dc.collect_on([(self.entity1, self.eventType1), (self.entity1, self.eventType2)], combine_rule=combine_rule)
                if combination[0]:
                    self.entity1._schedule_now(self.eventType1)
                if combination[1]:
                    self.entity1._schedule_now(self.eventType2)
                ns.sim_run()
                if combine_rule == "OR":
                    self.assertEqual(len(dc.dataframe), sum(combination))
                elif combine_rule == "AND":
                    self.assertEqual(len(dc.dataframe), (sum(combination) == 2))
                    if sum(combination) == 2:
                        self.assertEqual(dc.dataframe['entity_name'][0], str(self.entity1))

    def test_evt_handlers_keep_collecting(self):
        """Test if EventHandlers keep triggering"""
        dc = DataCollector(get_data_function=self._get_source_value)
        dc.collect_on([(self.entity1, self.eventType1)])
        for time_step in range(5):
            self.entity1._schedule_at(time_step, self.eventType1)
            ns.sim_run()
            self.assertEqual(len(dc.dataframe), time_step + 1)

    def test_evt_exprs_keep_collecting(self):
        """Test if EventExpressions keep triggering"""
        dc = DataCollector(get_data_function=self._get_dummy_value)
        rain_event = pydynaa.EventType("Rain", "Rainy weather")
        sun_event = pydynaa.EventType("Sun", "Sunny weather")
        evexpr_rain = pydynaa.EventExpression(event_type=rain_event)
        evexpr_sun = pydynaa.EventExpression(event_type=sun_event)
        evexpr_rainbow = evexpr_rain & evexpr_sun
        dc.collect_on(evexpr_rainbow)
        for time_step in range(5):
            self.entity1._schedule_at(time_step, rain_event)
            self.entity2._schedule_at(time_step, sun_event)
            ns.sim_run()
            self.assertEqual(len(dc.dataframe), time_step + 1)

    def test_evt_exprs_is_dismissed_when_adding_event_handler(self):
        """Test dismissing previous collect_on when adding source - event type."""
        dc = DataCollector(get_data_function=self._get_dummy_value)
        rain_event = pydynaa.EventType("Rain", "Rainy weather")
        sun_event = pydynaa.EventType("Sun", "Sunny weather")
        evexpr_rain = pydynaa.EventExpression(event_type=rain_event)
        dc.collect_on([evexpr_rain])
        dc.collect_on([(self.entity1, sun_event)])
        self.entity1._schedule_now(rain_event)
        ns.sim_run()
        self.assertEqual(len(dc.dataframe), 0)
        self.entity1._schedule_now(sun_event)
        ns.sim_run()
        self.assertEqual(len(dc.dataframe), 1)

    def test_evt_handlers_are_dismissed_when_adding_evt_exprs(self):
        """Test dismissing previous collect_on when adding event expression."""
        dc = DataCollector(get_data_function=self._get_dummy_value)
        rain_event = pydynaa.EventType("Rain", "Rainy weather")
        sun_event = pydynaa.EventType("Sun", "Sunny weather")
        evexpr_rain = pydynaa.EventExpression(event_type=rain_event)
        evexpr_sun = pydynaa.EventExpression(event_type=sun_event)
        evexpr_rainbow = evexpr_rain & evexpr_sun
        # Overwrite (Entity, EvenType) trigger with event expression
        dc.collect_on([(self.entity1, sun_event)])
        dc.collect_on([evexpr_rain])
        # Should not collect on sun_event
        self.entity1._schedule_now(sun_event)
        ns.sim_run()
        self.assertEqual(len(dc.dataframe), 0)
        # Should collect on rain_event
        self.entity1._schedule_now(rain_event)
        ns.sim_run()
        self.assertEqual(len(dc.dataframe), 1)
        # Overwrite  event expression
        dc.collect_on([evexpr_rainbow])
        # Should not collect on rain_event alone any more
        self.entity1._schedule_now(rain_event)
        self.assertEqual(len(dc.dataframe), 1)
        # Should collect when also sun_event is scheduled
        self.entity1._schedule_now(sun_event)
        ns.sim_run()
        self.assertEqual(len(dc.dataframe), 2)

    def test_evt_handlers_are_dismissed_when_adding_new_evt_handler(self):
        """Test dismissing previous single source - event type combination."""
        def get_dummy_value(event):
            return {"value": 99}
        dc = DataCollector(get_data_function=get_dummy_value)
        rain_event = pydynaa.EventType("Rain", "Rainy weather")
        sun_event = pydynaa.EventType("Sun", "Sunny weather")
        dc.collect_on([(self.entity1, sun_event)])
        dc.collect_on([(self.entity1, rain_event)])
        self.entity1._schedule_now(sun_event)
        self.entity1._schedule_now(rain_event)
        ns.sim_run()
        self.assertEqual(len(dc.dataframe), 1)

    def test_reset(self):
        """Test that reset removes EventExpressions and EventHandlers."""
        # Set EventExpression
        def get_dummy_value(event):
            return {"value": 99}
        dc = DataCollector(get_data_function=get_dummy_value)
        rain_event = pydynaa.EventType("Rain", "Rainy weather")
        sun_event = pydynaa.EventType("Sun", "Sunny weather")
        evexpr_rain = pydynaa.EventExpression(event_type=rain_event)
        evexpr_sun = pydynaa.EventExpression(event_type=sun_event)
        evexpr_rainbow = evexpr_rain & evexpr_sun
        dc.collect_on([evexpr_rainbow])
        dc.reset()
        self.entity1._schedule_now(rain_event)
        self.entity2._schedule_now(sun_event)
        ns.sim_run()
        self.assertEqual(len(dc.dataframe), 0)
        # Set EventHandler
        dc.collect_on([(self.entity1, self.eventType1)])
        self.entity1._schedule_now(self.eventType1)
        dc.reset()
        ns.sim_run()
        self.assertEqual(len(dc.dataframe), 0)

    def test_column_names(self):
        """Test standard names of columns in DataFrame and name of get_data_function output."""
        dc = DataCollector(get_data_function=self._get_source_value)
        self.assertEqual(["time_stamp", "entity_name"], dc.dataframe.columns.tolist())
        self.entity1._schedule_now(self.eventType1)
        dc.collect_on([(self.entity1, self.eventType1)])
        ns.sim_run()
        self.assertEqual(["time_stamp", "entity_name", 'value'], dc.dataframe.columns.tolist())

    def test_changing_get_data_function(self):
        """Test appending data before and after changing get_data_function."""
        dc = DataCollector(get_data_function=self._get_source_value)
        self.entity1._schedule_now(self.eventType1)
        dc.collect_on([(self.entity1, self.eventType1)])
        ns.sim_run()

        def get_dummy_value(event):
            return {"dummy": 99}

        dc.get_data_function = get_dummy_value
        self.entity1._schedule_now(self.eventType1)
        ns.sim_run()
        self.assertTrue("dummy" in dc.dataframe.columns.tolist())
        self.assertEqual(dc.dataframe["dummy"][1], 99)

    def test_disable_columns(self):
        """Test disabling the time_step and entity_name columns"""
        for use_name, name in zip([True, False], ['time_stamp', 'entity_name']):
            dc = DataCollector(get_data_function=self._get_source_value,
                               include_time_stamp=use_name,
                               include_entity_name=not use_name)
            self.assertEqual([name], dc.dataframe.columns.tolist())
            self.entity1._schedule_now(self.eventType1)
            dc.collect_on([(self.entity1, self.eventType1)])
            ns.sim_run()
            self.assertEqual([name, 'value'], dc.dataframe.columns.tolist())

    def test_empty_return(self):
        """Test returning None or an empty dict"""
        def return_none(_):
            return None

        def returndict(_):
            return {}

        for columns, func in itertools.product([True, False], [return_none, returndict]):
            dc = DataCollector(func, columns, columns)
            self.entity1._schedule_now(self.eventType1)
            dc.collect_on([(self.entity1, self.eventType1)])
            ns.sim_run()
            cols = 2 if columns else 0
            rows = 0 if func is return_none or cols == 0 else 1

            self.assertEqual((rows, cols), dc.dataframe.shape)

    def test_incorrect_return(self):
        """Test returning types which aren't allowed"""
        def return_bool(_):
            return True

        def return_list(_):
            return []

        for func in [return_bool, return_list]:
            dc = DataCollector(func)
            self.entity1._schedule_now(self.eventType1)
            dc.collect_on([(self.entity1, self.eventType1)])
            with self.assertRaises(TypeError):
                ns.sim_run()
            ns.sim_reset()  # ensure reset after sim is stopped


if __name__ == "__main__":
    unittest.main(verbosity=2)
