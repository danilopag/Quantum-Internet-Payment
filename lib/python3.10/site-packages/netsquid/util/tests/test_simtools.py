# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_simtools.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the simtools module.

"""
import unittest
import numpy as np
from pydynaa import Entity, EventHandler, EventType
from netsquid.util.simtools import (
    sim_state, sim_time, sim_run, sim_stop, sim_reset,
    sim_count_events, sim_count_instants, sim_count_handlers, sim_count_resets,
    SECOND, MICROSECOND, set_random_state, get_random_state)
from netsquid.util.simstats import SimStats


class TestSimTools(unittest.TestCase):
    """Unit tests for the simtools module.

    """

    def setUp(self):
        sim_reset()

    def tearDown(self):
        sim_reset()

    def test_sim_running(self):
        """Test running of simulator."""
        self.assertAlmostEqual(sim_time(), 0)
        self.assertEqual(sim_state(), 0)
        sim_run(end_time=10)
        self.assertAlmostEqual(sim_time(), 10)
        self.assertEqual(sim_state(), 0)
        sim_run(duration=5)
        self.assertAlmostEqual(sim_time(), 15)
        sim_stop()
        self.assertAlmostEqual(sim_time(), 15)
        self.assertEqual(sim_state(), 2)
        sim_reset()
        self.assertAlmostEqual(sim_time(), 0)
        self.assertEqual(sim_state(), 0)

    def test_sim_run_stats(self):
        """Test returning of statistical sim data."""
        god = Entity()
        god._schedule_now(EventType("A", "A"))
        god._schedule_now(EventType("B", "B"))
        god._schedule_after(5, EventType("C", "C"))
        god._wait(EventHandler(lambda event: None))
        stats = sim_run()
        self.assertIsInstance(stats, SimStats)
        self.assertAlmostEqual(stats.data["elapsed_sim_time"], 5)
        self.assertAlmostEqual(stats.data["events_triggered"], 3)
        self.assertAlmostEqual(stats.data["handled_callbacks"], 3)
        # Test stats is "ended"
        stats = sim_run(10)
        self.assertAlmostEqual(stats.data["elapsed_sim_time"], 5)

    def test_timeconversion(self):
        """Test time conversions."""
        # self.assertEqual(default_timeunit, UNIT_NANOSEC)
        sim_run(end_time=10)
        self.assertAlmostEqual(sim_time(), 10)
        self.assertAlmostEqual(sim_time(SECOND), 10e-9)
        sim_run(duration=1, magnitude=MICROSECOND)
        self.assertAlmostEqual(sim_time(), 1010)
        # default_timeunit = UNIT_MILLISEC
        # self.assertAlmostEqual(sim_time(), 1010e-6)
        # sim_run(end_time=10)
        # self.assertAlmostEqual(sim_time(), 10)

    def test_set_random_state(self):
        """Test setting the random state"""
        # test setting RNG
        rng = np.random.RandomState(5)
        self.assertTrue(rng != get_random_state())
        set_random_state(rng=rng)
        self.assertTrue(rng == get_random_state())
        with self.assertRaises(TypeError):
            set_random_state(rng=0)
        # test re-seeding
        set_random_state(seed=None)
        rng = get_random_state()
        set_random_state(seed=1)
        self.assertTrue(rng == get_random_state())
        with self.assertRaises(TypeError):
            set_random_state(seed=0.5)

    def test_sim_diagnostics(self):
        """Test simulation diagnostics."""
        self.assertEqual(sim_count_events(), 0)
        self.assertEqual(sim_count_instants(), 0)
        self.assertEqual(sim_count_handlers(), 0)
        god = Entity()
        god._schedule_now(EventType("A", "A"))
        god._schedule_now(EventType("B", "B"))
        god._schedule_after(5, EventType("C", "C"))
        god._wait(EventHandler(lambda event: None))
        self.assertEqual(sim_count_events(), 3)
        self.assertEqual(sim_count_instants(), 2)
        self.assertEqual(sim_count_handlers(), 1)

    def test_sim_count_resets(self):
        """Test counting of simulation resets."""
        num = sim_count_resets()
        self.assertTrue(num >= 0)
        for i in range(5):
            sim_reset()
            self.assertTrue(sim_count_resets() == num + i + 1)


if __name__ == "__main__":
    unittest.main(verbosity=2)
