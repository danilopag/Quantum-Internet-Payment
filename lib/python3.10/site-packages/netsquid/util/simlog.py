# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: simlog.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt
"""
Simulation logging utilities.

NetSquid makes use of `logging <https://docs.python.org/3/library/logging.html>`_, i.e. the logging facility for Python,
to handle logger objects. Loggers generally consists of a (severity) level and a message. The value of the logger level
determines if the logger is logged or ignored. The predefined log levels in order of severity (starting with least
severe) are the following: NOTSET, DEBUG, INFO, WARNING, ERROR, and CRITICAL. If the level is set at a given value, then
all loggers of that level and higher will be logged. The log messages are formatted to display the level name and log
message. A dictionary of all registered loggers for the NetSquid package can be found using
:meth:`~netsquid.util.simlog.get_loggers`. Note that the default logger level is set globally to WARNING, i.e. the level
of the logger `netsquid` is set to this value. The logger level of the (child) loggers may be configured locally by
selecting the logger from the dictionary and adjusting its level with the :meth:`logging.Logger.setLevel` method. To
reset the logger level of a child logger, such that it takes on the value of the parent logger again, simply set the
logger level to NOTSET.

"""
import gc
import warnings
import logging
from contextlib import contextmanager
import tracemalloc

__all__ = [
    "logger",
    "get_loggers",
    "warn_deprecated",
    "check_memory_usage"
]

# Define netsquid 'root' logger
logger = logging.getLogger('netsquid')
""":obj:`logging.Logger`: root logger for netsquid package."""

# Set default level for all loggers
logger.setLevel(logging.WARNING)

# How to format log messages
log_formatter = logging.Formatter('%(levelname)s:%(message)s')
""":obj:`logging.Formatter`: formatter for console logging."""

# Console handler
_console_handler = logging.StreamHandler()
_console_handler.setFormatter(log_formatter)
logger.addHandler(_console_handler)

# Record deprecation warnings so that we only give them once
_deprecation_warnings = {}


def warn_deprecated(message, key=None, stacklevel=2):
    """Warn that the called functionality is deprecated.

    Parameters
    ----------
    message : str
        Warning message to print.
    key: str or None, optional
        Unique string for warning to ensure it is only printed once.
    stacklevel : int, optional
        Level in stack to show information such as filename and linenumber for.
        If 1, current location is shown, if 2 location of the caller, etc.
        This wrapper function is ignored (it is stacklevel 0).

    """
    if key is None or _deprecation_warnings.get(key) is None:
        warnings.warn(message, DeprecationWarning, stacklevel=(stacklevel + 1))
        if key is not None:
            _deprecation_warnings[key] = True


def disable_warn_deprecated(fn):
    """Decorator to temporarily disable deprecation warnings."""
    def _wrapped(*args, **kwargs):
        with warnings.catch_warnings():
            warnings.simplefilter('ignore', DeprecationWarning)
            return fn(*args, **kwargs)
    return _wrapped


def get_loggers():
    """Retrieve all module loggers for the netsquid package.

    Returns
    -------
    dict
        All registered loggers for the netsquid package.

    Examples
    --------

    Obtain all registered loggers for the NetSquid package.

    >>> from netsquid.util import simlog
    >>> simlog.get_loggers()  # doctest: +SKIP
    {'netsquid.util.simtools': <Logger netsquid.util.simtools (WARNING)>,
    'netsquid.util': <Logger netsquid.util (WARNING)>,
    'netsquid': <Logger netsquid (WARNING)>,
    'netsquid.qubits.qrepr': <Logger netsquid.qubits.qrepr (WARNING)>,
    'netsquid.qubits': <Logger netsquid.qubits (WARNING)>,
    'netsquid.qubits.qstate': <Logger netsquid.qubits.qstate (WARNING)>,
    'netsquid.qubits.stabtools': <Logger netsquid.qubits.stabtools (WARNING)>,
    'netsquid.qubits.kettools': <Logger netsquid.qubits.kettools (WARNING)>,
    'netsquid.qubits.dmtools': <Logger netsquid.qubits.dmtools (WARNING)>,
    'netsquid.qubits.sparsedmtools': <Logger netsquid.qubits.sparsedmtools (WARNING)>,
    'netsquid.components.component': <Logger netsquid.components.component (WARNING)>,
    'netsquid.components': <Logger netsquid.components (WARNING)>,
    'netsquid.components.channel': <Logger netsquid.components.channel (WARNING)>,
    'netsquid.components.cchannel': <Logger netsquid.components.cchannel (WARNING)>,
    'netsquid.components.qprocessor': <Logger netsquid.components.qprocessor (WARNING)>,
    'netsquid.nodes.node': <Logger netsquid.nodes.node (WARNING)>,
    'netsquid.nodes': <Logger netsquid.nodes (WARNING)>,
    'netsquid.protocols.protocol': <Logger netsquid.protocols.protocol (WARNING)>,
    'netsquid.protocols': <Logger netsquid.protocols (WARNING)>}

    Configure the logger level of a subpackage or a particular module.

    >>> from netsquid.util import simlog
    >>> import logging
    >>> loggers = simlog.get_loggers()
    >>> loggers['netsquid.qubits'].setLevel(logging.DEBUG)
    >>> loggers['netsquid.qubits.qstate'].setLevel(logging.INFO)

    Reset the logger level of a subpackage or a particular module.

    >>> from netsquid.util import simlog
    >>> import logging
    >>> loggers = simlog.get_loggers()
    >>> loggers['netsquid.qubits.qstate'].setLevel(logging.NOTSET)
    >>> loggers['netsquid.qubits'].setLevel(logging.NOTSET)

    """
    loggers = {}
    for name, logger in logging.root.manager.loggerDict.items():
        if name.split('.')[0] == 'netsquid':
            loggers[name] = logger
    return loggers


@contextmanager
def check_memory_usage(max_memory_increase, filters=None, include_default_filters=True):
    """Context manager that checks NetSquid does not exceed a memory allocation limit for a code block.

    Use with 'with':

    >>> from netsquid.util import simlog
    >>> with simlog.check_memory_usage(10000, include_default_filters=False):
    ...     print(42)
    42
    >>> with simlog.check_memory_usage(100, include_default_filters=False):
    ...     print(42)
    Traceback (most recent call last):
    ...
    MemoryError: More memory used (...) than expected/allowed (100 B)...

    Parameters
    ----------
    max_memory_increase : int
        Maximum memory in number of bytes that NetSquid may allocate when running this code block [B].
    filters : list of :obj:`tracemalloc:Filter` or None,  optional
        Filters on traces of memory blocks. A trace is ignored if no inclusive filters match it.
        A trace is ignored if at least one exclusive filter matches it. (See the tracemalloc documentation at
        https://docs.python.org/3.6/library/tracemalloc.html)
    include_default_filters : bool (default: True)
        Whether the default NetSquid filters should be applied. The default filters are listed below.

    Raises
    ------
    MemoryError
        If the block allocated more memory than expected/allowed.

    Notes
    -----
        Default filters:

        * ``tracemalloc.Filter(True, "*netsquid*")  # only trace memory in netsquid``
        * ``tracemalloc.Filter(False, "*netsquid/util/datacollector*")  # don't trace memory in data collector``
        * ``tracemalloc.Filter(False, "*/test*")  # don't trace memory in tests``

        A garbage collection is done before both memory snapshots.

    """
    tracemalloc.start()
    # Do GC before and after to ensure clean snapshots
    gc.collect()
    snapshot_before = tracemalloc.take_snapshot()
    yield
    gc.collect()
    snapshot_after = tracemalloc.take_snapshot()
    if filters is None:
        filters = []
    if include_default_filters:
        filters.extend([tracemalloc.Filter(True, "*netsquid*"),
                        tracemalloc.Filter(False, "*netsquid/util/datacollector*"),
                        tracemalloc.Filter(False, "*/test*")])
    if filters:
        snapshot_after = snapshot_after.filter_traces(filters)
    statistics = snapshot_after.compare_to(snapshot_before, 'lineno', cumulative=True)
    tracemalloc.stop()
    memory_increase = sum([stat.size_diff for stat in statistics])
    if memory_increase >= max_memory_increase:
        message = "More memory used ({} B) than expected/allowed ({} B)".format(memory_increase, max_memory_increase)
        message += "\nTop 10 memory allocations by lineno:"
        for stat in statistics[:10]:
            message += "\n{}".format(stat)
        raise MemoryError(message)
