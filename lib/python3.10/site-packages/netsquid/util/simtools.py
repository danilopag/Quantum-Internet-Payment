# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: simtools.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""
Tools and utilities that assist with running a simulation.

The default simulation time magnitude is nanoseconds.

The pydynaa SimulationEngine() singleton is wrapped here, both
to add some additional functionality and to save the user from having
to deal with a singleton instance in the first place.

Examples
--------
Some of the functions provide example code snippets.
These snippets should run unedited if you set up a Python
interpreter with the following imports:

>>> import netsquid as ns

"""
import logging
import sys
import unittest
from time import time
import datetime
import numpy as np
from pydynaa import SimulationEngine
from netsquid.util.simstats import SimStats
__all__ = [
    "SECOND",
    "MILLISECOND",
    "MICROSECOND",
    "NANOSECOND",
    "PICOSECOND",
    "sim_time",
    "sim_state",
    "sim_run",
    "sim_stop",
    "sim_reset",
    "sim_count_events",
    "sim_count_instants",
    "sim_count_handlers",
    "sim_count_resets",
    "get_random_state",
    "set_random_state",
    "test",
]

# NOTE this is now only the simtools logger
logger = logging.getLogger(__name__)

SECOND = 1e9
"""float: factor to convert simulation time to seconds."""
MILLISECOND = 1e6
"""float: factor to convert simulation time to milliseconds."""
MICROSECOND = 1e3
"""float: factor to convert simulation time to microseconds."""
NANOSECOND = 1
"""float: factor to convert simulation time to nanoseconds."""
PICOSECOND = 1e-3
"""float: factor to convert simulation time to picoseconds."""

# Sim engine is a singleton so we need only construct it once
_simengine = SimulationEngine()

# Count number of simulation resets; DO NOT modify
_num_sim_resets = 0


def sim_time(magnitude=NANOSECOND):
    """Returns the current simulation time.

    Parameters
    ----------
    magnitude : float, optional
        Time magnitude to use. Default is nanoseconds.

    Returns
    -------
    float
        The current simulation time. Default unit is nanoseconds
        (see ``magnitude``).

    Examples
    --------

    >>> # Return time in nanoseconds:
    >>> ns.sim_reset()
    >>> ns.sim_run(5)
    >>> ns.sim_time()
    5.0
    >>> # Return time in microseconds:
    >>> ns.sim_time(ns.MICROSECOND)
    0.005

    """
    return _simengine.current_time / magnitude


def sim_state():
    """Returns the current state of the simulation.

    Returns
    -------
    int
        ``0`` if *idle*, ``1`` if *running*, ``2`` if *stopped*.

    """
    return _simengine.state


def sim_info():
    """Return diagnostic information for simulation engine.

    Returns
    -------
    dict
        Diagnostic information for simulation engine.

    """
    return _simengine.get_diagnostic_info()


def sim_count_events():
    """Returns the number of events on the simulation timeline.

    Returns
    -------
    int
        Number of events currently on the simulation timeline.

    """
    return _simengine.num_events


def sim_count_instants():
    """Returns the number of time instants on the simulation timeline.

    Returns
    -------
    int
        Number of time instants currently on the simulation timeline.
        One time instant can have multiple events

    """
    return _simengine.num_instants


def sim_count_handlers():
    """Returns the number of registered event handlers.

    Returns
    -------
    int
        Number of event handlers currently registered in the simulation.

    """
    return _simengine.num_handlers


def sim_count_resets():
    """Returns the number of times the simulation engine has been reset.

    Returns
    -------
    int
        Number of times simulation engine has been reset

    """
    return _num_sim_resets


def sim_run(end_time=None, duration=None, magnitude=NANOSECOND):
    """Run the simulation.

    If no ``end_time`` or ``duration`` are set, then the simulation will run
    until there are no more events in the timeline.

    Parameters
    ----------
    end_time : float or None, optional
        Time up to which to run the simulation, not including this instant itself.
        In other words, events scheduled at end_time will not be issued.
        Default unit is nanoseconds (see ``magnitude``).
    duration : float or None, optional
        Duration for which to run the simulation. Default unit is nanoseconds
        (see ``magnitude``).
    magnitude : float, optional
        Time magnitude to use. Default is nanoseconds.

    Returns
    -------
    :obj:`~netsquid.util.simstats.SimStats`
        General statistics for this simulation run.

    Notes
    -----
        It can be the case that there will always be a new event in the timeline.
        In this case, not passing an ``end_time`` or a ``duration`` to the run may
        cause a never ending simulation.

        The ``end_time`` parameter takes precedence over the ``duration`` parameter.

    Examples
    --------

    >>> # Runs simulation up to simulation time 10 nanoseconds:
    >>> ns.sim_reset()
    >>> ns.sim_run(end_time=10.)
    >>> ns.sim_time()
    10.0
    >>> # Run the simulation for 500 picoseconds from current time
    >>> ns.sim_run(duration=500, magnitude=ns.PICOSECOND)
    >>> ns.sim_time()
    10.5
    >>> # Resumes the simulation and stops only when there are no further events
    >>> # in the timeline:
    >>> ns.sim_run()
    SimStats()

    """
    if logger.isEnabledFor(logging.INFO):
        start_wc_time = time()
        logger.info("sim_run: ## Run started at {}".format(datetime.datetime.fromtimestamp(start_wc_time)))
        logger.info("sim_run:  - {}".format(SimStats.timeline_status()))
    stats = SimStats()
    with stats.record():
        # Do sim run
        if end_time is not None:
            _simengine.run(end_time * magnitude)
        elif duration is not None:
            _simengine.run((_simengine.current_time + duration * magnitude))
        else:
            _simengine.run()
    if logger.isEnabledFor(logging.INFO):
        end_wc_time = time()
        logger.info("sim_run: ## Run finished at {}. Elapsed time (wallclock): {}".format(
            datetime.datetime.fromtimestamp(end_wc_time),
            datetime.timedelta(seconds=(end_wc_time - start_wc_time))))
        logger.info("sim_run:  - {}".format(SimStats.timeline_status()))
    return stats


def sim_stop():
    """Permanently stop the simulation.

    Simulation must be reset in order to run again from the beginning.

    Notes
    -----
        Stopping the simulation means the actual time of the simulation is frozen and
        further (future) events are not thrown.  No further activation of any entity
        in the simulation.

    """
    _simengine.stop()


def sim_reset():
    """Reset the simulation by clearing all scheduled events, entities and event handlers.

    Resets time to 0.

    Notes
    -----
        After stopping, if the simulation is not reset, invoking a new run will resume the
        simulation from the moment it stopped.

        After reset, the simulation time is sent back to time zero,
        all events are eliminated from the timeline, existing entities are disposed,
        and event handlers are cleared.
        It brings the simulator to an initial state without any simulation entities in it.

    """
    global _num_sim_resets
    _num_sim_resets += 1
    _simengine.reset()


# The default random number generator used for qubit manipulation.
# This should be a protected value. Only accessible via set_random_generator and
# get_random_generator
_random_state = np.random.RandomState()


def set_random_state(seed=None, rng=None):
    """Set the random number generator to use.

    Either re-seed the random number generator already in use,
    or specify a new random number generator to use.

    Parameters
    ----------
    seed : int or None, optional
        Seed to re-seed random number generator with. If ``None`` a seed
        will be acquired from a random source.
    rng : :obj:`numpy.random.RandomState` or None, optional
        Random number generator to use. If ``None`` then
        :obj:`~netsquid.util.simtools.get_random_state` is used.

    Notes
    -----
        A new random number generator specified with ``rng`` will not be
        re-seeded even if a non-default ``seed`` is also given.

    Examples
    --------
    Re-seed the random number generator currently in use:

    >>> from netsquid.util.simtools import set_random_state
    ...
    >>> set_random_state(seed=42)

    Assign a random number generator to use:

    >>> _random_state = np.random.RandomState(42)
    >>> set_random_state(rng=_random_state)

    """
    # Åote that the variable _random_state must be used as a global variable
    global _random_state
    if rng is not None:
        if not isinstance(rng, np.random.RandomState):
            raise TypeError
        _random_state = rng
    else:
        if seed is not None and not isinstance(seed, int):
            raise TypeError
        _random_state.seed(seed)


def get_random_state():
    """Get the random number generator currently in use.

    Returns
    -------
    :obj:`numpy.random.RandomState`
        Random number generator.

    """
    return _random_state


def test(test_type="full"):
    """Run all discoverable unit and integration tests.

    Parameters
    ----------
    test_type : {`full`, `unit`, `integration`}
        Type of tests to discover. 'full' runs all tests.
        'unit' runs only unit tests. 'integration' runs only
        integration tests.

    Returns
    -------
    bool
        True if there were no errors or failures, otherwise False.

    """
    if test_type == "full":
        pattern = "test*.py"
    elif test_type == "unit":
        pattern = "test_*.py"
    elif test_type == "integration":
        pattern = "testint_*.py"
    else:
        raise ValueError(f"{test_type} is an invalid test_type")
    test_loader = unittest.defaultTestLoader
    test_runner = unittest.TextTestRunner()
    test_suite = test_loader.discover('netsquid', pattern=pattern)
    result = test_runner.run(test_suite)
    if len(result.errors) > 0 or len(result.failures) > 0:
        sys.exit(1)
