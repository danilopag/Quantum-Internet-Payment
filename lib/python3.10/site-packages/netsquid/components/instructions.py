# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: instructions.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Instructions represent low-level commands that run on a :obj:`~netsquid.components.qmemory.QuantumMemory`,
and its subclasses such as :obj:`~netsquid.components.qprocessor.QuantumProcessor`.
They are implemented as calls to the public methods of these objects.

:obj:`~netsquid.components.instructions.Instruction`\\s are intended to be agnostic of the quantum processor they are executed on.
Their duration and associated noise models can instead be described by a
separate :obj:`~netsquid.components.qprocessor.PhysicalInstruction` specified for specific
processors.

:obj:`~netsquid.components.instructions.Instruction`\\s are the commands with which :obj:`~netsquid.components.qprogram.QuantumProgram`\\s are written.

Examples
--------

To run the examples below use the following imports:

>>> from netsquid.components.instructions import *
>>> from netsquid.components.qmemory import QuantumMemory
>>> from netsquid.qubits import operators as ops
>>> from netsquid.qubits import qubitapi as qapi

Create a new gate instruction:

>>> my_op = ops.X * ops.Y
>>> INSTR_XY = IGate("xy_gate", my_op)

An instruction can be called directly with a quantum memory device as argument.

>>> qmem = QuantumMemory('MyQMem', num_positions=2)
>>> q0, q1 = qapi.create_qubits(2)
>>> qmem.put([q0, q1])
>>> INSTR_H(qmem, positions=[0])
>>> INSTR_CNOT(qmem, positions=[0, 1])

To directly execute a physical instruction on a quantum processor, see
instead :meth:`~netsquid.components.qprocessor.QuantumProcessor.execute_instruction`.

"""
from abc import ABC, abstractmethod
from netsquid.qubits.qubit import Qubit
from netsquid.qubits import qubitapi as qapi
from netsquid.qubits import operators as ops
from netsquid.qubits.qformalism import QFormalism, get_qstate_formalism
from netsquid.qubits.ketstates import s0, s1, BellIndex
import numpy as np
import math

__all__ = [
    "Instruction",
    "IInit",
    "ISwap",
    "IGate",
    "IRotationGate",
    "IControlledDirectionGate",
    "IMeasure",
    "IMeasureFaulty",
    "IMeasureBell",
    "ISignal",
    "IEmit",
    "InstructionError",
    "INSTR_INIT",
    "INSTR_SWAP",
    "INSTR_UNITARY",
    "INSTR_X",
    "INSTR_Y",
    "INSTR_S",
    "INSTR_T",
    "INSTR_Z",
    "INSTR_H",
    "INSTR_I",
    "INSTR_CX",
    "INSTR_CNOT",
    "INSTR_CCX",
    "INSTR_TOFFOLI",
    "INSTR_CS",
    "INSTR_CZ",
    "INSTR_CDIR",
    "INSTR_CXDIR",
    "INSTR_CYDIR",
    "INSTR_CZDIR",
    "INSTR_ROT",
    "INSTR_ROT_X",
    "INSTR_ROT_Y",
    "INSTR_ROT_Z",
    "INSTR_CROT",
    "INSTR_CROT_X",
    "INSTR_CROT_Y",
    "INSTR_CROT_Z",
    "INSTR_MEASURE",
    "INSTR_MEASURE_X",
    "INSTR_MEASURE_BELL",
    "INSTR_EMIT",
    "INSTR_SIGNAL",
    "INSTR_DISCARD",
]


class Instruction(ABC):
    """Instruction that can be executed on a quantum memory.

    Instructions represent low-level commands that run on a
    :obj:`~netsquid.components.qmemory.QuantumMemory`,
    and its subclasses such as :obj:`~netsquid.components.qprocessor.QuantumProcessor`.
    They are implemented as calls to the public methods of these objects.

    This is an abstract base class that must be overridden.

    Raises
    ------
    InstructionError
        If an error occurs that should cause the program to fail.

    Notes
    -----
        Instructions are passed by reference within a deep copy
        e.g. when a program is deep copied.

    """
    @property
    @abstractmethod
    def name(self):
        """str: instruction name."""
        pass

    @property
    @abstractmethod
    def num_positions(self):
        """int: number of targeted memory positions. If -1, number is unrestricted."""
        pass

    @abstractmethod
    def execute(self, quantum_memory, positions, *args, **kwargs):
        """Execute instruction on a quantum memory.

        Parameters
        ----------
        quantum_memory : :obj:`~netsquid.components.qmemory.QuantumMemory`
            Quantum memory to execute instruction on.
        positions : list of int
            Memory positions to do instruction on. Can be empty.
        \\*args : list
            Additional arguments that can be used to extend this method.
        \\*\\*kwargs : dict
            Keyword arguments that can be used to to extend this method.

        Notes
        -----
            For an instruction output to be modifiable by a classical noise model,
            it must be a mutable object e.g. a list instead of an int.

        """
        pass

    def __call__(self, quantum_memory, positions=None, **kwargs):
        # Check if num positions of instruction maps on the given positions,
        # but skip this check if the num_positions == -1 (e.g. for unitary_gate)
        if positions is None:
            positions = []
        if self.num_positions != -1 and len(positions) != self.num_positions:
            raise ValueError(f"Number of positions ({len(positions)}) "
                             f"doesn't match instruction ({self.num_positions}) "
                             f"for instruction {self.name}")
        return self.execute(quantum_memory, positions=positions, **kwargs)

    def __repr__(self):
        return "Instruction: {}".format(self.name)

    def __deepcopy__(self, memo):
        # Do not copy instructions when doing a deepcopy
        return self


class IInit(Instruction):
    """Instruction that initializes one or more qubit memory positions.

    Parameters
    ----------
    num_positions : int, optional
        The number of positions this instruction initializes.
        The default, -1, means that the instruction can handle any number.

    """

    def __init__(self, num_positions=-1):
        self._num_positions = num_positions

    @property
    def name(self):
        """str: instruction name."""
        return "initialization_op"

    @property
    def num_positions(self):
        """int: number of targeted memory positions. If -1, the number is unrestricted."""
        return self._num_positions

    def execute(self, quantum_memory, positions, qubits=None, *args, **kwargs):
        """Execute an instruction on a quantum memory.

        Parameters
        ----------
        quantum_memory : :obj:`~netsquid.components.qmemory.QuantumMemory`
            Quantum memory to execute instruction on.
        positions : list of int
            Memory position(s) to do instruction on. If empty, will attempt to initialise all positions.
        qubits : list of :obj:`~netsquid.qubits.qubit.Qubit` or :obj:`~netsquid.qubits.qubit.Qubit` or None, optional
            Qubit(s) to initialise. If ``None``,
            new qubits are initialised in the ``|0>`` state.
        \\*args : list
            Additional arguments that can be used to extend this method.
        \\*\\*kwargs : dict
            Keyword arguments that can be used to to extend this method.

        """
        # Check positions input
        if len(positions) == 0:
            positions = list(range(quantum_memory.num_positions))
        elif isinstance(positions, int):
            positions = [positions]
        if self.num_positions != -1 and len(positions) != self.num_positions:
            raise ValueError("The number of positions ({}) does not match that of instruction ({})"
                             .format(len(positions), self.num_positions))
        # Check qubits input
        if qubits is None:
            qubits = qapi.create_qubits(len(positions))
        elif isinstance(qubits, Qubit):
            qubits = [qubits]
        elif len(qubits) == 0:
            raise ValueError("'qubits' should either be None or specify at least one qubit.")
        if len(positions) != len(qubits):
            raise ValueError("The number of qubits ({}) and positions ({}) do not match."
                             .format(len(qubits), len(positions)))
        # Do initialisation
        quantum_memory.put(qubits, positions=positions, replace=True,
                           check_positions=True)


class ISignal(Instruction):
    """Instruction that sends out a signal.

    Parameters
    ----------
    name : str
        Name of instruction for identification purposes.
    event_type : :obj:`~pydynaa.core.EventType` or None, optional
        EventType of the signal.

    """

    def __init__(self, name, event_type=None):
        self._name = name
        self._default_event = event_type

    @property
    def name(self):
        """str: instruction name."""
        return self._name

    @property
    def num_positions(self):
        """int: number of targeted memory positions. If -1, number is unrestricted."""
        return 0

    def execute(self, quantum_memory, event_type=None, *args, **kwargs):
        """Execute an instruction on a quantum memory.

        Parameters
        ----------
        quantum_memory : :obj:`~netsquid.components.qmemory.QuantumMemory`
            Quantum memory to execute instruction on.
        event_type : :obj:`~pydynaa.core.EventType` or None, optional
            EventType of the signal which overwrites event_type given at initialization.
        \\*args : list
            Additional arguments that can be used to extend this method.
        \\*\\*kwargs : dict
            Keyword arguments that can be used to to extend this method.

        Returns
        -------
        :obj:`~pydynaa.core.Event`
            The scheduled signal event.

        """
        if event_type is None:
            event_type = self._default_event
        return quantum_memory.send_signal(event_type)


class ISwap(Instruction):
    """Instruction that swaps two qubits.

    Notes
    -----
        Implemented by switching the memory positions of the qubits.
        No two-qubit SWAP gate is applied, and thereby the quantum states
        of the qubits are not necessarily combined.

    """

    @property
    def name(self):
        """str: instruction name."""
        return "swap_gate"

    @property
    def num_positions(self):
        """int: number of targeted memory positions. If -1, number is unrestricted."""
        return 2

    def execute(self, quantum_memory, positions, *args, **kwargs):
        """Execute instruction on a quantum memory.

        Parameters
        ----------
        quantum_memory : :obj:`~netsquid.components.qmemory.QuantumMemory`
            Quantum memory to execute instruction on.
        positions : list of int
            Memory positions to do instruction on.
        \\*args : list
            Additional arguments that can be used to extend this method.
        \\*\\*kwargs : dict
            Keyword arguments that can be used to to extend this method.

        """
        # Pop will apply noise
        meta0 = quantum_memory.mem_positions[positions[0]].meta
        q0 = quantum_memory.mem_positions[positions[0]].get_qubit(remove=True)
        meta1 = quantum_memory.mem_positions[positions[1]].meta
        q1 = quantum_memory.mem_positions[positions[1]].get_qubit(remove=True)
        meta0 = {} if meta0 is None else meta0
        meta1 = {} if meta1 is None else meta1
        # Set qubits into new locations without using a "put" via ports
        quantum_memory.mem_positions[positions[1]].set_qubit(q0, **meta0)
        quantum_memory.mem_positions[positions[0]].set_qubit(q1, **meta1)


class IGate(Instruction):
    """Instruction to perform a quantum gate.

    Parameters
    ----------
    name : str
        Name of instruction for identification purposes.
    operator : :obj:`~netsquid.qubits.operators.Operator` or None, optional
        Default operator acting on qubits. If ``None`` the operator must
        be specified during execution.
    num_positions : int, optional
        Number of positions the gate acts on. Only used if ``operator`` is None.

    """

    def __init__(self, name, operator=None, num_positions=-1):
        self._name = name
        self._operator = operator
        self._num_positions = num_positions

    @property
    def name(self):
        """str: instruction name."""
        return self._name

    @property
    def num_positions(self):
        """int: number of targeted memory positions. If -1, number is unrestricted."""
        if self._operator is None:
            return self._num_positions
        else:
            return self._operator.num_qubits

    def execute(self, quantum_memory, positions, operator=None, *args, **kwargs):
        """Execute an instruction on a quantum memory.

        Parameters
        ----------
        quantum_memory : :obj:`~netsquid.components.qmemory.QuantumMemory`
            Quantum memory to execute instruction on.
        positions : list of int
            Memory positions to do instruction on.
        operator : :obj:`~netsquid.qubits.operators.Operator` or None, optional
            Operator acting on qubits.
        \\*args : list
            Additional arguments that can be used to extend this method.
        \\*\\*kwargs : dict
            Keyword arguments that can be used to to extend this method.

        """
        if self._operator is not None:
            op = self._operator
        elif operator is not None:
            op = operator
        else:
            raise InstructionError('No operator available')
        return quantum_memory.operate(op, positions)


class IRotationGate(IGate):
    """Instruction to perform a (controlled) quantum rotation gate.

    Parameters
    ----------
    name : str
        Name of instruction for identification purposes.
    axis : tuple, list or np.array of float, optional
        Unit vector representing the rotation axis.
    controlled : bool, optional
        Whether this gate should be a controlled gate or not.
    check_standard_rotations : bool, optional
        Whether this gate should check a list of standard rotation operators or not.
    angle_precision : int, optional
        The number of decimals used when comparing `angle` with standard rotation angles in degrees.

    Notes
    -----
    IRotationGate can check for standard rotations (axis is x, y, z and angle is 90, 180, 270) and
    use the corresponding rotation operator from the Operators module. In this way the cache of
    these operators can be used. If the axis or angle are 'not standard' a new operator will be used
    when executing the instruction.

    """
    _standard_rotation_ops = {
        90: ops.Rx90,
        180: ops.Rx180,
        270: ops.Rx270,
        1090: ops.Ry90,
        1180: ops.Ry180,
        1270: ops.Ry270,
        2090: ops.Rz90,
        2180: ops.Rz180,
        2270: ops.Rz270
    }

    def __init__(self, name, axis=None, controlled=False, check_standard_rotations=True, angle_precision=8):
        self._name = name
        self._axis = axis
        self._controlled = controlled
        self.check_standard_rotations = check_standard_rotations
        self.angle_precision = angle_precision

    @property
    def name(self):
        """str: instruction name."""
        return self._name

    @property
    def num_positions(self):
        """int: number of targeted memory positions. If -1, number is unrestricted."""
        return 2 if self._controlled else 1

    def execute(self, quantum_memory, positions, angle, *args, axis=None, **kwargs):
        """Execute instruction on a quantum memory.

        Parameters
        ----------
        quantum_memory : :obj:`~netsquid.components.qmemory.QuantumMemory`
            Quantum memory to execute instruction on.
        positions : list of int
            Memory positions to do instruction on.
        angle: float
            Rotation angle in radians.
        axis : tuple, list or np.array of float, optional
            Unit vector representing the rotation axis.
        \\*args : list
            Additional arguments that can be used to extend this method.
        \\*\\*kwargs : dict
            Keyword arguments that can be used to to extend this method.

        """
        if self._axis is not None:
            rot_axis = self._axis
        elif axis is not None:
            rot_axis = axis
        else:
            raise InstructionError('No axis available for rotation')
        operator = None
        if self.check_standard_rotations:
            operator = self._get_standard_rotation_operator(rot_axis, angle, self.angle_precision)
        if operator is None:
            operator = ops.create_rotation_op(angle=angle, rotation_axis=rot_axis)
        if self._controlled:
            operator = operator.ctrl
        return quantum_memory.operate(operator, positions)

    def _get_standard_rotation_operator(self, rot_axis, angle, angle_precision):
        # check rotation axis and angle in standard rotation dict
        axis_length = 0
        standard_axis = None
        for i, val in enumerate(rot_axis):
            axis_length += val
            if math.isclose(val, 1.):
                standard_axis = i * 1000
        if standard_axis is not None and math.isclose(axis_length, 1.):
            standard_angle = round(math.degrees(angle), angle_precision) % 360
            if standard_angle == 0:
                # no rotation needed
                return ops.I
            elif standard_angle in [90, 180, 270]:
                key = standard_axis + standard_angle
                return self._standard_rotation_ops.get(key, None)
        # Could not a assign standard operator
        return None


class IControlledDirectionGate(Instruction):
    """Instruction to perform a controlled quantum direction gate.

    Parameters
    ----------
    name : str
        Name of instruction for identification purposes.
    axis : tuple of float, optional
        Unit vector representing the rotation axis.

    """

    def __init__(self, name, axis=None):
        self._name = name
        self._axis = axis
        self._s0_outer = s0 * s0.transpose()
        self._s1_outer = s1 * s1.transpose()

    @property
    def name(self):
        """str: instruction name."""
        return self._name

    @property
    def num_positions(self):
        """int: number of targeted memory positions. If -1, number is unrestricted."""
        return 2

    def execute(self, quantum_memory, positions, angle, *args, axis=None, **kwargs):
        """Execute instruction on a quantum memory.

        Parameters
        ----------
        quantum_memory : :obj:`~netsquid.components.qmemory.QuantumMemory`
            Quantum memory to execute instruction on.
        positions : list of int
            Memory positions to do instruction on.
        angle: float
            Rotation angle in radians.
        axis : tuple of float, optional
            Unit vector representing the rotation axis.
        \\*args : list
            Additional arguments that can be used to extend this method.
        \\*\\*kwargs : dict
            Keyword arguments that can be used to to extend this method.

        """
        if self._axis is not None:
            rot_axis = self._axis
        elif axis is not None:
            rot_axis = axis
        else:
            raise InstructionError('No axis available for rotation')
        # TODO: this below can be improved/optimized. Waistful to use operator just to get a matrix.
        rot_positive = ops.create_rotation_op(angle=angle, rotation_axis=rot_axis)
        rot_negative = ops.create_rotation_op(angle=(-angle), rotation_axis=rot_axis)
        operator_mat = np.kron(self._s0_outer, rot_positive.arr) + np.kron(self._s1_outer, rot_negative.arr)
        operator = ops.Operator(self._name, operator_mat)
        return quantum_memory.operate(operator, positions)


class IMeasure(Instruction):
    """Instruction to do a measurement.

    Default is to create an instruction that measures in the standard basis.

    Parameters
    ----------
    name : str
        Name of instruction for identification purposes.
    observable : :obj:`~netsquid.qubits.operators.Operator`, optional
        Hermitian operator to measure qubit with. Default is ``Z`` i.e.
        the standard basis.
    meas_operators : list of :obj:`~netsquid.qubits.operators.Operator`, optional
        List of measurement operators to measure qubit(s) with. If not None,
        this will override the ``observable`` parameter.

    """

    def __init__(self, name, observable=ops.Z, meas_operators=None):
        self._name = name
        if not isinstance(observable, ops.Operator):
            raise TypeError("{} is not an Operator".format(observable))
        self._observable = observable
        self._meas_operators = meas_operators

    @property
    def name(self):
        """str: instruction name."""
        return self._name

    @property
    def num_positions(self):
        """int: number of targeted memory positions. If -1, number is unrestricted."""
        if self._meas_operators is not None and len(self._meas_operators) > 0:
            return self._meas_operators[0].num_qubits
        else:
            return self._observable.num_qubits

    def execute(self, quantum_memory, positions, *args, meas_operators=None, inplace=True, **kwargs):
        r"""Execute instruction on a quantum memory.

        Parameters
        ----------
        quantum_memory : :obj:`~netsquid.components.qmemory.QuantumMemory`
            Quantum memory to execute instruction on.
        positions : list of int
            Memory positions to do instruction on.
        meas_operators : :obj:`~netsquid.qubits.operators.Operator`, optional
            Measurement operators, which if not ``None`` will override the
            default measurement observable or operators. Can be used to do noisy measurements.
            A list of operators :math:`M_i` that should satisfy the
            completeness equation :math:`\sum_i M_i^\dagger M_i = I`, though this is not checked.
        inplace : bool, optional
            Whether to keep the qubit on the memory position, or remove it.
        \*args : list
            Additional arguments that can be used to extend this method.
        \*\*kwargs : dict
            Keyword arguments that can be used to to extend this method.

        Returns
        -------
        list of int
            List of 0 or 1 for positive or negative eigenvalue of observable, respectively.
            Or in case of measurement operators the index of the operator
            that succeeded.

        Notes
        -----
            For the measurement output to be modifiable by a classical noise model,
            it must be a mutable object, hence we always return a list.

        """
        meas_operators = meas_operators if meas_operators else self._meas_operators
        # Important that we return a mutable list for classical noise models
        results = quantum_memory.measure(positions, observable=self._observable,
                                         meas_operators=meas_operators,
                                         discard=not inplace)[0]
        # if not inplace:
        #     super().pop(positions)
        return results


class IMeasureFaulty(Instruction):
    r"""Projective measurement with error probabilities.

    This instruction calls the :meth:`~netsquid.components.qmemory.QuantumMemory.measure_faulty()` method.

    Parameters
    ----------
    name : str
        Name of this instruction
    observable : :class:`~netsquid.qubits.operators.Operator`, optional
        The observable to use for the measurement. Default the standard basis.
    p0 : float, optional
        The probability of measuring outcome 0 incorrectly. Default 0.
    p1 : float, optional
        The probability of measuring outcome 1 incorrectly. Default 0.

    Raises
    ------
    TypeError
        If the observable is not of class Operator.
    ValueError
        If p0 or p1 are not between 0 and 1.

    """

    def __init__(self, name, observable=ops.Z, p0=0., p1=0.):
        self._name = name
        self._observable = self._check_observable(observable)
        self.p0 = self._check_probability(p0)
        self.p1 = self._check_probability(p1)

    @property
    def name(self):
        return self._name

    @property
    def num_positions(self):
        return -1

    @staticmethod
    def _check_observable(observable):
        if not isinstance(observable, ops.Operator):
            raise TypeError("The observable must be an Operator.")
        if observable.num_qubits != 1:
            raise ValueError("The observable should be a one qubit operator")
        return observable

    @staticmethod
    def _check_probability(probability):
        if probability < 0 or probability > 1:
            raise ValueError(f"The error probability must be between 0 and 1, not {probability}")
        return probability

    def execute(self, quantum_memory, positions, *args, inplace=True, observable=None, p0=None, p1=None, **kwargs):
        """Measures the qubits.

        If multiple qubits are given, they are measured in order.

        Parameters
        ----------
        quantum_memory : :class:`~netsquid.components.qmemory.QuantumMemory`
            The quantum memory the qubits are stored in.
        positions : list of int
            The positions to measure.
        inplace : bool
            If the qubits should be kept in memory after the measurement.
        observable : :class:`~netsquid.qubits.operators.Operator`, optional
            The observable to use in this measurement. Overrides the observable set at initialzation.
        p0 : float, optional
            The probability of measuring outcome 0 incorrectly. Overrides p0 set at initialization.
        p1 : float, optional
            The probability of measuring outcome 1 incorrectly. Overrides p1 set at initialization.
        \\*args : list
            Additional arguments that can be used to extend this method.
        \\*\\*kwargs : dict
            Keyword arguments that can be used to to extend this method.

        Returns
        -------
        list of int
            List of 0 or 1 for positive or negative eigenvalue of observable, respectively.

        Raises
        ------
        TypeError
            If the observable is not of class Operator
        ValueError
            If p0 or p1 are not between 0 and 1

        """
        observable = self._observable if observable is None else self._check_observable(observable)
        p0 = self.p0 if p0 is None else self._check_probability(p0)
        p1 = self.p1 if p1 is None else self._check_probability(p1)
        results, _ = quantum_memory.measure_faulty(positions=positions, observable=observable,
                                                   p0=p0, p1=p1, discard=not inplace)
        return results


class IMeasureBell(IMeasure):
    r"""Instruction to perform a measurement in the Bell basis. The circuit that is used is a
    CNOT (first qubit is control), followed by a Hadamard.

    Notes
    -----

      * Handles special case of stabilizer formalism not supporting
        general measurements.
      * The measurement outcome is a number among {0, 1, 2, 3}. The relation to the measured Bell
        state is defined in :class:`~netsquid.qubits.ketstates.BellIndex`.

    """
    _bsm_op_indices = {
        BellIndex.B00: (0, 0),
        BellIndex.B01: (0, 1),
        BellIndex.B10: (1, 0),
        BellIndex.B11: (1, 1)
    }

    def __init__(self):
        super().__init__(name="measure_bellstate", meas_operators=ops.BELL_PROJECTORS)

    def execute(self, quantum_memory, positions, *args, meas_operators=None, inplace=True, **kwargs):
        r"""Execute instruction on a quantum memory.

        Parameters
        ----------
        quantum_memory : :obj:`~netsquid.components.qmemory.QuantumMemory`
            Quantum memory to execute instruction on.
        positions : list of int
            Memory positions to do instruction on.
        meas_operators : :obj:`~netsquid.qubits.operators.Operator`, optional
            Measurement operators, which if not ``None`` will override the
            default measurement observable or operators. Can be used to do noisy measurements.
            A list of operators :math:`M_i` that should satisfy the
            completeness equation :math:`\sum_i M_i^\dagger M_i = I`, though this is not checked.
        inplace : bool, optional
            Whether to keep the qubit on the memory position, or remove it.
        \*args : list
            Additional arguments that can be used to extend this method.
        \*\*kwargs : dict
            Keyword arguments that can be used to to extend this method.

        Returns
        -------
        list of int
            List of 0 or 1 for positive or negative eigenvalue of observable, respectively.
            Or in case of measurement operators the index of the operator
            that succeeded.

        Notes
        -----
            For the measurement output to be modifiable by a classical noise model,
            it must be a mutable object, hence we always return a list.

        """
        if get_qstate_formalism() not in [QFormalism.STAB, QFormalism.GSLC]:
            results = super().execute(quantum_memory=quantum_memory, positions=positions,
                                      meas_operators=meas_operators, inplace=inplace, **kwargs)
        else:
            # Mimic a Bell state measurement for stabilizers
            quantum_memory.operate(ops.CNOT, positions)
            quantum_memory.operate(ops.H, positions[0:1])
            results = quantum_memory.measure(positions, observable=ops.Z,
                                             discard=not inplace)[0]
            for key, val in self._bsm_op_indices.items():
                if val == tuple(results):
                    results = [key]
                    break
        return results


class IEmit(Instruction):
    """Instruction to emit a qubit that is entangled with a qubit in memory.

    Emission is conditioned on the memory qubit being in the ``|0>`` state, which is determined by measurement.
    Emission requires the use of an auxiliary memory position, which gets emptied in the process. The emitted qubit is
    put in a message on the qout port.

    The name of the emitting quantum memory is included in the meta of the message (as "source") along with other meta
    data added via the key word argument when calling this instruction.

    """

    @property
    def name(self):
        return "emit_ent_qubit"

    @property
    def num_positions(self):
        return 2

    def execute(self, quantum_memory, positions, *args, **kwargs):
        """Perform emission of entangled qubit.

        Parameters
        ----------
        quantum_memory : :obj:`~netsquid.components.qmemory.QuantumMemory`
            Quantum memory to execute instruction on.
        positions : list of int, length 2
            Memory positions involved in emission.
            The first is the position of the memory qubit that is entangled with the emitted qubit,
            the second is the auxiliary position used to perform the emission.
        \\*args : list
            Additional arguments that can be used to extend this method.
        \\*\\*kwargs : dict
            Keyword arguments that can be used to to extend this method.

        Notes
        -----
        When you need to apply noise to the entangled qubits, you can either add a noise model to the qout port of the
        quantum memory (which applies noise to the emitted qubit), or adding a quantum noise model to a
        ``PhysicalInstruction`` (which will apply noise to the memory position and not the empty emission position).

        When the measurement on the memory position returns 1, a qubit with an empty state will be emitted.

        """
        memory_position = positions[0]
        emission_position = positions[1]

        # Since only a |0> state can create an entangled photon, the qubit is measured.
        # Maybe it would be better to model this conditional emission by entangling the photon's presence
        # with the ion state, but since this would require qudits we instead collapse the wave function.
        [memory_state], _ = quantum_memory.measure(memory_position)

        # create photon
        if memory_state == 1:
            # emission not possible
            [emission_qubit] = qapi.create_qubits(1, no_state=True)
        else:
            # create entangled pair
            [memory_qubit] = quantum_memory.peek(memory_position)
            [emission_qubit] = qapi.create_qubits(1)
            qapi.operate(memory_qubit, ops.H)
            qapi.operate([memory_qubit, emission_qubit], ops.CNOT)

        quantum_memory.put(emission_qubit, emission_position)
        meta_data = {"source": quantum_memory.name}
        if "meta_data" in kwargs:
            meta_data.update(kwargs["meta_data"])
        quantum_memory.pop(emission_position, meta_data=meta_data, skip_noise=True)


class IDiscard(Instruction):
    """Instruction to discard a qubit or qubits from the quantum memory.

    """
    @property
    def name(self):
        return "discard_qubit"

    @property
    def num_positions(self):
        return -1

    def execute(self, quantum_memory, positions, *args, **kwargs):
        """Discard a qubit or qubits from the quantum memory at given positions.

        Parameters
        ----------
        quantum_memory : :obj:`~netsquid.components.qmemory.QuantumMemory`
            Quantum memory to execute instruction on.
        positions : list of int
            Memory position(s) of qubit(s) to discard.
        \\*args : list
            Additional arguments that can be used to extend this method.
        \\*\\*kwargs : dict
            Keyword arguments that can be used to to extend this method.

        """
        quantum_memory.discard(positions)


INSTR_INIT = IInit()
""":obj:`~netsquid.components.instructions.Instruction`: initialize a qubit on a quantum memory."""

INSTR_SWAP = ISwap()
""":obj:`~netsquid.components.instructions.Instruction`: swap qubits on a quantum memory."""

INSTR_UNITARY = IGate("unitary_gate")
""":obj:`~netsquid.components.instructions.Instruction`: arbitrary gate on arbitrary number of qubits."""

INSTR_1QUBIT = IGate("single_qubit_gate", num_positions=1)
""":obj:`~netsquid.components.instructions.Instruction`: arbitrary single qubit gate."""

INSTR_2QUBIT = IGate("two_qubit_gate", num_positions=2)
""":obj:`~netsquid.components.instructions.Instruction`: arbitrary two qubit gate."""

INSTR_X = IGate("x_gate", ops.X)
""":obj:`~netsquid.components.instructions.Instruction`: X gate."""

INSTR_Y = IGate("y_gate", ops.Y)
""":obj:`~netsquid.components.instructions.Instruction`: Y gate."""

INSTR_S = IGate("s_gate", ops.S)
""":obj:`~netsquid.components.instructions.Instruction`: S gate."""

INSTR_T = IGate("t_gate", ops.T)
""":obj:`~netsquid.components.instructions.Instruction`: T gate."""

INSTR_Z = IGate("z_gate", ops.Z)
""":obj:`~netsquid.components.instructions.Instruction`: Z gate."""

INSTR_H = IGate("h_gate", ops.H)
""":obj:`~netsquid.components.instructions.Instruction`: H gate."""

INSTR_K = IGate("k_gate", ops.K)
""":obj:`~netsquid.components.instructions.Instruction`: K gate."""

INSTR_I = IGate("i_gate", ops.I)
""":obj:`~netsquid.components.instructions.Instruction`: I gate."""

INSTR_CX = IGate("cx_gate", ops.CX)
""":obj:`~netsquid.components.instructions.Instruction`: Controlled X gate."""

# NOTE: same as INSTR_CX but with a different name
INSTR_CNOT = IGate("cnot_gate", ops.CX)
""":obj:`~netsquid.components.instructions.Instruction`: Controlled NOT gate (= CX)."""

INSTR_CCX = IGate("ccx_gate", ops.CCX)
""":obj:`~netsquid.components.instructions.Instruction`: Controlled controlled X gate."""

# NOTE: same as INSTR_CCX but with a different name
INSTR_TOFFOLI = IGate("toffoli_gate", ops.CCX)
""":obj:`~netsquid.components.instructions.Instruction`: Toffoli gate (= CCX)."""

INSTR_CS = IGate("cphase_gate", ops.CS)
""":obj:`~netsquid.components.instructions.Instruction`: controlled S gate."""

INSTR_CZ = IGate("cz_gate", ops.CZ)
""":obj:`~netsquid.components.instructions.Instruction`: controlled Z gate."""

INSTR_CDIR = IControlledDirectionGate('c_direction')
""":obj:`~netsquid.components.instructions.Instruction`: controlled direction gate."""

INSTR_CXDIR = IControlledDirectionGate('cx_direction', axis=(1, 0, 0))
""":obj:`~netsquid.components.instructions.Instruction`: controlled X-direction gate."""

INSTR_CYDIR = IControlledDirectionGate('cy_direction', axis=(0, 1, 0))
""":obj:`~netsquid.components.instructions.Instruction`: controlled Y-direction gate."""

INSTR_CZDIR = IControlledDirectionGate('cz_direction', axis=(0, 0, 1))
""":obj:`~netsquid.components.instructions.Instruction`: controlled Z-direction gate."""

INSTR_ROT = IRotationGate('rotation_gate')
""":obj:`~netsquid.components.instructions.Instruction`: rotation gate."""

INSTR_ROT_X = IRotationGate('x_rot_gate', axis=(1, 0, 0))
""":obj:`~netsquid.components.instructions.Instruction`: X-axis rotation gate."""

INSTR_ROT_Y = IRotationGate('y_rot_gate', axis=(0, 1, 0))
""":obj:`~netsquid.components.instructions.Instruction`: Y-axis rotation gate."""

INSTR_ROT_Z = IRotationGate('z_rot_gate', axis=(0, 0, 1))
""":obj:`~netsquid.components.instructions.Instruction`: Z-axis rotation gate."""

INSTR_CROT = IRotationGate('crot_gate', controlled=True)
""":obj:`~netsquid.components.instructions.Instruction`: controlled rotation gate."""

INSTR_CROT_X = IRotationGate('crotx_gate', axis=(1, 0, 0), controlled=True)
""":obj:`~netsquid.components.instructions.Instruction`: controlled X-axis rotation gate."""

INSTR_CROT_Y = IRotationGate('croty_gate', axis=(0, 1, 0), controlled=True)
""":obj:`~netsquid.components.instructions.Instruction`: controlled Y-axis rotation gate."""

INSTR_CROT_Z = IRotationGate('crotz_gate', axis=(0, 0, 1), controlled=True)
""":obj:`~netsquid.components.instructions.Instruction`: controlled Z-axis rotation gate."""

INSTR_MEASURE = IMeasure("measurement_op")
""":obj:`~netsquid.components.instructions.Instruction`: measure a qubit (default is standard basis)."""

INSTR_MEASURE_X = IMeasure("measure_x", observable=ops.X)
""":obj:`~netsquid.components.instructions.Instruction`: measure a qubit in Hadamard basis."""

INSTR_MEASURE_BELL = IMeasureBell()
""":obj:`~netsquid.components.instructions.Instruction`: measure two qubits in the Bell-state basis."""

INSTR_MEASURE_FAULTY = IMeasureFaulty('measure_faulty_op')
""":obj:`~netsquid.components.instructions.Instruction`: measure qubits with some probability of
measuring incorrectly (default is no error).
"""

INSTR_SIGNAL = ISignal("signal")
""":obj:`~netsquid.components.instructions.Instruction`: send out a signal."""

INSTR_EMIT = IEmit()
""":obj:`~netsquid.components.instructions.Instruction`: emit a qubit entangled with a qubit in memory."""

INSTR_DISCARD = IDiscard()
""":obj:`~netsquid.components.instructions.Instruction`: discard a qubit or qubits from the quantum
memory.
"""


class InstructionError(Exception):
    """An exception that, if raised, will cause a quantum program to fail.

    """
    pass
