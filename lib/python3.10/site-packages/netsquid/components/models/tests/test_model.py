# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_model.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"""Unit tests for model module.

"""
import unittest
import numpy as np
from netsquid.components.models.model import Model
from netsquid.components.component import Component
from netsquid.util import simtools
from netsquid.util.constrainedmap import ConstrainedMap
from netsquid.qubits import qformalism as qform


class BasicTestModel(Model):
    """Basic test model."""

    def __init__(self, **kwargs):
        super().__init__()
        self.properties.update(kwargs)
        self.required_properties = ["test_property"]

    def compute_model(self, items, increment=1, **kwargs):
        for idx in range(len(items)):
            items[idx] += increment
            if "multiplier" in kwargs:
                items[idx] *= kwargs["multiplier"]


class TestModel(unittest.TestCase):
    """Unit tests for the model module."""

    def setUp(self):
        qform.set_qstate_formalism(qform.QFormalism.KET)
        simtools.set_random_state(rng=np.random.RandomState(0))  # reset RNG

    def tearDown(self):
        qform.set_qstate_formalism(qform.QFormalism.KET)

    def test_properties(self):
        """Test setting and getting properties."""
        model_1 = BasicTestModel()
        self.assertIsInstance(model_1.properties, ConstrainedMap)
        self.assertEqual(len(model_1.properties), 0)
        model_2 = BasicTestModel(some_property=99)
        self.assertEqual(model_2.properties, {"some_property": 99})

    def test_required_properties(self):
        """Test getting and setting required properties."""
        model_1 = BasicTestModel()
        self.assertEqual(model_1.required_properties, ["test_property"])
        model_1.required_properties = ["prop_1", "prop_2"]
        self.assertCountEqual(model_1.required_properties, ["prop_1", "prop_2"])
        # Required properties should be set with a list, not a tuple.
        with self.assertRaises(TypeError):
            model_1.required_properties = ("prop_1", "prop_2")

    def test_validate_method(self):
        """Test validate method independently and when attached to a Component."""

        class BasicTestComponent(Component):
            """Basic test component."""

            def __init__(self, name, test_model, test_property):
                super().__init__(name, properties={"test_property": test_property}, models={"test_model": test_model})

        class WrongTestComponent(Component):
            """Basic test component."""

            def __init__(self, name, test_model, wrong_property):
                super().__init__(name, properties={"wrong_property": wrong_property}, models={"test_model": test_model})

        c = BasicTestComponent(name='test', test_model=BasicTestModel(), test_property=99)
        self.assertTrue(c.models["test_model"].validate(**c.properties))
        # A model given to a Component not having the required properties, should raise a ValueError.
        with self.assertRaises(ValueError):
            WrongTestComponent(name='test', test_model=BasicTestModel(), wrong_property=99)

    def test_compute_model(self):
        """Test calling compute model."""
        test_items = [1, 2, 3]
        model_1 = BasicTestModel()
        model_1.compute_model(test_items)
        self.assertEqual(test_items, [2, 3, 4])
        # Test passing args
        model_1.compute_model(test_items, increment=10)
        self.assertEqual(test_items, [12, 13, 14])
        # Test passing kwargs
        model_1.compute_model(test_items, increment=10, multiplier=2)
        self.assertEqual(test_items, [44, 46, 48])

    def test_calling_model(self):
        """Test calling the model directly."""
        test_items = [1, 2, 3]
        model_1 = BasicTestModel()
        model_1(test_items)
        self.assertEqual(test_items, [2, 3, 4])
        # Test passing args
        model_1(test_items, increment=10)
        self.assertEqual(test_items, [12, 13, 14])
        # Test passing kwargs
        model_1(test_items, increment=10, multiplier=2)
        self.assertEqual(test_items, [44, 46, 48])


if __name__ == "__main__":
    unittest.main()
