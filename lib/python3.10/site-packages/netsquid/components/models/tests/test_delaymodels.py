# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_delaymodels.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the delay models.

"""
import unittest
from unittest.mock import Mock, MagicMock
import numpy as np
from netsquid.components.models.delaymodels import DelayModel, GaussianDelayModel, FibreDelayModel
from netsquid.util import simtools
from netsquid.qubits import qformalism as qform


class TestDelayModels(unittest.TestCase):
    """Unit tests for the delaymodels module."""

    def setUp(self):
        qform.set_qstate_formalism(qform.QFormalism.KET)
        simtools.set_random_state(rng=np.random.RandomState(0))  # reset RNG

    def tearDown(self):
        qform.set_qstate_formalism(qform.QFormalism.KET)

    def test_DelayModel_interface(self):
        """Test DelayModel interface, model properties and required parameters."""

        class TestDelayModel(DelayModel):
            def __init__(self, delay=5, **kwargs):
                super().__init__(**kwargs)
                self.properties.update(kwargs)
                self.required_properties = ['length']
                self.delay = 5

            def get_mean(self, **kwargs):
                return self.generate_delay()

            def set_mean(self, value):
                self.delay = value

            def get_std(self, **kwargs):
                return 0

            def generate_delay(self, **kwargs):
                return self.delay

        model = TestDelayModel()
        self.assertEqual(model(), 5)

        model.set_mean(9)
        self.assertEqual(model(), 9)

        # test variables are passed properly
        model = TestDelayModel(test_variable=1, c=10)
        self.assertEqual(model.properties['test_variable'], 1)
        self.assertEqual(model.properties['c'], 10)
        # test validate function
        test_dict = {'length': 1, 'c': 1}
        self.assertTrue(model.validate(**test_dict))
        self.assertTrue(model.validate(length=1))
        self.assertFalse(model.validate(foo=5))
        self.assertFalse(model.validate())

    def test_GaussianDelayModel(self):
        """Test GaussianDelayModel example"""
        rng = Mock(np.random.RandomState)
        rng.normal = MagicMock(return_value=8)
        model = GaussianDelayModel(delay_mean=10, delay_std=1, rng=rng)
        self.assertEqual(model(), 8)
        model = GaussianDelayModel(delay_mean=0, delay_std=0, rng=None)
        self.assertEqual(model(), 0)

    def test_FibreDelayModel(self):
        """Test FibreDelayModel example"""
        # For several random values for the speed of light,
        # we check that the delay of a channel whose length
        # is precisely c, that its delay in seconds is c / c = 1,
        # which is equivalent to 10^9 nanoseconds
        for c in [3, 10, 25, 100]:
            fdmodel = FibreDelayModel(c=c)
            mean_delay = fdmodel.get_mean(length=c)
            sampled_delay = fdmodel.generate_delay(length=c)
            for delay in [mean_delay, sampled_delay]:
                self.assertEqual(delay, 1e9)
        with self.assertRaises(ValueError):
            FibreDelayModel(c=-10)
        with self.assertRaises(TypeError):
            FibreDelayModel(c=1j)


if __name__ == "__main__":
    unittest.main()
