# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_concatenatingmodels.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for concatenating different types of models.

"""
import unittest
import netsquid as ns
import numpy as np
from netsquid.qubits import ketutil as ku
from netsquid.qubits.qubit import Qubit
from netsquid.qubits import qformalism as qform
from netsquid.qubits import qubitapi as qapi
from netsquid.components.models.model import Model, ModelCompositionException
from netsquid.components.models.delaymodels import DelayModel, GaussianDelayModel, FixedDelayModel
from netsquid.components.models.errormodels import ErrorModel
from netsquid.components.models.cerrormodels import ClassicalErrorModel
from netsquid.components.models.qerrormodels import QuantumErrorModel, DepolarNoiseModel, DephaseNoiseModel, \
    T1T2NoiseModel, FibreLossModel


class NonComposableModel(Model):

    def compute_model(self, *args, **kwargs):
        pass


class ExampleModel(Model):

    def __init__(self, value=0):
        super().__init__()
        self.value = value

    def compute_model(self, items, *args, **kwargs):
        for i in range(len(items)):
            items[i] **= self.value

    @classmethod
    def concatenation_class(cls):
        return ExampleModel


class ExampleAddModel(ExampleModel):

    def compute_model(self, items, addition=0, *args, **kwargs):
        for i in range(len(items)):
            items[i] += addition


class ExampleMultiplicationModel(ExampleModel):
    def compute_model(self, items, multiplier=1, *args, **kwargs):
        for i in range(len(items)):
            items[i] *= multiplier


class TestConcatModels(unittest.TestCase):

    def test_init(self):
        """Test initialisation of concatenated models """
        m1 = ExampleModel(2)
        m2 = ExampleModel(3)
        self.assertEqual(len(m1), 1)
        self.assertFalse(m1.is_concatenated)
        self.assertFalse(m2.is_concatenated)
        m3 = m1 + m2
        self.assertTrue(m3.is_concatenated)
        self.assertEqual(len(m3), 2)
        self.assertIsInstance(m3, ExampleModel)
        self.assertIsInstance(m3, m1.concatenation_class())
        self.assertTrue(m1 in m3)
        self.assertTrue(m2 in m3)
        self.assertFalse(m3 in m2)
        self.assertFalse(m1 in m2)

    def test_order(self):
        """Test if models are computed in the right order"""
        m1 = ExampleModel(2)
        m2 = ExampleModel(3)
        m3 = m1 + m2
        self.assertEqual(len(m3), 2)
        self.assertIsInstance(m3, ExampleModel)
        items = [1, 2, 3, 4, 5]
        m3(items)
        self.assertListEqual(items, [1, 4 ** 3, 9 ** 3, 16 ** 3, 25 ** 3])
        m4 = m2 + m1
        self.assertEqual(len(m4), 2)
        self.assertIsInstance(m4, ExampleModel)
        items = [1, 2, 3, 4, 5]
        m4(items)
        self.assertListEqual(items, [1, 8 ** 2, 27 ** 2, 64 ** 2, 125 ** 2])

    def test_arguments(self):
        """Check if arguments are correctly passed through"""
        m1 = ExampleAddModel()
        m2 = ExampleMultiplicationModel()
        m3 = m1 + m2
        self.assertEqual(len(m3), 2)
        self.assertIsInstance(m3, ExampleModel)
        items = [1, 2, 3, 4, 5]
        m3(items, addition=4, multiplier=2)
        self.assertListEqual(items, [10, 12, 14, 16, 18])

    def test_multiplying(self):
        """Test for multiplying models to repeat them"""
        m1 = ExampleAddModel()
        m2 = ExampleMultiplicationModel()
        m3 = 5 * m1
        self.assertEqual(len(m3), 5)
        self.assertNotIn(m1, m2)
        self.assertIn(m1, m3)
        self.assertNotIn(m3, m1)
        self.assertIsInstance(m3, ExampleModel)
        items = [1, 2, 3, 4, 5]
        m3(items, addition=3)
        self.assertListEqual(items, [16, 17, 18, 19, 20])
        m3 = m1 * 5
        self.assertEqual(len(m3), 5)
        self.assertIn(m1, m3)
        self.assertNotIn(m2, m3)
        self.assertIsInstance(m3, ExampleModel)
        items = [1, 2, 3, 4, 5]
        m3(items, addition=3)
        self.assertListEqual(items, [16, 17, 18, 19, 20])
        m3 = 5 * (m1 + m2)  # != 5*m1 + 5*m2 if m1 and m2 are not commutative
        self.assertEqual(len(m3), 10)
        self.assertIn(m1, m3)
        self.assertIn(m2, m3)
        self.assertIsInstance(m3, ExampleModel)
        items = [1, 2, 3, 4, 5]
        expected_list = items[:]
        m3(items, addition=3, multiplier=2)
        for _ in range(5):
            for i in range(len(expected_list)):
                expected_list[i] = (expected_list[i] + 3) * 2
        self.assertListEqual(items, expected_list)
        m3 = 5 * m1 + 5 * m2
        self.assertEqual(len(m3), 10)
        self.assertIn(m1, m3)
        self.assertIn(m2, m3)
        self.assertIsInstance(m3, ExampleModel)
        items = [1, 2, 3, 4, 5]
        expected_list = items[:]
        m3(items, addition=3, multiplier=2)
        for i in range(len(expected_list)):
            expected_list[i] = (expected_list[i] + 5 * 3) * (2 ** 5)
        self.assertListEqual(items, expected_list)

        with self.assertRaises(TypeError):
            "1" * m1
        with self.assertRaises(TypeError):
            m1 * m2
        with self.assertRaises(TypeError):
            m1 * True
        with self.assertRaises(ValueError):
            m1 * 0
        with self.assertRaises(ValueError):
            m1 * -1
        with self.assertRaises(TypeError):
            m1 * 1.5

    def test_adding_not_addable(self):
        """Test for trying to add models that can't be added"""
        with self.assertRaises(ModelCompositionException):
            NonComposableModel() + NonComposableModel()
        with self.assertRaises(ModelCompositionException):
            NonComposableModel() + ExampleMultiplicationModel()
        with self.assertRaises(ModelCompositionException):
            ExampleMultiplicationModel() + NonComposableModel()
        with self.assertRaises(ModelCompositionException):
            4 * NonComposableModel()
        with self.assertRaises(ModelCompositionException):
            NonComposableModel() * 4

        x = NonComposableModel()
        self.assertEqual(len(x), 1)
        self.assertIn(x, x)
        y = 1 * x
        z = x * 1
        self.assertIn(z, y)
        self.assertIs(x, y)
        self.assertIs(z, x)


class TestConcatQuantumModels(unittest.TestCase):

    def test_depolar_concat(self):
        """Test concatenation two depolar noise models"""
        qform.set_qstate_formalism(qform.QFormalism.DM)
        p1 = 0.7
        p2 = 0.2
        m1 = DepolarNoiseModel(p1, time_independent=True)
        m2 = DepolarNoiseModel(p2, time_independent=True)
        m3 = m1 + m2
        self.assertIsInstance(m3, QuantumErrorModel)
        q = ns.qubits.create_qubits(1)[0]
        m3([q, None])
        p = (1 - (1 - p1) * (1 - p2)) / 2
        self.assertTrue(np.allclose(
            qapi.reduced_dm(q),
            p * ku.ket2dm(ns.s1) + (1 - p) * ku.ket2dm(ns.s0)))

    def test_dephase_concat(self):
        """Test concatenation two dephase noise models"""
        qform.set_qstate_formalism(qform.QFormalism.DM)
        p1 = 0.7
        p2 = 0.2
        m1 = DephaseNoiseModel(p1, time_independent=True)
        m2 = DephaseNoiseModel(p2, time_independent=True)
        m3 = m1 + m2
        self.assertIsInstance(m3, QuantumErrorModel)
        q = ns.qubits.create_qubits(1)[0]
        ns.qubits.operate(q, ns.H)
        m3([None, q])
        ns.qubits.operate(q, ns.H)
        p = (1 - (1 - p1) * (1 - p2)) / 2
        self.assertTrue(np.allclose(
            qapi.reduced_dm(q),
            p * ku.ket2dm(ns.s0) + (1 - p) * ku.ket2dm(ns.s1)))

    def test_dephase_plus_depolar(self):
        """Test concatenation of a depolar with a dephase"""
        qform.set_qstate_formalism(qform.QFormalism.DM)
        p1 = 0.7
        p2 = 0.2
        m1 = DephaseNoiseModel(p1, time_independent=True)
        m2 = DepolarNoiseModel(p2, time_independent=True)
        m3 = m1 + m2
        self.assertIsInstance(m3, QuantumErrorModel)
        q1, q2 = ns.qubits.create_qubits(2)
        ns.qubits.operate(q1, ns.H)
        ns.qubits.operate(q2, ns.H)
        m1([None, q2])
        m2([None, q2, None])
        m3([q1, None])
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), qapi.reduced_dm(q2)))

    def test_concat_T1T2(self):
        """Test concatenation two T1T2 noise models"""
        qform.set_qstate_formalism(qform.QFormalism.DM)
        m1 = T1T2NoiseModel(400, 300)
        m2 = T1T2NoiseModel(200, 120)
        m3 = m1 + m2
        self.assertIsInstance(m3, QuantumErrorModel)
        q1, q2 = ns.qubits.create_qubits(2)
        ns.qubits.operate(q1, ns.H)
        ns.qubits.operate(q2, ns.H)
        m1([None, q2])
        m2([None, q2, None])
        m3([q1, None])
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), qapi.reduced_dm(q2)))

    def test_much_concatenation(self):
        """Test concatenating lots of quantum error models"""
        qform.set_qstate_formalism(qform.QFormalism.DM)
        m = {0: T1T2NoiseModel(400), 1: T1T2NoiseModel(T2=120), 2: DephaseNoiseModel(0.44, time_independent=True),
             3: DepolarNoiseModel(0.44, time_independent=True), 4: T1T2NoiseModel(200, 120), 5: DepolarNoiseModel(0.78),
             6: DephaseNoiseModel(0.2)}
        big_model = m[0]
        for i in range(1, 6):
            big_model += m[i]
        self.assertIsInstance(big_model, QuantumErrorModel)
        q1, q2 = ns.qubits.create_qubits(2)
        ns.qubits.operate(q1, ns.H)
        ns.qubits.operate(q2, ns.H)
        for model in m.values():
            model([None, q2, None])
        big_model([q1])
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), qapi.reduced_dm(q2)))

    def test_loss_model_concat(self):
        """Test concatenating loss models"""
        qform.set_qstate_formalism(qform.QFormalism.DM)
        p1 = 0.2
        p2 = 0.5
        p = p1 + p2 - p1 * p2  # probability that a qubit gets lost with two loss models
        m1 = FibreLossModel(p_loss_init=p1)
        m2 = FibreLossModel(p_loss_init=p2)
        m3 = m1 + m2
        self.assertIsInstance(m3, QuantumErrorModel)
        n = 50000
        qubits = ns.qubits.create_qubits(n)
        m3(qubits, length=0)
        nones = 0
        for qubit in qubits:
            if qubit is None:
                nones += 1
        self.assertAlmostEqual(nones, p * n, delta=n / 100)


class ExampleClassicalErrorModel(ClassicalErrorModel):
    def error_operation(self, items, delta_time=0, **kwargs):
        for i in range(len(items)):
            items[i] += 4


class TestConcatErrorModel(unittest.TestCase):

    def test_adding_classical_with_quantum(self):
        """Test adding a classical with a quantum error model"""
        m1 = DephaseNoiseModel(0.4)
        m2 = ExampleClassicalErrorModel()
        m3 = m1 + m2
        self.assertIsInstance(m3, ErrorModel)

        # Test that doing this is completely useless as everything you input gets rejected by one or the other class
        with self.assertRaises(TypeError):
            m3([Qubit("test_qubit")])
        with self.assertRaises(TypeError):
            m3(["Test"])


class TestConcatClassicalErrorModel(unittest.TestCase):

    def test_adding_classical(self):
        """Test adding a classical  error model"""
        m1 = ExampleClassicalErrorModel()
        m2 = ExampleClassicalErrorModel()
        m3 = m1 + m2
        self.assertIsInstance(m3, ClassicalErrorModel)

        with self.assertRaises(TypeError):
            m3([Qubit("test_qubit")])


class TestConcatDelayModels(unittest.TestCase):

    def test_adding_delay_model(self):
        """Test adding delay models"""
        m1 = FixedDelayModel(4)
        m2 = GaussianDelayModel(10, 0)
        m3 = m1 + m2 + m1
        self.assertIsInstance(m3, DelayModel)

        self.assertEqual(m3(), 18)
        self.assertEqual(m3.generate_delay(), 18)
        self.assertEqual(m3.get_mean(), 18)

        with self.assertRaises(ModelCompositionException):
            m3.set_mean(4)

        with self.assertRaises(ModelCompositionException):
            m3.get_std()


# Test for inheritances

class TestModel(Model):

    def noise_operation(self, qubits, delta_time=0, **kwargs):
        pass

    def __init__(self, p=0):
        super().__init__()
        self.p = p

    @classmethod
    def concatenation_class(cls):
        return TestModel

    def compute_model(self, l):
        if self.is_concatenated:
            for model in self._models:
                l = model(l)
        else:
            l[0] = l[0] ** self.p
        return l


class A(TestModel):
    @classmethod
    def concatenation_class(cls):
        return A


class B(A):
    @classmethod
    def concatenation_class(cls):
        return B


class C(B):
    @classmethod
    def concatenation_class(cls):
        return C


class D(A):
    pass


class E(D):
    @classmethod
    def concatenation_class(cls):
        return E


class F(E):
    @classmethod
    def concatenation_class(cls):
        return F


class G(C, E):
    pass


class TestComposableModels(unittest.TestCase):

    def test_concatenation(self):
        """Test basic concatenation"""
        model1 = TestModel()
        model2 = TestModel()
        model3 = TestModel()

        model12 = model1 + model2
        self.assertIsInstance(model12, TestModel)
        self.assertEqual(len(model12), 2)
        self.assertTrue(model1 in model12)
        self.assertTrue(model2 in model12)
        self.assertFalse(model12 in model12)
        model123 = model3 + model12
        self.assertIsInstance(model123, TestModel)
        self.assertEqual(len(model123), 3)
        self.assertTrue(model1 in model123)
        self.assertTrue(model2 in model123)
        self.assertTrue(model3 in model123)
        self.assertFalse(model12 in model123)
        # order
        self.assertEqual(model123._concatenated_models[0], model3)
        self.assertEqual(model123._concatenated_models[1], model1)
        self.assertEqual(model123._concatenated_models[2], model2)

        with self.assertRaises(TypeError):
            TestModel() + 1

    def test_self_concatenation(self):
        """Test adding models to themselves"""
        model1 = TestModel()
        model2 = model1 + model1

        self.assertIsInstance(model2, TestModel)
        self.assertEqual(len(model2), 2)

    def test_required_properties(self):
        """Test if required properties are correctly copied over"""
        model1 = TestModel()
        model1._required_properties = ["a", "b"]

        model2 = TestModel()
        model2._required_properties = ["a", "c"]

        model12 = model1 + model2

        self.assertEqual(len(model12.required_properties), 3)
        self.assertTrue("a" in model12.required_properties)
        self.assertTrue("b" in model12.required_properties)
        self.assertTrue("c" in model12.required_properties)

        model1._required_properties = ["d", "e"]
        self.assertEqual(len(model12.required_properties), 4)
        self.assertTrue("a" in model12.required_properties)
        self.assertFalse("b" in model12.required_properties)
        self.assertTrue("c" in model12.required_properties)
        self.assertTrue("d" in model12.required_properties)
        self.assertTrue("e" in model12.required_properties)

        with self.assertRaises(ValueError):
            model12.required_properties = ["k"]

        self.assertTrue(model12.validate(a=1, b=2, c=3, d=4, e=5, f=6))
        self.assertTrue(model12.validate(a=1, c=3, d=4, e=5))
        self.assertFalse(model12.validate(a=1, c=3))
        self.assertFalse(model12.validate(d=1, e=3))

    def test_compute_model(self):
        """Test if the models are executed in the correct order"""
        model1 = TestModel(3)
        model2 = TestModel(4)
        model12 = model1 + model2
        x = [2]
        model12(x)
        self.assertEqual(x[0], (2 ** 3) ** 4)
        model21 = model2 + model1
        x = [2]
        model21(x)
        self.assertEqual(x[0], (2 ** 4) ** 3)

    def test_diff_noise_model_concatenation(self):
        """Test concatenation ability of different type of noise models"""

        self.assertEqual(type(A()), A)

        self.assertEqual(type(A() + A()), A)
        self.assertEqual(type(A() + B()), A)
        self.assertEqual(type(B() + B()), B)
        self.assertEqual(type(C() + F()), A)
        self.assertEqual(type(F() + C()), A)
        self.assertEqual(type(D() + D()), A)
        self.assertEqual(type(F() + F()), F)
        self.assertEqual(type(E() + B()), A)
        self.assertEqual(type(B() + E()), A)
        self.assertEqual(type(F() + E()), E)
        self.assertEqual(type(E() + F()), E)
        self.assertEqual(type(G() + F()), A)

        self.assertEqual(type(A() + A() + A()), A)
        self.assertEqual(type(A() + B() + B()), A)
        self.assertEqual(type(B() + B() + B()), B)
        self.assertEqual(type(C() + F() + G()), A)
        self.assertEqual(type(F() + C() + D()), A)
        self.assertEqual(type(D() + D() + E()), A)
        self.assertEqual(type(F() + F() + F()), F)
        self.assertEqual(type(E() + B() + C()), A)
        self.assertEqual(type(B() + E() + F()), A)
        self.assertEqual(type(F() + E() + F()), E)
        self.assertEqual(type(E() + F() + E()), E)
        self.assertEqual(type(G() + F() + G()), A)

        self.assertEqual(type((A() + A()) + (A() + A())), A)
        self.assertEqual(type((A() + B()) + (A() + B())), A)
        self.assertEqual(type((B() + B()) + (B() + B())), B)
        self.assertEqual(type((C() + F()) + (C() + F())), A)
        self.assertEqual(type((F() + C()) + (F() + C())), A)
        self.assertEqual(type((D() + D()) + (D() + D())), A)
        self.assertEqual(type((F() + F()) + (F() + F())), F)
        self.assertEqual(type((E() + B()) + (E() + B())), A)
        self.assertEqual(type((B() + E()) + (B() + E())), A)
        self.assertEqual(type((F() + E()) + (F() + E())), E)
        self.assertEqual(type((E() + F()) + (E() + F())), E)
        self.assertEqual(type((G() + F()) + (G() + F())), A)

    def test_multiplication(self):
        """Test multiplication of models"""

        x = A() * 5
        self.assertEqual(type(x), A)
        self.assertEqual(len(x), 5)

        x = 5 * A()
        self.assertEqual(type(x), A)
        self.assertEqual(len(x), 5)

        x = 5 * A() * 5
        self.assertEqual(len(x), 25)
        self.assertEqual(type(x), A)

        a = A()
        x = a * 1
        self.assertEqual(x, a)

        x = 1 * a
        self.assertEqual(a, x)

        with self.assertRaises(TypeError):
            A() * B()

        with self.assertRaises(TypeError):
            "a" * A()

        with self.assertRaises(TypeError):
            A() * "b"

        with self.assertRaises(ValueError):
            -1 * A()

        with self.assertRaises(ValueError):
            A() * -1

        with self.assertRaises(TypeError):
            1.5 * A()

        with self.assertRaises(TypeError):
            A() * 1.5

        with self.assertRaises(TypeError):
            1.0 * A()

        with self.assertRaises(TypeError):
            A() * 1.0

        a = A(3) + A(2) * 3 + 2 * A(3)
        x = [2]
        a(x)
        self.assertEqual(len(a), 6)
        self.assertEqual(x[0], (((((2 ** 2) ** 2) ** 2) ** 3) ** 3) ** 3)

        ef = 2 * (E(3) + 2 * F(2))
        self.assertEqual(len(ef), 6)
        x = [2]
        ef(x)
        self.assertEqual(x[0], (((((2 ** 3) ** 2) ** 2) ** 3) ** 2) ** 2)

    def test_diamond_model(self):
        """Test logic when adding models with multiple inheritance (such as diamond structure of models)"""

        #  since H subclasses both C and F..
        class H(F, C):
            pass

        self.assertEqual(type(H() + C()), A)  # Should this be CC?
        self.assertEqual(type(H() + F()), F)  # Should this be AC?
        self.assertEqual(type(H() + H()), F)  # What should this be?


if __name__ == "__main__":
    unittest.main()
