# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_errormodels.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for errormodel module.

"""
import unittest
from netsquid.components.models.errormodels import ErrorModel


class BasicTestErrorModel(ErrorModel):
    """Basic test model."""

    def __init__(self, **kwargs):
        super().__init__()

    def error_operation(self, items, increment=1, **kwargs):
        for idx in range(len(items)):
            if items[idx] is not None:
                items[idx] += increment
                if "multiplier" in kwargs:
                    items[idx] *= kwargs["multiplier"]


class TestErrorModel(unittest.TestCase):
    """Unit tests for the ErrorModel class."""

    def test_items_is_list(self):
        """Test items should be a list."""
        model_1 = BasicTestErrorModel()
        with self.assertRaises(TypeError):
            model_1(items=1)
        with self.assertRaises(TypeError):
            model_1(items="test_input_string")
        with self.assertRaises(TypeError):
            model_1(items=(1, 2, 3))
        model_1(items=[None, 2, 3])

    def test_compute_model(self):
        """Test calling compute model."""
        test_items = [1, 2, 3]
        model_1 = BasicTestErrorModel()
        model_1.compute_model(test_items)
        self.assertEqual(test_items, [2, 3, 4])
        # Test passing args
        model_1.compute_model(test_items, increment=10)
        self.assertEqual(test_items, [12, 13, 14])
        # Test passing kwargs
        model_1.compute_model(test_items, increment=10, multiplier=2)
        self.assertEqual(test_items, [44, 46, 48])

    def test_calling_model(self):
        """Test calling the model directly."""
        test_items = [1, 2, 3]
        model_1 = BasicTestErrorModel()
        model_1(test_items)
        self.assertEqual(test_items, [2, 3, 4])
        # Test passing args
        model_1(test_items, increment=10)
        self.assertEqual(test_items, [12, 13, 14])
        # Test passing kwargs
        model_1(test_items, increment=10, multiplier=2)
        self.assertEqual(test_items, [44, 46, 48])


if __name__ == "__main__":
    unittest.main()
