# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_qerrormodels.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the model in the QuantumErrorModels module.

"""
import unittest
from unittest.mock import Mock, MagicMock
import numpy as np
import random
import netsquid as ns
from netsquid.components.channel import Channel
from netsquid.components.models.qerrormodels import (
    QuantumErrorModel, DepolarNoiseModel, T1T2NoiseModel, DephaseNoiseModel, FibreLossModel)
from netsquid.util import simtools
from netsquid.qubits import qubitapi as qapi
from netsquid.qubits import operators as ops
from netsquid.qubits import qformalism as qform
from netsquid.qubits.ketstates import s0, s1, h0, h1, b00
from netsquid.qubits.ketutil import ket2dm


class TestQuantumErrorModel(unittest.TestCase):
    """Unit tests for the QuantumErrorModels module.

    """

    def setUp(self):
        qform.set_qstate_formalism(qform.QFormalism.KET)
        simtools.set_random_state(rng=np.random.RandomState(0))  # reset RNG

    def tearDown(self):
        qform.set_qstate_formalism(qform.QFormalism.KET)

    def test_interface(self):
        """Test QuantumErrorModel interface."""

        class TestQuantumErrorModel(QuantumErrorModel):
            def __init__(self, **kwargs):
                super().__init__()
                self.properties.update(kwargs)
                self.required_properties = ['test_variable']

            def error_operation(self, qubits, delta_time, **kwargs):
                if delta_time * kwargs['test_variable'] > 5:
                    for qubit in qubits:
                        qapi.operate(qubit, ops.X)

        q1, q2 = qapi.create_qubits(2)
        model = TestQuantumErrorModel(new_variable=3)
        # test passing any kwargs when model is instantiated
        self.assertEqual(model.properties['new_variable'], 3)
        # main model call and with a dictionary
        # insufficient delay for noise
        model([q1], **{'test_variable': 0})
        model([q1], test_variable=0)
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), ket2dm(s0)))
        model([q1], 1, test_variable=1)
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), ket2dm(s0)))
        # sufficient delay for noise
        model([q1], 2, test_variable=5)
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), ket2dm(s1)))
        # multiple qubits
        model([q1, q2], 10, test_variable=1)
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), ket2dm(s0)))
        self.assertTrue(np.allclose(qapi.reduced_dm(q2), ket2dm(s1)))

    def test_DepolarNoiseModel(self):
        """Test DepolarNoiseModel."""
        qform.set_qstate_formalism(qform.QFormalism.DM)
        model = DepolarNoiseModel(depolar_rate=500)
        self.assertEqual(model.depolar_rate, 500)
        self.assertFalse(model.time_independent)
        with self.assertRaises(ValueError):
            model.depolar_rate = -1
        model.depolar_rate = 1000
        self.assertEqual(model.depolar_rate, 1000)
        q1, = qapi.create_qubits(1)
        model([q1], 0)
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), ket2dm(s0)))
        model([q1], 100e9)
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), np.eye(2) * 0.5))
        model = DepolarNoiseModel(depolar_rate=1.0, time_independent=True)
        self.assertEqual(model.depolar_rate, 1.0)
        self.assertTrue(model.time_independent)
        with self.assertRaises(ValueError):
            model.depolar_rate = -1
        with self.assertRaises(ValueError):
            model.depolar_rate = 2
        q1, = qapi.create_qubits(1)
        model([q1], 0)
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), np.eye(2) * 0.5))

    def test_DephaseNoiseModel(self):
        """Test DephaseNoiseModel."""
        qform.set_qstate_formalism(qform.QFormalism.DM)
        model = DephaseNoiseModel(dephase_rate=500)
        self.assertEqual(model.dephase_rate, 500)
        self.assertFalse(model.time_independent)
        with self.assertRaises(ValueError):
            model.dephase_rate = -1
        model.dephase_rate = 1000
        self.assertEqual(model.dephase_rate, 1000)
        q1, = qapi.create_qubits(1)
        qapi.operate([q1], ops.H)
        model([q1], 0)
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), ket2dm(h0)))
        model([q1], 100e9)
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), ket2dm(h1)))
        model = DephaseNoiseModel(dephase_rate=1.0, time_independent=True)
        self.assertEqual(model.dephase_rate, 1.0)
        self.assertTrue(model.time_independent)
        with self.assertRaises(ValueError):
            model.dephase_rate = -1
        with self.assertRaises(ValueError):
            model.dephase_rate = 2
        q1, = qapi.create_qubits(1)
        qapi.operate([q1], ops.H)
        model([q1], 0)
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), ket2dm(h1)))


class TestT1T2NoiseModel(unittest.TestCase):
    """Unit tests for the T1T2NoiseModel.

    """

    def setUp(self):
        qform.set_qstate_formalism(qform.QFormalism.KET)
        simtools.set_random_state(rng=np.random.RandomState(0))  # reset RNG

    def tearDown(self):
        qform.set_qstate_formalism(qform.QFormalism.KET)

    def test_init(self):
        """Test initialization."""
        noise_model = T1T2NoiseModel()
        self.assertEqual(noise_model.T1, 0)
        self.assertEqual(noise_model.T2, 0)

        T1 = random.uniform(0, 10)
        T2 = random.uniform(0, T1)
        noise_model = T1T2NoiseModel(T1=T1, T2=T2)
        self.assertEqual(noise_model.T1, T1)
        self.assertEqual(noise_model.T2, T2)

        with self.assertRaises(ValueError):
            noise_model = T1T2NoiseModel(T1=-1)
        with self.assertRaises(ValueError):
            noise_model = T1T2NoiseModel(T2=-1)
        with self.assertRaises(ValueError):
            noise_model = T1T2NoiseModel(T1=3, T2=5)

    def test_error_operation_ket(self):
        """Test error_operation for QFormalism.KET."""
        qform.set_qstate_formalism(qform.QFormalism.KET)

        # No noise (infinite T1 and T2)
        noise_model = T1T2NoiseModel()
        q1, q2 = qapi.create_qubits(2)
        qapi.operate(q1, ns.H)
        qapi.operate(q2, ns.H)
        noise_model.error_operation([q1, None], 10)
        self.assertTrue(q1.qstate.compare(q2.qstate))

        # XXX probabilistic tests

    def test_error_operation_dm(self):
        """Test error_operation for QFormalism.DM."""
        qform.set_qstate_formalism(qform.QFormalism.DM)

        # No noise (infinite T1 and T2)
        noise_model = T1T2NoiseModel()
        q1, q2 = qapi.create_qubits(2)
        qapi.operate(q1, ns.H)
        qapi.operate(q2, ns.H)
        noise_model.error_operation([q1, None], 10)
        self.assertTrue(q1.qstate.compare(q2.qstate))

        # Infinite T1, High T2
        noise_model = T1T2NoiseModel(T2=100)
        q1 = qapi.create_qubits(1)[0]
        qapi.operate(q1, ns.H)
        noise_model.error_operation([q1, None], 1)
        ref_ket = np.array([[1 / np.sqrt(2)]] * 2)
        F = qapi.fidelity(q1, ref_ket)
        self.assertAlmostEqual(F, 1, 2)

        # Infinite T1, Low T2
        noise_model = T1T2NoiseModel(T2=1)
        q1 = qapi.create_qubits(1)[0]
        qapi.operate(q1, ns.H)
        noise_model.error_operation([q1, None], 100)
        rho = qapi.reduced_dm(q1)
        purity = np.trace(rho @ rho)
        self.assertAlmostEqual(purity, 1 / 2)

        # High T1, High T2
        noise_model = T1T2NoiseModel(T1=100, T2=100)
        q1 = qapi.create_qubits(1)[0]
        qapi.operate(q1, ns.H)
        noise_model.error_operation([q1, None], 1)
        ref_ket = np.array([[1 / np.sqrt(2)]] * 2)
        F = qapi.fidelity(q1, ref_ket)
        self.assertAlmostEqual(F, 1, 2)

        # High T1, Low T2
        noise_model = T1T2NoiseModel(T1=10000, T2=1)
        q1 = qapi.create_qubits(1)[0]
        qapi.operate(q1, ns.H)
        noise_model.error_operation([q1, None], 100)
        rho = qapi.reduced_dm(q1)
        purity = np.trace(rho @ rho)
        self.assertAlmostEqual(purity, 1 / 2, 4)

        # Low T1, Low T2
        noise_model = T1T2NoiseModel(T1=1, T2=1)
        q1 = qapi.create_qubits(1)[0]
        qapi.operate(q1, ns.H)
        noise_model.error_operation([q1, q2], 100)
        ref_ket = np.array([[1], [0]])
        F = qapi.fidelity(q1, ref_ket)
        self.assertAlmostEqual(F, 1)

    def test_fibre_loss_model_init(self):
        """Test FibreLossModel init"""
        rng = np.random.RandomState()
        p_loss_init = np.random.random_sample()
        p_loss_length = np.random.random_sample()
        model = FibreLossModel(p_loss_init=p_loss_init, p_loss_length=p_loss_length, rng=rng)
        self.assertEqual(model.p_loss_init, p_loss_init)
        self.assertEqual(model.p_loss_length, p_loss_length)
        self.assertEqual(model.rng, rng)
        self.assertEqual(model.properties['p_loss_init'], p_loss_init)
        self.assertEqual(model.properties['p_loss_length'], p_loss_length)
        self.assertEqual(model.properties['rng'], rng)
        model.p_loss_init = 0.1
        self.assertEqual(model.properties['p_loss_init'], 0.1)

    def test_fibre_loss_model_qubits(self):
        """Test FibreLossModel example on standard qubits"""
        qform.set_qstate_formalism(qform.QFormalism.KET)
        q1, q2, q3, q4 = qapi.create_qubits(4)
        qapi.operate(q1, ops.H)
        qapi.operate([q1, q2], ops.CNOT)  # b00 state
        qapi.operate(q3, ops.H)
        qapi.operate([q3, q4], ops.CNOT)  # b00 state
        rng = Mock(np.random.RandomState)
        c = Channel("TestChannel", length=20)
        model = FibreLossModel(p_loss_init=0.2, p_loss_length=0, rng=rng)

        self._check_random_sample_threshold(lambda x=0: model([q1], 0, **c.properties), q1, 0.20, None, b00, rng)
        model = FibreLossModel(p_loss_init=0.0, p_loss_length=0.25, rng=rng)
        self._check_random_sample_threshold(lambda x=0: model([q3], 0, **c.properties), q3, 0.684, None, b00, rng)
        self.assertTrue(np.isclose(qapi.fidelity(q2, s0), 1) or np.isclose(qapi.fidelity(q2, s1), 1))
        self.assertTrue(np.isclose(qapi.fidelity(q4, s0), 1) or np.isclose(qapi.fidelity(q4, s1), 1))

    def _check_random_sample_threshold(self, fn_call, input_qubit, threshold, low_result, high_result, rng):
        # checks random sampling has correct threshold set
        # NOTE implementation specific
        rng.random_sample = MagicMock(return_value=threshold * 1.05)
        fn_call()
        self.assertTrue(np.allclose(input_qubit.qstate.qrepr.reduced_dm(), ket2dm(high_result)))
        rng.random_sample = MagicMock(return_value=threshold * 0.95)
        fn_call()
        self.assertEqual(input_qubit.qstate, low_result)


if __name__ == "__main__":
    unittest.main()
