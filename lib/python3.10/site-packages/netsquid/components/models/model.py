# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: model.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""
The model interface (abstract base class) defined in this module allows
users to specify custom functionality for the elements of the simulation.
"""
import abc
from netsquid.util.constrainedmap import ConstrainedMap


class Model(metaclass=abc.ABCMeta):
    """Interface to apply different functionalities (models) to the simulation
    components.

    Models can be used by any object as long as the parameters needed by the
    model are provided. The parameters needed by the models are divided in two types:
    properties and required_properties.

    Notes
    -----
        Each model has a minimum of requirements (parameters that need to be
        defined) in order for the model to be executed. The *model properties* are
        independent of the object that is calling the model and hence, some
        default values have already been set. The *required properties* depend on
        the object that is calling the model and are passed to the model when
        the model is called. The model properties defaults can be changed when
        an object is instantiated or as attributes.

    """

    def __init__(self):
        self._properties = ConstrainedMap()
        self._required_properties = []
        self._concatenated_models = [self]

    @classmethod
    def concatenation_class(cls):
        """Type of the object that is returned when concatenating this model.

        To be overwritten for classes that can be concatenated/combined.

        Returns
        -------
        subclass of `~netsquid.components.models.Model` or None
            The class that should be used when concatenating two Models that are an instance of this class

        """
        return None

    @property
    def properties(self):
        """:class:`~netsquid.util.constrainedmap.ConstrainedMap` : Properties of the model.
        They are independent of the object that is calling/using the model."""
        # NOTE no setter defined as it should not be set
        return self._properties

    def add_property(self, name, value=None, mutable=True, value_type=None, value_constraints=None):
        """Add a property to this model.

        Properties can be accessed and modified via the
        :attr:`~netsquid.components.models.Model.properties` attribute.

        If a property with this name already exists, an attempt will be made to
        set the new value.

        Parameters
        ----------
        name : str
            Name of the property.
        value : Any
            Value of the property.
        mutable : bool, optional
            Whether the property is mutable. Default True.
        value_type : type or tuple thereof, optional
            Allowed types of this property. Not constrained by default.
        value_constraints : `~netsquid.util.constrainedmap.ValueConstraint` or list of `~netsquid.util.constrainedmap.ValueConstraint` , optional
            Constraint checks to verify if value is a valid value. Not constrained by default.

        """
        if name not in self._properties:
            self._properties.internal_add(key=name, value=value, mutable=mutable, value_type=value_type, value_constraints=value_constraints)
        else:
            self._properties[name] = value

    @property
    def required_properties(self):
        """list: Parameters that need to be passed to the model when the
        model is called."""
        properties = self._required_properties
        if self.is_concatenated:
            properties = []
            for model in self._models:
                properties += model.required_properties
        return list(set(properties))

    @required_properties.setter
    def required_properties(self, value):
        if self.is_concatenated:
            raise ValueError("Can not set properties of a composite models")
        if not isinstance(value, list):
            raise TypeError("{} is not a list".format(value))
        self._required_properties = value

    def validate(self, **properties):
        """Verifies that the given properties match the required properties.

        The validate method is only called when a model is "attached" to a component.
        The model verifies that all the *required properties* have been
        defined as a part of the components properties.

        Parameters
        ----------
        \\*\\*properties
            Input properties to be validated.

        Returns
        -------
        bool
            Returns True if all the *required properties* have been passed to
            the model. Otherwise returns False.

        """
        if self.is_concatenated:
            for model in self._models:
                if not model.validate(**properties):
                    return False
            return True
        for item in self.required_properties:
            if item not in properties.keys():
                return False
        return True

    @abc.abstractmethod
    def compute_model(self, *args, **kwargs):
        """Execute the model based on the given parameters and model properties.

        This is the method called when the object is used as a callable function.

        Parameters
        ----------
        \\*args
            Any dynamic variable passed to the model.
        \\*\\*kwargs:
            These are the :attr:`~netsquid.components.models.model.Model.required_properties`
            needed by the model.

        Notes
        -----
            For error models it executes the method "error_operation".
            For delay models it executes the method "generate_delay".

        """
        raise NotImplementedError

    @property
    def is_concatenated(self):
        """If this model is concatenated by adding multiple models together

        Returns
        -------
        bool
            Whether this model consist of multiple models
        """
        return len(self._models) >= 2

    @property
    def _models(self):
        if not hasattr(self, "_concatenated_models"):
            self._concatenated_models = [self]
        return self._concatenated_models

    @_models.setter
    def _models(self, models):
        if self.concatenation_class() is None:
            raise ModelCompositionException("Model {} can not be concatenated".format(type(self)))
        for model in models:
            if not isinstance(model, Model) and not issubclass(model.concatenation_class(), self.concatenation_class()):
                raise TypeError("Model {} can not be concatenated into a {}".format(type(model),
                                                                                    type(self.concatenation_class())))
        self._concatenated_models = models

    def __call__(self, *args, **kwargs):
        # Makes this a callable function.
        if self.is_concatenated:
            for model in self._models:
                model(*args, **kwargs)
        else:
            return self.compute_model(*args, **kwargs)

    def __add__(self, other):
        if not isinstance(other, Model):
            raise TypeError("unsupported operand type(s) for +: {} and {}".format(type(self), type(other)))
        concatenation_class_self = self.__class__.concatenation_class()
        concatenation_class_other = other.__class__.concatenation_class()
        if concatenation_class_self is None or concatenation_class_other is None:
            raise ModelCompositionException("Cannot concatenate models {} and {}".format(type(self), type(other)))
        # Find closest common super class
        concatenation_class = None
        if issubclass(concatenation_class_self, concatenation_class_other):
            concatenation_class = concatenation_class_other
        elif issubclass(concatenation_class_other, concatenation_class_self):
            concatenation_class = concatenation_class_self
        else:
            super_classes = concatenation_class_self.__bases__
            while concatenation_class is None and super_classes:
                for base in super_classes:
                    if issubclass(base, Model):
                        if issubclass(concatenation_class_other, base):
                            concatenation_class = base
                        else:
                            super_classes = base.__bases__
                        break
                else:
                    raise ModelCompositionException("Cannot concatenate models {} and {}".format(type(self), type(other)))
        concatenation_model = concatenation_class()
        concatenation_model._models = self._models + other._models
        return concatenation_model

    def __mul__(self, other):
        if isinstance(other, bool) or not isinstance(other, int):
            raise TypeError(
                "unsupported operand type(s) for *: {} and {}. Can only multiply models by integers"
                .format(type(self), type(other)))
        if other <= 0:
            raise ValueError("Can not multiply models by negative numbers or zero")
        if other == 1:
            return self
        if not self.__class__.concatenation_class():
            raise ModelCompositionException("Can not multiply instance of class {}".format(type(self)))
        concatenation_model = self.__class__.concatenation_class()()
        concatenation_model._models = self._models * other
        return concatenation_model

    def __rmul__(self, other):
        return self.__mul__(other)

    def __len__(self):
        return len(self._models)

    def __contains__(self, item):
        return item in self._models


class ModelCompositionException(Exception):
    pass
