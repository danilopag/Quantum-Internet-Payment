# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: qchannel.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Defines a quantum channel, which is essentially a :obj:`~netsquid.components.channel.Channel`
intended for transmitting qubits. It also facilitates qubit noise and loss.
Note that *transmission* is used in the loose sense of moving the qubit through
time, not necessarily through space. For example, a quantum memory or quantum
gate are also quantum channels because they use the same *send* and *receive* functionality,
and may wish to specify delay, noise and loss models.

"""
from netsquid.qubits.qubit import Qubit
from netsquid.components.channel import Channel
from netsquid.components.models.qerrormodels import QuantumErrorModel
__all__ = [
    "QuantumChannel",
]


class QuantumChannel(Channel):
    """A one-way quantum channel capable of transmitting qubit(s) with
    delay, loss and noise.

    Functions similarly to :obj:`~netsquid.components.channels.Channel` but
    for qubits.

    Parameters
    ----------
    name : str
        Name of channel for identification purposes.
    delay : float, optional
        Fixed transmission delay to use if ``delay_model`` is ``None`` [ns].
    length : float, optional
        Length of channel [km]. May be used by delay, loss and noise models.
    models : dict or None, optional
        Models associated with this component. Will first specify them by their
        type and them set them.
        See the Models section to see which (key, Model) pair it recognizes.
    transmit_empty_items : bool, optional
        Whether to transmit items equal to ``None``. This includes items that become
        None after input prepocessing. Default is False.
    properties : dict or None, optional
        Extra properties associated with this component.

    Properties
    ----------
    length : int
        Length of the channel.

    Ports
    -----
    send
        Input port for transmitting messages.
    recv
        Output port for receiving messages.

    Models
    ------
    delay_model : :obj:`~netsquid.components.models.delaymodels.DelayModel` or None, optional
        Callable object that generates a transmission delay.
        If ``None``, :obj:`~netsquid.components.models.delaymodels.FixedDelayModel` is used.
        Non-trivial use of this functionality can result in messages arriving
        out of order.
    quantum_noise_model : :obj:`~netsquid.components.models.qerrormodels.QuantumErrorModel` or None, optional
        Callable object intended to probabilistically apply quantum noise to qubit(s) when they are received from the channel.
        If ``None``, no error model is applied.
    quantum_loss_model : :obj:`~netsquid.components.models.qerrormodels.QuantumErrorModel` or None, optional
        Callable object intended to compute whether the qubit(s) are (collectively) lost when they are put on the channel.
        If ``None``, no error model is applied.

    Notes
    -----
        QChannel supports multiple concurrent transmissions. A FIFO order is
        guaranteed. Delays generated by a ``delay_model`` that do not conform
        to FIFO will raise an exception.

    """

    def __init__(self, name, delay=0, length=0, models=None, transmit_empty_items=False, properties=None, **kwargs):
        if models is None:
            models = {}
        self.specify_model('quantum_noise_model', model_type=QuantumErrorModel)
        self.specify_model('quantum_loss_model', model_type=QuantumErrorModel)
        super().__init__(name=name, delay=delay, length=length, models=models,
                         transmit_empty_items=transmit_empty_items, properties=properties, **kwargs)

    def preprocess_inputs(self, delay, qubits):
        """Process sent qubits to see if they will be lost during transmission.

        Parameters
        ----------
        delay : float
            Time that qubit(s) will spend transmitting on channel.
        qubits : list of :obj:`~netsquid.qubits.qubit.Qubit`
            Qubits being transmitted. Qubits can also be ``None``.

        Returns
        -------
        list of :obj:`~netsquid.qubits.qubit.Qubit`
            Preprocessed qubits being transmitted, with lost qubits
            either set to``None`` or removed (see ).

        Raises
        ------
        ValueError
            If ``qubits`` is not a list of qubits. Qubits can also be ``None``.

        """
        # Check if user gave tuple of qubits (instead of list) by mistake
        if len(qubits) == 1 and isinstance(qubits[0], tuple):
            qubits = list(qubits[0])
        for qubit in qubits:
            if qubit is not None and not isinstance(qubit, Qubit):
                raise ValueError("{} is not a valid Qubit".format(qubit))
        if self.models["quantum_loss_model"] is not None:
            self.models["quantum_loss_model"](qubits, delay, **self.properties)
        if not self.transmit_empty_items:
            qubits = [qubit for qubit in qubits if qubit is not None]
        return qubits

    def postprocess_outputs(self, delta_time, qubits):
        """Postprocess outputs as they are taken off the channel.

        Parameters
        ----------
        delta_time : float
            Time that qubits spent on the channel.
        qubits : list of :obj:`~netsquid.qubits.qubit.Qubit`
            Qubits being transmitted.

        Returns
        -------
        list of Qubit
            Postprocessed output items.

        """
        if len(qubits) > 0 and self.models["quantum_noise_model"] is not None:
            self.models["quantum_noise_model"](qubits, delta_time, **self.properties)
        return qubits
