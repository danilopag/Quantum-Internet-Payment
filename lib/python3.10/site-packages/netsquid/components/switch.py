# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: switch.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Defines the Switch interface, a component to control the flow of messages.
Implements a SimpleSwitch component to quickly setup forwarding and merging of messages.

"""

from netsquid.components.component import Component, Message
import abc

__all__ = ["Switch", "SimpleSwitch", "SwitchError"]


class Switch(Component, metaclass=abc.ABCMeta):
    """Forward messages based on a routing table.

    By subclassing this interface and implementing a routing table,
    it is possible to direct, split, and broadcast messages
    to the ports of this component.

    Parameters
    ----------
    name : str
       Name of component for identification and display purposes.
    properties : dict or None, optional
        Properties associated with this component, as key-value pairs.
        Properties set this way are mutable and do not have a specified type.
    models : dict or None, optional
        Models associated with this component. Will first specify them by their
        type and then set them.
        See the Models section of a component to see which (key, Model) pair it recognizes.
    subcomponents : dict or None, optional
        Sub-components of this component.
    port_names : list of str or None, optional
        Names of ports to add to this component.

    """

    def add_ports(self, names):
        """Add ports to this component.

        Added ports are accessible via :attr:`~netsquid.components.switch.Switch.ports`.
        Their inputs are automatically bound to :meth:`~netsquid.components.switch.Switch._handle_input`.

        Parameters
        ----------
        names : list of str
            Names of ports.

        Returns
        -------
        list of :obj:`~netsquid.components.component.Port`
            List of the ports with the given names.

        Notes
        -----
        If a port with this name already exists it is also returned in the list, but not overwritten.
        The bound input handler will be overwritten.

        """
        ports = super(Switch, self).add_ports(names)
        for port in ports:
            port.bind_input_handler(self._input_handler, tag_meta=True)

    def _input_handler(self, message: Message):
        # Retrieve the target port from the routing table
        # and send the message on its way.
        input_port = message.meta.pop("rx_port_name")
        targets = self.routing_table(input_port, message)
        for msg, port_name in targets:
            if port_name not in self.ports:
                raise SwitchError(f"Forwarding to unknown port '{port_name}'.")
            self.ports[port_name].tx_output(msg)

    @abc.abstractmethod
    def routing_table(self, input_port, message) -> [(Message, str)]:
        """Specify which port this message should be forwarded to.

        Parameters
        ----------
        input_port : str
            The name of the input port.
        message : :class:`~netsquid.components.component.Message`
            The message which is routed.

        Returns
        -------
        list of tuples of :class:`~netsquid.components.component.Message` and string
            Returns a list with message and port pairs, where each message is forwarded to the port output.

        """


class SimpleSwitch(Switch):
    """A switch to route messages via a topology.

    Incoming messages are forwarded without any alteration to the destination port.
    The destination port is defined in the topology, thus only depends on the input port.

    Parameters
    ----------
    name : str
        The name of this component.
    topology : dict[str, str]
        The mapping from input port to output port.
        The input ports are added automatically.

    Examples
    --------

    >>> from netsquid.components.switch import SimpleSwitch
    >>> switch = SimpleSwitch('switch', {'a': 'c', 'b': 'c', 'c': 'c'})
    >>> switch.ports['a'].tx_input('hello, world!')
    >>> switch.ports['c'].rx_output()
    Message(items=['hello, world!'])

    """

    def __init__(self, name, topology: {str: str}):
        ports = list(topology.keys())
        super(SimpleSwitch, self).__init__(name, port_names=ports)
        self._topology = topology

    @property
    def topology(self):
        """dict: The mapping from input port to output port."""
        return self._topology

    @topology.setter
    def topology(self, value):
        self._topology = value

    def routing_table(self, input_port, message) -> [(Message, str)]:
        return [(message, self.topology[input_port])]


class SwitchError(Exception):
    """An error associated with switches."""
    pass
