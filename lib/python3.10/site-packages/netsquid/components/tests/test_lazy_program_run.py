# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_lazy_program_run.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import unittest
from unittest.mock import patch
import netsquid as ns
from netsquid.components import qprocessor as qproc_module
from netsquid.qubits import operators as ops
from netsquid.qubits import qubitapi as qapi
import numpy as np
from netsquid.components.instructions import (
    INSTR_X, INSTR_Z, INSTR_H, INSTR_CNOT, INSTR_CZ, INSTR_UNITARY, INSTR_MEASURE, INSTR_MEASURE_X, INSTR_INIT,
    INSTR_1QUBIT, INSTR_2QUBIT, INSTR_SIGNAL)
from netsquid.components.qmemory import MemPositionEmptyError
from netsquid.components.qprocessor import (
    QuantumProcessor, PhysicalInstruction, MissingInstructionError, ProcessorStatus)
from netsquid.components.qprogram import QuantumProgram
from netsquid.components.models.qerrormodels import QuantumErrorModel
from netsquid.components.tests.test_cchannel import ThresholdBitNoiseModel as CThresholdNoiseModel
from netsquid.components.tests.test_qchannel import ThresholdNoiseModel as QThresholdNoiseModel
from netsquid.qubits.ketstates import s0, s1, h0, h1, s10, s01, s00, h01, h10, s11


class LazyQuantumProgram(QuantumProgram):
    def run(self, *args, **kwargs):
        if "lazy" not in kwargs:
            return super().run(*args, lazy=True, **kwargs)
        return super().run(*args, **kwargs)


class CustomQProgram(LazyQuantumProgram):
    """A program that applies a sequence of gates."""
    default_num_qubits = 2

    def program(self):
        q1, q2 = self.get_qubit_indices(2)
        self.apply(INSTR_X, q1)
        self.apply(INSTR_CNOT, [q1, q2])
        self.apply(INSTR_SIGNAL)
        self.apply(INSTR_MEASURE, q1, output_key="m1")
        self.apply(INSTR_MEASURE, q2, output_key="m2")
        yield self.run()


class ControlledQProgram(LazyQuantumProgram):
    """A program that makes use classical control."""
    default_num_qubits = 3

    def program(self):
        # Example of program with control logic
        q1, q2, q3 = self.get_qubit_indices(3)
        self.apply(INSTR_MEASURE, q1, output_key="m1")
        self.first_sequence = True  # Used by test
        yield self.run()
        # Depending on outcome on q1 either flip q2 or q3
        if self.output["m1"][0] == 0:
            self.apply(INSTR_X, q2)
        else:
            self.apply(INSTR_X, q3)
        self.apply(INSTR_MEASURE, q2, output_key="m2")
        self.apply(INSTR_MEASURE, q3, output_key="m3")
        self.second_sequence = True  # Used by test
        yield self.run()


class ParallelQProgram(LazyQuantumProgram):
    """A program that runs very differently in parallel versus non-parallel."""
    default_num_qubits = 4

    def program(self):
        q1, q2, q3, q4 = self.get_qubit_indices(4)
        self.apply(INSTR_INIT, q1)
        self.apply(INSTR_INIT, q2)
        self.apply(INSTR_INIT, q3)
        self.apply(INSTR_INIT, q4)
        yield self.run(parallel=self.parallel)
        self.apply(INSTR_X, q1)
        self.apply(INSTR_X, q4)
        self.apply(INSTR_CNOT, [q1, q2])
        self.apply(INSTR_CNOT, [q3, q4])
        self.apply(INSTR_H, q3)
        self.apply(INSTR_H, q4)
        self.apply(INSTR_MEASURE, q1, output_key="m1")
        self.apply(INSTR_MEASURE, q2, output_key="m2")
        self.apply(INSTR_MEASURE_X, q3, output_key="m3")
        self.apply(INSTR_MEASURE_X, q4, output_key="m4")
        yield self.run(parallel=self.parallel)
        if self.output["m1"][0] == 1:
            self.apply(INSTR_X, q1)
        if self.output["m2"][0] == 1:
            self.apply(INSTR_X, q2)
        yield self.run(parallel=self.parallel)


class CheatingQProgram(LazyQuantumProgram):
    """A program that 'cheats' using some non-physical instructions."""
    default_num_qubits = 2

    def program(self):
        q1, q2 = self.get_qubit_indices(2)
        self.apply(INSTR_X, q1)
        self.apply(INSTR_SIGNAL, physical=False)
        self.apply(INSTR_Z, q1, physical=False)
        self.apply(INSTR_CNOT, [q1, q2])
        self.apply(INSTR_MEASURE, q1, output_key="m1", physical=False)
        self.apply(INSTR_MEASURE, q2, output_key="m2", physical=False)
        yield self.run()


class TestLazyJobExecution(unittest.TestCase):

    def setUp(self):
        ns.sim_reset()
        qproc_module.error_on_program_fail = False  # default value
        self.helper = ns.Entity()  # helper entity
        self.PI_X = PhysicalInstruction(INSTR_X, duration=1)
        self.PI_H = PhysicalInstruction(INSTR_H, duration=1)
        self.PI_1QUBIT = PhysicalInstruction(INSTR_1QUBIT, duration=5)
        self.PI_CNOT = PhysicalInstruction(INSTR_CNOT, duration=2)
        self.PI_CZ = PhysicalInstruction(INSTR_CZ, duration=4)
        self.PI_2QUBIT = PhysicalInstruction(INSTR_2QUBIT, duration=6)
        self.PI_MZ = PhysicalInstruction(INSTR_MEASURE, duration=3)
        self.PI_SIG = PhysicalInstruction(INSTR_SIGNAL, duration=0.1)
        self.program_done = False
        self.program_fail = False
        self.signal = None

        def done_callback(event):
            self.program_done = True

        def fail_callback(event):
            self.program_fail = True

        def signal_callback(event):
            self.signal = ns.sim_time()

        self.evhandler_prog_done = ns.EventHandler(done_callback)
        self.evhandler_prog_fail = ns.EventHandler(fail_callback)
        self.evhandler_signal = ns.EventHandler(signal_callback)

    def test_lazy_program(self):
        qproc = QuantumProcessor("TestQPD", num_positions=2, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=2, parallel=True),
            PhysicalInstruction(INSTR_H, duration=200, parallel=True),
            PhysicalInstruction(INSTR_CNOT, duration=2, parallel=True)
        ])
        prog = LazyQuantumProgram(num_qubits=2)
        prog.apply(INSTR_INIT, 0)
        prog.apply(INSTR_INIT, 1)
        prog.apply(INSTR_H, 0)
        prog.apply(INSTR_CNOT, [0, 1])
        qproc.execute_program(prog, error_on_fail=True)
        ns.sim_run(1)
        with self.assertRaises(ns.components.qmemory.MemPositionBusyError):
            qproc.peek(0)
        qproc.mem_positions[0].busy = False
        qproc.mem_positions[1].busy = False
        q0 = qproc.peek(0)[0]
        q1 = qproc.peek(1)[0]
        self.assertIsInstance(q0, ns.qubits.qubit.Qubit)
        self.assertIsInstance(q1, ns.qubits.qubit.Qubit)
        self.assertTrue(q0.qstate == q1.qstate)
        ns.sim_run()
        self.assertEqual(ns.sim_time(), 204)

    def test_parallel_program(self):
        qproc = QuantumProcessor("TestQPD", num_positions=2, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=2, parallel=True),
            PhysicalInstruction(INSTR_X, duration=20, parallel=True),
            PhysicalInstruction(INSTR_H, duration=200, parallel=True),
            PhysicalInstruction(INSTR_CNOT, duration=2, parallel=True)
        ])
        prog = LazyQuantumProgram(num_qubits=2)
        prog.apply(INSTR_INIT, 0)
        prog.apply(INSTR_INIT, 1)
        prog.apply(INSTR_X, 0)
        prog.apply(INSTR_X, 0)
        prog.apply(INSTR_X, 0)
        prog.apply(INSTR_X, 0)
        prog.apply(INSTR_H, 1)
        prog.apply(INSTR_CNOT, [0, 1])
        qproc.execute_program(prog, error_on_fail=True)
        ns.sim_run(1)
        with self.assertRaises(ns.components.qmemory.MemPositionBusyError):
            qproc.peek(0)
        qproc.mem_positions[0].busy = False
        qproc.mem_positions[1].busy = False
        q0 = qproc.peek(0)[0]
        q1 = qproc.peek(1)[0]
        self.assertIsInstance(q0, ns.qubits.qubit.Qubit)
        self.assertIsInstance(q1, ns.qubits.qubit.Qubit)
        self.assertTrue(q0.qstate == q1.qstate)
        ns.sim_run()
        self.assertEqual(ns.sim_time(), 204)

    def test_exec_qprogram_parallel(self):
        """Test execution of quantum program in parallel."""
        qproc = QuantumProcessor("TestQPD", num_positions=4, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=2, parallel=True),
            PhysicalInstruction(INSTR_X, duration=1, parallel=True),
            PhysicalInstruction(INSTR_H, duration=1.5, parallel=False, topology=[2, 3]),
            PhysicalInstruction(INSTR_CNOT, duration=2, parallel=True, topology=[(0, 1), (2, 3)]),
            PhysicalInstruction(INSTR_MEASURE, duration=3, parallel=True),
            PhysicalInstruction(INSTR_MEASURE_X, duration=2, parallel=False)])
        prog = ParallelQProgram()
        # Run program on parallel-capable processor
        # input is |0000>, expected output is |00+->
        # Run parallel and serial version of same program
        for parallel, duration in zip([True, False], [13, 29]):
            ns.sim_reset()
            qproc.reset()
            qproc.put(qapi.create_qubits(4))
            prog.parallel = parallel
            qproc.execute_program(prog, qubit_mapping=[0, 1, 2, 3])
            self.assertTrue(qproc.busy)
            ns.sim_run()
            self.assertAlmostEqual(ns.sim_time(), duration)
            self.assertFalse(qproc.busy)
            qubits = qproc.peek([0, 1, 2, 3])
            self.assertEqual(prog.output["m1"][0], 1)
            self.assertEqual(prog.output["m2"][0], 1)
            self.assertEqual(prog.output["m3"][0], 0)
            self.assertEqual(prog.output["m4"][0], 1)
            self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(s00, h01)), 1)

    def test_exec_phys_instruction(self):
        """Test execution of a single physical instruction."""
        qproc = QuantumProcessor("TestQPD", num_positions=2, phys_instructions=[
            PhysicalInstruction(INSTR_H, duration=1.5, topology=[1])])
        qproc.put(qapi.create_qubits(2))
        qproc.execute_instruction(INSTR_H, [1])
        self.helper._wait_once(self.evhandler_prog_done, entity=qproc, event_type=qproc.evtype_program_done)
        self.program_done = False
        ns.sim_run()
        self.assertTrue(self.program_done)
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(s0, h0)), 1)
        self.assertAlmostEqual(ns.sim_time(), 1.5)
        # Test executing an instruction with a parameter
        ns.sim_reset()
        qproc = QuantumProcessor("TestQPD", num_positions=2, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=5),
            PhysicalInstruction(INSTR_UNITARY, duration=1),
            PhysicalInstruction(INSTR_MEASURE, duration=1)])
        q1, q2 = qapi.create_qubits(2)
        qapi.operate(q1, ops.X)
        qapi.operate(q2, ops.H)
        qproc.execute_instruction(INSTR_INIT, [0], qubits=[q1])
        ns.sim_run()
        qproc.execute_instruction(INSTR_INIT, [1], qubits=[q2])
        ns.sim_run()
        qproc.execute_instruction(INSTR_UNITARY, [1], operator=ops.Z)
        ns.sim_run()
        key = "foo"
        output, run_time, _ = qproc.execute_instruction(INSTR_MEASURE, [0], output_key=key)
        output["x"] = 4
        self.assertEqual(run_time, 1)
        ns.sim_run()
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(s1, h1)), 1)
        self.assertAlmostEqual(ns.sim_time(), 12)
        self.assertEqual(output[key], [1])
        # Test missing instruction error raised
        with self.assertRaises(MissingInstructionError):
            qproc.execute_instruction(INSTR_Z, [0], qubits=[q1])

    def test_exec_nonphys_instruction(self):
        """Test execution of a single non-physical instruction."""
        qproc = QuantumProcessor("TestQPD", num_positions=2, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=2, noise_model=QThresholdNoiseModel(1, ops.Y)),
            PhysicalInstruction(INSTR_H, duration=1.5)])
        q2, = qapi.create_qubits(1)
        qapi.operate(q2, ops.X)
        qproc.execute_instruction(INSTR_INIT, [0], physical=False)
        qproc.execute_instruction(INSTR_INIT, [1], qubits=[q2], physical=False)
        qproc.execute_instruction(INSTR_H, [0], physical=False)
        output, run_time = qproc.execute_instruction(INSTR_MEASURE, [1], physical=False)
        # Test the instruction executed instantly and without noise
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(h0, s1)), 1)
        self.assertAlmostEqual(output["instr"], [1])
        self.assertEqual(run_time, 0)
        # Test running simulator has no further effect
        self.helper._wait_once(self.evhandler_prog_done, entity=qproc, event_type=qproc.evtype_program_done)
        self.program_done = False
        ns.sim_run()
        self.assertAlmostEqual(ns.sim_time(), 0.)
        self.assertFalse(self.program_done)
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(h0, s1)), 1)

    def test_fallback_nonphysical(self):
        """Test fallback to non-physical instructions."""
        qproc = QuantumProcessor("TestQPD", num_positions=2, phys_instructions=[
            PhysicalInstruction(INSTR_H, duration=1.5)], fallback_to_nonphysical=False)
        self.assertEqual(qproc.fallback_to_nonphysical, False)
        qproc.fallback_to_nonphysical = True
        self.assertEqual(qproc.fallback_to_nonphysical, True)
        # These instructions should fallback to non-physical
        qproc.execute_instruction(INSTR_INIT, [0])
        qproc.execute_instruction(INSTR_INIT, [1])
        qproc.execute_instruction(INSTR_X, [1])
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, s01), 1)
        self.assertAlmostEqual(ns.sim_time(), 0.)
        # This instruction should not fallback to non-physical
        qproc.execute_instruction(INSTR_H, [0])
        ns.sim_run()
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(h0, s1)), 1)
        self.assertAlmostEqual(ns.sim_time(), 1.5)

    def test_exec_qprogram_qnoise(self):
        """Test application of quantum noise on instruction and memory."""
        mem_noise_model1 = QThresholdNoiseModel(1, ops.Z)
        mem_noise_model2 = QThresholdNoiseModel(1, ops.X)
        instr_noise_model1 = QThresholdNoiseModel(1, ops.Z)
        instr_noise_model2 = QThresholdNoiseModel(1, ops.Y)
        instr_time = 2
        ns.sim_reset()
        qproc = QuantumProcessor(
            "TestQPD", num_positions=4, mem_noise_models=[mem_noise_model1] * 2 + [mem_noise_model2] * 2,
            phys_instructions=[
                PhysicalInstruction(INSTR_H, duration=instr_time, quantum_noise_model=instr_noise_model1, topology=[(0,)]),
                PhysicalInstruction(INSTR_H, duration=instr_time, parallel=True, topology=[(1,)]),
                PhysicalInstruction(INSTR_H, duration=instr_time, quantum_noise_model=instr_noise_model2, topology=[(2,)])],
        )
        qproc.put(qapi.create_qubits(4))
        prog = LazyQuantumProgram(num_qubits=3, parallel=True)
        q1, q2, q3 = prog.get_qubit_indices(3)
        prog.apply(INSTR_H, q1)
        prog.apply(INSTR_H, q2)  # parallel
        prog.apply(INSTR_H, q3)
        qproc.execute_program(prog, qubit_mapping=[0, 1, 2])
        ns.sim_run()
        self.assertAlmostEqual(2 * instr_time, ns.sim_time())
        # t=0->2 : |0000> -(mem_noise)-> |0011> -(instr)-> |++11> -(instr_noise)-> |-+11>
        # t=2->4 : |-+11> -(mem_noise)-> |+-11> -(instr)-> |+--1> -(instr_noise)-> |+-+1>
        # Note that q4 only receives threshold noise once
        qubits = qproc.peek([0, 1, 2, 3])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(h01, np.kron(h0, s1))), 1)
        # Run again after peeking to apply extra noise (resets noise thresholds)
        ns.sim_run(duration=instr_time)
        self.assertAlmostEqual(3 * instr_time, ns.sim_time())
        # t=4->6 : |+-+1> -(mem_noise)-> |-++0>
        qubits = qproc.peek([0, 1, 2, 3])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(h10, np.kron(h0, s0))), 1)

    def test_exec_qprogram_qnoise_after_init(self):
        """Test application of quantum noise with an initialization instruction."""
        instr_noise_model = QThresholdNoiseModel(1, ops.X)
        instr_time = 2
        ns.sim_reset()
        # Add two physical instructions, of which one applies noise before the instruction.
        qproc = QuantumProcessor(
            "TestQPD", num_positions=2, mem_noise_models=None, phys_instructions=[
                PhysicalInstruction(INSTR_INIT, duration=instr_time, quantum_noise_model=instr_noise_model, topology=[(0,)]),
                PhysicalInstruction(INSTR_INIT, duration=instr_time, quantum_noise_model=instr_noise_model, topology=[(1,)],
                                    apply_q_noise_after=False)],
        )
        qproc.put(qapi.create_qubits(2))
        prog = LazyQuantumProgram(num_qubits=2, parallel=True)
        q1, q2, = prog.get_qubit_indices(2)
        prog.apply(INSTR_INIT, q1)
        prog.apply(INSTR_INIT, q2)
        qproc.execute_program(prog, qubit_mapping=[0, 1])
        ns.sim_run()
        # t=0->2 : |00> -(instr)-> |10>
        # Note that on q2 noise is applied before the instruction is carried out.
        # The instruction will create a new qubit.
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, s10), 1)

    def test_exec_qprogram_cnoise(self):
        """Test application of classical noise on instruction output."""
        ns.sim_reset()
        c_noise_model = CThresholdNoiseModel(2)
        qproc = QuantumProcessor(
            "TestQPD", num_positions=2, phys_instructions=[
                PhysicalInstruction(INSTR_MEASURE, duration=1, classical_noise_model=c_noise_model, topology=[0]),
                PhysicalInstruction(INSTR_MEASURE, duration=3, classical_noise_model=c_noise_model, topology=[1])
            ])
        qproc.put(qapi.create_qubits(2))
        prog = LazyQuantumProgram(num_qubits=2, parallel=True)
        q1, q2 = prog.get_qubit_indices(2)
        prog.apply(INSTR_MEASURE, q1, output_key="m1")
        prog.apply(INSTR_MEASURE, q2, output_key="m2")
        qproc.execute_program(prog, qubit_mapping=[0, 1])
        ns.sim_run()
        self.assertAlmostEqual(4, ns.sim_time())
        self.assertEqual(prog.output["m1"][0], 0)
        self.assertEqual(prog.output["m2"][0], 1)  # subject to noise

    @patch('netsquid.components.qprocessor.logger.warning')
    def test_terminate_program_on_error(self, mock_warning):
        """Test program self terminates on error."""
        num_pos = 6
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos, phys_instructions=[
            PhysicalInstruction(INSTR_X, duration=2)])
        # Create insufficient qubits
        qproc.put(qapi.create_qubits(3), [0, 1, 2])
        # Check two different exceptions are caught:
        # 1. Instruction on an empty memory position
        # 2. Missing instruction
        # In the second test we continue from where first failed
        for i, (instr, e_type) in enumerate(zip(
                [INSTR_X, INSTR_Z], [MemPositionEmptyError, MissingInstructionError],
        )):
            prog = LazyQuantumProgram(num_qubits=num_pos)
            for qubit in prog.get_qubit_indices(num_pos):
                prog.apply(instr, qubit)
            qproc.execute_program(prog, qubit_mapping=list(range(num_pos)))
            self.program_fail = False
            self.program_done = False
            # self.helper._wait_once(self.evhandler_prog_fail, entity=qproc, event_type=qproc.evtype_program_fail)
            self.helper._wait_once(self.evhandler_prog_done, entity=qproc, event_type=qproc.evtype_program_done)

            def fail():
                self.program_fail = True

            qproc.set_program_fail_callback(callback=fail)
            ns.sim_run()
            self.assertEqual(ns.sim_time(), 2 * 4)
            self.assertTrue(self.program_fail)
            self.assertIsInstance(qproc.fail_exception, e_type)
            self.assertFalse(self.program_done)
            qubits = qproc.peek(list(range(num_pos)))
            self.assertEqual(qubits[3:], [None] * 3)
            self.assertAlmostEqual(qapi.fidelity(qubits[0:3], np.kron(s11, s1)), 1)
            # self.assertEqual(mock_warning.call_count, i + 1)

    def test_raise_exception_on_error(self):
        """Test fail exception is raised when global flag is set."""
        num_pos = 6
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos, phys_instructions=[
            PhysicalInstruction(INSTR_X, duration=2)])
        # Create insufficient qubits
        qproc.put(qapi.create_qubits(3), [0, 1, 2])
        # Test setting error condition via both module (mod) and when call program (prog)
        for mod_error, prog_error in [(True, False), (False, True), (False, False)]:
            qproc_module.error_on_program_fail = mod_error
            # Test two different program failures
            for instr, e_type in zip([INSTR_X, INSTR_Z], [MemPositionEmptyError, MissingInstructionError]):
                prog = LazyQuantumProgram(num_qubits=num_pos)
                for qubit in prog.get_qubit_indices(num_pos):
                    prog.apply(instr, qubit)

                def run_program():
                    qproc.execute_program(prog, qubit_mapping=list(range(num_pos)),
                                          error_on_fail=prog_error)
                    ns.sim_run()

                if mod_error or prog_error:
                    with self.assertRaises(e_type):
                        run_program()
                else:
                    try:
                        run_program()
                    except e_type:
                        self.fail("Should not raise {} exception.")

    def test_get_finished_instrs(self):
        """Test if get_finished_instrs gives the right instructions and end times"""
        num_pos = 2
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=2, parallel=False),
            PhysicalInstruction(INSTR_X, duration=3)])
        prog = LazyQuantumProgram(num_qubits=num_pos)
        q1, q2 = prog.get_qubit_indices(num_pos)
        prog.apply(INSTR_INIT, q1)
        prog.apply(INSTR_X, q1)
        prog.apply(INSTR_INIT, q2)
        finished_instructions = [instr for instr, time in qproc.get_finished_instrs()]
        self.assertEqual(len(finished_instructions), 0)
        qproc.execute_program(prog)
        duration_init = qproc.get_instruction_duration(INSTR_INIT, [q1])
        duration_x = qproc.get_instruction_duration(INSTR_X, [q1])
        self.assertEqual(len(finished_instructions), 0)
        ns.sim_run(duration=duration_init + duration_x / 2)
        finished_instructions = [instr for instr, time in qproc.get_finished_instrs()]
        self.assertEqual(len(finished_instructions), 3)
        self.assertTrue(INSTR_INIT in finished_instructions)
        ns.sim_run()
        finished_instructions = [instr for instr, time in qproc.get_finished_instrs()]
        self.assertEqual([INSTR_INIT, INSTR_X, INSTR_INIT], finished_instructions)
        end_times = [time for instr, time in qproc.get_finished_instrs()]
        self.assertAlmostEqual([7, 5, 2], end_times)

    def test_processor_status(self):
        """Test if processor is set to the correct statuses"""
        # Does not test for STATUS_PAUSED
        num_pos = 2
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=2, parallel=False),
            PhysicalInstruction(INSTR_X, duration=3)])
        prog = LazyQuantumProgram(num_qubits=num_pos)
        self.assertEqual(qproc.status, ProcessorStatus.IDLE)
        qproc.execute_program(prog)
        self.assertEqual(qproc.status, ProcessorStatus.RUNNING)
        ns.sim_run()
        self.assertEqual(qproc.status, ProcessorStatus.IDLE)

    def test_processor_status_fail(self):
        """Test if processor is set to the failed status"""
        # Does not test for STATUS_PAUSED
        num_pos = 1
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=2, parallel=False),
            PhysicalInstruction(INSTR_X, duration=3)])
        prog = LazyQuantumProgram(num_qubits=num_pos)
        self.assertEqual(qproc.status, ProcessorStatus.IDLE)
        q1 = prog.get_qubit_indices(num_pos)
        prog.apply(INSTR_X, q1)
        qproc.execute_program(prog)
        ns.sim_run()
        self.assertEqual(qproc.status, ProcessorStatus.FAILED)

    def test_lazy_run_noise(self):

        class TestQuantumErrorModel(QuantumErrorModel):
            def __init__(self, **kwargs):
                super().__init__(**kwargs)
                self.times = []
                self.qproc = None

            def error_operation(self, qubits, delta_time=0, **kwargs):
                self.times.append(
                    (qproc.mem_positions[0].time_last_access, qproc.mem_positions[1].time_last_access, delta_time))

        num_pos = 2
        # Parallel = False
        error_model = TestQuantumErrorModel()
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos, phys_instructions=[
                                 PhysicalInstruction(INSTR_INIT, duration=2, parallel=False),
                                 PhysicalInstruction(INSTR_CNOT, duration=2, parallel=False),
                                 PhysicalInstruction(INSTR_X, duration=3)],
                                 mem_noise_models=[error_model] * num_pos)
        error_model.qproc = qproc
        prog = LazyQuantumProgram(num_qubits=num_pos)
        prog.apply(INSTR_INIT, 0)
        prog.apply(INSTR_INIT, 1)
        prog.apply(INSTR_X, 0)
        prog.apply(INSTR_X, 0)
        prog.apply(INSTR_CNOT, [0, 1])
        prog.apply(INSTR_X, 0)
        qproc.execute_program(prog)
        ns.sim_run()
        expected_list = [(2.0, 4.0, 2.0), (7.0, 4.0, 0.0), (7.0, 4.0, 0.0), (10.0, 4.0, 0.0),
                         (10.0, 4.0, 0.0), (10.0, 4.0, 6.0), (12.0, 12.0, 0.0), (12.0, 12.0, 0.0),
                         (12.0, 12.0, 0.0), (15.0, 12.0, 0.0)]

        self.assertListEqual(expected_list, error_model.times)
        self.assertEqual(ns.sim_time(), 15)

        ns.sim_reset()

        # Parallel = True
        error_model = TestQuantumErrorModel()
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos, phys_instructions=[
                                 PhysicalInstruction(INSTR_INIT, duration=2, parallel=True),
                                 PhysicalInstruction(INSTR_CNOT, duration=2, parallel=True),
                                 PhysicalInstruction(INSTR_X, duration=3)],
                                 mem_noise_models=[error_model] * num_pos)
        error_model.qproc = qproc
        prog = LazyQuantumProgram(num_qubits=num_pos, parallel=True)
        prog.apply(INSTR_INIT, 0)
        prog.apply(INSTR_INIT, 1)
        prog.apply(INSTR_X, 0)
        prog.apply(INSTR_X, 0)
        prog.apply(INSTR_CNOT, [0, 1])
        prog.apply(INSTR_X, 0)
        qproc.execute_program(prog)
        ns.sim_run()
        expected_list = [(2.0, 2.0, 0.0), (5.0, 2.0, 0.0), (5.0, 2.0, 0.0),
                         (8.0, 2.0, 0.0), (8.0, 2.0, 0.0), (8.0, 2.0, 6.0),
                         (10.0, 10.0, 0.0), (10.0, 10.0, 0.0), (10.0, 10.0, 0.0),
                         (13.0, 10.0, 0.0)]
        self.assertListEqual(expected_list, error_model.times)
        self.assertEqual(ns.sim_time(), 13)


if __name__ == '__main__':
    unittest.main()
