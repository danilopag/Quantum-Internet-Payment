# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_qprocessor.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the qprocessor module.

"""
import unittest
from unittest.mock import patch
from itertools import permutations
import numpy as np
from netsquid.qubits import ketutil
import netsquid as ns
from netsquid.components.qmemory import MemPositionEmptyError, MemPositionBusyError
from netsquid.components import qprocessor as qproc_module
from netsquid.components.qprocessor import (
    QuantumProcessor, ProcessorStatus, PhysicalInstruction, ProcessorBusyError, MissingInstructionError)
from netsquid.components import INSTR_I, PhysicalIndex
from netsquid.components.qprogram import QuantumProgram
from netsquid.components.models.qerrormodels import DepolarNoiseModel
from netsquid.components.tests.test_qchannel import ThresholdNoiseModel as QThresholdNoiseModel
from netsquid.components.tests.test_cchannel import ThresholdBitNoiseModel as CThresholdNoiseModel
from netsquid.qubits import operators as ops
from netsquid.qubits import qubitapi as qapi
from netsquid.qubits.ketstates import s0, s1, h0, h1, s10, s01, s00, s11, h01, h10, b10
from netsquid.components.instructions import (
    INSTR_X, INSTR_Y, INSTR_Z, INSTR_H, INSTR_CNOT, INSTR_CZ, INSTR_UNITARY, INSTR_SWAP,
    INSTR_MEASURE, INSTR_MEASURE_X, INSTR_INIT, INSTR_1QUBIT, INSTR_2QUBIT, INSTR_SIGNAL, INSTR_T, INSTR_S, INSTR_K)
from netsquid.components.tests.test_qprogram import DoubleSequenceProgram, NestingProgram


class CustomQProgram(QuantumProgram):
    """A program that applies a sequence of gates."""
    default_num_qubits = 2

    def program(self):
        q1, q2 = self.get_qubit_indices(2)
        self.apply(INSTR_X, q1)
        self.apply(INSTR_CNOT, [q1, q2])
        self.apply(INSTR_SIGNAL)
        self.apply(INSTR_MEASURE, q1, output_key="m1")
        self.apply(INSTR_MEASURE, q2, output_key="m2")
        yield self.run()


class ControlledQProgram(QuantumProgram):
    """A program that makes use classical control."""
    default_num_qubits = 3

    def program(self):
        # Example of program with control logic
        q1, q2, q3 = self.get_qubit_indices(3)
        self.apply(INSTR_MEASURE, q1, output_key="m1")
        self.first_sequence = True  # Used by test
        yield self.run()
        # Depending on outcome on q1 either flip q2 or q3
        if self.output["m1"][0] == 0:
            self.apply(INSTR_X, q2)
        else:
            self.apply(INSTR_X, q3)
        self.apply(INSTR_MEASURE, q2, output_key="m2")
        self.apply(INSTR_MEASURE, q3, output_key="m3")
        self.second_sequence = True  # Used by test
        yield self.run()


class ParallelQProgram(QuantumProgram):
    """A program that runs very differently in parallel versus non-parallel."""
    default_num_qubits = 4

    def program(self):
        q1, q2, q3, q4 = self.get_qubit_indices(4)
        self.apply(INSTR_INIT, q1)
        self.apply(INSTR_INIT, q2)
        self.apply(INSTR_INIT, q3)
        self.apply(INSTR_INIT, q4)
        yield self.run(parallel=self.parallel)
        self.apply(INSTR_X, q1)
        self.apply(INSTR_X, q4)
        self.apply(INSTR_CNOT, [q1, q2])
        self.apply(INSTR_CNOT, [q3, q4])
        self.apply(INSTR_H, q3)
        self.apply(INSTR_H, q4)
        self.apply(INSTR_MEASURE, q1, output_key="m1")
        self.apply(INSTR_MEASURE, q2, output_key="m2")
        self.apply(INSTR_MEASURE_X, q3, output_key="m3")
        self.apply(INSTR_MEASURE_X, q4, output_key="m4")
        yield self.run(parallel=self.parallel)
        if self.output["m1"][0] == 1:
            self.apply(INSTR_X, q1)
        if self.output["m2"][0] == 1:
            self.apply(INSTR_X, q2)
        yield self.run(parallel=self.parallel)


class CheatingQProgram(QuantumProgram):
    """A program that 'cheats' using some non-physical instructions."""
    default_num_qubits = 2

    def program(self):
        q1, q2 = self.get_qubit_indices(2)
        self.apply(INSTR_X, q1)
        self.apply(INSTR_SIGNAL, physical=False)
        self.apply(INSTR_Z, q1, physical=False)
        self.apply(INSTR_CNOT, [q1, q2])
        self.apply(INSTR_MEASURE, q1, output_key="m1", physical=False)
        self.apply(INSTR_MEASURE, q2, output_key="m2", physical=False)
        yield self.run()


class TestPhysicalInstruction(unittest.TestCase):
    """Unit tests for the PhysicalInstruction class.

    """

    def test_init(self):
        """Test initialization."""
        instruction = INSTR_X
        duration = 13
        example_noise_model = DepolarNoiseModel(1000)
        for noise_model in [example_noise_model, None]:
            for parallel in [True, False]:
                phys_instr = PhysicalInstruction(instruction, duration=duration,
                                                 quantum_noise_model=noise_model, parallel=parallel)
                self.assertEqual(phys_instr.instruction, instruction)
                self.assertEqual(phys_instr.duration, duration)
                self.assertEqual(phys_instr.quantum_noise_model, noise_model)
                self.assertEqual(phys_instr.parallel, parallel)
        with self.assertRaises(TypeError):
            PhysicalInstruction("foo", duration=duration)
        with self.assertRaises(TypeError):
            PhysicalInstruction(instruction, duration=duration, quantum_noise_model="foo")


class TestQProcessor(unittest.TestCase):
    """Unit tests for the QuantumProcessor class.

    """

    def setUp(self):
        ns.sim_reset()
        qproc_module.error_on_program_fail = False  # default value
        self.helper = ns.Entity()  # helper entity
        self.PI_X = PhysicalInstruction(INSTR_X, duration=1)
        self.PI_H = PhysicalInstruction(INSTR_H, duration=1)
        self.PI_1QUBIT = PhysicalInstruction(INSTR_1QUBIT, duration=5)
        self.PI_CNOT = PhysicalInstruction(INSTR_CNOT, duration=2)
        self.PI_CZ = PhysicalInstruction(INSTR_CZ, duration=4)
        self.PI_2QUBIT = PhysicalInstruction(INSTR_2QUBIT, duration=6)
        self.PI_MZ = PhysicalInstruction(INSTR_MEASURE, duration=3)
        self.PI_SIG = PhysicalInstruction(INSTR_SIGNAL, duration=0.1)
        self.program_done = False
        self.program_fail = False
        self.signal = None

        def done_callback(event):
            self.program_done = True

        def fail_callback(event):
            self.program_fail = True

        def signal_callback(event):
            self.signal = ns.sim_time()

        self.evhandler_prog_done = ns.EventHandler(done_callback)
        self.evhandler_prog_fail = ns.EventHandler(fail_callback)
        self.evhandler_signal = ns.EventHandler(signal_callback)

    def tearDown(self):
        qproc_module.error_on_program_fail = False  # default value

    def test_init(self):
        """Test initialization."""
        num_pos = 3
        noise_models = [DepolarNoiseModel(1000 * i) for i in range(num_pos)]
        qproc = QuantumProcessor(
            "TestQPD", num_positions=num_pos, mem_noise_models=noise_models,
        )
        self.assertFalse(qproc.busy)
        # Check qmemory subclassed and constructor called
        self.assertEqual(qproc.num_positions, num_pos)
        qproc.put(qapi.create_qubits(num_pos))
        self.assertEqual(len(qproc.used_positions), num_pos)
        for idx, mem_pos in enumerate(qproc.mem_positions):
            self.assertEqual(mem_pos.models['noise_model'], noise_models[idx])

    def test_init_phys_instr(self):
        """Test init with physical instructions."""
        num_pos = 3
        phys_instrs = [self.PI_X, self.PI_H, self.PI_CNOT, self.PI_CZ]
        qproc = QuantumProcessor(
            "TestQPD", num_positions=num_pos, phys_instructions=phys_instrs,
        )
        for i in range(num_pos):
            self.assertEqual(qproc.get_physical_instructions(positions=(i,)),
                             {self.PI_X, self.PI_H})
        for p in permutations(range(num_pos), 2):
            self.assertEqual(qproc.get_physical_instructions(positions=tuple(p)),
                             {self.PI_CNOT, self.PI_CZ})
        # Check adding new physical instruction and its duration lookup
        duration = 3
        new_instr = INSTR_Y
        new_PI_Y = PhysicalInstruction(new_instr, duration=duration)
        qproc.add_physical_instruction(new_PI_Y)
        for i in range(num_pos):
            self.assertEqual(qproc.get_physical_instructions(positions=(i,)),
                             {self.PI_X, self.PI_H, new_PI_Y})
            self.assertEqual(qproc.get_instruction_duration(new_instr, positions=(i,)), duration)
        # Check overriding of physical instructions
        duration = 4
        new_instr = INSTR_H
        new_PI_H = PhysicalInstruction(INSTR_H, duration=duration)
        qproc.add_physical_instruction(new_PI_H)
        self.assertNotEqual(qproc.get_physical_instructions(instruction=INSTR_H), {self.PI_H})
        self.assertEqual(qproc.get_physical_instructions(instruction=INSTR_H), {new_PI_H})
        for i in range(num_pos):
            self.assertEqual(qproc.get_instruction_duration(new_instr, positions=(i,)), duration)

    def test_init_topologies(self):
        """Test init with physical instructions on specific topologies."""
        num_pos = 3
        phys_instrs = [self.PI_X, self.PI_H, self.PI_CNOT, self.PI_MZ, self.PI_SIG]
        topologies = [[0, 1, 2], [(1,)], [(0, 1), (1, 2), (2, 1)], None, [()]]
        for instr, topo in zip(phys_instrs, topologies):
            instr.topology = topo
        qproc = QuantumProcessor(
            "TestQPD", num_positions=num_pos, phys_instructions=phys_instrs,
        )
        # Check physical instructions (also tests get_physical_instructions())
        self.assertEqual(qproc.get_physical_instructions(positions=(1,)),
                         {self.PI_X, self.PI_H, self.PI_MZ})
        self.assertEqual(qproc.get_physical_instructions(positions=(1,), instruction=INSTR_H),
                         {self.PI_H})
        self.assertEqual(qproc.get_physical_instructions(instruction=INSTR_H),
                         {self.PI_H})
        self.assertEqual(qproc.get_physical_instructions(positions=(1, 2)),
                         {self.PI_CNOT})
        self.assertEqual(qproc.get_physical_instructions(),
                         set(phys_instrs))
        self.assertEqual(qproc.get_physical_instructions(positions=()),
                         {self.PI_SIG})
        # Check overriding of physical instructions with topology
        new_PI_H = PhysicalInstruction(INSTR_H, duration=4)
        self.assertEqual(qproc.get_physical_instructions(positions=(1,), instruction=INSTR_H), {self.PI_H})
        self.assertEqual(qproc.get_physical_instructions(positions=(2,), instruction=INSTR_H), set())
        new_PI_H.topology = [(1,), (2,)]
        qproc.add_physical_instruction(new_PI_H)
        self.assertNotEqual(qproc.get_physical_instructions(positions=(1,), instruction=INSTR_H), {self.PI_H})
        self.assertEqual(qproc.get_physical_instructions(positions=(1,), instruction=INSTR_H), {new_PI_H})
        self.assertEqual(qproc.get_physical_instructions(positions=(2,), instruction=INSTR_H), {new_PI_H})
        # Check invalid topologies
        for topology, exception in zip([(0,), [(0, 1)], [(0,), (0, 1)], [(num_pos,)], [None]],
                                       [TypeError, ValueError, ValueError, IndexError, TypeError]):
            with self.assertRaises(exception):
                self.PI_X.topology = topology
                qproc.add_physical_instruction(self.PI_X)
        for topology, exception in zip([(0, 1), [(0,)], [(0,), (None, None)]],
                                       [ValueError, ValueError, TypeError]):
            with self.assertRaises(Exception):
                self.PI_CZ.topology = topology
                qproc.add_physical_instruction(self.PI_CZ)

    def test_add_instruction(self):
        """Test add instruction method."""
        qproc = QuantumProcessor("TestQPD", num_positions=3)
        self.assertEqual(qproc.get_physical_instructions(), set())
        duration = 1
        q_noise_model = DepolarNoiseModel(1000)
        c_noise_model = CThresholdNoiseModel(1)
        qproc.add_instruction(INSTR_CNOT, topology=[(0, 2)], duration=duration,
                              q_noise_model=q_noise_model, c_noise_model=c_noise_model)
        phys_instrs = qproc.get_physical_instructions(positions=(0, 2), instruction=INSTR_CNOT)
        self.assertTrue(isinstance(phys_instrs, set))
        phys_instrs = list(phys_instrs)
        self.assertEqual(len(phys_instrs), 1)
        self.assertTrue(isinstance(phys_instrs[0], PhysicalInstruction))
        self.assertEqual(phys_instrs[0].instruction, INSTR_CNOT)
        self.assertEqual(phys_instrs[0].duration, duration)
        self.assertEqual(phys_instrs[0].quantum_noise_model, q_noise_model)
        self.assertEqual(phys_instrs[0].classical_noise_model, c_noise_model)
        # Check type errors
        with self.assertRaises(TypeError):
            qproc.add_instruction("foo", duration=duration)
        with self.assertRaises(TypeError):
            qproc.add_instruction(INSTR_CNOT, duration=duration,
                                  q_noise_model=c_noise_model)
        with self.assertRaises(TypeError):
            qproc.add_instruction(INSTR_CNOT, duration=duration,
                                  c_noise_model=q_noise_model)

    def test_exec_qprogram_trivial(self):
        """Test execution of trivial quantum program."""
        num_pos = 2
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos)
        # Create trivial program
        prog = QuantumProgram()
        # Check incorrect mapping gives error
        for mapping in [0, [1, 1], list(range(num_pos + 1)), [-1], [num_pos + 1]]:
            with self.assertRaises((TypeError, ValueError)):
                qproc.execute_program(prog, mapping, check_qubit_mapping=True)
        # Any valid mapping should work even for a trivial program, because we can't
        # know a priori what program does
        for mapping in [list(range(num_pos)), None]:
            qproc.execute_program(prog, mapping)
            self.helper._wait_once(self.evhandler_prog_done, entity=qproc, event_type=qproc.evtype_program_done)
            self.program_done = False
            ns.sim_run()
            self.assertTrue(self.program_done)

    def test_exec_qprogram_sequence(self):
        """Test execution of simple quantum sequence of gates."""
        qproc = QuantumProcessor("TestQPD", num_positions=3, phys_instructions=[
            PhysicalInstruction(INSTR_X, duration=1, topology=[0, 1, 2]),
            PhysicalInstruction(INSTR_CNOT, duration=2),
            PhysicalInstruction(INSTR_SIGNAL, duration=0.1, topology=[()]),
            PhysicalInstruction(INSTR_MEASURE, duration=3)])
        # Here we test two programs that should do same thing
        exp_sim_time = 9.1
        exp_signal_time = 3.1
        # Specify the sequence of gates:
        prog1 = QuantumProgram(num_qubits=2)
        q1, q2 = prog1.get_qubit_indices()
        prog1.apply(INSTR_X, q1)
        prog1.apply(INSTR_CNOT, [q1, q2])
        prog1.apply(INSTR_SIGNAL)
        prog1.apply(INSTR_MEASURE, q1, output_key="m1")
        prog1.apply(INSTR_MEASURE, q2, output_key="m2")
        # Specify a custom program that implements same gates:
        prog2 = CustomQProgram()
        # By repeating executions and reseting simulation in between we test that:
        # 1. internal event handlers of qproc are restored after a reset
        #    (they use a sim reset counter)
        # 2. programs defined above can each be rerun
        for prog in [prog1, prog2, prog1, prog2]:
            ns.sim_reset()
            self.program_done = False
            self.program_fail = False
            self.signal = 0.
            self.helper._wait_once(self.evhandler_prog_done, entity=qproc,
                                   event_type=qproc.evtype_program_done)
            self.helper._wait_once(self.evhandler_prog_fail, entity=qproc,
                                   event_type=qproc.evtype_program_fail)
            self.helper._wait_once(self.evhandler_signal, entity=qproc,
                                   event_type=qproc.evtype_signal_default)
            # qproc.reset()
            qproc.put(qapi.create_qubits(2), [0, 2])
            self.assertFalse(qproc.busy)
            qproc.execute_program(prog, qubit_mapping=[0, 2])
            self.assertTrue(qproc.busy)
            with self.assertRaises(MemPositionBusyError):
                qproc.peek([0])
            ns.sim_run()
            self.assertFalse(self.program_fail)
            self.assertTrue(self.program_done)
            qubits = qproc.pop([0, 2])
            self.assertAlmostEqual(qapi.fidelity(qubits[0], s1), 1)
            self.assertAlmostEqual(qapi.fidelity(qubits[1], s1), 1)
            self.assertEqual(prog.output["m1"][0], 1)
            self.assertEqual(prog.output["m2"][0], 1)
            self.assertFalse(qproc.busy)
            self.assertAlmostEqual(self.signal, exp_signal_time)
            self.assertAlmostEqual(ns.sim_time(), exp_sim_time)

    def test_exec_qprogram_concatenated(self):
        """Test execution of a concatenated program with output."""
        qproc = QuantumProcessor("TestQPD", num_positions=3, phys_instructions=[
            PhysicalInstruction(INSTR_X, duration=1, topology=[0, 1, 2]),
            PhysicalInstruction(INSTR_CNOT, duration=2),
            PhysicalInstruction(INSTR_SIGNAL, duration=0.1, topology=[()]),
            PhysicalInstruction(INSTR_MEASURE, duration=3)])
        # Here we test two programs that should do same thing
        exp_sim_time = 9.1
        # Specify the sequence of gates:
        prog1 = QuantumProgram(num_qubits=2)
        q1, q2 = prog1.get_qubit_indices()
        prog1.apply(INSTR_X, q1)
        prog1.apply(INSTR_CNOT, [q1, q2])
        prog1.apply(INSTR_SIGNAL)
        prog1.apply(INSTR_MEASURE, q1, output_key="m1")
        prog2 = QuantumProgram(num_qubits=2)
        q1, q2 = prog2.get_qubit_indices()
        prog2.apply(INSTR_MEASURE, q2, output_key="m2")
        # Concatenate program
        prog3 = prog1 + prog2
        ns.sim_reset()
        self.helper._wait_once(self.evhandler_prog_done, entity=qproc,
                               event_type=qproc.evtype_program_done)
        qproc.put(qapi.create_qubits(2), [0, 2])
        qproc.execute_program(prog3, qubit_mapping=[0, 2])
        ns.sim_run()
        self.assertTrue(self.program_done)
        self.assertTrue("m1" in prog3.output)
        self.assertTrue("m2" in prog3.output)
        self.assertEqual(prog3.output["m1"][0], 1)
        self.assertEqual(prog3.output["m2"][0], 1)
        self.assertAlmostEqual(ns.sim_time(), exp_sim_time)

    def test_exec_qprogram_nonphysical(self):
        """Test execution of quantum program with nonphysical instructions."""
        # We do not add the non-physical measure gates to the processor
        qproc = QuantumProcessor("TestQPD", num_positions=3, phys_instructions=[
            PhysicalInstruction(INSTR_X, duration=1),
            PhysicalInstruction(INSTR_Z, duration=4),
            PhysicalInstruction(INSTR_CNOT, duration=2)])
        qproc.put(qapi.create_qubits(3))
        # Run program, input is |000>
        self.signal = 0.
        self.helper._wait_once(self.evhandler_signal, entity=qproc,
                               event_type=qproc.evtype_signal_default)
        prog = CheatingQProgram()
        qproc.execute_program(prog, qubit_mapping=[2, 1])
        ns.sim_run()
        self.assertAlmostEqual(ns.sim_time(), 3)
        self.assertAlmostEqual(self.signal, 1)
        qubits = qproc.peek([2, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits[0], s1), 1)
        self.assertAlmostEqual(qapi.fidelity(qubits[1], s1), 1)
        self.assertEqual(prog.output["m1"][0], 1)
        self.assertEqual(prog.output["m2"][0], 1)

    def test_exec_qprogram_control(self):
        """Test execution of quantum program with control."""
        qproc = QuantumProcessor("TestQPD", num_positions=3, phys_instructions=[
            PhysicalInstruction(INSTR_X, duration=1, topology=[0, 1, 2]),
            PhysicalInstruction(INSTR_CNOT, duration=2),
            PhysicalInstruction(INSTR_MEASURE, duration=3)])
        qproc.put(qapi.create_qubits(3))
        # Run program, input is |000>
        prog = ControlledQProgram()
        qproc.execute_program(prog, qubit_mapping=[0, 1, 2])
        ns.sim_run()
        self.assertAlmostEqual(ns.sim_time(), 10)
        qubits = qproc.peek([0, 1, 2])
        self.assertEqual(prog.output["m1"][0], 0)
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(s0, s10)), 1)
        # Run program again, input is now |100> (re-arranged by mapping)
        prog = ControlledQProgram()
        qproc.execute_program(prog, qubit_mapping=[1, 0, 2])
        ns.sim_run()
        qubits = qproc.peek([1, 0, 2])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(s1, s01)), 1)
        self.assertAlmostEqual(ns.sim_time(), 20)

    def test_exec_qprogram_loading(self):
        """Test nested loading of programs within programs."""
        qproc = QuantumProcessor("TestQPD", num_positions=2, phys_instructions=[
            PhysicalInstruction(INSTR_X, duration=1),
            PhysicalInstruction(INSTR_MEASURE, duration=2)])
        qproc.put(qapi.create_qubits(2))
        prog = NestingProgram()
        qproc.execute_program(prog, qubit_mapping=[0, 1])
        ns.sim_run()
        self.assertAlmostEqual(ns.sim_time(), 7)
        qubits = qproc.peek([0, 1])
        self.assertEqual(prog.output["LoadedProgramCount"], 2)
        self.assertEqual(prog.output["m1"][0], 1)
        self.assertEqual(prog.output["m2"][0], 1)
        self.assertAlmostEqual(qapi.fidelity(qubits, s01), 1)

    def test_qprogram_duration(self):
        """Test estimate of quantum program duration."""
        qproc = QuantumProcessor("TestQPD", num_positions=2, phys_instructions=[
            PhysicalInstruction(INSTR_X, duration=1, topology=[0, 1]),
            PhysicalInstruction(INSTR_CNOT, duration=2),
            PhysicalInstruction(INSTR_MEASURE, duration=3)])
        qproc.put(qapi.create_qubits(2))
        qubit_mapping = [0, 1]
        # Test single sequence program
        prog = QuantumProgram(2)
        prog.apply(INSTR_X, 0)
        prog.apply(INSTR_CNOT, [0, 1])
        run_time = qproc.get_program_duration(prog, qubit_mapping=qubit_mapping)
        self.assertEqual(run_time, 3)
        # Test exception raised if instruction is missing
        prog = QuantumProgram(2)
        prog.apply(INSTR_H, 0)
        with self.assertRaises(MissingInstructionError):
            qproc.get_program_duration(prog, qubit_mapping=qubit_mapping)
        # Check program duration matches only first sequence for a double sequence program
        prog = DoubleSequenceProgram()
        run_time = qproc.get_program_duration(prog, qubit_mapping=qubit_mapping)
        self.assertEqual(run_time, 6)
        # Check no programs have not run
        self.program_done = False
        self.helper._wait_once(self.evhandler_prog_done, entity=qproc, event_type=qproc.evtype_program_done)
        ns.sim_run()
        self.assertAlmostEqual(ns.sim_time(), 0)
        self.assertFalse(self.program_done)
        # Our copy of program should not have run yet
        with self.assertRaises(AttributeError):
            prog.first_sequence
        # Check program still executes as expected
        qproc.execute_program(prog, qubit_mapping=qubit_mapping)
        self.helper._wait_once(self.evhandler_prog_done, entity=qproc, event_type=qproc.evtype_program_done)
        ns.sim_run()
        self.assertTrue(prog.first_sequence)
        self.assertTrue(prog.second_sequence)
        self.assertAlmostEqual(ns.sim_time(), 12)
        self.assertTrue(self.program_done)
        # Check can get a program's duration during execution
        prog = DoubleSequenceProgram()
        qproc.execute_program(prog, qubit_mapping=qubit_mapping)
        ns.sim_run(1)
        run_time = qproc.get_program_duration(prog, qubit_mapping=qubit_mapping)
        ns.sim_run()
        self.assertEqual(run_time, 6)

    def test_exec_qprogram_parallel(self):
        """Test execution of quantum program in parallel."""
        qproc = QuantumProcessor("TestQPD", num_positions=4, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=2, parallel=True),
            PhysicalInstruction(INSTR_X, duration=1, parallel=True),
            PhysicalInstruction(INSTR_H, duration=1.5, parallel=False, topology=[2, 3]),
            PhysicalInstruction(INSTR_CNOT, duration=2, parallel=True, topology=[(0, 1), (2, 3)]),
            PhysicalInstruction(INSTR_MEASURE, duration=3, parallel=True),
            PhysicalInstruction(INSTR_MEASURE_X, duration=2, parallel=False)])
        prog = ParallelQProgram()
        # Run program on parallel-capable processor
        # input is |0000>, expected output is |00+->
        # Run parallel and serial version of same program
        for parallel, duration in zip([True, False], [13, 29]):
            ns.sim_reset()
            qproc.reset()
            qproc.put(qapi.create_qubits(4))
            prog.parallel = parallel
            qproc.execute_program(prog, qubit_mapping=[0, 1, 2, 3])
            self.assertTrue(qproc.busy)
            ns.sim_run()
            self.assertFalse(qproc.busy)
            self.assertAlmostEqual(ns.sim_time(), duration)
            qubits = qproc.peek([0, 1, 2, 3])
            self.assertEqual(prog.output["m1"][0], 1)
            self.assertEqual(prog.output["m2"][0], 1)
            self.assertEqual(prog.output["m3"][0], 0)
            self.assertEqual(prog.output["m4"][0], 1)
            self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(s00, h01)), 1)

    def test_exec_phys_instruction(self):
        """Test execution of a single physical instruction."""
        qproc = QuantumProcessor("TestQPD", num_positions=2, phys_instructions=[
            PhysicalInstruction(INSTR_H, duration=1.5, topology=[1])])
        qproc.put(qapi.create_qubits(2))
        qproc.execute_instruction(INSTR_H, [1])
        self.helper._wait_once(self.evhandler_prog_done, entity=qproc, event_type=qproc.evtype_program_done)
        self.program_done = False
        ns.sim_run()
        self.assertTrue(self.program_done)
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(s0, h0)), 1)
        self.assertAlmostEqual(ns.sim_time(), 1.5)
        # Test executing an instruction with a parameter
        ns.sim_reset()
        qproc = QuantumProcessor("TestQPD", num_positions=2, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=5),
            PhysicalInstruction(INSTR_UNITARY, duration=1),
            PhysicalInstruction(INSTR_MEASURE, duration=1)])
        q1, q2 = qapi.create_qubits(2)
        qapi.operate(q1, ops.X)
        qapi.operate(q2, ops.H)
        qproc.execute_instruction(INSTR_INIT, [0], qubits=[q1])
        ns.sim_run()
        qproc.execute_instruction(INSTR_INIT, [1], qubits=[q2])
        ns.sim_run()
        qproc.execute_instruction(INSTR_UNITARY, [1], operator=ops.Z)
        ns.sim_run()
        key = "foo"
        output, run_time, _ = qproc.execute_instruction(INSTR_MEASURE, [0], output_key=key)
        self.assertEqual(run_time, 1)
        self.assertEqual(output[key], None)
        ns.sim_run()
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(s1, h1)), 1)
        self.assertAlmostEqual(ns.sim_time(), 12)
        self.assertEqual(output[key], [1])
        # Test missing instruction error raised
        with self.assertRaises(MissingInstructionError):
            qproc.execute_instruction(INSTR_Z, [0], qubits=[q1])

    def test_exec_nonphys_instruction(self):
        """Test execution of a single non-physical instruction."""
        qproc = QuantumProcessor("TestQPD", num_positions=2, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=2, noise_model=QThresholdNoiseModel(1, ops.Y)),
            PhysicalInstruction(INSTR_H, duration=1.5)])
        q2, = qapi.create_qubits(1)
        qapi.operate(q2, ops.X)
        qproc.execute_instruction(INSTR_INIT, [0], physical=False)
        qproc.execute_instruction(INSTR_INIT, [1], qubits=[q2], physical=False)
        qproc.execute_instruction(INSTR_H, [0], physical=False)
        output, run_time = qproc.execute_instruction(INSTR_MEASURE, [1], physical=False)
        # Test the instruction executed instantly and without noise
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(h0, s1)), 1)
        self.assertAlmostEqual(output["instr"], [1])
        self.assertEqual(run_time, 0)
        # Test running simulator has no further effect
        self.helper._wait_once(self.evhandler_prog_done, entity=qproc, event_type=qproc.evtype_program_done)
        self.program_done = False
        ns.sim_run()
        self.assertAlmostEqual(ns.sim_time(), 0.)
        self.assertFalse(self.program_done)
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(h0, s1)), 1)

    def test_fallback_nonphysical(self):
        """Test fallback to non-physical instructions."""
        qproc = QuantumProcessor("TestQPD", num_positions=2, phys_instructions=[
            PhysicalInstruction(INSTR_H, duration=1.5)], fallback_to_nonphysical=False)
        self.assertEqual(qproc.fallback_to_nonphysical, False)
        qproc.fallback_to_nonphysical = True
        self.assertEqual(qproc.fallback_to_nonphysical, True)
        # These instructions should fallback to non-physical
        qproc.execute_instruction(INSTR_INIT, [0])
        qproc.execute_instruction(INSTR_INIT, [1])
        qproc.execute_instruction(INSTR_X, [1])
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, s01), 1)
        self.assertAlmostEqual(ns.sim_time(), 0.)
        # This instruction should not fallback to non-physical
        qproc.execute_instruction(INSTR_H, [0])
        self.assertAlmostEqual(qapi.fidelity(qubits, s01), 1)
        with self.assertRaises(MemPositionBusyError):
            qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, s01), 1)
        ns.sim_run()
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(h0, s1)), 1)
        self.assertAlmostEqual(ns.sim_time(), 1.5)

    def test_exec_qprogram_qnoise(self):
        """Test application of quantum noise on instruction and memory."""
        mem_noise_model1 = QThresholdNoiseModel(1, ops.Z)
        mem_noise_model2 = QThresholdNoiseModel(1, ops.X)
        instr_noise_model1 = QThresholdNoiseModel(1, ops.Z)
        instr_noise_model2 = QThresholdNoiseModel(1, ops.Y)
        instr_time = 2
        ns.sim_reset()
        qproc = QuantumProcessor(
            "TestQPD", num_positions=4, mem_noise_models=[mem_noise_model1] * 2 + [mem_noise_model2] * 2,
            phys_instructions=[
                PhysicalInstruction(INSTR_H, duration=instr_time, quantum_noise_model=instr_noise_model1, topology=[(0,)]),
                PhysicalInstruction(INSTR_H, duration=instr_time, parallel=True, topology=[(1,)]),
                PhysicalInstruction(INSTR_H, duration=instr_time, quantum_noise_model=instr_noise_model2, topology=[(2,)])],
        )
        qproc.put(qapi.create_qubits(4))
        prog = QuantumProgram(num_qubits=3, parallel=True)
        q1, q2, q3 = prog.get_qubit_indices(3)
        prog.apply(INSTR_H, q1)
        prog.apply(INSTR_H, q2)  # parallel
        prog.apply(INSTR_H, q3)
        qproc.execute_program(prog, qubit_mapping=[0, 1, 2])
        ns.sim_run()
        self.assertAlmostEqual(2 * instr_time, ns.sim_time())
        # t=0->2 : |0000> -(mem_noise)-> |0011> -(instr)-> |++11> -(instr_noise)-> |-+11>
        # t=2->4 : |-+11> -(mem_noise)-> |+-11> -(instr)-> |+--1> -(instr_noise)-> |+-+1>
        # Note that q4 only receives threshold noise once
        qubits = qproc.peek([0, 1, 2, 3])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(h01, np.kron(h0, s1))), 1)
        # Run again after peeking to apply extra noise (resets noise thresholds)
        ns.sim_run(duration=instr_time)
        self.assertAlmostEqual(3 * instr_time, ns.sim_time())
        # t=4->6 : |+-+1> -(mem_noise)-> |-++0>
        qubits = qproc.peek([0, 1, 2, 3])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(h10, np.kron(h0, s0))), 1)

    def test_exec_qprogram_qnoise_after_init(self):
        """Test application of quantum noise with an initialization instruction."""
        instr_noise_model = QThresholdNoiseModel(1, ops.X)
        instr_time = 2
        ns.sim_reset()
        # Add two physical instructions, of which one applies noise before the instruction.
        qproc = QuantumProcessor(
            "TestQPD", num_positions=2, mem_noise_models=None, phys_instructions=[
                PhysicalInstruction(INSTR_INIT, duration=instr_time, quantum_noise_model=instr_noise_model, topology=[(0,)]),
                PhysicalInstruction(INSTR_INIT, duration=instr_time, quantum_noise_model=instr_noise_model, topology=[(1,)],
                                    apply_q_noise_after=False)],
        )
        qproc.put(qapi.create_qubits(2))
        prog = QuantumProgram(num_qubits=2, parallel=True)
        q1, q2, = prog.get_qubit_indices(2)
        prog.apply(INSTR_INIT, q1)
        prog.apply(INSTR_INIT, q2)
        qproc.execute_program(prog, qubit_mapping=[0, 1])
        ns.sim_run()
        # t=0->2 : |00> -(instr)-> |10>
        # Note that on q2 noise is applied before the instruction is carried out.
        # The instruction will create a new qubit.
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, s10), 1)

    def test_exec_qprogram_cnoise(self):
        """Test application of classical noise on instruction output."""
        ns.sim_reset()
        c_noise_model = CThresholdNoiseModel(2)
        qproc = QuantumProcessor(
            "TestQPD", num_positions=2, phys_instructions=[
                PhysicalInstruction(INSTR_MEASURE, duration=1, classical_noise_model=c_noise_model, topology=[0]),
                PhysicalInstruction(INSTR_MEASURE, duration=3, classical_noise_model=c_noise_model, topology=[1])
            ])
        qproc.put(qapi.create_qubits(2))
        prog = QuantumProgram(num_qubits=2, parallel=True)
        q1, q2 = prog.get_qubit_indices(2)
        prog.apply(INSTR_MEASURE, q1, output_key="m1")
        prog.apply(INSTR_MEASURE, q2, output_key="m2")
        qproc.execute_program(prog, qubit_mapping=[0, 1])
        ns.sim_run()
        self.assertAlmostEqual(4, ns.sim_time())
        self.assertEqual(prog.output["m1"][0], 0)
        self.assertEqual(prog.output["m2"][0], 1)  # subject to noise

    def test_stop_program(self):
        """Test abruptly stopping a program."""
        num_pos = 6
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos, phys_instructions=[
            PhysicalInstruction(INSTR_X, duration=2)])
        qproc.put(qapi.create_qubits(num_pos))
        prog = QuantumProgram(num_qubits=num_pos)
        for qubit in prog.get_qubit_indices(num_pos):
            prog.apply(INSTR_X, qubit)
        qproc.execute_program(prog, qubit_mapping=list(range(num_pos)))
        self.program_fail = False
        self.program_done = False
        self.helper._wait_once(self.evhandler_prog_fail, entity=qproc, event_type=qproc.evtype_program_fail)
        self.helper._wait_once(self.evhandler_prog_done, entity=qproc, event_type=qproc.evtype_program_done)
        stop_time = 7
        ns.sim_run(end_time=stop_time)
        qproc.stop_program()
        self.assertFalse(self.program_fail)
        self.assertFalse(self.program_done)
        ns.sim_run()
        self.assertEqual(ns.sim_time(), stop_time)
        self.assertFalse(self.program_done)
        qubits = qproc.peek(list(range(num_pos)))
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(s11, np.kron(s10, s00))), 1)

    def test_exec_qprogram_callback(self):
        """Test setting callback for quantum program."""
        num_pos = 6
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=2, parallel=True),
            PhysicalInstruction(INSTR_X, duration=3)])
        prog = QuantumProgram(num_qubits=num_pos)
        for qubit in prog.get_qubit_indices(num_pos):
            prog.apply(INSTR_INIT, qubit)
            prog.apply(INSTR_X, qubit)
        data = None

        def test_callback(foo, bar=12):
            nonlocal data
            data = foo + bar

        qproc.set_program_done_callback(test_callback, 8, bar=7)
        qproc.execute_program(prog, qubit_mapping=list(range(num_pos)))
        ns.sim_run()
        self.assertEqual(ns.sim_time(), 3 * num_pos + 2)
        self.assertEqual(data, 8 + 7)

    @patch('netsquid.components.qprocessor.logger.warning')
    def test_terminate_program_on_error(self, mock_warning):
        """Test program self terminates on error."""
        num_pos = 6
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos, phys_instructions=[
            PhysicalInstruction(INSTR_X, duration=2)])
        # Create insufficient qubits
        qproc.put(qapi.create_qubits(3), [0, 1, 2])
        # Check two different exceptions are caught:
        # 1. Instruction on an empty memory position
        # 2. Missing instruction
        # In the second test we continue from where first failed
        for i, (instr, e_type) in enumerate(zip(
                [INSTR_X, INSTR_Z], [MemPositionEmptyError, MissingInstructionError],
        )):
            prog = QuantumProgram(num_qubits=num_pos)
            for qubit in prog.get_qubit_indices(num_pos):
                prog.apply(instr, qubit)
            qproc.execute_program(prog, qubit_mapping=list(range(num_pos)))
            self.program_fail = False
            self.program_done = False
            # self.helper._wait_once(self.evhandler_prog_fail, entity=qproc, event_type=qproc.evtype_program_fail)
            self.helper._wait_once(self.evhandler_prog_done, entity=qproc, event_type=qproc.evtype_program_done)

            def fail():
                self.program_fail = True

            qproc.set_program_fail_callback(callback=fail)
            ns.sim_run()
            self.assertTrue(self.program_fail)
            self.assertIsInstance(qproc.fail_exception, e_type)
            self.assertFalse(self.program_done)
            self.assertEqual(ns.sim_time(), 2 * 4)
            qubits = qproc.peek(list(range(num_pos)))
            self.assertEqual(qubits[3:], [None] * 3)
            self.assertAlmostEqual(qapi.fidelity(qubits[0:3], np.kron(s11, s1)), 1)
            # self.assertEqual(mock_warning.call_count, i + 1)

    def test_raise_exception_on_error(self):
        """Test fail exception is raised when global flag is set."""
        num_pos = 6
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos, phys_instructions=[
            PhysicalInstruction(INSTR_X, duration=2)])
        # Create insufficient qubits
        qproc.put(qapi.create_qubits(3), [0, 1, 2])
        # Test setting error condition via both module (mod) and when call program (prog)
        for mod_error, prog_error in [(True, False), (False, True), (False, False)]:
            qproc_module.error_on_program_fail = mod_error
            # Test two different program failures
            for instr, e_type in zip([INSTR_X, INSTR_Z], [MemPositionEmptyError, MissingInstructionError]):
                prog = QuantumProgram(num_qubits=num_pos)
                for qubit in prog.get_qubit_indices(num_pos):
                    prog.apply(instr, qubit)

                def run_program():
                    qproc.execute_program(prog, qubit_mapping=list(range(num_pos)),
                                          error_on_fail=prog_error)
                    ns.sim_run()

                if mod_error or prog_error:
                    with self.assertRaises(e_type):
                        run_program()
                    ns.sim_reset()  # ensure reset after sim is stopped
                else:
                    try:
                        run_program()
                    except e_type:
                        self.fail("Should not raise {} exception.")

    def test_get_finished_instrs(self):
        """Test if get_finished_instrs gives the right instructions and end times"""
        num_pos = 2
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=2, parallel=False),
            PhysicalInstruction(INSTR_X, duration=3)])
        prog = QuantumProgram(num_qubits=num_pos)
        q1, q2 = prog.get_qubit_indices(num_pos)
        prog.apply(INSTR_INIT, q1)
        prog.apply(INSTR_X, q1)
        prog.apply(INSTR_INIT, q2)
        finished_instructions = [instr for instr, time in qproc.get_finished_instrs()]
        self.assertEqual(len(finished_instructions), 0)
        qproc.execute_program(prog)
        duration_init = qproc.get_instruction_duration(INSTR_INIT, [q1])
        duration_x = qproc.get_instruction_duration(INSTR_X, [q1])
        self.assertEqual(len(finished_instructions), 0)
        ns.sim_run(duration=duration_init + duration_x / 2)
        finished_instructions = [instr for instr, time in qproc.get_finished_instrs()]
        self.assertEqual(len(finished_instructions), 1)
        self.assertTrue(INSTR_INIT in finished_instructions)
        ns.sim_run()
        finished_instructions = [instr for instr, time in qproc.get_finished_instrs()]
        self.assertEqual([INSTR_INIT, INSTR_X, INSTR_INIT], finished_instructions)
        end_times = [time for instr, time in qproc.get_finished_instrs()]
        self.assertAlmostEqual([7, 5, 2], end_times)

    def test_processor_status(self):
        """Test if processor is set to the correct statuses"""
        # Does not test for STATUS_PAUSED
        num_pos = 2
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=2, parallel=False),
            PhysicalInstruction(INSTR_X, duration=3)])
        prog = QuantumProgram(num_qubits=num_pos)
        self.assertTrue(qproc.status == ProcessorStatus.IDLE)
        qproc.execute_program(prog)
        self.assertTrue(qproc.status == ProcessorStatus.RUNNING)
        ns.sim_run()
        self.assertTrue(qproc.status == ProcessorStatus.IDLE)

    def test_processor_status_fail(self):
        """Test if processor is set to the failed status"""
        # Does not test for STATUS_PAUSED
        num_pos = 1
        qproc = QuantumProcessor("TestQPD", num_positions=num_pos, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=2, parallel=False),
            PhysicalInstruction(INSTR_X, duration=3)])
        prog = QuantumProgram(num_qubits=num_pos)
        self.assertTrue(qproc.status == ProcessorStatus.IDLE)
        q1 = prog.get_qubit_indices(num_pos)
        prog.apply(INSTR_X, q1)
        qproc.execute_program(prog)
        self.assertTrue(qproc.status == ProcessorStatus.RUNNING)
        ns.sim_run()
        self.assertTrue(qproc.status == ProcessorStatus.FAILED)

    def test_scheduling_pos_ordering(self):
        """Test position ordering in job scheduling."""
        # Create instructions with zero duration
        qproc = QuantumProcessor("TestQPD", num_positions=2, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=0),
            PhysicalInstruction(INSTR_SWAP, duration=0)])
        # Specify the sequence of gates:
        prog = QuantumProgram(num_qubits=2)
        q1, q2 = qapi.create_qubits(2)
        qapi.operate(q2, ops.X)
        prog.apply(INSTR_INIT, 0, qubits=[q1])
        prog.apply(INSTR_INIT, 1, qubits=[q2])
        prog.apply(INSTR_SWAP, [1, 0])
        qproc.execute_program(prog)
        self.assertTrue(qproc.status == ProcessorStatus.RUNNING)
        self.helper._wait_once(self.evhandler_prog_done, entity=qproc, event_type=qproc.evtype_program_done)
        self.program_done = False
        ns.sim_run()
        self.assertTrue(self.program_done)
        self.assertTrue(qproc.status == ProcessorStatus.IDLE)
        # Check swap succeeded
        qubits = qproc.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, s10), 1)

    def test_get_sequence_end_time(self):
        """Test sequence_end_time attribute for sequential and parallel program."""
        qproc = QuantumProcessor("TestQPD", num_positions=4, phys_instructions=[
            PhysicalInstruction(INSTR_INIT, duration=2, parallel=True),
            PhysicalInstruction(INSTR_X, duration=1, parallel=True),
            PhysicalInstruction(INSTR_H, duration=1.5, parallel=False, topology=[2, 3]),
            PhysicalInstruction(INSTR_CNOT, duration=2, parallel=True, topology=[(0, 1), (2, 3)]),
            PhysicalInstruction(INSTR_MEASURE, duration=3, parallel=True),
            PhysicalInstruction(INSTR_MEASURE_X, duration=2, parallel=False)])
        prog = ParallelQProgram()
        seq1_dt = 8
        seq2_dt = 19
        seq3_dt = 2
        for parallel, seq1_dt, seq2_dt, seq3_dt in [(False, 8, 19, 2), (True, 2, 10, 1)]:
            prog.parallel = parallel
            start_time = ns.sim_time()
            self.assertEqual(qproc.status, ProcessorStatus.IDLE)
            self.assertAlmostEqual(start_time, qproc.sequence_end_time)
            qproc.execute_program(prog)
            self.assertEqual(qproc.status, ProcessorStatus.RUNNING)
            self.assertAlmostEqual(start_time + seq1_dt, qproc.sequence_end_time)
            ns.sim_run(duration=seq1_dt)
            # At sequence end_time next sequence has not yet been scheduled
            self.assertAlmostEqual(start_time + seq1_dt, qproc.sequence_end_time)
            # Take epsilon step; now next sequence should be scheduled
            ns.sim_run(duration=1e-5)
            self.assertAlmostEqual(start_time + seq1_dt + seq2_dt, qproc.sequence_end_time)
            # This step includes previous epsilon, so next sequence should be scheduled
            ns.sim_run(duration=seq2_dt)
            self.assertAlmostEqual(start_time + seq1_dt + seq2_dt + seq3_dt, qproc.sequence_end_time)
            # Run to end of program
            ns.sim_run()
            self.assertEqual(qproc.status, ProcessorStatus.IDLE)
            self.assertAlmostEqual(ns.sim_time(), qproc.sequence_end_time)
            self.assertAlmostEqual(ns.sim_time(), start_time + seq1_dt + seq2_dt + seq3_dt)

    def test_active_instructions(self):
        """Test the list of active instructions is updated and sorted correctly."""
        ns.sim_reset()
        p_instr_0 = PhysicalInstruction(INSTR_INIT, duration=2, topology=[0], parallel=True)
        p_instr_1 = PhysicalInstruction(INSTR_INIT, duration=4, topology=[1], parallel=True)
        qproc = QuantumProcessor('TestQPD', num_positions=2, phys_instructions=[p_instr_0, p_instr_1])
        prog = QuantumProgram(num_qubits=2)
        prog.apply(INSTR_INIT, [0])
        prog.apply(INSTR_INIT, [1])
        prog.apply(INSTR_INIT, [0])
        qproc.execute_program(prog)
        jobs = qproc.active_instructions()
        self.assertEqual(2, len(jobs))
        # Start at 0, duration 2 on pos 0
        self.assertEqual(0, jobs[0][0])
        self.assertEqual(2, jobs[0][1])
        self.assertEqual(p_instr_0, jobs[0][2])
        self.assertEqual((0,), jobs[0][3])
        # Start at 0, duration 4 on pos 1
        self.assertEqual(0, jobs[1][0])
        self.assertEqual(4, jobs[1][1])
        self.assertEqual(p_instr_1, jobs[1][2])
        self.assertEqual((1,), jobs[1][3])
        ns.sim_run(3)
        jobs = qproc.active_instructions()
        self.assertEqual(2, len(jobs))
        # Start at 0, duration 4 on pos 1
        self.assertEqual(0, jobs[0][0])
        self.assertEqual(4, jobs[0][1])
        self.assertEqual(p_instr_1, jobs[0][2])
        self.assertEqual((1,), jobs[0][3])
        # Start at 2, duration 4 on pos 0
        self.assertEqual(2, jobs[1][0])
        self.assertEqual(4, jobs[1][1])
        self.assertEqual(p_instr_0, jobs[1][2])
        self.assertEqual((0,), jobs[1][3])

    def test_component_reset(self):
        """Test the required component reset functionality."""
        # TODO
        # Similar to stop_program()
        pass

    def test_unused_qubits_accessable(self):
        qproc = QuantumProcessor("TestQPD", num_positions=2, phys_instructions=[
            PhysicalInstruction(INSTR_I, duration=2)
        ])
        qubits = qapi.create_qubits(num_qubits=2)
        qproc.put(qubits)

        prog = QuantumProgram(num_qubits=1)
        q1, = prog.get_qubit_indices(num_qubits=1)
        prog.apply(INSTR_I, q1)
        qproc.execute_program(prog, qubit_mapping=[1])

        ns.sim_run(duration=1)
        # Processor should be locked up
        self.assertTrue(qproc.busy)
        mempos0, mempos1 = qproc.mem_positions
        self.assertFalse(mempos0.busy)
        self.assertTrue(mempos1.busy)
        with self.assertRaises(MemPositionBusyError):
            qproc.peek(1)
        self.assertEqual(qproc.peek(0)[0], qubits[0])

        ns.sim_run(end_time=3)
        # Processor should be free
        self.assertFalse(qproc.busy)
        mempos0, mempos1 = qproc.mem_positions
        self.assertFalse(mempos0.busy)
        self.assertFalse(mempos1.busy)
        self.assertEqual(qproc.peek([0, 1]), qubits)

    def test_processor_busy(self):
        qproc = QuantumProcessor("TestQPD", num_positions=1, phys_instructions=[
            PhysicalInstruction(INSTR_I, duration=2)
        ])
        qubits = qapi.create_qubits(num_qubits=1)
        qproc.put(qubits)

        prog = QuantumProgram(num_qubits=1)
        prog.apply(INSTR_I, 0)
        qproc.execute_program(prog)
        ns.sim_run(duration=1)
        with self.assertRaises(ProcessorBusyError):
            qproc.execute_program(prog)

    def test_program_params(self):

        class ParamProgram(QuantumProgram):

            def program(self, a, b=1):
                self.output["a"] = a
                self.output["b"] = b
                yield self.run()

        qproc = QuantumProcessor("TestQPD")
        prog = ParamProgram()
        with self.assertRaises(TypeError):
            qproc.execute_program(prog)

        qproc = QuantumProcessor("TestQPD")
        prog = ParamProgram()

        qproc.execute_program(prog, a=1)
        self.assertEqual(prog.output["a"], 1)
        self.assertEqual(prog.output["b"], 1)
        ns.sim_run()
        qproc.execute_program(prog, a=2, b=3)
        self.assertEqual(prog.output["a"], 2)
        self.assertEqual(prog.output["b"], 3)
        ns.sim_run()

        # Executing a QuantumProgram with incorrect arguments should result in an error
        with self.assertRaises(TypeError):
            qproc.execute_program(prog, a=4, b=5, c=6)

        qproc = QuantumProcessor("TestQPD")
        prog2 = QuantumProgram()
        with self.assertRaises(TypeError):
            qproc.execute_program(prog2, a=1)

    def test_program_and_processor_qubit_mapping(self):
        """Check when both the program and the processor have qubit mapping"""
        qproc = QuantumProcessor("TestQPD", num_positions=4, fallback_to_nonphysical=True)
        qubits = qapi.create_qubits(num_qubits=4)
        qproc.put(qubits)

        prog = QuantumProgram(num_qubits=2, qubit_mapping=[1, 0])
        q0, q1 = prog.get_qubit_indices(2)
        self.assertEqual(q0, 1)
        self.assertEqual(q1, 0)
        prog.apply(INSTR_X, q0)
        prog.apply(INSTR_H, q1)
        qproc.execute_program(prog, qubit_mapping=[3, 1], error_on_fail=True)
        ns.sim_run()

        self.assertTrue(np.allclose(qapi.reduced_dm(qubits[0]), ketutil.ket2dm(ns.s0)))
        self.assertTrue(np.allclose(qapi.reduced_dm(qubits[1]), ketutil.ket2dm(ns.s1)))
        self.assertTrue(np.allclose(qapi.reduced_dm(qubits[2]), ketutil.ket2dm(ns.s0)))
        self.assertTrue(np.allclose(qapi.reduced_dm(qubits[3]), ketutil.ket2dm(ns.h0)))


class InitProgram(QuantumProgram):
    default_num_qubits = 1

    def program(self):
        q0, = self.get_qubit_indices()
        self.apply(INSTR_H, q0)
        self.apply(INSTR_S, q0)
        yield self.run()


class EntangleProgram(QuantumProgram):
    default_num_qubits = 2

    def program(self):
        q0, q1 = self.get_qubit_indices()
        self.apply(INSTR_H, q0)
        self.apply(INSTR_CNOT, [q0, q1])
        yield self.run()


class BellMeasureProgram(QuantumProgram):
    default_num_qubits = 2

    def program(self):
        q0, q1 = self.get_qubit_indices()
        self.apply(INSTR_CNOT, [q0, q1])
        self.apply(INSTR_H, q0)
        self.apply(INSTR_MEASURE, q0, output_key="m0")
        self.apply(INSTR_MEASURE, q1, output_key="m1")
        yield self.run()


class CorrectionProgram(QuantumProgram):
    default_num_qubits = 1

    def program(self):
        q0, = self.get_qubit_indices()
        yield self.run()
        m0 = self.output["m0"][0]
        m1 = self.output["m1"][0]
        if m1:
            self.apply(INSTR_X, q0)
        if m0:
            self.apply(INSTR_Z, q0)
        yield self.run()


class TestConcatenatedProgramsProcessor(unittest.TestCase):

    def setUp(self) -> None:
        ns.sim_reset()

    def test_teleportation(self):
        teleportation_program = (InitProgram(qubit_mapping=[0]) + EntangleProgram(qubit_mapping=[1, 2]) +
                                 BellMeasureProgram(qubit_mapping=[0, 1]) + CorrectionProgram(qubit_mapping=[2]))
        qproc = QuantumProcessor("TestQPROC", num_positions=3,
                                 phys_instructions=[
                                     PhysicalInstruction(INSTR_I, duration=0),
                                     PhysicalInstruction(INSTR_X, duration=1),
                                     PhysicalInstruction(INSTR_Z, duration=1),
                                     PhysicalInstruction(INSTR_T, duration=1),
                                     PhysicalInstruction(INSTR_S, duration=1),
                                     PhysicalInstruction(INSTR_Y, duration=1),
                                     PhysicalInstruction(INSTR_H, duration=1),
                                     PhysicalInstruction(INSTR_CNOT, duration=2),
                                     PhysicalInstruction(INSTR_MEASURE, duration=5)
                                 ])
        qubits = qapi.create_qubits(3)
        qproc.put(qubits)
        qproc.execute_program(teleportation_program, qubit_mapping=[2, 0, 1])
        ns.sim_run()

        self.assertTrue(np.allclose(qapi.reduced_dm(qubits[1]), ketutil.ket2dm(ns.y0)))

    def test_incorrect_qubit_mappings(self):
        qproc = QuantumProcessor("TestQPROC", num_positions=3,
                                 phys_instructions=[
                                     PhysicalInstruction(INSTR_I, duration=0),
                                     PhysicalInstruction(INSTR_X, duration=1),
                                     PhysicalInstruction(INSTR_Z, duration=1),
                                     PhysicalInstruction(INSTR_T, duration=1),
                                     PhysicalInstruction(INSTR_S, duration=1),
                                     PhysicalInstruction(INSTR_Y, duration=1),
                                     PhysicalInstruction(INSTR_H, duration=1),
                                     PhysicalInstruction(INSTR_CNOT, duration=2),
                                     PhysicalInstruction(INSTR_MEASURE, duration=5)
                                 ])
        qubits = qapi.create_qubits(3)
        qproc.put(qubits)
        with self.assertRaises(ValueError):  # Too many indices
            qproc.execute_program(InitProgram(qubit_mapping=[0, 1]))
        qproc.reset()
        qubits = qapi.create_qubits(3)
        qproc.put(qubits)
        with self.assertRaises(ValueError):  # index too high
            qproc.execute_program(InitProgram(qubit_mapping=[3]))
        qproc.reset()
        qubits = qapi.create_qubits(3)
        qproc.put(qubits)
        with self.assertRaises(ValueError):  # index too high
            qproc.execute_program(InitProgram(qubit_mapping=[2]), qubit_mapping=[5])
        qproc.reset()
        qubits = qapi.create_qubits(3)
        qproc.put(qubits)
        with self.assertRaises(ValueError):  # Too few indices
            qproc.execute_program(EntangleProgram(qubit_mapping=[2]))
        qproc.reset()
        qubits = qapi.create_qubits(3)
        qproc.put(qubits)
        with self.assertRaises(ValueError):  # incorrect mapping (need 3 not 2)
            qproc.execute_program(InitProgram(qubit_mapping=[2]), qubit_mapping=[0, 1])
        qproc.reset()
        qubits = qapi.create_qubits(3)
        qproc.put(qubits)
        with self.assertRaises(ValueError):  # index too high
            qproc.execute_program(InitProgram(qubit_mapping=[2]) + EntangleProgram(qubit_mapping=[0, 3]))
            ns.sim_run()


def get_topo(topo1, qubit_mapping1, *indices):
    if topo1 is None and qubit_mapping1 is None:
        return None
    if qubit_mapping1 is None:
        return [topo1[i] for i in indices]
    if topo1 is None:
        return [qubit_mapping1[i] for i in indices]
    return [topo1[qubit_mapping1[i]] for i in indices]


class TestCompositeInstructionProcessor(unittest.TestCase):
    """Tests for composite instructions. Checking (amongst others) for topologies and index mappings."""

    def setUp(self) -> None:
        ns.sim_reset()
        self.topologies = [None, [0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]

    def _create_program(self, mapping=None):
        program = QuantumProgram(num_qubits=3, qubit_mapping=mapping)
        q0, q1, q2 = program.get_qubit_indices()
        program.apply(INSTR_INIT, q0)
        program.apply(INSTR_INIT, q2)
        program.apply(INSTR_H, q0)
        program.apply(INSTR_CNOT, (q0, q2))
        program.apply(INSTR_Z, q0)
        return program

    def _create_processor(self, topo_s=None, topo_z=None, topo_cz=None, topo_cnot=None):
        qproc = QuantumProcessor("test processor", num_positions=3)
        phys1 = PhysicalInstruction(INSTR_S, duration=4, topology=topo_s)
        phys_init = PhysicalInstruction(INSTR_INIT, duration=0)
        phys_h = PhysicalInstruction(INSTR_H, duration=1)
        phys_cz = PhysicalInstruction(INSTR_CZ, duration=2, topology=topo_cz)
        qproc.add_physical_instruction(phys1)
        qproc.add_physical_instruction(phys_h)
        qproc.add_physical_instruction(phys_cz)
        qproc.add_physical_instruction(phys_init)
        qproc.add_composite_instruction(INSTR_Z, [(INSTR_S, 0), (INSTR_S, 0)], topology=topo_z)
        qproc.add_composite_instruction(INSTR_CNOT, [(INSTR_H, 1), (INSTR_CZ, (0, 1)), (INSTR_H, 1)],
                                        topology=topo_cnot)
        return qproc

    def test_composite_instructions(self):
        """Test for composite instructions"""
        for qubit_mapping in self.topologies:
            program = self._create_program(qubit_mapping)
            if qubit_mapping is None:
                qubit_mapping = [0, 1, 2]
            for topo in self.topologies:
                qproc = self._create_processor()
                qproc.execute_program(program, error_on_fail=True, qubit_mapping=topo)
                ns.sim_run()
                if topo is None:
                    topo = [0, 1, 2]
                self.assertTrue(np.allclose(
                    qproc.peek(topo[qubit_mapping[0]])[0].qstate.qrepr.reduced_dm(),
                    ketutil.ket2dm(b10)))
                self.assertEqual(ns.sim_time(), 13)
                ns.sim_reset()

    def test_execute_composite_instruction(self):
        """Test qproc.execute_instruction with a composite instruction"""
        qproc = self._create_processor()
        qproc.execute_instruction(INSTR_INIT, [0])
        ns.sim_run()
        qproc.execute_instruction(INSTR_H, [0])
        ns.sim_run()
        qproc.execute_instruction(INSTR_Z, [0])
        ns.sim_run()
        qproc.execute_instruction(INSTR_H, [0])
        ns.sim_run()
        self.assertTrue(np.allclose(
            qapi.reduced_dm(qproc.peek(0)[0]), ketutil.ket2dm(s1)))

    def test_composite_instructions_with_topology_fails(self):
        """Test for composite instructions checking topology that fail"""
        for qubit_mapping in self.topologies:
            program = self._create_program(qubit_mapping)
            for topo in self.topologies:
                if topo is None and qubit_mapping is None:
                    continue
                # topology on sub instruction
                qproc = self._create_processor(topo_s=get_topo(topo, qubit_mapping, 1))
                with self.assertRaises(MissingInstructionError):
                    qproc.execute_program(program, error_on_fail=True, qubit_mapping=topo)
                ns.sim_reset()
                # topology on super instruction
                qproc = self._create_processor(topo_z=get_topo(topo, qubit_mapping, 1))
                with self.assertRaises(MissingInstructionError):
                    qproc.execute_program(program, error_on_fail=True, qubit_mapping=topo)
                ns.sim_reset()
                # topology on both but mismatch
                qproc = self._create_processor(topo_s=get_topo(topo, qubit_mapping, 0),
                                               topo_z=get_topo(topo, qubit_mapping, 1))
                with self.assertRaises(MissingInstructionError):
                    qproc.execute_program(program, error_on_fail=True, qubit_mapping=topo)
                ns.sim_reset()
                qproc = self._create_processor(topo_s=get_topo(topo, qubit_mapping, 2),
                                               topo_z=get_topo(topo, qubit_mapping, 1))
                with self.assertRaises(MissingInstructionError):
                    qproc.execute_program(program, error_on_fail=True, qubit_mapping=topo)
                qproc = self._create_processor(topo_s=get_topo(topo, qubit_mapping, 1),
                                               topo_z=get_topo(topo, qubit_mapping, 0))
                ns.sim_reset()
                with self.assertRaises(MissingInstructionError):
                    qproc.execute_program(program, error_on_fail=True, qubit_mapping=topo)
                ns.sim_reset()
                qproc = self._create_processor(topo_s=get_topo(topo, qubit_mapping, 1),
                                               topo_z=get_topo(topo, qubit_mapping, 1))
                with self.assertRaises(MissingInstructionError):
                    qproc.execute_program(program, error_on_fail=True, qubit_mapping=topo)
                ns.sim_reset()
                # topology on multiple
                qproc = self._create_processor(topo_s=get_topo(topo, qubit_mapping, 0, 1),
                                               topo_z=get_topo(topo, qubit_mapping, 1, 2))
                with self.assertRaises(MissingInstructionError):
                    qproc.execute_program(program, error_on_fail=True, qubit_mapping=topo)
                ns.sim_reset()
                # topology on multiple
                qproc = self._create_processor(topo_s=get_topo(topo, qubit_mapping, 2),
                                               topo_z=get_topo(topo, qubit_mapping, 0, 1))
                with self.assertRaises(MissingInstructionError):
                    qproc.execute_program(program, error_on_fail=True, qubit_mapping=topo)
                ns.sim_reset()

    def test_composite_instructions_with_topology_success(self):
        """Test for composite instructions checking topology that fail"""
        # topology on sub instruction
        for qubit_mapping in self.topologies:
            program = self._create_program(mapping=qubit_mapping)
            for topo in self.topologies:
                qproc = self._create_processor(topo_s=get_topo(topo, qubit_mapping, 0))
                qproc.execute_program(program, error_on_fail=True, qubit_mapping=topo)
                ns.sim_run()
                self.assertTrue(np.allclose(
                    qproc.peek(get_topo(topo, qubit_mapping, 0) or 0)[0].qstate.qrepr.reduced_dm(),
                    ketutil.ket2dm(b10)))
                self.assertEqual(ns.sim_time(), 13)
                ns.sim_reset()
                # topology on super instruction
                qproc = self._create_processor(topo_z=get_topo(topo, qubit_mapping, 0))
                qproc.execute_program(program, error_on_fail=True, qubit_mapping=topo)
                ns.sim_run()
                self.assertTrue(np.allclose(
                    qproc.peek(get_topo(topo, qubit_mapping, 0) or 0)[0].qstate.qrepr.reduced_dm(),
                    ketutil.ket2dm(b10)))
                self.assertEqual(ns.sim_time(), 13)
                ns.sim_reset()
                # topology on both
                qproc = self._create_processor(topo_s=get_topo(topo, qubit_mapping, 0),
                                               topo_z=get_topo(topo, qubit_mapping, 0))
                qproc.execute_program(program, error_on_fail=True, qubit_mapping=topo)
                ns.sim_run()
                self.assertTrue(np.allclose(
                    qproc.peek(get_topo(topo, qubit_mapping, 0) or 0)[0].qstate.qrepr.reduced_dm(),
                    ketutil.ket2dm(b10)))
                self.assertEqual(ns.sim_time(), 13)
                ns.sim_reset()
                # topology on multiple
                qproc = self._create_processor(topo_s=get_topo(topo, qubit_mapping, 0, 1),
                                               topo_z=get_topo(topo, qubit_mapping, 0, 2))
                qproc.execute_program(program, error_on_fail=True, qubit_mapping=topo)
                ns.sim_run()
                self.assertTrue(np.allclose(
                    qproc.peek(get_topo(topo, qubit_mapping, 0) or 0)[0].qstate.qrepr.reduced_dm(),
                    ketutil.ket2dm(b10)))
                self.assertEqual(ns.sim_time(), 13)
                ns.sim_reset()

    def test_recursive_composite_instructions(self):
        """Test for testing composite instructions that are composed of other composite instructions"""
        qproc = QuantumProcessor("test processor", num_positions=3)
        phys_t = PhysicalInstruction(INSTR_T, duration=2)
        phys_init = PhysicalInstruction(INSTR_INIT, duration=0)
        phys_h = PhysicalInstruction(INSTR_H, duration=1)
        qproc.add_physical_instruction(phys_t)
        qproc.add_physical_instruction(phys_h)
        qproc.add_physical_instruction(phys_init)
        qproc.add_composite_instruction(INSTR_S, [(INSTR_T, 0), (INSTR_T, 0)])
        qproc.add_composite_instruction(INSTR_Z, [(INSTR_S, 0), (INSTR_S, 0)])
        qproc.add_composite_instruction(INSTR_I, [(INSTR_Z, 0), (INSTR_Z, 0)])
        program = QuantumProgram()
        program.apply(INSTR_INIT, 0)
        program.apply(INSTR_H, 0)
        program.apply(INSTR_Z, 0)
        program.apply(INSTR_I, 0)
        qproc.execute_program(program, error_on_fail=True)
        ns.sim_run()
        self.assertTrue(np.allclose(qapi.reduced_dm(qproc.peek(0)[0]), ketutil.ket2dm(h1)))
        self.assertEqual(ns.sim_time(), 1 + 8 + 16)
        ns.sim_reset()

        # Check if an infinite recursive instruction fails
        qproc = QuantumProcessor("test processor", num_positions=3)
        qproc.add_composite_instruction(INSTR_K, [(INSTR_K, 0)])
        qproc.add_composite_instruction(INSTR_X, [(INSTR_Y, 0), (INSTR_Z, 0)])
        qproc.add_composite_instruction(INSTR_Y, [(INSTR_X, 0), (INSTR_Z, 0)])

        program_k = QuantumProgram()
        program_k.apply(INSTR_K, 0)
        with self.assertRaises(MissingInstructionError):
            qproc.execute_program(program_k, error_on_fail=True)
        ns.sim_reset()
        program_y = QuantumProgram()
        program_y.apply(INSTR_Y, 0)
        with self.assertRaises(MissingInstructionError):
            qproc.execute_program(program_y, error_on_fail=True)
        ns.sim_reset()

    def test_get_composite_instructions(self):
        """Tests for get_composite_instructions"""
        qproc = self._create_processor()
        self.assertSetEqual({INSTR_Z, INSTR_CNOT}, qproc.get_composite_instructions())
        self.assertSetEqual({INSTR_Z, INSTR_CNOT}, qproc.get_composite_instructions(-1))
        with self.assertRaises(TypeError):
            self.assertSetEqual({INSTR_Z, INSTR_CNOT}, qproc.get_composite_instructions([-1]))
        self.assertSetEqual({INSTR_Z, INSTR_CNOT}, qproc.get_composite_instructions((0,)))
        qproc = self._create_processor(topo_z=[2], topo_cnot=[(0, 1)])
        self.assertSetEqual({INSTR_Z, INSTR_CNOT}, qproc.get_composite_instructions())
        self.assertSetEqual(set(), qproc.get_composite_instructions(-1))
        self.assertSetEqual(set(), qproc.get_composite_instructions((0,)))
        self.assertSetEqual({INSTR_Z}, qproc.get_composite_instructions((2,)))
        self.assertSetEqual({INSTR_CNOT}, qproc.get_composite_instructions((0, 1)))
        self.assertSetEqual(set(), qproc.get_composite_instructions((1, 0)))

    def test_physical_index(self):
        """Tests for using PhysicalIndex in composite instruction"""
        qproc = QuantumProcessor("qproc", num_positions=3)
        qproc.add_physical_instruction(PhysicalInstruction(INSTR_INIT, duration=1))
        qproc.add_physical_instruction(PhysicalInstruction(INSTR_X, duration=1,
                                                           topology=[0]))
        qproc.add_physical_instruction(PhysicalInstruction(INSTR_SWAP, duration=2))
        qproc.add_composite_instruction(INSTR_X, [(INSTR_SWAP, (PhysicalIndex(0), 0)),
                                                  (INSTR_X, PhysicalIndex(0)),
                                                  (INSTR_SWAP, (PhysicalIndex(0), 0))],
                                        topology=[1, 2])
        program = QuantumProgram()
        program.apply(INSTR_INIT, 1)
        program.apply(INSTR_X, 1)
        qproc.execute_program(program, error_on_fail=True)
        ns.sim_run()
        self.assertTrue(np.allclose(qapi.reduced_dm(qproc.peek(1)[0]), ketutil.ket2dm(s1)))
        self.assertEqual(ns.sim_time(), 6)


if __name__ == "__main__":
    unittest.main()
