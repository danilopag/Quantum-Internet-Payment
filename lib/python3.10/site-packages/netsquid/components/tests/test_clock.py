# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_clock.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for clock in the clock module.

"""
import unittest
import netsquid as ns
from pydynaa import EventHandler
from netsquid.components.clock import Clock, ClockAlreadyRunningError
from netsquid.components.models.delaymodels import DelayModel, FixedDelayModel


class TestClock(unittest.TestCase):
    """Unit tests for the Clock module."""

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        ns.sim_reset()

    def tearDown(self):
        ns.sim_stop()

    def test_constructor(self):
        # You should provide at least a frequency or a timing_model.
        with self.assertRaises(ValueError):
            Clock(name="test")

        # Initialize with frequency.
        test_frequency = 10
        clock = Clock(name="test", frequency=test_frequency)
        self.assertEqual(clock.frequency, test_frequency)
        self.assertTrue(clock.models["timing_model"], FixedDelayModel)
        self.assertEqual(clock.models["timing_model"].get_mean(), 1e9 / test_frequency)
        self.assertEqual(clock.models["timing_model"].get_std(), 0)

        # Initialize with timing model.
        test_frequency_2 = 99
        fixed_delay_model = FixedDelayModel(delay=1e9 / test_frequency_2)
        clock = Clock(name="test", models={"timing_model": fixed_delay_model})
        self.assertEqual(clock.frequency, test_frequency_2)
        self.assertTrue(clock.models["timing_model"], FixedDelayModel)
        self.assertEqual(clock.models["timing_model"].get_mean(), 1e9 / test_frequency_2)
        self.assertEqual(clock.models["timing_model"].get_std(), 0)

        # Check initial number of ticks.
        self.assertEqual(clock.num_ticks, 0)

        # Check name of output port.
        self.assertEqual(list(clock.ports.keys()), ["cout"])

    def test_frequency(self):
        """Test setter and getter of frequency"""
        frequency = 100
        clock = Clock('test', frequency=frequency)
        self.assertEqual(frequency, clock.frequency)
        with self.assertRaises(ValueError):
            clock.frequency = 0
        with self.assertRaises(ValueError):
            clock.frequency = -1
        # Check period (1 / frequency)
        self.assertEqual(clock.get_period(), 1e9 / (frequency))
        # Check setter
        clock.frequency = frequency + 1
        self.assertEqual(clock.frequency, frequency + 1)

    def test_start_stop(self):
        """Test the start and stop functionality."""
        frequency = 100
        clock = Clock('test', frequency=frequency)
        clock.start()
        with self.assertRaises(ClockAlreadyRunningError):
            clock.start()
        self.assertTrue(clock.is_running)

        # Check if ticks are created (first at t=0).
        ns.sim_run(duration=1)
        self.assertEqual(clock.ports["cout"].output_queue[0][1].meta["tick_number"], 1)
        ns.sim_run(duration=1e9 / frequency)
        self.assertEqual(clock.ports["cout"].output_queue[0][1].meta["tick_number"], 2)

        # Check no additional ticks are created after stop.
        clock.stop()
        ns.sim_run(duration=1e9 / frequency)
        self.assertEqual(clock.ports["cout"].output_queue[0][1].meta["tick_number"], 2)
        self.assertFalse(clock.is_running)

        # Check additional ticks when started again.
        clock.start()
        ns.sim_run(duration=1e9 / frequency)
        self.assertEqual(clock.ports["cout"].output_queue[0][1].meta["tick_number"], 3)

    def test_timing_model(self):
        """Test if QSource works with timing models."""
        max_delay = 1e9

        class TestDelayModel(DelayModel):
            def __init__(self, max_delay):
                """Delay model that switches between a delay of 0 and max_delay each time it is called."""
                super().__init__()
                self.delay = 0
                self.max_delay = max_delay

            def generate_delay(self, **kwargs):
                self.delay = self.max_delay - self.delay
                return self.delay

            def get_mean(self, **kwargs):
                return self.max_delay / 2

            def set_mean(self, value):
                self.max_delay = value * 2

            def get_std(self, **kwargs):
                return self.max_delay / 2

        port_output = []

        def store_output_from_port(message):
            """Store all messages send to a port in a list."""
            nonlocal port_output
            port_output.append(message)

        test_model = TestDelayModel(max_delay)
        clock = Clock("test", models={"timing_model": test_model})
        clock.ports["cout"].bind_output_handler(store_output_from_port)

        self.assertEqual(clock.models["timing_model"], test_model)

        # Check after each time step of max_delay, 2 ticks are added to the port
        # (2, because the second tick is generated with zero delay).
        clock.start()
        for n in range(11):
            ns.sim_run(n * max_delay + 1)
            self.assertEqual(len(port_output), 1 + 2 * n)

    def test_counter(self):
        """Test if counter counts correctly and stops the clock."""
        counter = 0
        number_of_clicks = 100

        def count_ticks(event):
            nonlocal counter
            counter += 1

        tick_handler = EventHandler(count_ticks)
        for time_interval in [ns.PICOSECOND, ns.NANOSECOND, ns.MICROSECOND, ns.MICROSECOND, ns.SECOND]:
            clock_100 = Clock("100_ticks_clock", frequency=1e9 / time_interval, max_ticks=number_of_clicks)
            clock_100._wait(tick_handler, entity=clock_100, event_type=clock_100.evtype_tick)
            clock_100.start()
            # Run simulation twice as long as the clock should tick.
            ns.sim_run(duration=2 * time_interval * number_of_clicks)
            # Check correct number of clicks on the port, as number of events and as num_ticks variable.
            self.assertEqual(clock_100.ports["cout"].output_queue[0][1].meta["tick_number"], number_of_clicks)
            self.assertEqual(counter, number_of_clicks)
            self.assertEqual(clock_100.num_ticks, number_of_clicks)
            # Check the clock stops.
            self.assertFalse(clock_100.is_running)
            counter = 0

    def test_start_delay(self):
        """Test start delay property."""
        start_delay = 10
        clock = Clock("test", frequency=1, start_delay=start_delay)
        self.assertEqual(clock.properties["start_delay"], start_delay)
        # Test changing the start_delay property before a new call to start.
        for idx in range(3):
            clock.properties["start_delay"] = start_delay * (idx + 1)
            clock.start()
            ns.sim_run(duration=start_delay * (idx + 1))
            self.assertEqual(clock.num_ticks, idx)
            ns.sim_run(duration=1)
            self.assertEqual(clock.num_ticks, idx + 1)
            clock.stop()
        # Test negative start delay will raise error
        with self.assertRaises(ValueError):
            clock.properties["start_delay"] = -1
        with self.assertRaises(ValueError):
            clock = Clock("test", frequency=1, start_delay=-0.1)

    def test_reset(self):
        """Test reset functionality."""
        clock = Clock("test", frequency=1e9)
        clock.start()
        ns.sim_run(10)
        self.assertTrue(clock.is_running)
        self.assertEqual(clock.num_ticks, 10)
        clock.reset()
        self.assertEqual(clock.num_ticks, 0)
        self.assertFalse(clock.is_running)


if __name__ == "__main__":
    unittest.main()
