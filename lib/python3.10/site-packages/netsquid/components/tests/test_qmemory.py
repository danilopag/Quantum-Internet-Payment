# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_qmemory.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the qmemory module.

"""
import itertools
import unittest
import numpy as np
import netsquid as ns
import pydynaa as pd
from netsquid.qubits import qubitapi as qapi
from netsquid.components.component import Port, Message
from netsquid.components.qmemory import QuantumMemory, MemPositionEmptyError, MemPositionInUseError, MemoryPosition, \
    MemPositionBusyError

from netsquid import Operator
from netsquid.components.models.qerrormodels import QuantumErrorModel, DepolarNoiseModel
from netsquid.qubits import assign_qstate
from netsquid.qubits.ketstates import s0, s1, h0, h1, s01, s11, h00, h11, b00, b01, b10, b11
from netsquid.qubits.operators import X, H, Z
from netsquid.qubits.ketutil import ket2dm
from netsquid.qubits import qformalism as qform

# NOTE below tests require refinement and completion
# TODO test replacing of a qubit applies noise


class ThresholdNoiseModel(QuantumErrorModel):
    """A test noise model based on a delay threshold.

    Applies X noise to a qubit if it's been on channel for longer
    than threshold time.

    """

    def __init__(self, threshold, operator=X):
        super().__init__()
        self.properties["threshold"] = threshold
        self.properties["operator"] = operator
        self.required_properties = ["num_positions", "threshold_multiplier"]

    def error_operation(self, qubits, delta_time=0, **kwargs):
        # threshold = self.properties["threshold"] * kwargs["threshold_multiplier"][0]
        threshold = self.properties["threshold"] * kwargs["threshold_multiplier"]
        if delta_time >= threshold:
            for qubit in qubits:
                qapi.operate(qubit, self.properties["operator"])


class TestQuantumMemory(unittest.TestCase):
    """Unit tests for the qmemory module."""

    def _do_put_on_delay(self, quantum_memory, item, positions, delay):
        """Schedule the callback function after delay time."""

        def callback_put(event):
            quantum_memory.put(item, positions)

        event = self.god._schedule_after(delay, self.delay_evtype)
        eventhandler = ns.EventHandler(callback_put)
        self.god._wait_once(eventhandler, event=event)

    def _qmemory_get_qubits(self, quantum_memory, remove, positions, **kwargs):
        if remove:
            return quantum_memory.pop(positions, **kwargs)
        else:
            return quantum_memory.peek(positions, **kwargs)

    def _do_get_qubits_on_delay(self, quantum_memory, remove, positions, delay, skip_noise=False):
        """Schedule the callback function after delay time."""
        self.qitems = []
        self.delta_times = []

        def callback_func(event):
            self.delta_times = quantum_memory.delta_time(positions)
            self.qitems = self._qmemory_get_qubits(quantum_memory, remove, positions, skip_noise=skip_noise)

        event = self.god._schedule_after(delay, self.delay_evtype)
        eventhandler = ns.EventHandler(callback_func)
        self.god._wait_once(eventhandler, event=event)

    def _do_operate_on_delay(self, quantum_memory, operator, positions, delay, skip_noise=False):
        """Schedule the callback function after delay time."""

        def callback_put(event):
            quantum_memory.operate(operator, positions=positions, check_positions=True, skip_noise=skip_noise)

        event = self.god._schedule_after(delay, self.delay_evtype)
        eventhandler = ns.EventHandler(callback_put)
        self.god._wait_once(eventhandler, event=event)

    def _do_measure_on_delay(self, quantum_memory, positions, delay, skip_noise=False):
        """Schedule the callback function after delay time."""

        self.measure_results = []
        self.measure_probs = []

        def callback_put(event):
            self.measure_results, self.measure_probs = quantum_memory.measure(positions=positions,
                                                                              skip_noise=skip_noise)

        event = self.god._schedule_after(delay, self.delay_evtype)
        eventhandler = ns.EventHandler(callback_put)
        self.god._wait_once(eventhandler, event=event)

    @staticmethod
    def bell_measure_operator():
        m00 = np.array([[0.5, 0, 0, 0.5],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0.5, 0, 0, 0.5]],
                       dtype=complex)
        m01 = np.array([[0, 0, 0, 0],
                        [0, 0.5, 0.5, 0],
                        [0, 0.5, 0.5, 0],
                        [0, 0, 0, 0]],
                       dtype=complex)
        m10 = np.array([[0.5, 0, 0, -0.5],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [-0.5, 0, 0, 0.5]],
                       dtype=complex)
        m11 = np.array([[0, 0, 0, 0],
                        [0, 0.5, -0.5, 0],
                        [0, -0.5, 0.5, 0],
                        [0, 0, 0, 0]],
                       dtype=complex)
        n00 = Operator("Bell00", m00)
        n01 = Operator("Bell01", m01)
        n10 = Operator("Bell10", m10)
        n11 = Operator("Bell11", m11)
        return [n00, n01, n10, n11]

    def setUp(self):
        """Set up a new simulation environment for each test."""
        ns.sim_reset()
        self.god = pd.Entity()  # helper entity
        qform.set_qstate_formalism(qform.QFormalism.KET)
        self.delay_evtype = pd.EventType("DELAY", "General delay event type")

    def test_init(self):
        """Test correct QuantumMemory initialization"""
        noise_models = [DepolarNoiseModel(i) for i in range(1000, 5000, 1000)]
        num_positions = 4
        quantum_memory = QuantumMemory(name='test_memory',
                                       memory_noise_models=noise_models,
                                       num_positions=num_positions)
        for idx, mem_pos in enumerate(quantum_memory.mem_positions):
            self.assertEqual(mem_pos.models["noise_model"], noise_models[idx])
        quantum_memory = QuantumMemory(name='test_memory',
                                       memory_noise_models=noise_models[0],
                                       num_positions=num_positions)
        for idx, mem_pos in enumerate(quantum_memory.mem_positions):
            self.assertEqual(mem_pos.models["noise_model"], noise_models[0])
        # Check ports are assigned
        port_names = ["qin", "qout"] + ["qin{}".format(i) for i in range(num_positions)]
        for port_name in port_names:
            self.assertTrue(port_name in quantum_memory.ports)
            self.assertTrue(isinstance(quantum_memory.ports[port_name], Port))
        # Initiating with only a name results in a QuantumMemory with no
        # QuantumErrorModel and a maximum of 1 positions.
        quantum_memory = QuantumMemory('test_memory')
        self.assertEqual(quantum_memory.mem_positions[0].models["noise_model"], None)
        self.assertEqual(quantum_memory.properties["num_positions"], 1)
        self.assertEqual(quantum_memory.num_positions, 1)
        # Check num_positions given in properties overwrites the num_positions argument
        quantum_memory = QuantumMemory('test_memory', num_positions=1, properties={"num_positions": 2})
        self.assertEqual(quantum_memory.properties["num_positions"], 2)

    def test_qubit_types(self):
        """Test setting and retrieving of qubit types."""
        quantum_memory = QuantumMemory(name='test_memory',
                                       num_positions=4, qubit_types=None)
        for i in range(quantum_memory.num_positions):
            self.assertEqual(quantum_memory.mem_positions[i].properties.get("qubit_type"), None)
        qubit_types = ["A", "B", "C", "D", "A"]
        quantum_memory = QuantumMemory(name='test_memory',
                                       num_positions=5, qubit_types=qubit_types)
        for i, qubit_type in enumerate(qubit_types):
            self.assertEqual(quantum_memory.mem_positions[i].properties.get("qubit_type"), qubit_type)
        self.assertEqual(quantum_memory.get_matching_positions("qubit_type", "A"), [0, 4])
        self.assertEqual(quantum_memory.get_matching_positions("qubit_type", "B"), [1])
        self.assertEqual(quantum_memory.get_matching_positions("qubit_type", "Z"), [])

    # def test_create_qubits_at(self):
    #    """Test the create_qubits_at function"""
    #    quantum_memory = QuantumMemory('test_memory', num_positions=1)
    #    # Creating at position > num_positions, should raise a ValueError
    #    with self.assertRaises(IndexError):
    #        quantum_memory.create_qubits_at(1)
    #    # Creating more than num_positions, should raise a ValueError
    #    with self.assertRaises(ValueError):
    #        quantum_memory.create_qubits_at([0, 1])
    #    # create_qubits_at at a valid position, should return a Qubit
    #    quantum_memory.create_qubits_at(0)
    #    self.assertIsInstance(quantum_memory.peek(0)[0], Qubit)
    #    # Giving a list of int should work
    #    quantum_memory = QuantumMemory('test_memory', num_positions=3)
    #    quantum_memory.create_qubits_at([0, 2])
    #    self.assertIsInstance(quantum_memory.peek(0)[0], Qubit)
    #    self.assertIsInstance(quantum_memory.peek(2)[0], Qubit)

    def test_put(self):
        """Test the put function"""
        # Put should handle non-list input
        qubit, = ns.qubits.create_qubits(1)
        quantum_memory = QuantumMemory('test_memory')
        quantum_memory.put(qubit, 0)
        self.assertEqual(quantum_memory.pop(0), [qubit])

        # The qubits should be positioned at the given position
        num_qubits = 4
        qubits = ns.qubits.create_qubits(num_qubits)
        positions = [3, 1, 2, 0]
        quantum_memory = QuantumMemory('test_memory', num_positions=num_qubits)
        self.assertEqual(len(quantum_memory.used_positions), 0)
        self.assertEqual(set(quantum_memory.unused_positions), set(range(num_qubits)))
        quantum_memory.put(qubits, positions)
        for position, qubit in zip(positions, qubits):
            self.assertFalse(quantum_memory.mem_positions[position].is_empty)
            self.assertTrue(quantum_memory.mem_positions[position].in_use)
            self.assertEqual(quantum_memory.peek(position), [qubit])
        self.assertEqual(len(quantum_memory.used_positions), num_qubits)
        self.assertEqual(quantum_memory.unused_positions, [])
        # If no positions are given, the qubits should be positioned at
        # positions 0:len(qubits)
        quantum_memory.put(qubits)
        for idx in range(num_qubits):
            self.assertEqual(quantum_memory.pop(idx), [qubits[idx]])
        # Test type error on non-qubit or None
        with self.assertRaises(TypeError):
            quantum_memory.put(["A"])
        # Test that None qubits override existing qubits.
        quantum_memory.put([None] * num_qubits)
        for idx in range(num_qubits):
            self.assertEqual(quantum_memory.pop(idx), [None])
        # It should not be allowed to enter qubits and positions of different length
        with self.assertRaises(ValueError):
            quantum_memory.put(qubit, [idx for idx in range(num_qubits)])

    def test_port_input_qubits(self):
        """Test input of qubits with IO port."""
        # NOTE We repeat the rests as for put test above
        # TODO refine for additional meta data features e.g. replace, ready_evtype
        # Put should handle non-list input
        qubit, = ns.qubits.create_qubits(1)
        quantum_memory = QuantumMemory('test_memory')
        quantum_memory.ports["qin"].tx_input(Message(qubit))
        self.assertEqual(quantum_memory.pop(0), [qubit])
        # The qubits should be positioned at the given position
        num_qubits = 4
        qubits = ns.qubits.create_qubits(num_qubits)
        positions = [3, 1, 2, 0]
        quantum_memory = QuantumMemory('test_memory', num_positions=num_qubits)
        self.assertEqual(len(quantum_memory.used_positions), 0)
        self.assertEqual(set(quantum_memory.unused_positions), set(range(num_qubits)))
        quantum_memory.ports["qin"].tx_input(Message(qubits, qm_positions=positions))
        for position, qubit in zip(positions, qubits):
            self.assertFalse(quantum_memory.mem_positions[position].is_empty)
            self.assertTrue(quantum_memory.mem_positions[position].in_use)
            self.assertEqual(quantum_memory.peek(position), [qubit])
        self.assertEqual(len(quantum_memory.used_positions), num_qubits)
        self.assertEqual(quantum_memory.unused_positions, [])
        # If no positions are given, the qubits should be positioned at
        # positions 0:len(qubits)
        quantum_memory.ports["qin"].tx_input(Message(qubits))
        for idx in range(num_qubits):
            self.assertEqual(quantum_memory.pop(idx), [qubits[idx]])
        # It should not be allowed to enter qubits and positions of different length
        with self.assertRaises(ValueError):
            quantum_memory.ports["qin"].tx_input(
                Message(qubit, qm_positions=[idx for idx in range(num_qubits)]))

    def test_port_input_specific_position(self):
        """Test input of single qubit with specific memory position port."""
        qubit, = ns.qubits.create_qubits(1)
        quantum_memory = QuantumMemory('test_memory')
        with self.assertRaises(KeyError):
            quantum_memory.ports["qin1"].tx_input(Message(qubit))
        quantum_memory.ports["qin0"].tx_input(Message(qubit))
        self.assertEqual(quantum_memory.pop(0), [qubit])
        # The qubits should be positioned at the given position
        num_qubits = 4
        qubits = ns.qubits.create_qubits(num_qubits)
        positions = [3, 1, 2, 0]
        quantum_memory = QuantumMemory('test_memory', num_positions=num_qubits)
        self.assertEqual(len(quantum_memory.used_positions), 0)
        self.assertEqual(set(quantum_memory.unused_positions), set(range(num_qubits)))
        for position, qubit in zip(positions, qubits):
            quantum_memory.ports["qin{}".format(position)].tx_input(Message(qubit))
        for position, qubit in zip(positions, qubits):
            self.assertFalse(quantum_memory.mem_positions[position].is_empty)
            self.assertTrue(quantum_memory.mem_positions[position].in_use)
            self.assertEqual(quantum_memory.peek(position), [qubit])
        self.assertEqual(len(quantum_memory.used_positions), num_qubits)
        self.assertEqual(quantum_memory.unused_positions, [])

    def get_qubits_test_single_position(self, remove):
        """Test if pop/peek of 1 qubit returns the correct qubit, time and in_use"""
        delay = 13
        qubit = ns.qubits.create_qubits(1)[0]
        quantum_memory = QuantumMemory('test_memory', num_positions=2)
        quantum_memory.put(qubit)  # put the qubit on the memory at t=0 at position=0

        # pop/peek a single position (an int not a list)
        self._do_get_qubits_on_delay(quantum_memory, remove=remove, positions=0, delay=delay)
        ns.sim_run()

        self.assertEqual(self.qitems, [qubit])
        self.assertAlmostEqual(self.delta_times, [delay])
        if not remove:
            self.assertFalse(quantum_memory.mem_positions[0].is_empty)
            self.assertTrue(quantum_memory.mem_positions[0].in_use)
        else:
            self.assertTrue(quantum_memory.mem_positions[0].is_empty)
            self.assertFalse(quantum_memory.mem_positions[0].in_use)

        # Popping/Peeking an empty position returns empty (None, 0)
        [delta_time] = quantum_memory.delta_time(positions=1)
        [qitem] = self._qmemory_get_qubits(quantum_memory, remove, positions=1)
        self.assertEqual(qitem, None)
        self.assertEqual(delta_time, 0)
        # test get_position_used as well
        self.assertTrue(quantum_memory.mem_positions[1].is_empty)
        self.assertFalse(quantum_memory.mem_positions[1].in_use)

    def get_qubits_test_multiple_positions(self, remove):
        """Test if pop/peek of multiple qubits returns the correct qubits, times and in_use"""
        ns.sim_reset()

        num_qubits = 4
        put_positions = [2, 1, 0, 3]
        delays = [1, 7, 4, 15]  # delays before putting
        sim_end_time = sum(delays)

        qubits = ns.qubits.create_qubits(num_qubits)
        quantum_memory = QuantumMemory('test_memory', num_positions=num_qubits)
        quantum_memory.put(qubits)

        for put_item, put_position, delay in zip(qubits, put_positions, delays):
            self._do_put_on_delay(quantum_memory=quantum_memory, item=put_item, positions=put_position, delay=delay)
        ns.sim_run(end_time=sim_end_time)

        positions = [1, 3]
        # access all qubits at once at sim end time
        delta_times = quantum_memory.delta_time(positions=positions)
        qitems = self._qmemory_get_qubits(quantum_memory, remove, positions=positions)
        # import pdb; pdb.set_trace()
        for idx, position in enumerate(positions):
            self.assertEqual(qitems[idx], qubits[put_positions.index(position)])
            self.assertAlmostEqual(delta_times[idx], sim_end_time - delays[put_positions.index(position)])
            self.assertEqual(quantum_memory.mem_positions[position].is_empty, remove)
            self.assertNotEqual(quantum_memory.mem_positions[position].in_use, remove)

    def get_qubits_test_noise(self, remove, skip_noise=False):
        """Test if quantum noise applied after a threshold time."""
        num_qubits = 4
        threshold_time = 6
        positions = [2, 0, 3, 1]
        delays = [3, 2, 19, 25]
        cummulative_delays = list(np.cumsum(delays))
        kets = [s1 if threshold_time < delay else s0 for delay in cummulative_delays]
        # kets = [s0, s0, s1, s1]
        qubits = ns.qubits.create_qubits(num_qubits)
        quantum_memory = QuantumMemory('test_memory', num_positions=num_qubits)
        quantum_memory.put(qubits)
        noise_model = ThresholdNoiseModel(0.5 * threshold_time)
        with self.assertRaises(ValueError):
            # Missing the threshold multiplier
            quantum_memory.mem_positions[0].models["noise_model"] = noise_model
        for mem_pos in quantum_memory.mem_positions:
            mem_pos.add_property('threshold_multiplier', value=1)
        for mem_pos in quantum_memory.mem_positions:
            mem_pos.models["noise_model"] = noise_model
        # Change multiplier after setting model
        for mem_pos in quantum_memory.mem_positions:
            mem_pos.properties["threshold_multiplier"] = 2
        for mem_pos in quantum_memory.mem_positions:
            self.assertEqual(mem_pos.models['noise_model'], noise_model)
        for position, delay, ket in zip(positions, delays, kets):
            self._do_get_qubits_on_delay(quantum_memory, remove=remove, positions=position,
                                         delay=delay, skip_noise=skip_noise)
            ns.sim_run()
            if skip_noise:
                ket = s0
            self.assertTrue(np.allclose(qapi.reduced_dm(self.qitems[0]), ket2dm(ket)))
            self.assertEqual(quantum_memory.mem_positions[position].is_empty, remove)
            self.assertNotEqual(quantum_memory.mem_positions[position].in_use, remove)

    def test_pop_with_positions(self):
        """Test the pop functionality with positions"""
        # pop is a call to _get_qubits with remove=True
        self.get_qubits_test_single_position(remove=True)
        self.get_qubits_test_multiple_positions(remove=True)

    def test_peek_with_positions(self):
        """Test accessing the the peek function with positions"""
        # peek is a call to _get_qubits with remove=False
        self.get_qubits_test_single_position(remove=False)
        self.get_qubits_test_multiple_positions(remove=False)

    # def test_pop_with_events(self):
    #    """Test accessing the pop function with events"""
    #    # pop is a call to _get_qubits with remove=True
    #    self.get_qubits_test_events(remove=True)

    # def test_peek_with_events(self):
    #    """Test accessing the peek function with events"""
    #    num_qubits = 4
    #    #threshold_time = 4
    #    qubits = ns.qubits.create_qubits(num_qubits)
    #    quantum_memory = QuantumMemory('test_memory', num_positions=num_qubits)
    #    quantum_memory.put(qubits)
    #    # Only 1 event
    #    quantum_memory.put(qubits[0], 0)
    #    event = quantum_memory.get_put_event(0)
    #    self.assertEqual(qubits[:1], self._qmemory_get_qubits(quantum_memory, remove=False, positions=[0], put_event=event))
    #    # Using both positions and put event should favour latter
    #    quantum_memory.put(qubits[0], 0)
    #    quantum_memory.put(qubits[3], 3)
    #    event = quantum_memory.get_put_event(3)
    #    [qubit] = self._qmemory_get_qubits(quantum_memory, remove=False, positions=[0], put_event=event)
    #    self.assertEqual(qubit, qubits[3])
    #    self.assertFalse(quantum_memory.mem_positions[0].is_empty)
    #    self.assertTrue(quantum_memory.mem_positions[0].in_use)
    #    self.assertEqual(quantum_memory.mem_positions[3].is_empty, remove=False)
    #    self.assertNotEqual(quantum_memory.mem_positions[3].in_use, remove=False)
    #    # Using something different than int or eventType as input should raise an error
    #    with self.assertRaises(TypeError):
    #        self._qmemory_get_qubits(quantum_memory, positions='0', remove=False)

    def test_pop_with_noise(self):
        """Test if noise applied when qubit(s) popped"""
        # pop is a call to _get_qubits with remove=True
        self.get_qubits_test_noise(remove=True)
        self.get_qubits_test_noise(remove=True, skip_noise=True)

    def test_peek_with_noise(self):
        """Test if noise applied when qubit(s) peeked"""
        # peek is a call to _get_qubits with remove=False
        self.get_qubits_test_noise(remove=False)
        self.get_qubits_test_noise(remove=False, skip_noise=True)

    # def test_get_position_used(self):
    #    """Test the get_position_used function.

    #    Note: this is already done in test_put/pop.
    #    """
    #    pass

    def test_get_put_and_positions_of_event(self):
        """Test get_put event and get_matching_qubits functions"""
        quantum_memory = QuantumMemory('test_memory')
        quantum_memory.put(ns.qubits.create_qubits(1))  # To get an event type at te first position.
        event_put = quantum_memory.mem_positions[0].meta.get("put_event")
        position = quantum_memory.get_matching_qubits("put_event", event_put)
        # Test return type
        self.assertIsInstance(event_put, pd.Event)
        self.assertIsInstance(position, list)
        # Test return value
        self.assertEqual(position, [0])
        # Requesting a position > max_memories should result in a ValueError
        # with self.assertRaises(IndexError):
        #    quantum_memory.quantum_memory.mem_positions[99].meta("put_event")
        # Requestion an Event not used in memory should return an empty list
        evtype = pd.EventType("RANDOM", "Random event for testing")
        event = self.god._schedule_now(evtype)
        self.assertEqual(quantum_memory.get_matching_qubits("put_event", event), [])

    # def test_get_noise_model(self):
    #    """Test the get_noise_model function"""
    #    noise_model = DepolarNoiseModel(1000)
    #    num_positions = 3
    #    quantum_memory = QuantumMemory(name='test_memory',
    #                                   noise_models=noise_model,
    #                                   num_positions=num_positions)
    #    self.assertEqual(quantum_memory.get_noise_model(0), noise_model)
    #    # Without specifying the positions, get_noise_model should return
    #    # the noise model as position 0
    #    self.assertEqual(quantum_memory.get_noise_model(),
    #                     noise_model)
    #    # Requesting a position > max_memories should result in a ValueError
    #    with self.assertRaises(IndexError):
    #        quantum_memory.get_noise_model(99)

    # def test_set_noise_model(self):
    #    """Test the set_noise_model function"""
    #    noise_model = DepolarNoiseModel(1000)
    #    noise_model_2 = DepolarNoiseModel(2000)
    #    noise_model_3 = DepolarNoiseModel(3000)
    #    num_positions = 3
    #    quantum_memory = QuantumMemory(name='test_memory',
    #                                   num_positions=num_positions)
    #    # Set a single noise model  at a specifed position
    #    quantum_memory.set_noise_model(noise_model, 1)
    #    self.assertEqual(quantum_memory.get_noise_model(1), noise_model)
    #    # Set a set of noise models
    #    quantum_memory.set_noise_model(noise_model, [0, 1])
    #    quantum_memory.set_noise_model(noise_model_2, 2)
    #    self.assertEqual(quantum_memory.get_noise_model(0), noise_model)
    #    self.assertEqual(quantum_memory.get_noise_model(1), noise_model)
    #    self.assertEqual(quantum_memory.get_noise_model(2), noise_model_2)
    #    # Without specifying the positions, set_noise_model should put the
    #    # noise model at all positions
    #    quantum_memory.set_noise_model(noise_model_3)
    #    for position in range(num_positions):
    #        self.assertEqual(quantum_memory.get_noise_model(position), noise_model_3)
    #    # Requesting a position > max_memories should result in a ValueError
    #    with self.assertRaises(IndexError):
    #        quantum_memory.set_noise_model(noise_model, 99)
    #    with self.assertRaises(IndexError):
    #        quantum_memory.set_noise_model(noise_model, [0, 99])

    def test_operate(self):
        """Test the operate function"""
        # Test positions argument: nothing, int and list of int
        two_qubit_operator = X ^ X
        quantum_memory_1 = QuantumMemory(name='test_memory_1',
                                         num_positions=1)
        quantum_memory_1.put(ns.qubits.create_qubits(1))
        quantum_memory_2 = QuantumMemory(name='test_memory_2',
                                         num_positions=2)
        quantum_memory_2.put(ns.qubits.create_qubits(2))
        # Test if the qubits remain on the memory after operate and if positions can handle int, list and nothing
        self.assertFalse(quantum_memory_1.mem_positions[0].is_empty)
        quantum_memory_1.operate(X, positions=0)
        self.assertFalse(quantum_memory_1.mem_positions[0].is_empty)
        self.assertTrue(np.allclose(
            qapi.reduced_dm(quantum_memory_1.peek(0)[0]), ket2dm(s1)))  # <X|s0|X> = s1
        quantum_memory_1.operate(X, positions=0)
        self.assertFalse(quantum_memory_1.mem_positions[0].is_empty)
        self.assertFalse(quantum_memory_2.mem_positions[0].is_empty)
        self.assertFalse(quantum_memory_2.mem_positions[1].is_empty)
        quantum_memory_2.operate(two_qubit_operator, positions=[0, 1])  # Use SWAP as a 2 qubit operator
        self.assertFalse(quantum_memory_2.mem_positions[0].is_empty)
        self.assertFalse(quantum_memory_2.mem_positions[1].is_empty)
        self.assertTrue(np.allclose(
            qapi.reduced_dm(quantum_memory_2.peek([0, 1])), ket2dm(s11)))
        # Test if ValueError is raised when positions do not mathc operator
        with self.assertRaises(ValueError):
            quantum_memory_2.operate(two_qubit_operator, positions=0)
        with self.assertRaises(ValueError):
            quantum_memory_2.operate(X, positions=[0, 1])
        # Test if a IndexError is raised when non existing positions are given
        with self.assertRaises(IndexError):
            quantum_memory_1.operate(X, positions=1)
        with self.assertRaises(IndexError):
            quantum_memory_2.operate(two_qubit_operator, positions=[5, 99])
        # Pop a qubit an test if MemPositionEmptyError is raised
        quantum_memory_2.pop(0)
        with self.assertRaises(MemPositionEmptyError):
            quantum_memory_2.operate(two_qubit_operator, positions=[0, 1])

        # TODO: test 'check_positions'

    def test_operate_noise(self):
        """Test if quantum noise is applied to the qubits before the quantum operation."""
        num_qubits = 8
        threshold_time = 6

        quantum_memory = QuantumMemory('test_memory', num_positions=num_qubits)
        for mem_pos in quantum_memory.mem_positions:
            mem_pos.add_property('threshold_multiplier', value=1)
        noise_model = ThresholdNoiseModel(threshold_time)
        for mem_pos in quantum_memory.mem_positions:
            mem_pos.models["noise_model"] = noise_model

        # measure at time > threshold_time
        for skip_noise, ket_noise in zip([False, True], [
                np.kron(h11, h1),  # with noise: |0> -X-> |1> -H-> |->
                np.kron(h00, h0),  # without noise: |0> -H-> |+>
        ]):
            ns.sim_reset()
            qubits = ns.qubits.create_qubits(num_qubits)
            quantum_memory.put(qubits)
            operate_positions = [0, 3, 7]
            operator = H ^ H ^ H
            self._do_operate_on_delay(quantum_memory, operator, operate_positions,
                                      delay=threshold_time + 1, skip_noise=skip_noise)
            ns.sim_run()
            op_qubits = quantum_memory.pop(operate_positions)
            self.assertAlmostEqual(qapi.fidelity(op_qubits, ket_noise), 1.)

    def test_discard(self):
        """Test the discard function"""
        nq = 2
        quantum_memory = QuantumMemory(name='test_memory',
                                       num_positions=nq)
        q1, q2 = ns.qubits.create_qubits(nq)
        ns.qubits.combine_qubits([q1, q2])
        quantum_memory.put([q1, q2])
        # Check if the discard method also properly removes qubit from combined state.
        self.assertEqual(q1.qstate.num_qubits, 2)
        quantum_memory.discard(0)
        self.assertTrue(quantum_memory.mem_positions[0].is_empty)
        self.assertEqual(q2.qstate.num_qubits, 1)

    def test_measure(self):
        """Test the measure function"""
        num_qubits = 5
        quantum_memory = QuantumMemory(name='test_memory',
                                       num_positions=num_qubits)
        quantum_memory.put(ns.qubits.create_qubits(num_qubits))

        # Test positions: int or list of int or None and if the qubits remain on the memory, unless ``discard`` is True.
        quantum_memory.measure(positions=0)
        self.assertFalse(quantum_memory.mem_positions[0].is_empty)
        self.assertFalse(quantum_memory.mem_positions[0].is_empty)
        self.assertFalse(quantum_memory.mem_positions[1].is_empty)
        # Test meas_operators
        measurements, probabilities = quantum_memory.measure(
            positions=[0, 1], meas_operators=Z.projectors)
        self.assertFalse(quantum_memory.mem_positions[0].is_empty)
        self.assertFalse(quantum_memory.mem_positions[1].is_empty)
        self.assertEqual(measurements, [0, 0])
        self.assertEqual(len(probabilities), 2)
        measurements, probabilities = quantum_memory.measure(positions=None)
        # Test output type
        self.assertEqual(measurements, [0] * num_qubits)
        self.assertIsInstance(probabilities, list)
        for idx in range(num_qubits):
            self.assertIsInstance(measurements[idx], int)
            self.assertIsInstance(probabilities[idx], float)
        self.assertEqual(len(probabilities), num_qubits)
        # Test discarding a qubit and test if MemPositionEmptyError is raised
        self.assertFalse(quantum_memory.mem_positions[0].is_empty)
        self.assertTrue(quantum_memory.mem_positions[0].in_use)
        quantum_memory.measure(positions=0, discard=True)
        self.assertTrue(quantum_memory.mem_positions[0].is_empty)
        self.assertFalse(quantum_memory.mem_positions[0].in_use)
        with self.assertRaises(MemPositionEmptyError):
            quantum_memory.measure(positions=0)
        for index, state in enumerate([b00, b01, b10, b11]):
            qubits = ns.qubits.create_qubits(2)
            assign_qstate(qubits, state)
            quantum_memory.put(qubits, positions=[0, 1])
            res, p = quantum_memory.measure([0, 1], meas_operators=self.bell_measure_operator())
            self.assertEqual(len(res), 1)
            self.assertEqual(res[0], index)
            self.assertAlmostEqual(p[0], 1.0)

        # TODO: test observable

        # TODO: test 'check_positions'

    def test_measure_noise(self):
        """Test if quantum noise is applied to the qubits before measurement."""
        num_qubits = 8
        threshold_time = 6

        quantum_memory = QuantumMemory('test_memory', num_positions=num_qubits)
        for mem_pos in quantum_memory.mem_positions:
            mem_pos.add_property('threshold_multiplier', value=1)
        noise_model = ThresholdNoiseModel(threshold_time)
        for mem_pos in quantum_memory.mem_positions:
            mem_pos.models["noise_model"] = noise_model

        # measure at time > threshold_time
        for skip_noise, ket, mresult in zip([False, True], [s1, s0], [1, 0]):
            ns.sim_reset()
            qubits = ns.qubits.create_qubits(num_qubits)
            quantum_memory.put(qubits)
            operate_positions = [0, 3, 7]
            self._do_measure_on_delay(quantum_memory, operate_positions,
                                      delay=(threshold_time + 1), skip_noise=skip_noise)
            ns.sim_run()
            # We expect to measure |1> starting with |0> and adding X as noise
            self.assertEqual(self.measure_results, [mresult] * len(operate_positions))
            self.assertEqual(self.measure_probs, [1] * len(operate_positions))
            # check state after measurement
            for idx in operate_positions:
                self.assertAlmostEqual(qapi.fidelity(qubits[idx], ket), 1.)

    def test_measure_faulty(self):
        """Test faulty measurement outcomes and probabilities."""
        quantum_memory = QuantumMemory('test_memory', num_positions=2)
        for formalism in qform.QFormalism:
            qform.set_qstate_formalism(formalism)
            quantum_memory.put(qapi.create_qubits(2), [0, 1])
            m, p = quantum_memory.measure_faulty(positions=[0])
            self.assertEqual([0], m)
            self.assertEqual([1], p)
            quantum_memory.operate(ns.X, positions=[0])
            m, p = quantum_memory.measure_faulty(positions=[0])
            self.assertEqual([1], m)
            self.assertEqual([1], p)
            m, p = quantum_memory.measure_faulty(positions=[0], p0=1, p1=1)
            self.assertEqual([0], m)
            self.assertEqual([1], p)
            qform.set_qstate_formalism(formalism)
            m, p = quantum_memory.measure_faulty(positions=[0], p0=0.5, p1=0)
            self.assertEqual([1], p)
            m, p = quantum_memory.measure_faulty(positions=[1], p0=0.5, p1=0)
            self.assertEqual([0.5], p)
            quantum_memory.put(qapi.create_qubits(2), [0, 1])
            quantum_memory.operate(ns.H, [0])
            m, p = quantum_memory.measure_faulty([0], p0=0.5, p1=0.5)
            self.assertEqual([0.5], p)
            qubit = quantum_memory.peek([0])[0]
            if formalism in qform.QFormalism.ensemble_formalisms:
                self.assertTrue(np.allclose(np.eye(2)/2, qapi.reduced_dm(qubit)))
            else:
                fid = qapi.fidelity(qubit, ns.s0)
                self.assertTrue(fid == 0 or fid == 1)

    def test_absorption(self):
        """Test qubit absorption functionality and methods."""
        qmem = QuantumMemory("test_memory", num_positions=3)
        self.assertTrue("qin" in qmem.ports)
        qubits = ns.qubits.create_qubits(3)
        test_meta = {"foo": 4, "bar": 12}
        msg = Message(qubits, **test_meta)
        # Test qubit input via port
        qmem.ports["qin"].tx_input(msg)
        self.assertEqual(qubits, qmem.peek(positions=[0, 1, 2]))
        for pos in range(qmem.num_positions):
            self.assertTrue(test_meta.items() <= qmem.mem_positions[pos].meta.items())
        self.assertEqual(set(qmem.get_matching_qubits("foo", 4)), set([0, 1, 2]))
        # Check setting of positions via meta
        msg2 = Message(qubits, qm_positions=[2, 0, 1], qm_replace=True)
        qmem.ports["qin"].tx_input(msg2)
        self.assertEqual(qubits, qmem.peek(positions=[2, 0, 1]))
        # Should remove qm specific meta
        self.assertTrue("qm_positions" not in qmem.mem_positions[2].meta)
        self.assertTrue("qm_replace" not in qmem.mem_positions[2].meta)
        with self.assertRaises(MemPositionInUseError):
            qmem.ports["qin"].tx_input(Message(ns.qubits.create_qubits(1), qm_replace=False))
        # Test absorption noise
        qmem.add_property('threshold_multiplier', value=1)
        qmem.models["qin_noise_model"] = ThresholdNoiseModel(0)
        qubits = ns.qubits.create_qubits(2)
        msg3 = Message(qubits)
        qmem.ports["qin"].tx_input(msg3)
        self.assertAlmostEqual(qapi.fidelity(qmem.peek(positions=[0, 1]), s11), 1.)

    def test_emission(self):
        """Test qubit output functionality and methods."""
        qmem = QuantumMemory("test_memory", num_positions=3)
        self.assertTrue("qout" in qmem.ports)
        test_meta1 = {"foo": 4, "bar": 12}
        test_meta2 = {"bar": 15, "goo": 6}
        qubits = ns.qubits.create_qubits(3)
        qmem.ports["qin"].tx_input(Message(qubits[:2], qm_positions=[0, 2], **test_meta1))
        qmem.ports["qin"].tx_input(Message(qubits[2], qm_positions=[1], **test_meta2))
        self.assertEqual(qmem.pop(positions=[0, 2, 1]), qubits)
        msg = qmem.ports["qout"].rx_output()
        self.assertEqual(msg.items, qubits)
        # Test meta was merged and in correct direction
        metaa = test_meta1.copy()
        metaa.update(test_meta2)
        self.assertTrue(metaa.items() <= msg.meta.items())
        metab = test_meta2.copy()
        metab.update(test_meta1)
        self.assertFalse(metab.items() <= msg.meta.items())
        # Test additonal meta in pop
        new_meta = {"foo": 66}
        qubits = ns.qubits.create_qubits(2)
        qmem.ports["qin"].tx_input(Message(qubits[:2], qm_positions=[0, 2], **test_meta1))
        self.assertEqual(qmem.pop(positions=[0, 2], meta_data=new_meta), qubits)
        msg = qmem.ports["qout"].rx_output()
        self.assertEqual(msg.items, qubits)
        self.assertEqual(msg.meta["foo"], new_meta["foo"])
        all_new_meta = test_meta1.copy()
        all_new_meta.update(new_meta)
        self.assertTrue(all_new_meta.items() <= msg.meta.items())
        # Test emission noise model
        qmem.add_property('threshold_multiplier', value=1)
        qmem.models["qout_noise_model"] = ThresholdNoiseModel(0)
        qmem.ports["qin"].tx_input(Message(ns.qubits.create_qubits(3), qm_positions=[0, 1, 2]))
        qmem.pop(positions=[0, 1])
        self.assertEqual(qapi.fidelity(qmem.ports["qout"].rx_output().items, s11), 1.)
        self.assertEqual(qapi.fidelity(qmem.peek([2]), s0), 1.)
        # Test with additional noise positions
        qmem.ports["qin"].tx_input(Message(ns.qubits.create_qubits(3), qm_positions=[0, 1, 2]))
        qmem.pop(positions=[0], noise_positions=[2])
        self.assertEqual(qapi.fidelity(qmem.ports["qout"].rx_output().items, s1), 1.)
        self.assertEqual(qapi.fidelity(qmem.peek([1, 2]), s01), 1.)

    def test_separate_emission(self):
        """Test emmision from separate positions."""
        qmem = QuantumMemory("test_memory", num_positions=3)
        self.assertTrue("qout0" in qmem.ports)
        self.assertTrue("qout1" in qmem.ports)
        self.assertTrue("qout2" in qmem.ports)
        test_meta1 = {"foo": 4, "bar": 12}
        test_meta2 = {"bar": 15, "goo": 6}
        qubits = ns.qubits.create_qubits(3)
        qmem.ports["qin"].tx_input(Message(qubits[:2], qm_positions=[0, 2], **test_meta1))
        qmem.ports["qin"].tx_input(Message(qubits[2], qm_positions=[1], **test_meta2))
        self.assertEqual(qmem.pop(positions=[0, 2, 1], positional_qout=True), qubits)
        msg = qmem.ports["qout0"].rx_output()
        self.assertEqual(msg.items, [qubits[0]])
        self.assertTrue(msg.meta.items() >= test_meta1.items())
        msg = qmem.ports["qout1"].rx_output()
        self.assertEqual(msg.items, [qubits[2]])
        self.assertTrue(msg.meta.items() >= test_meta2.items())
        msg = qmem.ports["qout2"].rx_output()
        self.assertEqual(msg.items, [qubits[1]])
        self.assertTrue(msg.meta.items() >= test_meta1.items())
        self.assertIsNone(qmem.ports["qout"].rx_output())
        qmem.ports["qin"].tx_input(Message(qubits[:2], qm_positions=[0, 2], **test_meta1))
        qmem.ports["qin"].tx_input(Message(qubits[2], qm_positions=[1], **test_meta2))
        self.assertEqual(qmem.pop(positions=[0, 2, 1], positional_qout=True, meta_data={"baz": 10}), qubits)
        msg = qmem.ports["qout0"].rx_output()
        self.assertEqual(msg.meta['baz'], 10)
        self.assertEqual(msg.meta['bar'], 12)
        msg = qmem.ports["qout1"].rx_output()
        self.assertEqual(msg.meta['baz'], 10)
        self.assertEqual(msg.meta['bar'], 15)
        msg = qmem.ports["qout2"].rx_output()
        self.assertEqual(msg.meta['baz'], 10)
        self.assertEqual(msg.meta['bar'], 12)

    def test_set_position_used(self):
        """Test manual setting of whether memory position is used."""
        qmem = QuantumMemory("test_memory", num_positions=3)
        qmem.put(ns.qubits.create_qubits(2), [0, 1])
        self.assertFalse(qmem.mem_positions[0].is_empty)
        self.assertFalse(qmem.mem_positions[1].is_empty)
        self.assertTrue(qmem.mem_positions[2].is_empty)
        self.assertTrue(qmem.mem_positions[0].in_use)
        self.assertTrue(qmem.mem_positions[1].in_use)
        self.assertFalse(qmem.mem_positions[2].in_use)
        qmem.mem_positions[0].in_use = False
        qmem.mem_positions[1].in_use = True
        qmem.mem_positions[2].in_use = False
        # Check qubits not removed
        self.assertFalse(qmem.mem_positions[0].is_empty)
        self.assertFalse(qmem.mem_positions[1].is_empty)
        self.assertTrue(qmem.mem_positions[2].is_empty)
        # Check used status changed correctly
        self.assertFalse(qmem.mem_positions[0].in_use)
        self.assertTrue(qmem.mem_positions[1].in_use)
        self.assertFalse(qmem.mem_positions[2].in_use)
        self.assertEqual(qmem.unused_positions, [0, 2])
        # Toggle empty qubit
        self.assertTrue(qmem.mem_positions[2].is_empty)
        self.assertFalse(qmem.mem_positions[2].in_use)
        qmem.mem_positions[2].in_use = True
        self.assertTrue(qmem.mem_positions[2].in_use)

    def test_send_signal(self):
        """Test send_signal method."""
        qmem = QuantumMemory("test_memory")

        def signal_callback(event):
            self.signal_emitted = True

        self.evhandler_signal_emitted = ns.EventHandler(signal_callback)
        helper = pd.Entity()
        # Test if default event type is scheduled.
        self.signal_emitted = False
        helper._wait_once(self.evhandler_signal_emitted, entity=qmem, event_type=qmem.evtype_signal_default)
        qmem.send_signal()
        ns.sim_run()
        self.assertTrue(self.signal_emitted)
        # Test if given event type is scheduled.
        self.signal_emitted = False
        evtype_signal_custom = ns.EventType("SIGNAL_CUSTOM", "A custom signal emitted by the Processor.")
        helper._wait_once(self.evhandler_signal_emitted, entity=qmem, event_type=evtype_signal_custom)
        qmem.send_signal(evtype_signal_custom)
        ns.sim_run()
        self.assertTrue(self.signal_emitted)

    def test_reset(self):
        """Test the reset function"""
        noise_model = DepolarNoiseModel(1000)
        qubit, = ns.qubits.create_qubits(1)
        quantum_memory = QuantumMemory('test_memory', memory_noise_models=noise_model)
        quantum_memory.put(qubit, 0)
        noise_model_before = quantum_memory.mem_positions[0].models['noise_model']
        self.assertFalse(quantum_memory.mem_positions[0].is_empty)
        self.assertTrue(quantum_memory.mem_positions[0].in_use)
        quantum_memory.reset()
        # Memory should be available after reset
        self.assertTrue(quantum_memory.mem_positions[0].is_empty)
        self.assertFalse(quantum_memory.mem_positions[0].in_use)
        # Noise model should be preserved after reset
        noise_model_after = quantum_memory.mem_positions[0].models['noise_model']
        self.assertIsInstance(noise_model_after, QuantumErrorModel)
        self.assertEqual(noise_model_before, noise_model_after)
        # Make sure it is possible to reset while the memory position is busy
        quantum_memory.mem_positions[0].busy = True
        quantum_memory.reset()


class TestMemoryPosition(unittest.TestCase):

    def assertStateIsClose(self, qubit, ket_state_list):
        if not isinstance(ket_state_list, list):
            ket_state_list = list(ket_state_list)
        self.assertIsNotNone(qubit.qstate)
        self.assertTrue(any([np.allclose(qapi.reduced_dm(qubit), ket2dm(ket)) for ket in ket_state_list]))

    def assertMemPosEmpty(self):
        self.assertFalse(self.mempos.in_use)
        self.assertIsNone(self.mempos.get_qubit())
        self.assertFalse(self.mempos.busy)
        self.assertIsNone(self.mempos.meta)

    def assertMemPosContains(self, qubit):
        self.assertTrue(self.mempos.in_use)
        self.assertIs(self.mempos.get_qubit(), qubit)
        self.assertFalse(self.mempos.busy)

    def setUp(self):
        ns.sim_reset()
        qform.set_qstate_formalism(qform.QFormalism.KET)
        self.mempos = MemoryPosition("test_mem")

    def test_init(self):
        self.assertMemPosEmpty()
        self.assertIsNone(self.mempos.time_last_access)

    def test_set_qubit_with_none(self):
        ns.sim_run(duration=1)
        meta = {"testkey": "testval"}
        self.mempos.set_qubit(None, **meta)
        self.assertMemPosEmpty()
        self.assertEqual(self.mempos.time_last_access, 1)

    def test_set_qubit_with_qubit(self):
        qubit = qapi.create_qubits(1)[0]
        meta = {"testkey": "testval"}
        self.mempos.set_qubit(qubit, **meta)
        self.assertMemPosContains(qubit)
        self.assertEqual(self.mempos.time_last_access, 0)
        self.assertEqual(self.mempos.meta, meta)

    def test_remove_qubit(self):
        ns.sim_run(duration=1)
        meta = {"testkey": "testval"}
        qubit = qapi.create_qubits(1)[0]
        self.mempos.set_qubit(qubit, **meta)
        got_qubit = self.mempos.get_qubit(remove=True)
        self.assertMemPosEmpty()
        self.assertIsNone(self.mempos.time_last_access)
        self.assertIs(got_qubit, qubit)

    def test_replace_qubit_with_none(self):
        q1, q2 = qapi.create_qubits(2)
        qapi.assign_qstate([q1, q2], b00)
        meta = {"testkey": "testval"}
        self.mempos.set_qubit(q1, **meta)
        self.mempos.set_qubit(None)
        self.assertMemPosEmpty()
        # Should have resulted in q1 being measured
        self.assertStateIsClose(q2, [s0, s1])
        self.assertEqual(self.mempos.time_last_access, 0)

    def test_replace_qubit_with_other(self):
        q1, q2 = qapi.create_qubits(2)
        qapi.assign_qstate([q1, q2], b00)
        q3 = qapi.create_qubits(1)[0]
        meta = {"testkey": "testval"}
        meta2 = {"testkey2": "testval2"}
        self.mempos.set_qubit(q1, **meta)
        self.mempos.set_qubit(q3, **meta2)
        self.assertMemPosContains(q3)
        # Should have resulted in q1 being measured
        self.assertStateIsClose(q2, [s0, s1])
        self.assertEqual(self.mempos.time_last_access, 0)
        self.assertEqual(self.mempos.meta, meta2)

    def test_replace_qubit_with_bool(self):
        q1, q2 = qapi.create_qubits(2)
        qapi.assign_qstate([q1, q2], b00)
        meta = {"testkey": "testval"}
        self.mempos.set_qubit(q1, **meta)
        with self.assertRaises(TypeError):
            self.mempos.set_qubit(True)
        self.assertMemPosContains(q1)
        self.assertIsNotNone(q2.qstate)
        # Shouldn't have changed the state
        self.assertEqual(q1.qstate, q2.qstate)
        self.assertTrue(np.allclose(qapi.reduced_dm([q1, q2]), ket2dm(b00)))
        self.assertEqual(self.mempos.time_last_access, 0)
        self.assertEqual(self.mempos.meta, meta)

    def test_reset_qubit(self):
        q1, q2 = qapi.create_qubits(2)
        qapi.assign_qstate([q1, q2], b00)
        meta = {"testkey": "testval"}
        self.mempos.set_qubit(q1, **meta)
        self.mempos.reset()
        self.assertMemPosEmpty()
        self.assertStateIsClose(q2, [s0, s1])
        self.assertIsNone(self.mempos.time_last_access)

    def test_skip_noise(self):
        # TODO add this test
        pass

    def test_busy(self):
        """Test the busy flag raises errors correctly."""
        self.mempos.busy = True
        [qubit] = qapi.create_qubits(1)
        for skip_noise, remove in itertools.product([True, False], [True, False]):
            with self.assertRaises(MemPositionBusyError):
                self.mempos.get_qubit(skip_noise=skip_noise, remove=remove)
        with self.assertRaises(MemPositionBusyError):
            self.mempos.set_qubit(qubit)
        # Resetting is allowed when busy
        self.mempos.reset()

    def test_busy_event(self):
        """Test an event is scheduled after the busy flag is toggled."""
        # FIXME this does not test the event is scheduled when processor busy running a program
        self.mempos.busy_event_enabled = True
        event_count = 0

        def count_events(_):
            nonlocal event_count
            event_count += 1
        self.mempos._wait(pd.EventHandler(count_events), self.mempos, self.mempos.evtype_busy_toggled)
        busy_status = [True, False, False, True, True]
        exp_event_count = [1, 2, 2, 3, 3]
        for status, exp_ev_count in zip(busy_status, exp_event_count):
            self.mempos.busy = status
            ns.sim_run()
            self.assertEqual(exp_ev_count, event_count)
        self.mempos.busy = False
        self.mempos.busy = True
        ns.sim_run()
        self.assertEqual(5, event_count)
        self.mempos.busy_event_enabled = False
        self.mempos.busy = False
        self.mempos.busy = True
        ns.sim_run()
        self.assertEqual(5, event_count)
        self.mempos.busy_event_enabled = True
        self.mempos.reset()
        ns.sim_run()
        self.assertEqual(5, event_count)

    def test_in_use_event(self):
        """Test an event is scheduled after the in_use flag is toggled."""
        # FIXME this does not test the event is scheduled when qubits get/set or put/pop
        self.mempos.in_use_event_enabled = True
        event_count = 0

        def count_events(_):
            nonlocal event_count
            event_count += 1
        self.mempos._wait(pd.EventHandler(count_events), self.mempos, self.mempos.evtype_in_use_toggled)
        in_use_status = [True, False, False, True, True]
        exp_event_count = [1, 2, 2, 3, 3]
        for exp_ev_count, status in zip(exp_event_count, in_use_status):
            self.mempos.in_use = status
            ns.sim_run()
            self.assertEqual(exp_ev_count, event_count)
        self.mempos.in_use = False
        self.mempos.in_use = True
        ns.sim_run()
        self.assertEqual(5, event_count)
        self.mempos.in_use_event_enabled = False
        self.mempos.in_use = False
        self.mempos.in_use = True
        ns.sim_run()
        self.assertEqual(5, event_count)
        self.mempos.in_use_event_enabled = True
        self.mempos.reset()
        ns.sim_run()
        self.assertEqual(5, event_count)
        # Test event also scheduled for get/set
        self.mempos.reset()
        self.mempos.in_use_event_enabled = True
        qubit, = ns.qubits.create_qubits(1)
        self.mempos.set_qubit(qubit)
        ns.sim_run()
        self.assertEqual(6, event_count)
        self.mempos.get_qubit(qubit)
        ns.sim_run()
        self.assertEqual(7, event_count)


if __name__ == "__main__":
    unittest.main()
