# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_cqchannel.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the cqhannel module.

"""
import unittest
from netsquid.components.models.qerrormodels import T1T2NoiseModel, FibreLossModel
from netsquid.components.tests.test_cchannel import LossModel, ThresholdFrameNoiseModel
from netsquid.components.cqchannel import CombinedChannel
from netsquid.components.ccoding import ClassicalCodingFactory
from netsquid.qubits import qubitapi as qapi


class FixedLossModel(LossModel):
    """A test loss model. Always or never loses an item.

    """

    def __init__(self, lose_always):
        super().__init__()
        self.properties["lose_always"] = lose_always

    def prob_item_lost(self, item, delta_time, **kwargs):
        return 1 if self.properties["lose_always"] else 0


class TestCombinedChannel(unittest.TestCase):
    """Unit tests for CombinedChannel class.

    """

    def test_init(self):
        c_noise_model = ThresholdFrameNoiseModel(1)
        c_loss_model = FixedLossModel(lose_always=True)
        q_noise_model = T1T2NoiseModel()
        q_loss_model = FibreLossModel()
        length = 10
        c = CombinedChannel(name="TestChannel",
                            models={
                                "classical_noise_model": c_noise_model,
                                "classical_loss_model": c_loss_model,
                                "quantum_noise_model": q_noise_model,
                                "quantum_loss_model": q_loss_model},
                            length=length)
        assert c.models["classical_loss_model"] == c_loss_model
        assert c.models["classical_noise_model"] == c_noise_model
        assert c.models["quantum_noise_model"] == q_noise_model
        assert c.models["quantum_loss_model"] == q_loss_model
        assert c.properties["length"] == length

    def test_preprocess_inputs(self):
        c_loss_model_always = FixedLossModel(lose_always=True)
        c_loss_model_never = FixedLossModel(lose_always=False)
        q_loss_model_always = FibreLossModel(p_loss_init=1, p_loss_length=0)
        q_loss_model_never = FibreLossModel(p_loss_init=0, p_loss_length=0)
        classical_msg = "test"
        qubit_msg = qapi.create_qubits(1)
        combo_message = [(classical_msg, qubit_msg)]
        # Test never losing information
        c = CombinedChannel(name="TestChannel", models={"classical_loss_model": c_loss_model_never,
                                                        "quantum_loss_model": q_loss_model_never})
        items = c.preprocess_inputs(delay=0, items=combo_message)
        new_combo_message = c.postprocess_outputs(delta_time=0, items=items)
        assert new_combo_message == combo_message
        # Test losing just quantum information
        c = CombinedChannel(name="TestChannel", models={"classical_loss_model": c_loss_model_never,
                                                        "quantum_loss_model": q_loss_model_always})
        items = c.preprocess_inputs(delay=0, items=combo_message)
        new_combo_message = c.postprocess_outputs(delta_time=0, items=items)
        assert new_combo_message == [(classical_msg, [])]
        # Test losing just classical information
        qubit_msg = qapi.create_qubits(1)  # Reset qubit_msg since loss models removed the qubit in the test above.
        combo_message = [(classical_msg, qubit_msg)]
        c = CombinedChannel(name="TestChannel", models={"classical_loss_model": c_loss_model_always,
                                                        "quantum_loss_model": q_loss_model_never},
                            classical_code=ClassicalCodingFactory())
        items = c.preprocess_inputs(delay=0, items=combo_message)
        new_combo_message = c.postprocess_outputs(delta_time=0, items=items)
        assert new_combo_message == [(None, qubit_msg)]
        # Test losing all information
        c = CombinedChannel(name="TestChannel", models={"classical_loss_model": c_loss_model_always,
                                                        "quantum_loss_model": q_loss_model_always},
                            classical_code=ClassicalCodingFactory())
        items = c.preprocess_inputs(delay=0, items=combo_message)
        new_combo_message = c.postprocess_outputs(delta_time=0, items=items)
        assert new_combo_message == [(None, [])]

    def test_send_receive(self):
        # Test various classical constructs and putting methods
        cmsg_set = ["Test", [1, 2, 3], 1024, {"key": "val"}]
        qubit_set = [qapi.create_qubits(n) for n in [2, 3, 4, 5]]
        c = CombinedChannel(name="TestChannel")
        # Test sending separately
        assert c.output_empty
        c.send([cmsg_set[0], qubit_set[0]], header=0)
        items, __ = c.peek(postprocess=True)
        assert cmsg_set[0] in items[0]
        assert qubit_set[0] in items[0]
        assert not c.output_empty
        c.send([cmsg_set[1], qubit_set[1]], header=1)
        items, __ = c.peek(header=1, postprocess=True)
        assert cmsg_set[1] in items[0]
        assert qubit_set[1] in items[0]
        assert not c.output_empty
        combo_message, deltaT = c.receive(header=0)
        assert combo_message == [(cmsg_set[0], qubit_set[0])]
        assert not c.output_empty
        combo_message, deltaT = c.receive(header=1)
        assert combo_message == [(cmsg_set[1], qubit_set[1])]
        assert c.output_empty
        # Test appending
        c.send([cmsg_set[2], qubit_set[2]], append=False)
        c.send([cmsg_set[3], qubit_set[3]], append=True)
        assert not c.output_empty
        items, __ = c.peek(postprocess=True)
        assert cmsg_set[2] in items[0]
        assert qubit_set[2] in items[0]
        assert cmsg_set[3] in items[1]
        assert qubit_set[3] in items[1]
        combo_message, deltaT = c.receive()
        assert combo_message == [(cmsg_set[2], qubit_set[2]), (cmsg_set[3], qubit_set[3])]
        assert c.output_empty


if __name__ == "__main__":
    unittest.main()
