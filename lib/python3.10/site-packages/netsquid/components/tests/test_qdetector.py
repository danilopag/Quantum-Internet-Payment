# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_qdetector.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for quantum detectors in the qdetector module.

"""
import unittest
import netsquid as ns
from netsquid.qubits import qubitapi as qapi
from netsquid.qubits.ketstates import BellIndex
from netsquid.components.component import Message
from netsquid.components import IMeasureBell, QuantumErrorModel, ClassicalErrorModel, Clock
from netsquid.components.qdetector import QuantumDetector, GatedQuantumDetector, QuantumDetectorError

__all__ = [
    'TestQDetector',
    'TestGatedQDetector'
]


class MockDetector(QuantumDetector):

    def measure(self):
        pass

    def finish(self):
        pass


class TestQDetector(unittest.TestCase):
    """Unit tests for the QuantumDetector module.

    """

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        ns.sim_reset()
        ns.set_random_state(seed=42)
        self.output_messages = []

    def _msg_helper(self, message):
        # Used to bind on port in order to capture messages
        self.output_messages.append(message)

    def tearDown(self):
        ns.sim_stop()

    def test_mock_detector(self):
        """Test detector still functions without any control logic in measure or finish."""
        qdetector = MockDetector('mockdetector', system_delay=2, dead_time=3)
        for _ in range(3):
            assert not qdetector.is_triggered
            assert not qdetector.in_dead_time
            qdetector.ports['qin0'].tx_input(qapi.create_qubits(1))
            ns.sim_run(duration=1)
            assert qdetector.is_triggered
            assert not qdetector.in_dead_time
            ns.sim_run(duration=2)
            assert not qdetector.is_triggered
            assert qdetector.in_dead_time
            ns.sim_run(duration=2)

    def test_port_creation(self):
        """Test if ports are created correctly."""
        num_input_ports = 2
        total_num_ports = num_input_ports + 1
        test_detector = QuantumDetector('test', num_input_ports=num_input_ports,
                                        error_on_fail=True)
        self.assertEqual(len(test_detector.ports), total_num_ports)
        for port_name in [f"qin{idx}" for idx in range(num_input_ports)]:
            self.assertTrue(port_name in test_detector.ports)

    def test_multiple_qubits_per_port(self):
        """Test Qubits are stored or discarded."""
        test_detector = QuantumDetector('test', num_input_ports=2, system_delay=2)
        test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
        q1, q2 = qapi.create_qubits(2)
        test_detector.ports['qin0'].tx_input(Message([q1]))
        ns.sim_run(duration=3)
        self.assertEqual(1, len(self.output_messages))
        self.assertEqual(1, len(self.output_messages[0].items))
        self.assertIsNone(q1.qstate)
        self.assertIsNotNone(q2.qstate)
        test_detector.ports['qin0'].tx_input(Message([q2]))
        ns.sim_run(duration=3)
        self.assertEqual(2, len(self.output_messages))
        self.assertEqual(1, len(self.output_messages[1].items))
        self.assertIsNone(q1.qstate)
        self.assertIsNone(q2.qstate)
        q3, q4 = qapi.create_qubits(2)
        test_detector.ports['qin1'].tx_input(Message([q3, q4]))
        ns.sim_run(duration=3)
        self.assertEqual(3, len(self.output_messages))
        self.assertEqual(2, len(self.output_messages[2].items))
        self.assertIsNone(q3.qstate)
        self.assertIsNone(q4.qstate)

    def test_incorrect_messages(self):
        """Test an error is raised when non-qubits are entered into the port."""
        test_detector = QuantumDetector('test')
        with self.assertRaises(ValueError):
            test_detector.ports['qin0'].tx_input(Message(["Not a Qubit"]))

    def test_invalid_operators(self):
        """Test an error is raised when invalid operators or observables are provided."""
        with self.assertRaises(TypeError):
            QuantumDetector('failing_detector', observable=True)
        with self.assertRaises(TypeError):
            QuantumDetector('failing_detector', meas_operators=[True, True])
        with self.assertRaises(TypeError):
            QuantumDetector('failing_detector', meas_operators=True)
        with self.assertRaises(TypeError):
            QuantumDetector('failing_detector', meas_operators=1)

    def test_detection(self):
        """Test the detector's continuous detection functionality."""
        q1, q2 = qapi.create_qubits(2)
        test_detector = QuantumDetector('test', num_input_ports=1, error_on_fail=True)
        test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
        test_detector.ports['qin0'].tx_input(Message([q1]))
        ns.sim_run()
        self.assertEqual(1, len(self.output_messages))
        self.assertEqual([0], self.output_messages[0].items)
        test_detector.ports['qin0'].tx_input(Message([q2]))
        ns.sim_run()
        self.assertEqual(2, len(self.output_messages))
        self.assertEqual([0], self.output_messages[1].items)

    def test_error_failure(self):
        """Test raising errors doesn't break the detector."""
        ns.set_random_state(seed=52)
        test_detector = QuantumDetector("test", num_input_ports=3, error_on_fail=True, meas_operators=IMeasureBell()._meas_operators)
        test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
        q1 = qapi.create_qubits(1)[0]
        test_detector.ports['qin0'].tx_input(Message([q1]))
        with self.assertRaises(QuantumDetectorError):
            ns.sim_run()
        self.assertEqual(0, len(self.output_messages))
        self.assertFalse(test_detector.is_triggered)
        self.assertFalse(test_detector.in_dead_time)
        self.assertIsNone(q1.qstate)
        ns.sim_reset()
        test_detector = QuantumDetector("test", num_input_ports=3, error_on_fail=True, meas_operators=IMeasureBell()._meas_operators)
        test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
        q2, q3 = qapi.create_qubits(2)
        test_detector.ports['qin0'].tx_input(Message([q2]))
        test_detector.ports['qin1'].tx_input(Message([q3]))
        ns.sim_run()
        self.assertEqual(1, len(self.output_messages))
        self.assertEqual([ns.BellIndex.B10], self.output_messages[0].items)
        self.assertFalse(test_detector.is_triggered)
        self.assertFalse(test_detector.in_dead_time)
        self.assertIsNone(q2.qstate)
        self.assertIsNone(q3.qstate)
        q4, q5, q6 = qapi.create_qubits(3)
        test_detector.ports['qin0'].tx_input(Message([q4]))
        test_detector.ports['qin1'].tx_input(Message([q5]))
        test_detector.ports['qin2'].tx_input(Message([q6]))
        with self.assertRaises(QuantumDetectorError):
            ns.sim_run()
        self.assertEqual(1, len(self.output_messages))
        self.assertFalse(test_detector.is_triggered)
        self.assertFalse(test_detector.in_dead_time)
        self.assertIsNone(q4.qstate)
        self.assertIsNone(q5.qstate)
        self.assertIsNone(q6.qstate)

    def test_noise(self):
        """Test noise models are applied correctly."""
        test_detector_0 = QuantumDetector("test", num_output_ports=2, models={'qin0_noise_model': QFlipErrorModel()})
        test_detector_1 = QuantumDetector("test", num_output_ports=2)
        test_detector_1.set_input_models(QFlipErrorModel())
        test_detector_2 = QuantumDetector("test", num_output_ports=2)
        test_detector_2.set_input_models([QFlipErrorModel()])
        for test_detector in [test_detector_0, test_detector_1, test_detector_2]:
            self.output_messages = []
            q1, q2 = qapi.create_qubits(2)
            test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
            test_detector.ports['cout1'].bind_output_handler(self._msg_helper)
            test_detector.ports['qin0'].tx_input(Message([q1]))
            ns.sim_run()
            self.assertEqual(2, len(self.output_messages))
            self.assertEqual(1, self.output_messages[0].items[0])
            self.assertEqual(1, self.output_messages[1].items[0])
            test_detector.models['qin0_noise_model'] = None
            test_detector.models['cout0_noise_model'] = CAddErrorModel()
            test_detector.ports['qin0'].tx_input(Message([q2]))
            ns.sim_run()
            self.assertEqual(4, len(self.output_messages))
            self.assertEqual(10, self.output_messages[2].items[0])
            self.assertEqual(0, self.output_messages[3].items[0])

    def test_instant_arrival_observable(self):
        """Test two qubits which arrive at the same time can still be measured together."""
        test_detector = QuantumDetector("test", num_input_ports=2)
        test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
        q1, q2 = qapi.create_qubits(2)
        test_detector.ports['qin0'].tx_input(Message([q1]))
        test_detector.ports['qin1'].tx_input(Message([q2]))
        ns.sim_run()
        self.assertEqual(1, len(self.output_messages))
        self.assertEqual([0, 0], self.output_messages[0].items)

    def test_instant_arrival_measurement(self):
        """Test two qubits which arrive at the same time can still be measured together."""
        meas_ops = IMeasureBell()._meas_operators
        test_detector = QuantumDetector("test", num_input_ports=2, meas_operators=meas_ops)
        test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
        q1, q2 = qapi.create_qubits(2)
        test_detector.ports['qin0'].tx_input(Message([q1]))
        test_detector.ports['qin1'].tx_input(Message([q2]))
        ns.sim_run()
        self.assertEqual(1, len(self.output_messages))
        self.assertEqual([BellIndex.B00], self.output_messages[0].items)

    def test_delayed_measurement(self):
        """Test two qubits that arrive at different times can still be measured together."""
        meas_ops = IMeasureBell()._meas_operators
        test_detector = QuantumDetector("test", num_input_ports=1, meas_operators=meas_ops, system_delay=15)
        test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
        q1, q2 = qapi.create_qubits(2)
        test_detector.ports['qin0'].tx_input(Message([q1]))
        ns.sim_run(11)
        test_detector.ports['qin0'].tx_input(Message([q2]))
        ns.sim_run()
        self.assertEqual(1, len(self.output_messages))
        self.assertEqual([BellIndex.B00], self.output_messages[0].items)

    def test_dual_qubit_observation(self):
        """Test qubits which arrive in the same message can be measured together."""
        test_detector = QuantumDetector("test", num_input_ports=1, observable=ns.Z)
        test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
        qubits = qapi.create_qubits(3)
        test_detector.ports['qin0'].tx_input(Message(qubits))
        ns.sim_run()
        self.assertEqual(1, len(self.output_messages))
        self.assertEqual(3, len(self.output_messages[0].items))

    def test_qubit_ordering(self):
        """Test in which order qubits are measured."""
        test_detector = QuantumDetector("test", num_input_ports=2)
        test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
        qubits = qapi.create_qubits(2)
        qapi.operate(qubits[0], ns.X)
        test_detector.ports['qin0'].tx_input(Message(qubits))
        ns.sim_run()
        self.assertEqual(1, len(self.output_messages))
        self.assertEqual([1, 0], self.output_messages[0].items)
        qubits = qapi.create_qubits(2)
        qapi.operate(qubits[0], ns.X)
        test_detector.ports['qin1'].tx_input(Message(qubits))
        ns.sim_run()
        self.assertEqual(2, len(self.output_messages))
        self.assertEqual([1, 0], self.output_messages[1].items)
        qubits = qapi.create_qubits(2)
        qapi.operate(qubits[0], ns.X)
        test_detector.ports['qin1'].tx_input(Message(qubits[0]))
        test_detector.ports['qin0'].tx_input(Message(qubits[1]))
        ns.sim_run()
        self.assertEqual(3, len(self.output_messages))
        self.assertEqual([0, 1], self.output_messages[2].items)

    def test_no_deadtime(self):
        """Test qubits can be measured exactly after the deadtime"""
        test_detector = QuantumDetector("test", num_input_ports=1, observable=ns.Z)
        test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
        q1, q2 = qapi.create_qubits(2)
        test_detector.ports['qin0'].tx_input(Message([q1]))
        ns.sim_run()
        self.assertEqual(0.0, ns.sim_time())
        test_detector.ports['qin0'].tx_input(Message([q2]))
        ns.sim_run()
        self.assertEqual(2, len(self.output_messages))
        self.assertEqual([0], self.output_messages[0].items)
        self.assertEqual([0], self.output_messages[1].items)

    def test_deadtime(self):
        """Test qubits can't be measured during the deadtime"""
        test_detector = QuantumDetector("test", num_input_ports=1, observable=ns.Z, dead_time=1)
        test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
        q1, q2, q3 = qapi.create_qubits(3)
        test_detector.ports['qin0'].tx_input(Message([q1]))
        ns.sim_run(0.0)
        self.assertEqual(0.0, ns.sim_time())
        test_detector.ports['qin0'].tx_input(Message([q2]))
        ns.sim_run()
        self.assertEqual(1, len(self.output_messages))
        self.assertEqual([0, 0], self.output_messages[0].items)
        self.assertEqual(1.0, ns.sim_time())
        test_detector.ports['qin0'].tx_input(Message([q3]))
        ns.sim_run()
        self.assertEqual(2, len(self.output_messages))
        self.assertEqual([0], self.output_messages[1].items)


class TestGatedQDetector(TestQDetector):

    def test_trigger(self):
        """Test if a trigger enables the detector"""
        test_detector = GatedQuantumDetector("test", 10)
        test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
        clock = Clock('external_clock', frequency=10)
        clock.ports['cout'].connect(test_detector.ports['gate_trigger'])
        clock.start()
        ns.sim_run(1e9 + 1)
        self.assertEqual(0, len(self.output_messages))
        for _ in range(10):
            qubit = qapi.create_qubits(1)
            test_detector.ports['qin0'].tx_input(Message(qubit))
            ns.sim_run(duration=1e8)
        self.assertEqual(10, len(self.output_messages))
        for msg in self.output_messages:
            self.assertEqual([0], msg.items)

    def test_time_window(self):
        """Test if qubits aren't measured when outside the time window"""
        test_detector = GatedQuantumDetector('test', detection_window=10, num_input_ports=2)
        test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
        clock = Clock('external_clock', frequency=10)
        clock.ports['cout'].connect(test_detector.ports['gate_trigger'])
        clock.start()
        q1, q2 = qapi.create_qubits(2)
        # We need to get a trigger before we can start measuring
        ns.sim_run(1)
        test_detector.ports['qin0'].tx_input(Message([q1]))
        test_detector.ports['qin1'].tx_input(Message([q2]))
        ns.sim_run(11)
        self.assertEqual(1, len(self.output_messages))
        self.assertEqual([0, 0], self.output_messages[0].items)
        # Time window is now over
        q3, q4 = qapi.create_qubits(2)
        test_detector.ports['qin0'].tx_input(Message([q3]))
        test_detector.ports['qin1'].tx_input(Message([q4]))
        ns.sim_run(1e8 + 1)
        self.assertEqual(1, len(self.output_messages))
        q5, q6 = qapi.create_qubits(2)
        test_detector.ports['qin0'].tx_input(Message([q5]))
        test_detector.ports['qin1'].tx_input(Message([q6]))
        ns.sim_run(2e8)
        self.assertEqual(2, len(self.output_messages))
        self.assertEqual([0, 0], self.output_messages[1].items)

    def test_forced_measurement(self):
        """Test a measurement is executed at the end of the time window."""
        test_detector = GatedQuantumDetector('test', 10, system_delay=20)
        test_detector.ports['cout0'].bind_output_handler(self._msg_helper)
        q1, q2 = qapi.create_qubits(2)
        test_detector.ports['gate_trigger'].tx_input(Message(['go']))
        test_detector.ports['qin0'].tx_input(Message([q1]))
        ns.sim_run(duration=15)
        # The time window should have closed even though the measurement delay is longer
        self.assertEqual(1, len(self.output_messages))
        test_detector.ports['qin0'].tx_input(Message([q2]))
        ns.sim_run()
        self.assertEqual(1, len(self.output_messages))

    def test_empty_time_window(self):
        """Test the detector works when nothing has arrived during the time window."""
        test_detector = GatedQuantumDetector('test', 10, system_delay=20)
        test_detector.ports['gate_trigger'].tx_input(Message(['go']))
        ns.sim_run()


class QFlipErrorModel(QuantumErrorModel):

    def error_operation(self, qubits, delta_time=0, **kwargs):
        for qubit in qubits:
            qapi.operate(qubit, ns.X)


class CAddErrorModel(ClassicalErrorModel):

    def error_operation(self, items, delta_time=0, **kwargs):
        for idx, item in enumerate(items):
            items[idx] = item + 10


if __name__ == "__main__":
    unittest.main()
