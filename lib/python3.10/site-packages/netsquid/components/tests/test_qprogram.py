# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_qprogram.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the qprogram module.

"""
import unittest
import types

from netsquid.components.qprogram import QuantumProgram
from netsquid.components.instructions import (
    INSTR_X, INSTR_Z, INSTR_H, INSTR_CNOT, INSTR_SWAP, INSTR_MEASURE, INSTR_SIGNAL)


class CustomQProgA(QuantumProgram):
    """A program that applies a sequence of gates."""
    default_num_qubits = 1

    def program(self):
        q1 = self.get_qubit_indices(1)
        self.apply(INSTR_H, q1)
        self.apply(INSTR_Z, q1)
        self.output["A"] = 1
        yield self.run()


class CustomQProgB(QuantumProgram):
    """A program that applies a sequence of gates."""
    default_num_qubits = 2

    def program(self):
        q1, q2 = self.get_qubit_indices(2)
        self.apply(INSTR_CNOT, [q1, q2])
        self.apply(INSTR_SWAP, [q1, q2])
        self.apply(INSTR_MEASURE, q1, output_key="m1")
        self.apply(INSTR_MEASURE, q2, output_key="m2")
        self.output["B"] = 1
        yield self.run()


class DoubleSequenceProgram(QuantumProgram):
    """A program that contains two sequences."""
    default_num_qubits = 2

    def program(self):
        q1, q2 = self.get_qubit_indices(2)
        self.apply(INSTR_MEASURE, q1, output_key="m1")
        self.apply(INSTR_X, q1)
        self.apply(INSTR_CNOT, [q1, q2])
        self.first_sequence = True  # Used by test
        yield self.run()
        self.apply(INSTR_MEASURE, q1, output_key="m1")
        self.apply(INSTR_MEASURE, q2, output_key="m2")
        self.second_sequence = True  # Used by test
        yield self.run()


class MeasureProgram(QuantumProgram):
    """A program to be loaded in that measures a qubit."""
    default_num_qubits = -1

    def program(self):
        key = "LoadedProgramCount"
        if key in self.output:
            self.output[key] += 1
        else:
            self.output[key] = 1
        # Measure the qubit specified in the output state
        q = self.output["qubit_index"]
        self.apply(INSTR_MEASURE, q, output_key="m{}".format(q + 1))
        yield self.run()


class LoadingProgram(QuantumProgram):
    """A program that loads another program."""
    default_num_qubits = 2

    def program(self):
        for i in range(2):
            self.output["LoadingProgram"] = 1
            self.apply(INSTR_X, [i])
            yield self.run()
            self.output["qubit_index"] = i
            # Load in as class
            yield from self.load(MeasureProgram)


class NestingProgram(QuantumProgram):
    """A program that loads a program that loads a program."""
    default_num_qubits = 2

    def program(self):
        self.output["NestingProgram"] = 1
        # Load in as instance
        loading_prog = LoadingProgram()
        yield from self.load(loading_prog)
        self.apply(INSTR_X, [0])
        yield self.run()


class ParamProgram(QuantumProgram):

    def program(self, a, b=1):
        self.output["a"] = a
        self.output["b"] = b
        yield self.run()


class TestQProgram(unittest.TestCase):
    """Unit tests for the qprogram module."""

    # TODO test rerunning of the same program (as also done in test_qprocessor)

    def iterate_program(self, program):
        # Run through program as a generator
        prog_instrs = []
        for apply_list, __, __ in program():
            prog_instrs.extend(apply_list)
        return prog_instrs

    def setUp(self):
        self.qProgA = QuantumProgram()
        q1 = self.qProgA.get_qubit_indices(1)
        self.qProgA.apply(INSTR_H, q1)
        self.qProgA.apply(INSTR_Z, q1)
        self.qProgB = QuantumProgram()
        q1, q2 = self.qProgB.get_qubit_indices(2)
        self.qProgB.apply(INSTR_CNOT, [q1, q2])
        self.qProgB.apply(INSTR_SWAP, [q1, q2])
        self.qProgB.apply(INSTR_MEASURE, q1, output_key="m1")
        self.qProgB.apply(INSTR_MEASURE, q2, output_key="m2")

    def test_init(self):
        """Test initialization."""
        # Test num_qubits
        qprog = QuantumProgram()
        self.assertEqual(qprog.default_num_qubits, -1)
        self.assertEqual(qprog.num_qubits, -1)
        qprog = QuantumProgram(num_qubits=3)
        self.assertEqual(qprog.num_qubits, 3)
        # Test if default behaviour is to run in parallel.
        self.assertTrue(qprog.parallel)
        # Test type of 'output'
        self.assertIsInstance(qprog.output, dict)

    def test_get_qubit_indices(self):
        """Test get_qubit_indices method."""
        qprog = QuantumProgram()
        indices = qprog.get_qubit_indices(2)
        self.assertEqual(indices, [0, 1])
        with self.assertRaises(ValueError):
            qprog.get_qubit_indices()
        qprog = QuantumProgram(num_qubits=3)
        indices = qprog.get_qubit_indices()
        self.assertEqual(indices, [0, 1, 2])
        indices = qprog.get_qubit_indices(2)
        self.assertEqual(indices, [0, 1])
        with self.assertRaises(ValueError):
            qprog.get_qubit_indices(4)

    def test_apply_and_run(self):
        """Test apply() and run() methods."""
        qprog = QuantumProgram()
        q1, = qprog.get_qubit_indices(1)
        qprog.apply(INSTR_X, q1)
        qprog.apply(INSTR_MEASURE, q1, output_key="m1", physical=False)
        qprog.apply(INSTR_SIGNAL, physical=False)
        apply_list, parallel, lazy = qprog.run(parallel=False)
        self.assertFalse(parallel)
        self.assertFalse(lazy)
        self.assertEqual(apply_list[0].instruction, INSTR_X)
        self.assertEqual(apply_list[1].instruction, INSTR_MEASURE)
        self.assertEqual(apply_list[2].instruction, INSTR_SIGNAL)
        self.assertEqual(apply_list[0].qubit_indices, [q1])
        self.assertEqual(apply_list[1].qubit_indices, [q1])
        self.assertEqual(apply_list[2].qubit_indices, [])
        self.assertTrue(apply_list[0].physical)
        self.assertFalse(apply_list[1].physical)
        # TODO: can we check if correct callback function is returned? (function QuantumProgram.apply.<locals>.callback)

    def test_generator(self):
        """Test calling a program returns a generator."""
        qprog = QuantumProgram()
        q1, = qprog.get_qubit_indices(1)
        qprog.apply(INSTR_X, q1)
        qprog.apply(INSTR_SIGNAL)
        self.assertIsInstance(qprog(), types.GeneratorType)
        apply_list, parallel, lazy = next(qprog())
        self.assertTrue(parallel)
        self.assertFalse(lazy)
        self.assertEqual(apply_list[0].instruction, INSTR_X)
        self.assertEqual(apply_list[0].qubit_indices, [q1])
        self.assertEqual(apply_list[1].instruction, INSTR_SIGNAL)
        self.assertEqual(apply_list[1].qubit_indices, [])
        qprog = DoubleSequenceProgram()
        instrs = [pi.instruction for pi in self.iterate_program(qprog)]
        self.assertEqual(instrs, [INSTR_MEASURE, INSTR_X, INSTR_CNOT, INSTR_MEASURE, INSTR_MEASURE])

    def test_program_loading(self):
        """Test loading of programs within programs."""
        qprog = NestingProgram()
        instrs = [pi.instruction for pi in self.iterate_program(qprog)]
        self.assertEqual(instrs, [INSTR_X, INSTR_MEASURE, INSTR_X, INSTR_MEASURE, INSTR_X])
        indices = [pi.qubit_indices[0] for pi in self.iterate_program(qprog)]
        self.assertEqual(indices, [0, 0, 1, 1, 0])
        self.assertEqual(qprog.output["LoadedProgramCount"], 2)
        self.assertTrue("LoadingProgram" in qprog.output)
        self.assertTrue("NestingProgram" in qprog.output)
        # TODO check error if num qubits mismatch

    def test_program_concatenation(self):
        """Test concatenating programs."""
        # Set up program instances from the base class;
        # These match the subclasses CustomQProgA and CustomQProgB
        # Test different combinations of program instances and classes
        # from base class and subclasses
        for prog1, prog2 in [
            (self.qProgA, self.qProgB),
            (self.qProgA, CustomQProgB()),
            (self.qProgA, CustomQProgB),
            (CustomQProgA(), self.qProgB),
            (CustomQProgA(), CustomQProgB()),
            (CustomQProgA(), CustomQProgB),
            (CustomQProgA, self.qProgB),
            (CustomQProgA, CustomQProgB())
        ]:
            # If possible, set some custom state
            if isinstance(prog1, QuantumProgram):
                prog1.output["foo"] = 1
            if isinstance(prog2, QuantumProgram):
                prog2.output["bar"] = 1
            prog3 = prog1 + prog2
            instrs = [pi.instruction for pi in self.iterate_program(prog3)]
            self.assertEqual(instrs, [INSTR_H, INSTR_Z, INSTR_CNOT,
                                      INSTR_SWAP, INSTR_MEASURE, INSTR_MEASURE])
            self.assertNotIn("foo", prog3.output)
            self.assertNotIn("bar", prog3.output)
            # Check output is modified in custom programs
            if isinstance(prog1, CustomQProgA):
                self.assertIn("A", prog3.output)
            if isinstance(prog2, CustomQProgB):
                self.assertIn("B", prog3.output)
            # Check existing output is not copied for non-custom programs
            if isinstance(prog1, QuantumProgram):
                self.assertLessEqual(prog1.num_qubits, prog3.num_qubits)
                self.assertNotEqual(prog3.output, prog1.output)
                self.assertIn("foo", prog1.output)
                self.assertNotIn("bar", prog1.output)
            if isinstance(prog2, QuantumProgram):
                self.assertLessEqual(prog2.num_qubits, prog3.num_qubits)
                self.assertIn("bar", prog2.output)
                self.assertNotIn("foo", prog2.output)
                self.assertNotEqual(prog3.output, prog2.output)
            # Test if the program can be repeated
            self.assertEqual(len(self.iterate_program(prog3)), len(instrs))

    def test_program_multiplication(self):
        """Test multiplying of programs."""
        n = 3
        for prog1 in [self.qProgA, CustomQProgA()]:
            with self.assertRaises(TypeError):
                prog2 = prog1 * prog1
            with self.assertRaises(TypeError):
                prog2 = prog1 * 5.0
            with self.assertRaises(ValueError):
                prog2 = prog1 * 0
            prog2 = prog1 * n
            self.assertEqual(prog2.num_qubits, prog1.num_qubits)
            instrs = [pi.instruction for pi in self.iterate_program(prog2)]
            self.assertEqual(instrs, [INSTR_H, INSTR_Z, INSTR_H, INSTR_Z, INSTR_H, INSTR_Z])
            self.assertEqual(len(self.iterate_program(prog2)), len(instrs))
            prog2 = n * prog1
            instrs = [pi.instruction for pi in self.iterate_program(prog2)]
            self.assertEqual(instrs, [INSTR_H, INSTR_Z, INSTR_H, INSTR_Z, INSTR_H, INSTR_Z])
            self.assertEqual(len(self.iterate_program(prog2)), len(instrs))

        #
        # Check output state is shared

        class TestQProg(QuantumProgram):
            def program(self):
                q1 = self.get_qubit_indices(1)
                self.apply(INSTR_Z, q1)
                if "test" in self.output:
                    self.output["test"] += 1
                else:
                    self.output["test"] = 1
                yield self.run()

        n = 8
        prog = TestQProg()
        prog2 = prog * n
        instrs = [pi.instruction for pi in self.iterate_program(prog2)]
        self.assertEqual(instrs, [INSTR_Z] * n)
        self.assertTrue("test" in prog2.output)
        self.assertEqual(prog2.output["test"], n)

    def test_program_params(self):
        """Test adding program parameters"""
        prog = ParamProgram()
        prog2 = QuantumProgram()
        # You should call the program with the correct arguments
        with self.assertRaises(TypeError):
            prog()
        with self.assertRaises(TypeError):
            prog(c=9)
        with self.assertRaises(TypeError):
            next(prog2(a=1))

        next(prog(a=4))
        self.assertEqual(prog.output["a"], 4)
        self.assertEqual(prog.output["b"], 1)
        next(prog.program(a=3, b=2))
        self.assertEqual(prog.output["a"], 3)
        self.assertEqual(prog.output["b"], 2)

    def test_qubit_mapping_program(self):
        """Test qubit mapping of programs"""
        qprog = QuantumProgram(qubit_mapping=[1, 2, 0])
        indices = qprog.get_qubit_indices()
        self.assertEqual(indices, [1, 2, 0])
        qprog.apply(INSTR_X, indices[0])
        qprog.apply(INSTR_MEASURE, indices[1], output_key="m1", physical=False)
        apply_list, parallel, __ = qprog.run(parallel=False)
        self.assertFalse(parallel)
        self.assertEqual(apply_list[0].instruction, INSTR_X)
        self.assertEqual(apply_list[1].instruction, INSTR_MEASURE)
        self.assertEqual(apply_list[0].qubit_indices, [1])
        self.assertEqual(apply_list[1].qubit_indices, [2])
        self.assertEqual(qprog.get_qubit_indices(2), [1, 2])

        with self.assertRaises(ValueError):
            QuantumProgram(qubit_mapping=[0, 0])

    def test_concat_program_qubit_mapping(self):
        """Test for concatenating 2 programs with qubit_mappings"""
        p1 = CustomQProgA(qubit_mapping=[3, 6])
        p2 = CustomQProgB(qubit_mapping=[2, 5, 3])
        self.assertEqual((p1 + p2).num_qubits, 4)
        instrs = [pi for pi in self.iterate_program(p1 + p2)]
        self.assertListEqual([instr.instruction for instr in instrs],
                             [INSTR_H, INSTR_Z, INSTR_CNOT, INSTR_SWAP, INSTR_MEASURE, INSTR_MEASURE])
        self.assertListEqual([instr.qubit_indices for instr in instrs],
                             [[3], [3], [2, 5], [2, 5], [2], [5]])

    def test_concat_Program_mixed_mapping(self):
        """Test for concatenating programs where one has a qubit mapping and the other doesnt"""
        p1 = CustomQProgA()
        p2 = CustomQProgB(qubit_mapping=[5, 10])
        p_sum = p1 + p2
        self.assertEqual(p_sum.num_qubits, 3)
        instrs = [pi for pi in self.iterate_program(p1 + p2)]
        self.assertListEqual([instr.instruction for instr in instrs],
                             [INSTR_H, INSTR_Z, INSTR_CNOT, INSTR_SWAP, INSTR_MEASURE, INSTR_MEASURE])
        self.assertListEqual([instr.qubit_indices for instr in instrs],
                             [[0], [0], [5, 10], [5, 10], [5], [10]])

        p3 = MeasureProgram()
        p_sum2 = p3 + p2
        self.assertEqual(p_sum2.num_qubits, 2)


if __name__ == "__main__":
    unittest.main()
