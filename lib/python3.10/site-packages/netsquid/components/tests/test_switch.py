# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_switch.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import unittest
from netsquid.components.component import Message
from netsquid.components.switch import Switch, SimpleSwitch, SwitchError


class TestSwitch(unittest.TestCase):
    def test_interface(self):
        """Test the Switch needs a routing_table"""
        with self.assertRaises(TypeError):
            Switch("switch")

        class PassSwitch(Switch):
            def routing_table(self, input_port, message) -> [(Message, str)]:
                pass

        PassSwitch("switch")

    def test_merging_ports(self):
        """Test forwarding to a single port."""

        class MergerSwitch(Switch):
            def routing_table(self, input_port, message) -> [(Message, str)]:
                return [(message, "C")]

        switch = MergerSwitch("qswitch", port_names=["A", "B", "C"])
        switch.ports["A"].tx_input("hello")
        switch.ports["B"].tx_input("world")
        msg_a = switch.ports["C"].rx_output()
        msg_b = switch.ports["C"].rx_output()
        self.assertEqual(1, len(msg_a.items))
        self.assertEqual(msg_a.items[0], "hello")
        self.assertEqual(1, len(msg_b.items))
        self.assertEqual(msg_b.items[0], "world")

    def test_conditional_splitting(self):
        """Test a Round Robin switch."""

        class RoundRobinSwitch(Switch):
            def routing_table(self, input_port, message):
                target = self.properties["round_robin"].pop(0)
                self.properties["round_robin"].append(target)
                return [(message, target)]

        switch = RoundRobinSwitch("switch", port_names=["A", "B", "C"])
        switch.add_property("round_robin", ["B", "C"])
        for i in range(10):
            switch.ports["A"].tx_input(i)
        self.assertEqual(5, len(switch.ports["B"].output_queue))
        self.assertEqual(5, len(switch.ports["C"].output_queue))
        for i in range(5):
            msg_b = switch.ports["B"].rx_output()
            self.assertEqual(2 * i, msg_b.items[0])
            msg_c = switch.ports["C"].rx_output()
            self.assertEqual(1 + 2 * i, msg_c.items[0])

    def test_splitting_messages(self):
        """Test splitting a message into parts."""

        class SplitSwitch(Switch):
            def routing_table(self, input_port, message):
                return [(Message(item), input_port) for item in message.items]

        switch = SplitSwitch("splitswitch", port_names=["splitter"])
        switch.ports["splitter"].tx_input(Message(["hello", "world", "!"]))
        self.assertEqual(3, len(switch.ports["splitter"].output_queue))
        for word in ("hello", "world", "!"):
            self.assertEqual([word], switch.ports["splitter"].rx_output().items)

    def test_broadcasting(self):
        """Test broadcasting input messages to all but the input port"""

        class BroadcastSwitch(Switch):
            def routing_table(self, input_port, message) -> [(Message, str)]:
                outputs = []
                for port in self.ports:
                    if port == input_port:
                        continue
                    outputs.append((message, port))
                return outputs

        switch = BroadcastSwitch("switch", port_names=["in", "out0", "out1", "out2"])
        switch.ports["in"].tx_input("hello!")
        for port_index in range(3):
            msg = switch.ports[f"out{port_index}"].rx_output()
            self.assertEqual(["hello!"], msg.items)
        self.assertIsNone(switch.ports["in"].rx_output())

    def test_invalid_port(self):
        class InvalidSwitch(Switch):
            def routing_table(self, input_port, message) -> [(Message, str)]:
                return [(message, "port_a")]

        switch = InvalidSwitch("switch", port_names=["A"])
        with self.assertRaises(SwitchError):
            switch.ports["A"].tx_input("hello")

    # def test_discarding(self):
    #     """Test discarding qubits when the target port is None"""
    #     switch = Switch('switch', port_names=['A'])
    #     qubits = qapi.create_qubits(2)
    #     qapi.combine_qubits(qubits)
    #     q2 = qubits.pop(1)
    #     switch.ports['A'].tx_input(qubits.pop(0))  # This adds 2 additional references to the qubits.
    #     # switch.ports['A'].tx_input([qubits.pop(0)])  # This works fine.
    #     # switch.ports['A'].tx_input(Message(qubits.pop(0)))
    #     self.assertEqual(1, q2.qstate.num_qubits)


class TestSimpleSwitch(unittest.TestCase):
    def test_forwarding(self):
        """Test the simple switch implementation."""
        switch = SimpleSwitch("switch", {"a": "c", "b": "c", "c": "c"})
        switch.ports["a"].tx_input("hello")
        switch.ports["b"].tx_input("world")
        switch.ports["c"].tx_input("!")
        self.assertEqual(3, len(switch.ports["c"].output_queue))
        for word in ("hello", "world", "!"):
            self.assertEqual([word], switch.ports["c"].rx_output().items)


if __name__ == "__main__":
    unittest.main()
