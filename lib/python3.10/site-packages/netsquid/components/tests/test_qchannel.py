# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_qchannel.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the qchannel module.

"""
import math
import unittest
import numpy as np
import netsquid as ns
from netsquid.qubits import qubitapi as qapi
from netsquid.qubits import operators as ops
from netsquid.qubits.ketstates import s0, s1, b00
from netsquid.qubits.ketutil import ket2dm
from netsquid.qubits import qformalism as qform
from netsquid.components.tests import test_channel
from netsquid.components.models.delaymodels import FixedDelayModel
from netsquid.components.models.qerrormodels import QuantumErrorModel
from netsquid.components.qchannel import QuantumChannel


class ThresholdLossModel(QuantumErrorModel):
    """A test loss model. Loses a qubit if it's been on channel
    for longer than threshold time.

    """

    def __init__(self, threshold):
        super().__init__()
        self.properties["threshold"] = threshold

    def error_operation(self, qubits, delta_time=0, **kwargs):
        self.apply_loss(qubits, delta_time, **kwargs)

    def apply_loss(self, qubits, delta_time=0, **kwargs):
        for idx, qubit in enumerate(qubits):
            if qubit is None:
                continue
            prob_loss = self.prob_item_lost(qubit, delta_time, **kwargs)
            if qubit.is_number_state:
                # If qubit is a number state, then we want to amplitude dampen
                # towards |0> but not physically lose it.
                qapi.amplitude_dampen(qubit, gamma=prob_loss, prob=1.)
            elif math.isclose(prob_loss, 1.):
                if qubit.qstate is not None:
                    qapi.discard(qubit)
                qubits[idx] = None

    def prob_item_lost(self, qubit, delta_time, **kwargs):
        return 1. if delta_time > self.properties["threshold"] else 0


class ThresholdNoiseModel(QuantumErrorModel):
    """A test noise model based on a delay threshold.

    Applies X noise to a qubit if it's been on channel for longer
    than threshold time.

    """

    def __init__(self, threshold, operator=ops.X):
        super().__init__()
        self.properties["threshold"] = threshold
        self.properties["operator"] = operator

    def error_operation(self, qubits, delta_time=0, **kwargs):
        if delta_time > self.properties["threshold"]:
            for qubit in qubits:
                qapi.operate(qubit, self.properties["operator"])


class TestQuantumChannel(test_channel.TestChannel):
    """Unit tests for the qchannel module.

    """

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        super().setUp()
        qform.set_qstate_formalism(qform.QFormalism.KET)
        self.test_items = qapi.create_qubits(5)
        self.Channel_cls = QuantumChannel

    def tearDown(self):
        qform.set_qstate_formalism(qform.QFormalism.KET)

    def test_QuantumChannel_init(self):
        """Test initialization of QuantumChannel"""
        delay = 5
        noise_model = ThresholdNoiseModel(3)
        loss_model = ThresholdLossModel(3)
        qc = QuantumChannel("QuantumChannelTest", delay=delay,
                            models={"quantum_noise_model": noise_model,
                                    "quantum_loss_model": loss_model})
        self.assertEqual(qc.models["quantum_noise_model"], noise_model)
        self.assertEqual(qc.models["quantum_loss_model"], loss_model)
        self.assertIsInstance(qc.models["delay_model"], FixedDelayModel)
        self.assertAlmostEqual(qc.models["delay_model"](), delay)

    def test_send_qubits(self):
        """Test sending of qubits"""
        qc = QuantumChannel("QuantumChannelTest", delay=5)
        q1, q2, q3 = qapi.create_qubits(3)
        # test putting single qubit
        ns.sim_reset()
        self._wait_for_channel_items(qc)
        self._send_item_on_channel(qc, q1, 0)
        ns.sim_run()
        self.assertEqual(len(self.read_items), 1)
        self.assertEqual(q1, self.read_items[0])
        # test putting multiple qubits
        ns.sim_reset()
        self._wait_for_channel_items(qc)
        self._send_item_on_channel(qc, [q1, q2], 0)
        ns.sim_run()
        self.assertEqual(len(self.read_items), 1)
        qubits = self.read_items[0]
        self.assertEqual(type(qubits), list)
        self.assertEqual(q1, qubits[0])
        self.assertEqual(q2, qubits[1])
        # test putting too many qubits (greater than bandwidth)
        # with self.assertRaises(ChannelBandwidthError):
        #    qc.send([q1, q2, q3])

    def test_noise_model(self):
        """Tests for a non-trivial noise model."""
        noise_model = ThresholdNoiseModel(5)
        # Test noise only applied beyond threshold delay
        for delay, ket in [(3, s0), (7, s1)]:
            qc = QuantumChannel("QuantumChannelTest", delay=delay,
                                models={"quantum_noise_model": noise_model})
            ns.sim_reset()
            self._wait_for_channel_items(qc)
            q1, = qapi.create_qubits(1)
            self._send_item_on_channel(qc, q1, 0)
            ns.sim_run()
            self.assertEqual(len(self.read_items), 1)
            qr = self.read_items[0]
            self.assertTrue(np.allclose(qapi.reduced_dm(qr), ket2dm(ket)))

    def test_loss_model(self):
        """Test non-trivial loss model."""
        loss_model = ThresholdLossModel(5)
        qform.set_qstate_formalism(qform.QFormalism.DM)
        # Test qubit lost beyond threshold delay
        for delay, read_count in [(3, 1), (7, 0)]:
            qc = QuantumChannel("QuantumChannelTest", delay=delay,
                                models={"quantum_loss_model": loss_model})
            qc.reset()
            ns.sim_reset()
            self._wait_for_channel_items(qc)
            # create entangled
            q1, q2 = qapi.create_qubits(2)
            qapi.operate(q1, ops.H)
            qapi.operate([q1, q2], ops.CNOT)
            self._send_item_on_channel(qc, q1, 0)
            ns.sim_run()
            self.assertEqual(len(self.read_items), read_count)
            if read_count == 1:
                # qubit not lost, so Bell state maintained
                qr = self.read_items[0]
                self.assertAlmostEqual(qapi.fidelity(qr.qstate.qubits, b00), 1.)
            else:
                # qubit lost => was measured in Z basis
                self.assertEqual(q1.qstate, None)
                self.assertEqual(q2.qstate.num_qubits, 1)
                self.assertTrue(np.allclose(qapi.reduced_dm(q2), 0.5 * np.eye(2)))


if __name__ == "__main__":
    unittest.main()
