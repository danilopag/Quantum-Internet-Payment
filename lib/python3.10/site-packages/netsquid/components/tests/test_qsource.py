# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_qsource.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for quantum source types in the qsource module.

"""
import unittest
import itertools
import numpy as np
import netsquid as ns
from netsquid.components.qsource import QSource, SourceStatus, QSourceTriggerError
from netsquid.components.clock import Clock
from netsquid.qubits.state_sampler import StateSampler
from netsquid.components.models.qerrormodels import QuantumErrorModel
from netsquid.components.models.delaymodels import DelayModel, FixedDelayModel
from netsquid.qubits.ketstates import s0, s00, s11
from netsquid.qubits.ketutil import ket2dm
from netsquid.qubits import qubitapi as qapi


class ThresholdNoiseModel(QuantumErrorModel):
    """A test noise model based on a delay threshold.

    Applies X noise to a qubit if the source delay (1 / frequency) is longer than threshold time.

    """

    def __init__(self, threshold, operator=qapi.ops.X):
        super().__init__()
        self.properties["threshold"] = threshold
        self.properties["operator"] = operator

    def error_operation(self, qubits, **kwargs):
        if kwargs['test_time'] > self.properties["threshold"]:
            for qubit in qubits:
                qapi.operate(qubit, self.properties["operator"])


class TestQSource(unittest.TestCase):
    """Unit tests for the QSource module."""
    SS_1_QUBIT = StateSampler(np.diag([0.5, 0.5]))
    SS_2_QUBITS = StateSampler(np.diag([0.25] * 2 ** 2))
    SS_3_QUBITS = StateSampler(np.diag([0.125] * 2 ** 3))
    SS_4_QUBITS = StateSampler(np.diag([0.0625] * 2 ** 4))

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        ns.sim_reset()

    def tearDown(self):
        ns.sim_stop()

    def store_output_from_port(self, message, port_idx):
        """Store all messages send to a port in a list."""
        self.port_output[port_idx].append(message)

    def create_test_source(self, state_sampler=None, frequency=99, num_ports=1, status=SourceStatus.OFF,
                           qubit_port_mapping=None, emission_noise_model=None,
                           timing_model=None, properties=None):
        """Create a source and connect its ports to store its output."""
        source = QSource('test', frequency=frequency, state_sampler=state_sampler, status=status,
                         num_ports=num_ports, qubit_port_mapping=qubit_port_mapping,
                         models={"emission_noise_model": emission_noise_model},
                         timing_model=timing_model, properties=properties)
        # Create a dict with output per port to be able to check correct generation and distribution of qubits.
        self.port_output = {}
        for idx in range(num_ports):
            self.port_output[idx] = []
            source.ports["qout" + str(idx)].bind_output_handler(lambda message, idx=idx:
                                                                self.store_output_from_port(message, idx))
        return source

    def test_state_sampler(self):
        """Test setting state_sampler at and after initialization."""
        with self.assertRaises(ValueError):
            # 3 qubits for 2 ports
            _ = QSource('test', state_sampler=self.SS_3_QUBITS, num_ports=2)
        source = QSource('test', state_sampler=self.SS_2_QUBITS, num_ports=2)
        self.assertEqual(source.state_sampler, self.SS_2_QUBITS)
        with self.assertRaises(ValueError):
            # 4 qubits for 2 ports, but previous state size was 2.
            source.state_sampler = self.SS_4_QUBITS
        with self.assertRaises(ValueError):
            # 3 qubits for 2 ports
            source.state_sampler = self.SS_3_QUBITS
        # A new state sampler with the same number of qubits should work.
        new_state_sampler = StateSampler(s00)
        source.state_sampler = new_state_sampler
        self.assertEqual(source.state_sampler, new_state_sampler)

    def test_frequency(self):
        """Test setter and getter of frequency"""
        frequency = 100
        source = QSource('test', frequency=frequency, state_sampler=self.SS_2_QUBITS)
        self.assertEqual(frequency, source.frequency)
        with self.assertRaises(ValueError):
            source.frequency = 0
        with self.assertRaises(ValueError):
            source.frequency = -1
        # Check period (1 / frequency)
        self.assertEqual(source.period, 1e9 / (frequency))
        # Check setter
        source.frequency = frequency + 1
        self.assertEqual(source.frequency, frequency + 1)

        # Test changing frequency via model of internal clock
        new_frequency = 33
        source.subcomponents["internal_clock"].models["timing_model"] = FixedDelayModel(delay=1e9 / new_frequency)
        self.assertEqual(new_frequency, source.frequency)

    def test_trigger_delay(self):
        """Test setter and getter of trigger_delay"""
        frequency = 1
        trigger_delay = 30
        source = QSource('test', frequency=frequency, trigger_delay=trigger_delay, state_sampler=self.SS_2_QUBITS)
        self.assertEqual(trigger_delay, source.properties["trigger_delay"])
        self.assertEqual(trigger_delay, source.prep_delay)  # Without emission_delay, prep_delay == trigger_delay
        # Check setter
        source.properties["trigger_delay"] = 0
        self.assertEqual(source.properties["trigger_delay"], 0)
        self.assertEqual(source.prep_delay, source.properties["trigger_delay"])

    def test_emission_delay_model(self):
        """Test emission delay model."""

        class IncremetingDelayModel(DelayModel):
            """A test delay model that returns an increasing delay (doubling every time it is called).

            """

            def __init__(self, delay):
                super().__init__()
                self.delay = delay

            def get_mean(self, channel):
                # ill-defined
                return self.generate_delay()

            def set_mean(self, value):
                # ill-defined
                self.delay = value / 4 * 3

            def get_std(self):
                return 0

            def generate_delay(self, **kwargs):
                delay = self.delay
                self.delay = self.delay * 2
                return delay

        initial_delay = 10
        emission_delay_model = IncremetingDelayModel(delay=initial_delay)
        source = QSource('test', status=SourceStatus.EXTERNAL, models={"emission_delay_model": emission_delay_model})
        self.assertEqual(emission_delay_model, source.models["emission_delay_model"])
        self.assertEqual(initial_delay, source.prep_delay)  # Without trigger_delay, prep_delay == emission_delay
        #
        source.trigger()
        ns.sim_run(duration=initial_delay * 2)  # initial_delay already doubled when calling prep_delay
        source.trigger()
        with self.assertRaises(QSourceTriggerError):
            source.trigger()
        ns.sim_run(duration=initial_delay * 2 ** 2)
        source.trigger()

    def test_num_ports(self):
        """Test if the number of ports is added correctly. Note: there is always 1 extra input port for triggering."""
        test_source = QSource('test', state_sampler=self.SS_2_QUBITS, num_ports=2)
        self.assertEqual(len(test_source.ports), 3)
        test_source = QSource('test', state_sampler=self.SS_1_QUBIT, num_ports=1)
        self.assertEqual(len(test_source.ports), 2)

    def test_num_qubits_match_num_states(self):
        """ Test qubits in state are a multiple of number of ports."""
        QSource('test', state_sampler=self.SS_2_QUBITS, num_ports=1)
        # If not, raise error:
        with self.assertRaises(ValueError):
            # num qubits < num ports (2 < 3)
            QSource('test', state_sampler=self.SS_2_QUBITS, num_ports=3)
        with self.assertRaises(ValueError):
            # num qubits < num ports (2 < 4)
            QSource('test', state_sampler=self.SS_2_QUBITS, num_ports=4)
        with self.assertRaises(ValueError):
            # num qubits < num ports (1 < 2)
            QSource('test', state_sampler=self.SS_1_QUBIT, num_ports=2)
        with self.assertRaises(ValueError):
            # num qubits > num ports (3 > 2)
            QSource('test', state_sampler=self.SS_3_QUBITS, num_ports=2)

    def test_qubit_port_mapping(self):
        """Test if a qubit_port_mapping is executed correctly."""
        num_ports = 2
        source = self.create_test_source(state_sampler=self.SS_3_QUBITS, num_ports=num_ports,
                                         qubit_port_mapping=[0, 1, 1], status=SourceStatus.INTERNAL)
        ns.sim_run(source.prep_delay + 1)
        # Make sure the list of output is not empty
        self.assertTrue(len(self.port_output[0]) > 0)
        self.assertTrue(len(self.port_output[1]) > 0)
        # Check if the output has the correct length
        number_of_qubits_per_port = [len(self.port_output[idx][0].items) for idx in range(num_ports)]
        self.assertEqual(number_of_qubits_per_port[0], 1)
        self.assertEqual(number_of_qubits_per_port[1], 2)

    def test_incorrect_qubit_port_mapping(self):
        """Test if correct errors are raised when incorrect qubit_port_mappings are passed."""
        with self.assertRaises(ValueError):
            # num qubits > length qubit_port_mapping (2 > 1)
            QSource('test', state_sampler=self.SS_2_QUBITS, num_ports=2, qubit_port_mapping=[0])
        with self.assertRaises(ValueError):
            # negative values not allowed
            QSource('test', state_sampler=self.SS_2_QUBITS, num_ports=2, qubit_port_mapping=[-1, 0])
        with self.assertRaises(ValueError):
            # port index should be smaller than num_ports - 1
            QSource('test', state_sampler=self.SS_2_QUBITS, num_ports=2, qubit_port_mapping=[0, 2])
        with self.assertRaises(TypeError):
            # only integers allowed
            QSource('test', state_sampler=self.SS_2_QUBITS, num_ports=2, qubit_port_mapping=[0.5, 0])

    def test_applying_emission_models(self):
        """Test applying noise to qubits emitted via ports."""
        num_ports = 2
        threshold_delay = 5  # delay in nano seconds
        noise_model_1 = ThresholdNoiseModel(threshold=threshold_delay)
        # noise_model_2 = ThresholdNoiseModel(threshold=threshold_delay * 2)
        # First check naming of models
        source = QSource('test', state_sampler=self.SS_2_QUBITS, num_ports=num_ports,
                         models={"emission_noise_model": ThresholdNoiseModel(threshold=1)})
        self.assertTrue("emission_noise_model" in source.models)

        def _test_helper(num_ports, emission_noise_model, delta_time, ket):
            ns.sim_reset()
            source = self.create_test_source(state_sampler=StateSampler(s00), num_ports=num_ports,
                                             status=SourceStatus.INTERNAL,
                                             emission_noise_model=emission_noise_model,
                                             properties={"test_time": delta_time})
            ns.sim_run(source.prep_delay + 1)
            for idx in range(num_ports):
                self.assertEqual(len(self.port_output[idx]), 1)
                qubit = self.port_output[idx][0].items[0]
                self.assertTrue(np.allclose(qubit.qstate.qrepr.reduced_dm(), ket2dm(ket)))

        # Apply a single noise model to all ports (emission_noise_model=noise_model)
        # Test noise only applied beyond threshold delta_time.
        for delta_time, ket in [(threshold_delay * 0.9, s00), (threshold_delay, s00), (threshold_delay * 1.1, s11)]:
            _test_helper(num_ports=num_ports, emission_noise_model=noise_model_1, delta_time=delta_time, ket=ket)
        # Initiate with wrong type models
        with self.assertRaises(TypeError):
            # No list
            QSource('test', state_sampler=self.SS_2_QUBITS, num_ports=2,
                    models={"emission_noise_model": [noise_model_1]})
        with self.assertRaises(TypeError):
            QSource('test', state_sampler=self.SS_2_QUBITS, num_ports=1,
                    models={"emission_noise_model": FixedDelayModel(1)})

    def test_timing_model(self):
        """Test if QSource works with timing models."""
        num_ports = 2

        class ToggleDelayModel(DelayModel):
            def __init__(self, value_1, value_2):
                """Delay model that switches between a delay of value_1 and value_2
                each time it is called (starting with value_1)."""
                super().__init__()
                self._value_1 = value_1
                self._value_2 = value_2
                self.delay_generator = itertools.cycle((value_1, value_2))

            def generate_delay(self, **kwargs):
                return next(self.delay_generator)

            def get_mean(self, **kwargs):
                return (self._value_1 + self._value_2) / 2

            def set_mean(self, value):
                mean = self.get_mean()
                ratio = value / mean
                self._value_1 *= ratio
                self._value_2 *= ratio

            def get_std(self, **kwargs):
                return self.get_mean()

        delay_1 = 9
        delay_2 = 19
        test_model = ToggleDelayModel(delay_1, delay_2)
        source = self.create_test_source(state_sampler=self.SS_2_QUBITS, num_ports=num_ports, timing_model=test_model,
                                         status=SourceStatus.INTERNAL)
        self.assertEqual(source.subcomponents["internal_clock"].models["timing_model"], test_model)
        # Until t=prep_delay there should not be any pulses generated
        ns.sim_run(source.prep_delay)
        for idx in range(num_ports):
            self.assertEqual(len(self.port_output[idx]), 0)
        # Check after each time step of max_delay, 2 pulses are added to the ports (2, because the second pulse is generated with zero delay).
        # The first pulse is generated at t=0, the second at delay_1 and third at delay_1 + delay_2, third at delay_1 + delay_2 + delay_1 etc.
        delay_generator = itertools.cycle((delay_1, delay_2))
        for n in range(0, 11):
            delay = next(delay_generator)
            ns.sim_run(duration=delay)
            for idx in range(num_ports):
                self.assertEqual(len(self.port_output[idx]), n + 1)

    def test_internal_generation(self):
        """Test if QSource correctly generates Qubits and distributes them over its ports."""
        num_ports = 2
        source = self.create_test_source(frequency=100, state_sampler=self.SS_2_QUBITS,
                                         num_ports=num_ports, status=SourceStatus.INTERNAL)
        # Until t=prep_delay there should not be any pulses generated
        ns.sim_run(source.prep_delay)
        for idx in range(num_ports):
            self.assertEqual(len(self.port_output[idx]), 0)
        # Check after each pulse if it is added to the ports.
        for n in range(0, 11):
            ns.sim_run(n * source.period + 1)  # First pulse is schedule at t=0.
            for idx in range(num_ports):
                self.assertEqual(len(self.port_output[idx]), n + 1)

    def test_changing_frequency_while_generating(self):
        frequency = 0.5 * 1e9
        source = self.create_test_source(frequency=frequency)
        # Start the source by changing its status
        source.status = SourceStatus.INTERNAL
        ns.sim_run(duration=1)
        self.assertEqual(len(self.port_output[0]),
                         1)  # Without trigger delay or emission delay, the first pulse is generated at t=0.
        ns.sim_run(duration=2)
        self.assertEqual(len(self.port_output[0]),
                         2)  # After '1e9 / frequency = 2' nano seconds, the second pulse is generated.
        source.frequency = 1e9
        ns.sim_run(
            duration=2)  # After another 2 nano seconds, the third pulse is generated: this one was scheduled before changing the frequency.
        self.assertEqual(len(self.port_output[0]), 3)
        ns.sim_run(
            duration=1)  # From now on the new pulsed will be scheduled at the new frequency (i.e. every nano second.)
        self.assertEqual(len(self.port_output[0]), 4)

    def test_manually_triggered_generation(self):
        """Test if QSource correctly generates a pulse and distributes the qubits over its ports when triggered manually."""
        num_ports = 3
        source = self.create_test_source(frequency=100, state_sampler=self.SS_3_QUBITS,
                                         status=SourceStatus.EXTERNAL, num_ports=num_ports)
        # Until t=prep_delay there should not be any pulses generated
        ns.sim_run(source.prep_delay)
        self.assertEqual(len(self.port_output[0]), 0)
        # After t = prep_delay + 2 * delay, still no pulses should have been generated.
        ns.sim_run(source.prep_delay + source.period * 2)
        for idx in range(num_ports):
            self.assertEqual(len(self.port_output[idx]), 0)
        # Check pulse is generated when source is triggered.
        source.trigger()
        ns.sim_run(duration=1)
        for idx in range(num_ports):
            self.assertEqual(len(self.port_output[idx]), 1)
        ns.sim_run(duration=source.period)  # Wait one period before triggering again.
        source.trigger()
        ns.sim_run(duration=1)
        for idx in range(num_ports):
            self.assertEqual(len(self.port_output[idx]), 2)

    def test_too_fast_triggering(self):
        """Test that too fast triggering will raise an error."""
        source = QSource("test", status=SourceStatus.EXTERNAL, trigger_delay=0)
        source.trigger()
        # Triggering multiple times at the same time is allowed with zero trigger delay and emission delay.
        source.trigger()
        # After a single time step you can trigger again.
        ns.sim_run(duration=1)
        source.trigger()
        # Check if triggering with trigger delay will raise an error
        ns.sim_reset()
        delay = 10
        source = QSource("test", status=SourceStatus.EXTERNAL, trigger_delay=delay)
        source.trigger()
        # After exactly delay time, the source can start generating a pulse again.
        ns.sim_run(duration=delay)
        source.trigger()
        # Error when delta time < prep_time
        ns.sim_run(duration=delay - 1)
        with self.assertRaises(QSourceTriggerError):
            source.trigger()

    def test_triggering_via_port(self):
        """Test if QSource correctly generates pulses when triggered via the input port."""
        num_ports = 1
        num_ticks = 10
        time_step = 10
        source = self.create_test_source(state_sampler=self.SS_1_QUBIT,
                                         status=SourceStatus.EXTERNAL, num_ports=num_ports)
        clock = Clock("clock", frequency=1e9 / time_step, max_ticks=num_ticks)
        clock.ports["cout"].connect(source.ports["trigger"])
        clock.start()
        ns.sim_run()  # sim should stop after max number of ticks are created.
        for idx in range(num_ports):
            self.assertEqual(len(self.port_output[idx]), num_ticks)
            for idx2, message in enumerate(self.port_output[idx]):
                self.assertEqual(message.meta["emission_time"], idx2 * time_step)

    def test_triggering_via_port_while_in_internal_mode(self):
        """Test source will not trigger when in internal mode."""
        num_ports = 1
        num_clicks = 10
        source = self.create_test_source(frequency=1e9, state_sampler=self.SS_1_QUBIT,
                                         status=SourceStatus.INTERNAL, num_ports=num_ports)
        clock = Clock("clock", frequency=1, max_ticks=num_clicks)
        clock.ports["cout"].connect(source.ports["trigger"])
        clock.start()
        with self.assertRaises(QSourceTriggerError):
            ns.sim_run(1)

    def test_source_status(self):
        """Test different status possibilities of a QSource."""
        source = self.create_test_source(state_sampler=self.SS_2_QUBITS)
        # Test default status is OFF
        self.assertEqual(source.status, SourceStatus.OFF)
        # Test changing the status.
        source.status = SourceStatus.INTERNAL
        self.assertEqual(source.status, SourceStatus.INTERNAL)
        source.status = SourceStatus.OFF
        self.assertEqual(source.status, SourceStatus.OFF)
        source.status = SourceStatus.EXTERNAL
        self.assertEqual(source.status, SourceStatus.EXTERNAL)

    def test_turn_off(self):
        """Test if QSource stops generating pulses when turn_off is called."""
        num_ports = 1
        number_of_pulses = 3  # arbitrary number of pulses used in this test
        source = self.create_test_source(frequency=100, state_sampler=self.SS_2_QUBITS,
                                         num_ports=num_ports)
        # Create number_of_pulses
        source.status = SourceStatus.INTERNAL
        # 'number_of_pulses - 1' because the first pulse is generated at t=0
        ns.sim_run((number_of_pulses - 1) * source.period + 1)
        self.assertEqual(len(self.port_output[0]), number_of_pulses)
        # When turned off, no additional messages should arrive.
        source.status = SourceStatus.OFF
        ns.sim_run(duration=number_of_pulses * source.period + 1)
        self.assertEqual(len(self.port_output[0]), number_of_pulses)
        # When turned on again for the same amount of time, the number of pulses should be doubled.
        # Also to test if EventHandlers are not registered twice when turning on for the second time.
        source.status = SourceStatus.INTERNAL
        # 'number_of_pulses - 1' because the first pulse is generated at t=0
        ns.sim_run(duration=(number_of_pulses - 1) * source.period + 1)
        self.assertEqual(len(self.port_output[0]), 2 * number_of_pulses)

    def test_switching_between_internal_external(self):
        num_ports = 1
        # Start with default external_mode = False
        source = QSource(name='test', frequency=99, state_sampler=self.SS_2_QUBITS, num_ports=num_ports)
        source.status = SourceStatus.INTERNAL
        ns.sim_run(duration=source.period)
        # Switch to external mode - internal clock should be stopped, otherwise an error is raised.
        source.status = SourceStatus.EXTERNAL
        ns.sim_run(duration=source.period)
        # Start in external mode
        source = QSource(name='test', state_sampler=self.SS_2_QUBITS, status=SourceStatus.EXTERNAL,
                         num_ports=num_ports)
        source.trigger()
        ns.sim_run(duration=source.period)
        # Switch to internal mode (check if internal clock is created when at first no model or frequency are passed.)
        source.status = SourceStatus.INTERNAL
        with self.assertRaises(QSourceTriggerError):
            source.trigger()
        ns.sim_run(duration=source.period)

    def test_sampling_none_states(self):
        """Test sampling with None states"""
        num_states = 0

        def save_messages(msg):
            nonlocal num_states
            num_states += 1
        source = QSource(name='test', frequency=99, state_sampler=StateSampler([s00, None], [0.5, 0.5]))
        source.status = SourceStatus.INTERNAL
        source.ports['qout0'].bind_output_handler(save_messages)
        runs = 1000
        ns.sim_run(duration=runs*source.period)
        ratio = num_states / runs
        self.assertAlmostEqual(0.5, ratio, delta=1.65*np.sqrt(1/runs))  # Wald confidence bound 0.999%

    def test_reset(self):
        """Test the required component reset functionality."""
        source = QSource(name='test', status=SourceStatus.INTERNAL)
        source.status = SourceStatus.EXTERNAL
        source.reset()
        self.assertEqual(source.status, SourceStatus.INTERNAL)

    def test_omit_pulse_generation_for_vacuum_state(self):
        """Test that vacuum states are omitted in new pulse generation."""
        periods = 10
        state_sampler = StateSampler([None, s0], [1.0, 0.0])
        source = QSource(name="test", state_sampler=state_sampler, frequency=99,
                         status=SourceStatus.INTERNAL)
        stats = ns.sim_run(duration=(periods + 1/2) * source.period)  # Add half to make sure event has been processed.
        self.assertEqual(periods + 1, stats.data['handled_callbacks'])
        self.assertEqual(0, stats.data['qstate_max_size'])


if __name__ == "__main__":
    unittest.main()
