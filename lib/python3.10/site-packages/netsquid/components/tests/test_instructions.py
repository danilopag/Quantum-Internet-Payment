# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_instructions.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the instructions module.

"""
import unittest
import numpy as np
import pydynaa as pd
import netsquid as ns
from netsquid.qubits import operators as ops
from netsquid.components.qmemory import QuantumMemory
from netsquid.qubits import qubitapi as qapi
from netsquid.qubits.ketstates import s0, s1, s00, h0, b00, BellIndex, bell_states
from netsquid.qubits.ketutil import ket2dm
from netsquid.components.instructions import IGate, IRotationGate, IControlledDirectionGate, IMeasure, IMeasureBell, \
    IInit, ISwap, InstructionError, ISignal, IEmit, IMeasureFaulty, IDiscard
from netsquid.qubits.qformalism import QFormalism, set_qstate_formalism
from pydynaa.core import EventType


class TestInstructions(unittest.TestCase):
    """Unit tests for the instructions module."""

    def setUp(self):
        """Set up a new QuantumMemory for each test."""
        # TODO: check if we always/often need a QuantumMemory
        self.quantum_memory = QuantumMemory('test_quantum_memory', num_positions=2)
        self.quantum_memory.put(qapi.create_qubits(2), [0, 1])

    def tearDown(self):
        if self.quantum_memory is not None:
            self.quantum_memory.reset()
        set_qstate_formalism(QFormalism.KET)

    def test_iinit(self):
        """Test IInit instructions."""
        # Test instruction for an arbitrary number of qubits
        init_instr = IInit()
        self.assertEqual(init_instr.name, 'initialization_op')
        self.assertEqual(init_instr.num_positions, -1)
        # Test calling without positions nor qubits
        init_instr(self.quantum_memory)
        qubits = self.quantum_memory.pop([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, s00), 1)
        # Test calling with only positions
        init_instr(self.quantum_memory, [0, 1])
        qubits = self.quantum_memory.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, s00), 1)
        # Test init with only qubits
        q1, q2, q3 = qapi.create_qubits(3)
        init_instr(self.quantum_memory, qubits=[q1, q2])
        qubits = self.quantum_memory.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, s00), 1)
        # Test calling with wrong number of qubits and/or positions
        with self.assertRaises(ValueError):
            init_instr(self.quantum_memory, qubits=[q1, q2, q3])
        with self.assertRaises(ValueError):
            init_instr(self.quantum_memory, [0, 1], qubits=[q1])
        with self.assertRaises(ValueError):
            init_instr(self.quantum_memory, [0], qubits=[q1, q2])
        # Test calling with positions and qubits
        q1, q2 = qapi.create_qubits(2)
        qapi.operate(q1, ops.X)
        qapi.operate(q2, ops.H)
        init_instr(self.quantum_memory, [1, 0], qubits=[q1, q2])
        qubits = self.quantum_memory.peek([1, 0])
        self.assertAlmostEqual(qapi.fidelity(qubits, np.kron(s1, h0)), 1)
        # Test instruction for single qubit
        init_single_instr = IInit(num_positions=1)
        self.assertEqual(init_single_instr.num_positions, 1)
        with self.assertRaises(ValueError):
            init_single_instr(self.quantum_memory, [0, 1])
        # Test init single positions without qubits
        init_single_instr(self.quantum_memory, [0])
        init_single_instr(self.quantum_memory, [1])
        qubits = self.quantum_memory.peek([0, 1])
        self.assertAlmostEqual(qapi.fidelity(qubits, s00), 1)

    def test_isignal(self):
        """Test ISignal instruction."""
        signal_instr = ISignal("signal")
        self.assertEqual(signal_instr.num_positions, 0)

        def signal_callback(event):
            self.signal_emitted = True

        self.evhandler_signal_emitted = ns.EventHandler(signal_callback)
        helper = pd.Entity()
        # Test default signal.
        self.signal_emitted = False
        helper._wait_once(self.evhandler_signal_emitted, entity=self.quantum_memory,
                          event_type=self.quantum_memory.evtype_signal_default)
        signal_instr(self.quantum_memory)
        ns.sim_run()
        self.assertTrue(self.signal_emitted)
        # Test non default signal.
        self.signal_emitted = False
        evtype_signal_custom = EventType("SIGNAL_CUSTOM", "A custom signal emitted by the Processor.")
        helper._wait_once(self.evhandler_signal_emitted, entity=self.quantum_memory,
                          event_type=evtype_signal_custom)
        signal_instr(self.quantum_memory)
        ns.sim_run()
        self.assertFalse(self.signal_emitted)
        signal_instr(self.quantum_memory, event_type=evtype_signal_custom)
        ns.sim_run()
        self.assertTrue(self.signal_emitted)
        # Test event type given at init.
        signal_with_event_instr = ISignal("signal with event", event_type=evtype_signal_custom)
        self.assertEqual(signal_with_event_instr.num_positions, 0)
        self.signal_emitted = False
        helper._wait_once(self.evhandler_signal_emitted, entity=self.quantum_memory,
                          event_type=self.quantum_memory.evtype_signal_default)
        signal_with_event_instr(self.quantum_memory)
        ns.sim_run()
        self.assertFalse(self.signal_emitted)
        helper._wait_once(self.evhandler_signal_emitted, entity=self.quantum_memory,
                          event_type=evtype_signal_custom)
        signal_with_event_instr(self.quantum_memory)
        ns.sim_run()
        self.assertTrue(self.signal_emitted)
        # Test event type given when calling instruction overwrites original event type.
        self.signal_emitted = False
        helper._wait_once(self.evhandler_signal_emitted, entity=self.quantum_memory,
                          event_type=self.quantum_memory.evtype_signal_default)
        signal_with_event_instr(self.quantum_memory, event_type=self.quantum_memory.evtype_signal_default)
        ns.sim_run()
        self.assertTrue(self.signal_emitted)

    def test_iswap(self):
        """Test ISwap instructions."""
        swap_instr = ISwap()
        self.assertEqual(swap_instr.name, 'swap_gate')
        self.assertEqual(swap_instr.num_positions, 2)
        # Set qubit at 1 to |1> using operate(q2, X).
        self.quantum_memory.operate(ops.X, positions=1, skip_noise=True)
        self.assertAlmostEqual(qapi.fidelity(self.quantum_memory.peek([0]), s0), 1)
        self.assertAlmostEqual(qapi.fidelity(self.quantum_memory.peek([1]), s1), 1)
        with self.assertRaises(ValueError):
            swap_instr(self.quantum_memory, [0])
        swap_instr(self.quantum_memory, [0, 1])
        # Use fidelity to check (from qubitapi in test_qprocessor).
        self.assertAlmostEqual(qapi.fidelity(self.quantum_memory.peek([0]), s1), 1)
        self.assertAlmostEqual(qapi.fidelity(self.quantum_memory.peek([1]), s0), 1)

    def test_igate(self):
        """Test IGate instructions."""
        operator = ops.Operator('operator_name', np.array([[0, 1], [1, 0]]))
        instruction_gate = IGate('instruction_name', operator)
        self.assertEqual(instruction_gate.name, 'instruction_name')
        self.assertEqual(instruction_gate.num_positions, 1)
        self.assertAlmostEqual(qapi.fidelity(self.quantum_memory.peek([0]), s0), 1)
        instruction_gate(self.quantum_memory, [0])
        self.assertAlmostEqual(qapi.fidelity(self.quantum_memory.peek([0]), s1), 1)

    def test_irotation_gate(self):
        """Test IRotationGate instructions."""
        instr = IRotationGate('test_rot_gate', axis=None, controlled=False)
        self.assertEqual(instr.name, 'test_rot_gate')
        self.assertEqual(instr.num_positions, 1)
        # Test if calling IRotationGate without specifying an axis at init or in execute raises error.
        with self.assertRaises(InstructionError):
            instr(self.quantum_memory, positions=[0], angle=np.pi, axis=None)
        # Test if rotation is executed.
        instr(self.quantum_memory, positions=[0], angle=np.pi, axis=(1, 0, 0))
        self.assertAlmostEqual(qapi.fidelity(self.quantum_memory.peek([0]), s1), 1)
        # Test if axis at init is used instead of the axis given at execute.
        instr = IRotationGate('test_rot_gate_with_axis', axis=(1, 0, 0), controlled=False)
        instr(self.quantum_memory, positions=[1], angle=np.pi, axis=(0, 0, 1))
        self.assertAlmostEqual(qapi.fidelity(self.quantum_memory.peek([1]), s1), 1)

    def test_standard_rotation_op(self):
        """Test if standard rotation operators are used."""
        instr = IRotationGate('test_rot_gate_with_axis', axis=(1, 0, 0), controlled=False)
        test_sets = [{"axis": (1, 0, 0), "angle": np.pi / 2, "expected_operator": ops.Rx90},
                     {"axis": (1, 0, 0), "angle": np.pi, "expected_operator": ops.Rx180},
                     {"axis": (1, 0, 0), "angle": np.pi * 3 / 2, "expected_operator": ops.Rx270},
                     {"axis": (0, 1, 0), "angle": np.pi / 2, "expected_operator": ops.Ry90},
                     {"axis": (0, 1, 0), "angle": np.pi, "expected_operator": ops.Ry180},
                     {"axis": (0, 1, 0), "angle": np.pi * 3 / 2, "expected_operator": ops.Ry270},
                     {"axis": (0, 0, 1), "angle": np.pi / 2, "expected_operator": ops.Rz90},
                     {"axis": (0, 0, 1), "angle": np.pi, "expected_operator": ops.Rz180},
                     {"axis": (0, 0, 1), "angle": np.pi * 3 / 2, "expected_operator": ops.Rz270},
                     ]
        for test_set in test_sets:
            operator = instr._get_standard_rotation_operator(test_set["axis"], test_set["angle"], angle_precision=8)
            self.assertEqual(operator, test_set["expected_operator"])
        # check if an angle with too low precision does not return a standard rotation op.
        operator = instr._get_standard_rotation_operator(test_sets[0]["axis"], round(test_sets[0]["angle"], 3),
                                                         angle_precision=8)
        self.assertEqual(operator, None)

    def test_controlled_irotation_gate(self):
        """Test IRotationGate instructions."""
        instr = IRotationGate('test_controlled_rot_gate', axis=None, controlled=True)
        self.assertEqual(instr.num_positions, 2)
        # Test that rotation is not performed when first qubit is not |1>.
        instr(self.quantum_memory, positions=[0, 1], angle=np.pi, axis=(1, 0, 0))
        self.assertAlmostEqual(qapi.fidelity(self.quantum_memory.peek([0]), s0), 1)
        # Test that rotation is performed when first qubit is |1>.
        IGate('X', ops.X)(self.quantum_memory, [0])  # Set qubit 1 to |1>.
        instr(self.quantum_memory, positions=[0, 1], angle=np.pi, axis=(1, 0, 0))
        self.assertAlmostEqual(qapi.fidelity(self.quantum_memory.peek([0]), s1), 1)

    def test_icontrolled_direction_gate(self):
        """Test IControlledDirectionGate instructions."""
        instr = IControlledDirectionGate('test_cdir_gate', axis=None)
        self.assertEqual(instr.num_positions, 2)
        # Test if calling IControlledDirectionGate without specifying an axis at init or in execute raises error.
        with self.assertRaises(InstructionError):
            instr(self.quantum_memory, positions=[0, 1], angle=np.pi, axis=None)
        # Test that rotation is not performed when first qubit is not |1>.
        instr(self.quantum_memory, positions=[0, 1], angle=np.pi, axis=(1, 0, 0))
        self.assertAlmostEqual(qapi.fidelity(self.quantum_memory.peek([0]), s0), 1)
        # Test that rotation is performed when first qubit is |1>.
        IGate('X', ops.X)(self.quantum_memory, [0])  # Set qubit 1 to |1>.
        instr(self.quantum_memory, positions=[0, 1], angle=np.pi, axis=(1, 0, 0))
        self.assertAlmostEqual(qapi.fidelity(self.quantum_memory.peek([0]), s1), 1)

    def test_imeasure(self):
        """Test IMeasure instructions."""
        set_qstate_formalism(QFormalism.DM)
        with self.assertRaises(TypeError):
            instr = IMeasure('measure_instruction', observable=None)
        self.quantum_memory.put(qapi.create_qubits(2), [0, 1])
        instr = IMeasure('measure_instruction')
        IGate('X', ops.X)(self.quantum_memory, [0])  # set qubit 1 to |1>.
        # Measure a single position
        m0 = instr(self.quantum_memory, positions=[0])
        self.assertEqual(m0, [1])
        m1 = instr(self.quantum_memory, positions=[1], meas_operators=ops.Z.projectors)
        self.assertEqual(m1, [0])

    def test_bell_measurement(self):
        """Test the IMeasureBell instruction."""
        projectors = ops.Z.projectors
        bell_operators = [None] * 4
        bell_outcomes = {
            BellIndex.B00: (0, 0),
            BellIndex.B01: (0, 1),
            BellIndex.B10: (1, 0),
            BellIndex.B11: (1, 1)
        }
        for i, (j, k) in bell_outcomes.items():
            bell_operators[i] = ops.Operator(f"BSM{j}{k}",
                                             ops.CNOT * (ops.H ^ ops.I) * (projectors[j] ^ projectors[k]) * (ops.H ^ ops.I) * ops.CNOT)
        IBSM_bell1 = IMeasure("measure_bellstate", meas_operators=bell_operators)
        IBSM_bell2 = IMeasureBell()
        for formalism in QFormalism:
            set_qstate_formalism(formalism)
            # Measure two positions as Bell state
            for IBSM in [IBSM_bell1, IBSM_bell2]:
                for i, state in bell_states.items():
                    qubits = qapi.create_qubits(2, no_state=True)
                    qapi.assign_qstate(qubits, state)
                    self.quantum_memory.put(qubits, [0, 1])
                    if formalism not in QFormalism.universal_formalisms and IBSM == IBSM_bell1:
                        with self.assertRaises(NotImplementedError):
                            IBSM(self.quantum_memory, [0, 1])
                    else:
                        mres, = IBSM(self.quantum_memory, [0, 1])
                        self.assertEqual(mres, i)

    def _test_faulty_measurement_errors(self):
        with self.assertRaises(TypeError):
            IMeasureFaulty('measure_instruction', observable=None)
        # Test incorrect custom values
        instr = IMeasureFaulty('measure_instruction')
        with self.assertRaises(ValueError):
            instr(self.quantum_memory, positions=[1], p0=-1)
        with self.assertRaises(ValueError):
            instr(self.quantum_memory, positions=[1], p1=-1)
        with self.assertRaises(TypeError):
            instr(self.quantum_memory, observable=np.array([[1, 0], [0, 0]]))

    def _test_faulty_measurement_one_qubit(self):
        self.quantum_memory.put(qapi.create_qubits(1), [0])
        instr = IMeasureFaulty('measure_instruction')
        m = instr(self.quantum_memory, positions=[0])
        self.assertEqual(m, [0])
        self.quantum_memory.operate(ops.X, [0])
        m = instr(self.quantum_memory, positions=[0])
        self.assertEqual(m, [1])
        # Test deterministic faulty measurement
        instr = IMeasureFaulty('measure_instruction', p0=1, p1=1)
        m = instr(self.quantum_memory, positions=[0])
        self.assertEqual(m, [0])
        qubit = self.quantum_memory.peek(positions=[0])[0]
        self.assertTrue(np.allclose(ops.Z.projectors[1].arr, qapi.reduced_dm(qubit)))
        # Test we stay in the measurement basis
        instr = IMeasureFaulty('measure_instruction', p0=2/3, p1=1/3)
        instr(self.quantum_memory, positions=[0])[0]
        qubit = self.quantum_memory.peek(positions=[0])[0]
        self.assertTrue(np.allclose(ops.Z.projectors[1].arr, qapi.reduced_dm(qubit)))
        # Test another basis
        instr = IMeasureFaulty('measure_instruction', observable=ops.X)
        m = instr(self.quantum_memory, positions=[0])[0]
        qubit = self.quantum_memory.peek(positions=[0])[0]
        self.assertTrue(np.allclose(ket2dm(ops.X.eigenkets[m]), qapi.reduced_dm(qubit)))

    def _test_faulty_measurement_mixed_states(self):
        # Test a mixed state is produced
        self.quantum_memory.put(qapi.create_qubits(2))
        self.quantum_memory.operate(ops.H, positions=[0])
        instr = IMeasureFaulty('measure_instruction', p0=1/2, p1=1/2)
        instr(self.quantum_memory, positions=[0, 1])
        qubits = self.quantum_memory.peek(positions=[0, 1])
        self.assertTrue(np.allclose(np.array([[0.5, 0], [0, 0.5]]), qapi.reduced_dm(qubits[0])))
        self.assertTrue(np.allclose(ops.Z.projectors[0].arr, qapi.reduced_dm(qubits[1])))

    def _test_faulty_measurement_entanglement(self):
        # Test entanglement
        self.quantum_memory.put(qapi.create_qubits(2), [0, 1])
        self.quantum_memory.operate(ops.H, positions=[0])
        self.quantum_memory.operate(ops.CNOT, positions=[0, 1])
        instr = IMeasureFaulty('measure_instruction', p0=0, p1=0)
        m = instr(self.quantum_memory, positions=[0])[0]
        qubits = self.quantum_memory.peek(positions=[0, 1])
        for qubit in qubits:
            self.assertTrue(np.allclose(ket2dm(ops.Z.eigenkets[m]), qapi.reduced_dm(qubit)))
        # Test with totally mixed measurement
        self.quantum_memory.put(qapi.create_qubits(2), [0, 1])
        self.quantum_memory.operate(ops.H, positions=[0])
        self.quantum_memory.operate(ops.CNOT, positions=[0, 1])
        instr = IMeasureFaulty('measure_instruction', p0=1 / 2, p1=1 / 2)
        instr(self.quantum_memory, positions=[0])[0]
        qubits = self.quantum_memory.peek(positions=[0, 1])
        self.assertTrue(np.allclose(np.array([[0.5, 0, 0, 0],
                                              [0, 0, 0, 0],
                                              [0, 0, 0, 0],
                                              [0, 0, 0, 0.5]]),
                                    qapi.reduced_dm(qubits)))

    def _test_faulty_measurement_inplace(self):
        self.quantum_memory.put(qapi.create_qubits(1), [0])
        instr = IMeasureFaulty('measure_faulty')
        instr(self.quantum_memory, positions=[0], inplace=False)
        self.assertIsNone(self.quantum_memory.peek(positions=[0])[0])

    def test_faulty_measurement(self):
        """Test IMeasureFaulty instructions."""
        set_qstate_formalism(QFormalism.DM)
        self._test_faulty_measurement_errors()
        self._test_faulty_measurement_one_qubit()
        self._test_faulty_measurement_mixed_states()
        self._test_faulty_measurement_entanglement()
        self._test_faulty_measurement_inplace()
        set_qstate_formalism(QFormalism.KET)
        self.quantum_memory.put(qapi.create_qubits(1), positions=[0])
        instr = IMeasureFaulty('measure_instruction', ops.Z, p0=1, p1=0)
        m = instr(self.quantum_memory, positions=[0])[0]
        self.assertEqual(m, 1)
        qubit = self.quantum_memory.peek(positions=[0])[0]
        self.assertEqual(1, qapi.fidelity(qubit, ops.Z.eigenkets[0]))
        instr = IMeasureFaulty('measure_instruction', ops.X, p0=0, p1=0)
        m = instr(self.quantum_memory, positions=[0])[0]
        qubit = self.quantum_memory.peek(positions=[0])[0]
        self.assertAlmostEqual(1, qapi.fidelity(qubit, ops.X.eigenkets[m]))

    def test_iemit(self):
        """Test IEmit instructions."""
        emit_messages = []

        def collect_emit_messages(message):
            nonlocal emit_messages
            emit_messages.append(message)

        # Test memory and emitted qubit are entangled.
        instr = IEmit()
        self.assertEqual(instr.name, "emit_ent_qubit")
        self.quantum_memory.ports["qout"].bind_output_handler(collect_emit_messages)
        instr(self.quantum_memory, positions=[0, 1])
        [memory_qubit] = self.quantum_memory.peek([0], skip_noise=True)
        emitted_qubit = emit_messages.pop().items[0]
        self.assertAlmostEqual(qapi.fidelity([memory_qubit, emitted_qubit], b00), 1)
        # Test emission of empty qubit state if memory qubit not in |0>.
        [memory_qubit] = qapi.create_qubits(1)
        qapi.operate(memory_qubit, ops.X)
        self.quantum_memory.put(memory_qubit, 0)
        instr(self.quantum_memory, positions=[0, 1])
        emitted_qubit = emit_messages.pop().items[0]
        self.assertIsNone(emitted_qubit.qstate)
        # Test additional meta data (including overwriting source).
        instr(self.quantum_memory, positions=[0, 1], meta_data={"comment": "test123"})
        message_meta = emit_messages.pop().meta
        self.assertEqual(message_meta["source"], self.quantum_memory.name)
        self.assertEqual(message_meta["comment"], "test123")
        instr(self.quantum_memory, positions=[0, 1], meta_data={"source": "new_source_name"})
        message_meta = emit_messages.pop().meta
        self.assertEqual(message_meta["source"], "new_source_name")

    def test_discard(self):
        """Test IDiscard class"""
        instr = IDiscard()
        self.assertEqual(instr.name, "discard_qubit")
        nq = 2
        quantum_memory = QuantumMemory(name='test_memory',
                                       num_positions=nq)
        q1, q2 = ns.qubits.create_qubits(nq)
        ns.qubits.combine_qubits([q1, q2])
        quantum_memory.put([q1, q2])
        # Check if the IDiscard instruction properly discards qubit from combined state.
        self.assertEqual(q1.qstate.num_qubits, 2)
        instr(quantum_memory, positions=0)
        self.assertTrue(quantum_memory.mem_positions[0].is_empty)
        self.assertEqual(q2.qstate.num_qubits, 1)


if __name__ == "__main__":
    unittest.main()
