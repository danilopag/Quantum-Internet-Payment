# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_channel.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the channel module.

"""
import unittest
# from unittest.mock import patch
import numpy as np
import pydynaa as pd
import netsquid as ns
from netsquid.components.component import Port, Message
from netsquid.components.channel import Channel, ChannelDelayError
from netsquid.components.models import DelayModel, FixedDelayModel


class SquaredDelayModel(DelayModel):
    """A test delay model that returns the square of a specified delay.

    """

    def __init__(self, delay):
        super().__init__()
        self.delay = delay

    def get_mean(self, channel):
        return self.generate_delay()

    def set_mean(self, value):
        self.delay = value ** 0.5

    def get_std(self):
        return 0

    def generate_delay(self, **kwargs):
        return self.delay ** 2


class DecrementingDelayModel(DelayModel):
    """A test delay model that returns a shrinking delay.

    """

    def __init__(self, delay):
        super().__init__()
        self.delay = delay

    def get_mean(self, channel):
        # ill-defined
        return self.generate_delay()

    def set_mean(self, value):
        self.delay = value / 3 * 4

    def get_std(self):
        return 0

    def generate_delay(self, **kwargs):
        delay = self.delay
        self.delay = self.delay * 0.5
        return delay


class TestChannel(unittest.TestCase):
    """Unit tests for the channel module.

    """

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        ns.sim_reset()
        self.god = pd.Entity()  # helper entity
        self.EVT_END_EVENT = pd.EventType("END", "Dummy end of simulation event")
        self.test_items = ["cat", "dog", "elephant", "fox", "goat"]
        self.Channel_cls = Channel

    def _send_item_on_channel(self, channel, item, delay=0):
        # Helper function to test a channel by preparing it with an item
        EVT_PUT_EVENT = pd.EventType("PUT", "Put an item on the channel")

        def put_callback(event):
            channel.send(item)

        # Put item on channel after delay
        event = self.god._schedule_after(delay, event_type=EVT_PUT_EVENT)
        self.god._wait_once(pd.EventHandler(put_callback), event=event)

    def _wait_for_channel_items(self, channel=None):
        # Helper function to wait and read from Channel
        ns.sim_reset()
        self.read_items = []
        self.read_deltatimes = []
        self.callback_count = 0

        def receive_callback(event):
            self.callback_count += 1
            read_items, read_deltatime = event.source.component.receive()
            if len(read_items) == 1:
                read_items = read_items[0]
            self.read_items.append(read_items)
            self.read_deltatimes.append(read_deltatime)

        # receive item from channel once ready
        self.foo = pd.EventHandler(receive_callback)
        entity = channel.ports["recv"] if channel is not None else None
        self.god._wait(self.foo, entity=entity, event_type=Port.evtype_output)

    def _send_message_via_port(self, channel, message, delay=0):
        # Helper function to test a channel by preparing it with an item
        EVT_PUT_EVENT = pd.EventType("PUT", "Put an item on the channel")

        def put_callback(event):
            channel.ports["send"].tx_input(message)

        # Put item on channel after delay
        event = self.god._schedule_after(delay, event_type=EVT_PUT_EVENT)
        self.god._wait_once(pd.EventHandler(put_callback), event=event)

    def _wait_for_message_via_port(self, channel=None):
        # Helper function to wait and read from Channel
        ns.sim_reset()
        self.read_messages = []
        self.callback_count = 0

        def receive_callback(event):
            self.callback_count += 1
            message = event.source.rx_input()
            self.read_messages.append(message)

        # receive item from channel once ready
        self.foo = pd.EventHandler(receive_callback)
        entity = channel.ports["recv"] if channel is not None else None
        self.god._wait(self.foo, entity=entity, event_type=Port.evtype_output)

    def test_Channel_ready(self):
        """Test Channel ready event functionality"""
        # Ensure sure EventTypes are not equal
        c = self.Channel_cls("ChannelTest")
        start_delay = 5
        self._wait_for_channel_items(c)
        self._send_item_on_channel(c, self.test_items[0], start_delay)
        # Attempt to read channel before simulator has reached EVT_READY event:
        self.assertTrue(c.output_empty)
        self.assertEqual(c.receive(), ([], 0))
        ns.sim_run()
        self.assertEqual(len(self.read_items), 1)
        self.assertEqual(self.read_items[0], self.test_items[0])
        self.assertEqual(self.read_deltatimes[0], 0)
        # Test default ready event type
        self._wait_for_channel_items(c)
        self._send_item_on_channel(c, self.test_items[1], start_delay)
        ns.sim_run()
        self.assertEqual(len(self.read_items), 1)
        self.assertEqual(self.callback_count, 1)
        self.assertEqual(self.read_items[0], self.test_items[1])
        self.assertEqual(self.read_deltatimes[0], 0)

    def test_Channel_multi_transmit(self):
        """Test Channel multiple transmissions"""
        c = self.Channel_cls("ChannelTest", delay=10)
        self._wait_for_channel_items(c)
        for i, test_item in enumerate(self.test_items):
            self._send_item_on_channel(c, test_item, i)
        ns.sim_run()
        # Expect to have received both puts:
        self.assertEqual(len(self.read_items), len(self.test_items))
        for i in range(len(self.read_items)):
            self.assertEqual(self.read_items[i], self.test_items[i])

    def test_Channel_multiplex(self):
        """Test Channel multiplex"""
        channel = self.Channel_cls("ChannelTest", delay=10)
        self._wait_for_channel_items(channel)
        # put all items on at same time, also test that ready evtype
        # will only be called once
        for test_item in self.test_items:
            channel.send(test_item)
        ns.sim_run()
        # Expect to have received all items with one get in correct order:
        self.assertEqual(len(self.read_items), 1)
        for i in range(len(self.read_items)):
            self.assertEqual(self.read_items[0][i], self.test_items[i])

    # def test_Channel_max_bandwidth(self):
    #    """Test Channel max bandwidth"""
    #    c = self.Channel_cls("ChannelTest", delay=10)
    #    c.bandwidth = len(self.test_items) - 1
    #    self._wait_for_channel_items(c)
    #    # Test putting list bigger than bandwidth
    #    with self.assertRaises(ChannelBandwidthError):
    #        c.send(self.test_items)
    #    for test_item in self.test_items[1:]:
    #        c.send(test_item)
    #    # Test putting one item too many than bandwidth
    #    with self.assertRaises(ChannelBandwidthError):
    #        c.send(self.test_items[0])

    def test_Channel_receive_with_headers(self):
        """Test Channel receive call with headers"""
        delay = 10
        chan = self.Channel_cls("ChannelTest", delay=delay)
        headers = []
        for i, item in enumerate(self.test_items):
            headers.append("K{}".format(i))
            chan.send(item, header=headers[i])
        ns.sim_run()
        # Retrieve items one by one:
        for header, test_item in zip(headers, self.test_items):
            items, delta_time = chan.receive(header=header)
            self.assertAlmostEqual(delay, delta_time)
            self.assertEqual(len(items), 1)
            self.assertEqual(items[0], test_item)
        self.assertEqual(chan.receive(), ([], 0))
        # Retrieve multiple items at once:
        chan.send(self.test_items[:2], header="A")
        chan.send(self.test_items[2:], header="B")
        ns.sim_run()
        items, __ = chan.receive(header="A")
        self.assertEqual(items, self.test_items[:2])
        items, __ = chan.receive(header="B")
        self.assertEqual(items, self.test_items[2:])

    def test_Channel_peek(self):
        """Test Channel peek"""
        delay = 10
        chan = self.Channel_cls("ChannelTest", delay=delay)
        # chan.bandwidth = len(self.test_items)
        # ## Test peek on empty channel
        for i in range(3):
            peek_items, received = chan.peek(index=i)
            self.assertEqual(len(peek_items), 0)
            self.assertFalse(received)
        # ## Test peek before received
        for i, item in enumerate(self.test_items):
            self._send_item_on_channel(chan, item, delay=i / 100)
            # chan.send(item, append=False)
        ns.sim_run(len(self.test_items) / 100)
        for i, item in enumerate(self.test_items):
            peek_items, received = chan.peek(index=i, postprocess=True)
            self.assertEqual(len(peek_items), 1)
            self.assertEqual(peek_items[0], item)
            self.assertFalse(received)
        ns.sim_run()
        # ## Test peeking after received. Only last message
        # will be kept by channel
        peek_items, received = chan.peek(postprocess=True)
        self.assertEqual(peek_items[0], self.test_items[-1])
        self.assertTrue(received)
        # ## Test peek with headers
        chan.reset()
        headers = []
        for i, item in enumerate(self.test_items):
            headers.append("K{}".format(i))
            chan.send(item, header=headers[i])
        # Test peeking before received
        for header, item in zip(headers, self.test_items):
            peek_items, received = chan.peek(header=header, postprocess=True)
            self.assertEqual(len(peek_items), 1)
            self.assertEqual(peek_items[0], item)
            self.assertFalse(received)
        ns.sim_run()
        # Test peeking after received
        for header, item in zip(headers, self.test_items):
            peek_items, received = chan.peek(header=header, postprocess=True)
            self.assertEqual(len(peek_items), 1)
            self.assertEqual(peek_items[0], item)
            self.assertTrue(received)
        # ## Test partial received i.e. one message on port, others in transit
        chan.reset()
        ns.sim_reset()
        for i, item in enumerate(self.test_items[:3]):
            self._send_item_on_channel(chan, item, delay=i * 2)
        ns.sim_run(delay + 1)
        # First message should be received (and on port)
        peek_items, received = chan.peek(index=0, postprocess=True)
        self.assertEqual(len(peek_items), 1)
        self.assertEqual(peek_items[0], self.test_items[0])
        self.assertTrue(received)
        # Next two messages still in transit
        for i, item in enumerate(self.test_items[1:3]):
            peek_items, received = chan.peek(index=i + 1, postprocess=True)
            self.assertEqual(len(peek_items), 1)
            self.assertEqual(peek_items[0], item)
            self.assertFalse(received)

    def test_Channel_empty_message_loss(self):
        """Test Channel loss of empty messages"""
        delay = 10
        chan = self.Channel_cls("ChannelTest", delay=delay)
        # First do control case
        chan.transmit_empty_items = False
        chan.send(self.test_items[0])
        ns.sim_run()
        self.assertFalse(chan.output_empty)
        items, __ = chan.receive()
        self.assertEqual(items, self.test_items[0:1])
        # Now try empty item
        chan.send(None)
        ns.sim_run()
        self.assertTrue(chan.output_empty)
        # Now try list of empty items
        chan.send([None, None, None])
        ns.sim_run()
        self.assertEqual(chan.receive(), ([], 0))
        # Repeat, but now allowing empty transmissions
        ns.sim_reset()
        chan.transmit_empty_items = True
        chan.reset()
        chan.send([None, None, None])
        ns.sim_run()
        self.assertEqual(chan.receive(), ([None, None, None], 10.0))
        # Test ready event not fired
        ns.sim_reset()
        chan.reset()
        chan.transmit_empty_items = False
        self._wait_for_channel_items(chan)
        self._send_item_on_channel(chan, None, delay)
        self._send_item_on_channel(chan, [None, None], delay)
        self.assertEqual(len(self.read_items), 0)
        self.assertEqual(self.callback_count, 0)
        ns.sim_run()
        self.assertEqual(len(self.read_items), 0)
        self.assertEqual(self.callback_count, 0)

    def test_Channel_empty_items(self):
        """Test Channel receive only returns non-empty items"""
        delay = 10
        chan = self.Channel_cls("ChannelTest", delay=delay)
        chan.send([self.test_items[0], None, None, self.test_items[1]])
        ns.sim_run()
        items, __ = chan.receive()
        self.assertEqual(len(items), 2)
        self.assertEqual(items, [self.test_items[0], self.test_items[1]])
        self.assertTrue(chan.output_empty)

    def test_Channel_reset(self):
        """Test Channel reset."""
        c = self.Channel_cls("ChannelTest", delay=10)
        self._wait_for_channel_items(c)
        for i, test_item in enumerate(self.test_items):
            self._send_item_on_channel(c, test_item, i)
        # run until all items transmitting (but none yet arrived)
        ns.sim_run(len(self.test_items))
        self.assertEqual(len(self.read_items), 0)
        self.assertTrue(c.transmitting)
        self.assertTrue(c.last_rx_time >= 0)
        c.reset()
        self.assertFalse(c.transmitting)
        ns.sim_run()
        self.assertEqual(len(self.read_items), 0)
        self.assertTrue(c.last_rx_time < 0)

    def test_Channel_last_rx_time(self):
        """Test Channel properly accounts time of last scheduled receive"""
        delay = 10
        c = self.Channel_cls("ChannelTest", delay=delay)
        self.assertTrue(c.last_rx_time < 0)
        c.send(self.test_items[0])
        self.assertEqual(c.last_rx_time, ns.sim_time() + delay)
        ns.sim_run(delay // 2)
        self.assertAlmostEqual(c.last_rx_time, delay)
        ns.sim_run()
        self.assertTrue(c.last_rx_time < 0)

    # @patch('netsquid.components.channel.logger.warning')
    # def test_Channel_warn_on_discard(self, mock_warning):
    #    """Test Channel warns when discarding waiting outputs"""
    #    c = self.Channel_cls("ChannelTest", delay=10)
    #    c.warn_on_discard = True
    #    # send items that we won't retrieve on channel
    #    c.send(self.test_items[0])
    #    ns.sim_run()
    #    # send item that we will wait for on channel at later time
    #    self._wait_for_channel_items(c)
    #    self._send_item_on_channel(c, self.test_items[1], 5)
    #    ns.sim_run()
    #    self.assertEqual(mock_warning.call_count, 1)
    #    #mock_warning.assert_called_once()  # Python 3.6+ only

    def test_Channel_fixed_delay_model(self):
        """Test Channel fixed delay functionality"""
        # If only 'delay' given, Channel should default to FixedDelayModel
        delay1 = 17
        c = self.Channel_cls("ChannelTest", delay=delay1)
        self.assertIsInstance(c.models["delay_model"], FixedDelayModel)
        self.assertAlmostEqual(c.models["delay_model"].delay, delay1)
        self.assertAlmostEqual(c.models["delay_model"](), delay1)
        self.assertAlmostEqual(c.compute_delay(), delay1)
        self.assertAlmostEqual(c.compute_delay(), delay1)
        # Test assigning a new FixedDelayModel
        delay2 = 87
        delay_model = FixedDelayModel(delay2)
        c.models["delay_model"] = delay_model
        self.assertIsInstance(c.models["delay_model"], DelayModel)
        self.assertEqual(c.models["delay_model"](), delay2)
        start_delay = 5
        self._wait_for_channel_items(c)
        self._send_item_on_channel(c, self.test_items[0], start_delay)
        ns.sim_run(start_delay + 1)
        # Attempt to read channel before simulator has reached EVT_READY event:
        # with self.assertRaises(ChannelOutputError):
        #    c.receive()
        self.assertEqual(c.receive(), ([], 0))
        ns.sim_run()
        self.assertEqual(len(self.read_items), 1)
        self.assertEqual(self.read_items[0], self.test_items[0])
        self.assertAlmostEqual(self.read_deltatimes[0], delay2)

    def test_Channel_arbitrary_delay_model(self):
        """Test Channel arbitrary delay model functionality."""
        real_delay = 87
        unused_delay = 7
        delay_model = SquaredDelayModel(np.sqrt(real_delay))
        c = self.Channel_cls("ChannelTest", delay=unused_delay, models={"delay_model": delay_model})
        self.assertIsInstance(c.models["delay_model"], SquaredDelayModel)
        self.assertAlmostEqual(c.models["delay_model"], delay_model)
        self.assertAlmostEqual(c.models["delay_model"](), real_delay)
        self.assertAlmostEqual(c.compute_delay(), real_delay)
        self.assertAlmostEqual(c.compute_delay(), real_delay)
        start_delay = 5
        self._wait_for_channel_items(c)
        self._send_item_on_channel(c, self.test_items[0], start_delay)
        ns.sim_run(start_delay + 1)
        ns.sim_run()
        self.assertEqual(len(self.read_items), 1)
        self.assertEqual(self.read_items[0], self.test_items[0])
        self.assertAlmostEqual(self.read_deltatimes[0], real_delay)
        delay = 1024
        delay_model = DecrementingDelayModel(delay)
        c = self.Channel_cls("ChannelTest", models={"delay_model": delay_model})
        for i in range(3):
            self.assertAlmostEqual(c.compute_delay(), delay / 2 ** i)
        self._wait_for_channel_items(c)
        # Check channel delay error thrown for non FIFO transmission
        self._send_item_on_channel(c, self.test_items[0], 0)
        self._send_item_on_channel(c, self.test_items[0], 1e-5)
        with self.assertRaises(ChannelDelayError):
            ns.sim_run()

    def test_Channel_zero_delay(self):
        """Test Channel zero delay functionality"""
        c = self.Channel_cls("ChannelTest", delay=0)
        self.assertIsInstance(c.models["delay_model"], FixedDelayModel)
        self.assertAlmostEqual(c.models["delay_model"].delay, 0)
        self.assertAlmostEqual(c.models["delay_model"](), 0)

    def test_Channel_negative_delay(self):
        """Test Channel negative delay functionality"""
        with self.assertRaises(ValueError):
            self.Channel_cls("ChannelTest", delay=-1)

    def test_Channel_negative_length(self):
        """Test Channel negative length functionality"""
        with self.assertRaises(ValueError):
            self.Channel_cls("ChannelTest", length=-1)

    def test_channel_port_init(self):
        """Test initialization of Channel's ports."""
        channel = Channel("TestChannel")
        self.assertTrue("send" in channel.ports)
        self.assertTrue("recv" in channel.ports)
        self.assertIsInstance(channel.ports["send"], Port)
        self.assertIsInstance(channel.ports["recv"], Port)
        self.assertEqual(channel.ports["send"], channel.ports["send"])
        self.assertEqual(channel.ports["recv"], channel.ports["recv"])
        self.assertFalse(channel.ports["send"].is_connected)
        self.assertFalse(channel.ports["recv"].is_connected)

    def test_port_channel_chain(self):
        """Test chaining of channels using ports."""
        # Create channels
        ch_delays = [5, 3, 1.5]
        channels = [Channel("TestChannel{}".format(i), delay=delay) for i, delay in enumerate(ch_delays)]
        # Connect channels
        for i in range(0, len(channels) - 1):
            channels[i].ports["recv"].connect(channels[i + 1].ports["send"])
        # Prepare for output
        received = []

        def get_output(message):
            nonlocal received
            received.append(message)

        channels[-1].ports["recv"].bind_output_handler(get_output)
        # Send two messages along channel chain
        msg_delay = 3.3
        message1 = Message(self.test_items[:2])
        message2 = Message(self.test_items[2:])
        self._send_message_via_port(channels[0], message1, delay=0)
        self._send_message_via_port(channels[0], message2, delay=msg_delay)
        ns.sim_run()
        self.assertEqual(len(received), 2)
        self.assertEqual(type(received[0]), Message)
        self.assertEqual(type(received[1]), Message)
        self.assertTrue(received[0] is message1)
        self.assertTrue(received[1] is message2)
        self.assertEqual(received[0].items, self.test_items[:2])
        self.assertEqual(received[1].items, self.test_items[2:])
        self.assertEqual(received[0].meta["ch_delta_time"], ch_delays[-1])
        self.assertEqual(received[1].meta["ch_delta_time"], ch_delays[-1])
        self.assertAlmostEqual(ns.sim_time(), sum(ch_delays) + msg_delay)


if __name__ == "__main__":
    unittest.main()
