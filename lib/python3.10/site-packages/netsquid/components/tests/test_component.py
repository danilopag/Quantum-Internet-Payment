# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_component.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the component module.

"""
import unittest
import netsquid as ns
import pydynaa as pd
import gc
from netsquid.components.component import Component, Message, Port, ComponentHierarchyError
from netsquid.components.models.model import Model
from netsquid.util.constrainedmap import ImmutabilityError
from netsquid.qubits import qubitapi as qapi


class SimpleChannel(Component):
    """A simple one-way channel using ports."""

    _evtype_rx = pd.EventType("RX", "Message has been received")

    def __init__(self, name, delay):
        # self.delay = delay
        # super().__init__(name, properties={"delay": delay})
        super().__init__(name)
        self.add_property("delay", value=delay)
        self.messages = []
        port_in, __ = self.add_ports(["send", "recv"])
        port_in.bind_input_handler(self.handle_input)

    def send(self, message):
        # Helper method to send through input port
        self.ports["send"].tx_input(message)

    def receive(self):
        # Helper method to receive from output port
        return self.ports["recv"].rx_output()

    def handle_input(self, message):
        self.messages.insert(0, message)
        event = self._schedule_after(self.properties["delay"], self._evtype_rx)
        self._wait_once(pd.EventHandler(self.handle_output), event=event)

    def handle_output(self, event):
        if len(self.messages) > 0:
            message = self.messages.pop()
            self.ports["recv"].tx_output(message)

    def reset(self):
        super().reset()


class CompositeComponent(Component):
    """A composite component built from SimpleChannel sub-components.

    Creates four channels and internally forwards/connects their ports as follows

    .. code-block:: none

        A.tx_input  --(forward)-> C0 --(connect)-> C1 --(forward)-> B.tx_output
        A.tx_output <-(forward)-- C2 <-(connect)-- C3 <-(forward)-- B.tx_input

    Channels delays are: C0 = 1, C1 = 2, C2 = 3, C4 = 4. Delay from A to B is 3
    while reverse delay is 7.

    """

    def __init__(self, name):
        super().__init__(name)
        self.add_ports(["A", "B"])
        for i in range(4):
            self.add_subcomponent(SimpleChannel("Channel{}".format(i), delay=(1 + i)))
        self._setup_ports()

    def _setup_ports(self):
        # Setup ports of this component to use one-way channels as follows:
        port_A, port_B = self.ports["A"], self.ports["B"]
        # Connect C0 to C1
        self.subcomponents["Channel0"].ports["recv"].connect(self.subcomponents["Channel1"].ports["send"])
        # Connect C2 to C3
        self.subcomponents["Channel2"].ports["recv"].connect(self.subcomponents["Channel3"].ports["send"])
        # Forward ports:
        port_A.forward_input(self.subcomponents["Channel0"].ports["send"])
        port_B.forward_input(self.subcomponents["Channel2"].ports["send"])
        self.subcomponents["Channel1"].ports["recv"].forward_output(port_B)
        self.subcomponents["Channel3"].ports["recv"].forward_output(port_A)


class TestPort(unittest.TestCase):
    """Unit tests for the Port class."""

    def setUp(self):
        ns.sim_reset()
        self.items = ["apple", "pear", "banana", "pineapple"]
        self.helper = pd.Entity()

        class TestComponent(Component):
            pass

        self.TestComponent = TestComponent

    def test_port_init(self):
        """Test initialization of port."""
        port_name = "TestPort"
        comp_name = "TestComponent"
        component = self.TestComponent(comp_name)
        port = Port(port_name, component)
        self.assertEqual(port.name, port_name)
        self.assertEqual(port.component, component)
        self.assertEqual(str(port), "{}:{}".format(comp_name, port_name))
        self.assertEqual(port.is_connected, False)
        self.assertEqual(port.forwarded_ports, {})

    def test_port_transmit(self):
        """Test port transmit (tx) methods."""
        port = Port("TestPort", self.TestComponent("TestComp"))
        # Check queue (FIFO) behaviour of output
        self.assertEqual(len(port.output_queue), 0)
        for i, item in enumerate(self.items):
            port.tx_output(Message(item))
            self.assertEqual(len(port.output_queue), i + 1)
        for i, item in enumerate(self.items):
            msg = port.rx_output()
            self.assertEqual(msg.items, [item])
        self.assertEqual(len(port.output_queue), 0)
        self.assertEqual(len(port.input_queue), 0)
        for i, item in enumerate(self.items):
            port.tx_input(Message(item))
            self.assertEqual(len(port.input_queue), i + 1)
        for i, item in enumerate(self.items):
            msg = port.rx_input()
            self.assertEqual(msg.items, [item])
        self.assertEqual(len(port.input_queue), 0)

    def test_port_transmit_events(self):
        """Test port transmit event scheduling."""
        comp1 = self.TestComponent("TestComp1")
        comp2 = self.TestComponent("TestComp2")
        comp3 = self.TestComponent("TestComp3")
        comp2.add_subcomponent(comp3)
        n = len(self.items)
        # Test event scheduling for ports
        # A free port should always schedule events:
        port_free = Port("TestPort1", comp1)
        # A connected port should not schedule output event:
        port_connected = Port("TestPort2", comp1)
        port_connected.connect(Port("TestPort3", comp2))
        # A connected port with notify should schedule event, but won't have a message:
        port_connected2 = Port("TestPort4", comp1)
        port_connected2.connect(Port("TestPort5", comp2))
        # A forwarded port should not schedule input event:
        port_forwarded = Port("TestPort6", comp2)
        port_forwarded.forward_input(Port("TestPort7", comp3))
        # A forwarded port with notify should schedule event, but won't have a message:
        port_forwarded2 = Port("TestPort6", comp2)
        port_forwarded2.forward_input(Port("TestPort7", comp3))
        for port, res_input, res_output, input_count, output_count, always_notify in [
            (port_free, self.items, self.items, n, n, None),
            (port_connected, self.items, [], n, 0, None),
            (port_connected2, self.items, [], n, n, "output"),
            (port_forwarded, [], self.items, 0, n, None),
            (port_forwarded2, [], self.items, n, n, "input"),
        ]:
            received_input = []
            received_output = []
            num_output_callbacks = 0
            num_input_callbacks = 0
            if always_notify == "output":
                port.notify_all_output = True
            elif always_notify == "input":
                port.notify_all_input = True

            def output_callback(event):
                nonlocal num_output_callbacks
                num_output_callbacks += 1
                msg = event.source.rx_output(event)
                if msg:
                    received_output.append(msg)

            def input_callback(event):
                nonlocal num_input_callbacks
                num_input_callbacks += 1
                msg = event.source.rx_input(event)
                if msg:
                    received_input.append(msg)

            self.helper._wait(pd.EventHandler(output_callback), event_type=Port.evtype_output, entity=port)
            self.helper._wait(pd.EventHandler(input_callback), event_type=Port.evtype_input, entity=port)
            for i, item in enumerate(self.items):
                if i % 1:
                    port.notify_next_output = True
                    port.notify_next_input = True
                self.assertEqual(port.notify_next_output, always_notify == "output" or i % 1)
                self.assertEqual(port.notify_next_input, always_notify == "input" or i % 1)
                port.tx_output(Message(item))
                port.tx_input(Message(item))
            ns.sim_run()
            # Event order random for same instant, so use sets
            self.assertEqual(set([msg.items[0] for msg in received_output]), set(res_output))
            self.assertEqual(num_output_callbacks, output_count)
            self.assertEqual(set([msg.items[0] for msg in received_input]), set(res_input))
            self.assertEqual(num_input_callbacks, input_count)

    def test_port_transmit_with_meta_filtering(self):
        """Test transmit with message meta filtering."""
        port = Port("TestPort", self.TestComponent("TestComp"))
        self.assertEqual(len(port.output_queue), 0)
        port.tx_output(Message(self.items[1], bar=12))
        port.tx_output(Message(self.items[2]))
        port.tx_output(Message(self.items[0], foo=5))
        port.tx_output(Message(self.items[3], foo=5, bar=12))
        self.assertEqual(port.rx_output(foo=5, bar=8), None)
        self.assertEqual(port.rx_output(foo=5, bar=12).items, [self.items[3]])
        self.assertEqual(port.rx_output(foo=5).items, [self.items[0]])
        # Below should return next message in queue, irrespective of header
        msg = port.rx_output()
        self.assertEqual(msg.items, [self.items[1]])
        self.assertEqual(msg.meta, {"bar": 12})

    def test_port_connect(self):
        """Test connecting ports."""
        port1 = Port("TestPort1", self.TestComponent("TestComp1"))
        port2 = Port("TestPort2", self.TestComponent("TestComp2"))
        self.assertEqual(port1.is_connected, False)
        self.assertEqual(port2.is_connected, False)
        port1.connect(port2)
        self.assertEqual(port1.is_connected, True)
        self.assertEqual(port2.is_connected, True)
        self.assertEqual(port1.connected_port, port2)
        self.assertEqual(port2.connected_port, port1)
        self.assertEqual(port1.forwarded_ports, {})
        # Test disconnect
        port1.disconnect()
        self.assertEqual(port1.is_connected, False)
        self.assertEqual(port2.is_connected, False)
        self.assertEqual(port1.connected_port, None)
        self.assertEqual(port2.connected_port, None)
        # Test connection
        port1.connect(port2)
        self.assertEqual(len(port1.output_queue), 0)
        self.assertEqual(len(port2.input_queue), 0)
        for i, item in enumerate(self.items):
            port1.tx_output(Message(item))
            self.assertEqual(len(port2.input_queue), i + 1)
        for i, item in enumerate(self.items):
            msg = port2.rx_input()
            self.assertEqual(msg.items, [item])

    def test_port_connect_subcomponents(self):
        """Test connecting ports of subcomponents."""

        class TestComponent(Component):
            def __init__(self, name):
                super().__init__(name=name)
                self.add_ports(["P0"])

        # Create composite component tree of depth 2
        comps = [TestComponent("Comp{}".format(i)) for i in range(7)]
        comps[0].add_subcomponent(comps[1])
        comps[0].add_subcomponent(comps[2])
        comps[1].add_subcomponent(comps[3])
        comps[4].add_subcomponent(comps[5])
        comps[4].add_subcomponent(comps[6])
        # Test valid connections
        for i, j in [(0, 4), (1, 2), (5, 6)]:
            comps[i].ports["P0"].connect(comps[j].ports["P0"])
            comps[i].ports["P0"].disconnect()
        # Test invalid hierarchical connections
        for i, j in [(0, 1), (0, 5), (0, 3), (1, 3), (1, 4), (1, 5)]:
            with self.assertRaises(ValueError):
                comps[i].ports["P0"].connect(comps[j].ports["P0"])

    def test_port_forward(self):
        """Test forwarding ports."""
        comp1 = self.TestComponent("TestComp1")
        comp2 = self.TestComponent("TestComp2")
        comp3 = self.TestComponent("TestComp3")
        comp4 = self.TestComponent("TestComp4")
        comp2.add_subcomponent(comp1)
        comp1.add_subcomponent(comp3)
        comp3.add_subcomponent(comp4)
        port1 = Port("TestPort1", comp1)
        port2 = Port("TestPort2", comp2)
        port3 = Port("TestPort3", comp3)
        port4 = Port("TestPort4", comp4)
        # Forward output to one port
        port1.forward_output(port2)
        self.assertEqual(port1.is_connected, False)
        self.assertEqual(port2.is_connected, False)
        self.assertEqual(port1.forwarded_ports, {"output": port2})
        self.assertEqual(port2.forwarded_ports, {})
        # Forward input through two ports
        port1.forward_input(port3)
        port3.forward_input(port4)
        self.assertEqual(port1.forwarded_ports, {"output": port2, "input": port3})
        self.assertEqual(port3.forwarded_ports, {"input": port4})
        self.assertEqual(port4.forwarded_ports, {})
        self.assertEqual(port3.is_connected, False)
        self.assertEqual(port4.is_connected, False)
        # Test disconnect only applies to output
        port1.disconnect()
        self.assertEqual(port1.forwarded_ports, {"input": port3})
        # Test connection
        port1.forward_output(port2)
        # Test output forwarding
        self.assertEqual(len(port1.output_queue), 0)
        self.assertEqual(len(port2.output_queue), 0)
        for i, item in enumerate(self.items):
            port1.tx_output(Message(item))
            self.assertEqual(len(port2.output_queue), i + 1)
        self.assertEqual(len(port1.output_queue), 0)
        for i, item in enumerate(self.items):
            msg = port2.rx_output()
            self.assertEqual(msg.items, [item])
        self.assertEqual(len(port2.output_queue), 0)
        # Test input forwarding
        self.assertEqual(len(port1.input_queue), 0)
        self.assertEqual(len(port3.input_queue), 0)
        self.assertEqual(len(port4.input_queue), 0)
        for i, item in enumerate(self.items):
            port1.tx_input(Message(item))
            self.assertEqual(len(port4.input_queue), i + 1)
        self.assertEqual(len(port1.input_queue), 0)
        self.assertEqual(len(port3.input_queue), 0)
        for i, item in enumerate(self.items):
            msg = port4.rx_input()
            self.assertEqual(msg.items, [item])
        self.assertEqual(len(port4.input_queue), 0)

    def test_double_forwarding(self):
        a = Component("A", port_names=["port"])
        b = Component("B", port_names=["port"])
        c = Component("C", port_names=["port"])
        d = Component("D", port_names=["port"])
        d.add_subcomponent(c)
        c.add_subcomponent(b)
        b.add_subcomponent(a)

        port_a = a.ports["port"]
        port_b = b.ports["port"]
        port_c = c.ports["port"]
        port_d = d.ports["port"]
        port_b.forward_input(port_a)
        port_d.forward_input(port_c)
        port_c.forward_input(port_b)
        port_a.forward_output(port_b)
        port_c.forward_output(port_d)
        port_b.forward_output(port_c)

        port_d.tx_input("input")
        port_a.tx_output("output")
        ns.sim_run()
        self.assertEqual(port_a.rx_input().items, ["input"])
        self.assertEqual(port_d.rx_output().items, ["output"])

    def test_port_incorrect_hierarchy(self):
        """Test if ports are forwarded to correct components"""
        port_names = ["port1", "port2"]
        grandma = Component("grandma", port_names=port_names)
        dad = Component("dad", port_names=port_names)
        aunt = Component("aunt", port_names=port_names)
        cousin = Component("cousin", port_names=port_names)
        me = Component("me", port_names=port_names)
        son = Component("son", port_names=port_names)
        grandson = Component("grandson", port_names=port_names)
        sister = Component("sister", port_names=port_names)
        alien = Component("alien", port_names=port_names)
        grandma.add_subcomponent(dad)
        grandma.add_subcomponent(aunt)
        dad.add_subcomponent(me)
        dad.add_subcomponent(sister)
        me.add_subcomponent(son)
        son.add_subcomponent(grandson)
        aunt.add_subcomponent(cousin)

        family = [grandma, dad, aunt, cousin, me, son, grandson, sister, alien]
        results_input = [False, False, False, False, True, True, False, False, False]
        results_output = [False, True, False, False, True, False, False, False, False]
        results_connect = [False, False, False, False, False, False, False, True, False]
        for fam_member, is_possible in zip(family, results_input):
            if is_possible:
                me.ports["port1"].forward_input(fam_member.ports["port2"])
            else:
                with self.assertRaises(ValueError):
                    me.ports["port1"].forward_input(fam_member.ports["port2"])
        for fam_member, is_possible in zip(family, results_output):
            if is_possible:
                me.ports["port1"].forward_output(fam_member.ports["port2"])
            else:
                with self.assertRaises(ValueError):
                    me.ports["port1"].forward_output(fam_member.ports["port2"])
        for fam_member, is_possible in zip(family, results_connect):
            if is_possible:
                me.ports["port1"].connect(fam_member.ports["port2"])
            else:
                with self.assertRaises(ValueError):
                    me.ports["port1"].connect(fam_member.ports["port2"])

    def test_port_binding(self):
        """Test forwarding ports."""
        port = Port("TestPort", self.TestComponent("TestComp"))
        messages = []

        def handler(message):
            messages.append(message)

        # Test binding input
        port.bind_input_handler(handler, tag_meta=True)
        for item in self.items:
            port.tx_input(Message(item))
        self.assertEqual(len(messages), len(self.items))
        for msg, item in zip(messages, self.items):
            self.assertEqual(msg.items, [item])
            self.assertEqual(msg.meta, {"rx_port_name": "TestPort"})
        # Test binding output
        messages.clear()
        port.bind_output_handler(handler, tag_meta=True)
        for item in self.items:
            port.tx_output(Message(item))
        self.assertEqual(len(messages), len(self.items))
        for msg, item in zip(messages, self.items):
            self.assertEqual(msg.items, [item])
            self.assertEqual(msg.meta, {"rx_port_name": "TestPort"})

    def test_port_discard_qubit(self):
        """Test that qubits are discarded if they are not picked up at a port"""
        # Test single port
        port1 = Port("TestPort", self.TestComponent("TestComp1"))
        qubits = ns.qubits.create_qubits(9)
        qstates = [q.qstate for q in qubits]
        port1.tx_input(qubits.pop(0))  # Qubit 1
        port1.tx_output(qubits.pop(0))  # Qubit 2
        # We can't have the method reference the qubit objects
        # So we have to work via the qstate objects.
        self.assertIsNotNone(qstates[0].qubits[0].qstate)
        self.assertIsNotNone(qstates[1].qubits[0].qstate)
        ns.sim_run(10)
        self.assertIsNotNone(qstates[0].qubits[0].qstate)
        self.assertIsNotNone(qstates[1].qubits[0].qstate)
        gc.collect()  # Force garbage collection
        port1.tx_input(0)
        self.assertIsNone(qstates[0].qubits[0].qstate)
        self.assertIsNotNone(qstates[1].qubits[0].qstate)
        gc.collect()  # Force garbage collection
        port1.tx_output(0)
        self.assertIsNone(qstates[1].qubits[0].qstate)
        # Test connected port
        port2 = Port("TestPort", self.TestComponent("TestComp2"))
        port1.connect(port2)
        port1.tx_output(qubits.pop(0))  # Qubit 3
        self.assertIsNotNone(qstates[2].qubits[0].qstate)
        ns.sim_run(20)
        self.assertIsNotNone(qstates[2].qubits[0].qstate)
        gc.collect()  # Force garbage collection
        port2.rx_input()
        self.assertIsNone(qstates[2].qubits[0].qstate)
        port1.tx_output(qubits.pop(0))
        q4in = port2.rx_input().items[0]
        self.assertIsNotNone(q4in.qstate)
        self.assertIs(q4in, qstates[3].qubits[0])
        ns.sim_run(30)
        self.assertIsNotNone(q4in.qstate)
        self.assertIs(q4in, qstates[3].qubits[0])
        # Test external references saves from discard
        port1.tx_input(qubits.pop(0))  # Qubit 5
        port1.tx_output(qubits.pop(0))  # Qubit 6
        self.assertIsNotNone(qstates[4].qubits[0].qstate)
        self.assertIsNotNone(qstates[5].qubits[0].qstate)
        ns.sim_run(40)
        self.assertIsNotNone(qstates[4].qubits[0].qstate)
        self.assertIsNotNone(qstates[5].qubits[0].qstate)
        external_ref = [qstates[4].qubits[0], qstates[5].qubits[0]]  # noqa
        port1.tx_input(0)
        self.assertIsNotNone(qstates[4].qubits[0].qstate)
        port1.tx_output(0)
        self.assertIsNotNone(qstates[5].qubits[0].qstate)
        # Test combined qubits are discarded correctly
        qapi.combine_qubits(qubits[:2])  # Qubits 7 and 8
        self.assertEqual(2, len(qstates[6].qubits))
        self.assertEqual(0, len(qstates[7].qubits))
        port1.tx_input(qubits.pop(0))  # Qubit 7
        self.assertIsNotNone(qstates[6].qubits[0].qstate)
        ns.sim_run(50)
        self.assertIsNotNone(qstates[6].qubits[0].qstate)
        port1.tx_input(0)
        self.assertEqual(1, len(qstates[6].qubits))
        # Test a lost qubit
        qapi.discard(qubits[0])
        port1.tx_output(qubits.pop(0))
        ns.sim_run(60)
        port1.tx_output(0)

    def test_rx_output_discard(self):
        """Test messages retrieved too late are discarded."""
        port = Port("TestPort", self.TestComponent("TestComp"))
        port.tx_output("hello1")
        self.assertEqual("hello1", port.rx_output().items[0])
        port.tx_output("hello2")
        ns.sim_run(duration=1)
        self.assertIsNone(port.rx_output())
        port.tx_input("hello3")
        self.assertEqual("hello3", port.rx_input().items[0])
        port.tx_input("hello4")
        ns.sim_run(duration=1)
        self.assertIsNone(port.rx_input())


class TestComponent(unittest.TestCase):
    """Unit tests for the component class."""

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        ns.sim_reset()
        self.items = ["apple", "pear", "banana", "orange"]

    def test_Component_properties(self):
        """Test Channel reset."""
        c = SimpleChannel("ChannelTest", delay=1)
        # Test assigning a new length
        c.properties["delay"] = 1
        self.assertEqual(c.properties["delay"], 1)
        # Test adding new properties on the fly
        number_properties = len(c.properties)
        c.add_property("test_variable", value=3)
        self.assertEqual(c.properties["test_variable"], 3)
        self.assertEqual(len(c.properties), number_properties + 1)
        c.add_property("a", value=5, mutable=False)
        self.assertFalse(c.properties.get_mutable("a"))
        with self.assertRaises(ImmutabilityError):
            c.properties["a"] = 3
        with self.assertRaises(ImmutabilityError):
            c.add_property("a", value=3)
        with self.assertRaises(TypeError):
            c.add_property("b", value=3, value_type=str)
        comp = Component("TestComp", properties={"a": 1, "b": 2})
        self.assertEqual(len(comp.properties), 2)
        self.assertEqual(comp.properties["a"], 1)
        # Check "a" is mutable and not constrained to type:
        comp.properties["a"] = "cow"
        self.assertEqual(comp.properties["a"], "cow")

    def test_component_init(self):
        """Test inititialization of component."""

        class TestComponent(Component):
            pass

        name = "TestComp"
        comp = TestComponent(name)
        self.assertEqual(comp.name, name)
        self.assertEqual(len(comp.ports), 0)
        self.assertEqual(len(comp.subcomponents), 0)

    def test_component_ports(self):
        """Test component management of ports."""

        class TestComponent(Component):
            pass

        port_names = ["A", "B", "C"]
        comp1 = TestComponent("TestComp1")
        comp1.add_ports(port_names)
        comp2 = TestComponent("TestComp2", port_names=port_names)
        for comp in [comp1, comp2]:
            for port_name in port_names:
                self.assertEqual(len(comp.ports), len(port_names))
                self.assertTrue(port_name in comp.ports)
                self.assertEqual(comp.ports[port_name].name, port_name)
                self.assertEqual(str(comp.ports[port_name]), "{}:{}".format(comp.name, port_name))
        # Test adding ports with wrong input
        with self.assertRaises(TypeError):
            comp1.add_ports(123)
        # Test adding port with single str instead of a list
        one_port_name = "one_port"
        comp1.add_ports(one_port_name)
        self.assertTrue(one_port_name in comp1.ports)

    def test_component_models(self):
        """Test component management of models."""

        class TestModel1(Model):
            def compute_model(self):
                pass

        class TestModel2(Model):
            def compute_model(self):
                pass

        model1 = TestModel1()
        model2 = TestModel2()
        model2.required_properties = ["apples"]
        with self.assertRaises(ValueError):
            comp = Component(name="foo", models={"model2": model2})
        comp = Component(
            name="foo",
            properties={"apples": True},
            models={"model1": model1, "model2": model2, "model3": None},
        )
        self.assertEqual(len(comp.models), 3)
        self.assertEqual(comp.models["model1"], model1)
        self.assertEqual(comp.models["model2"], model2)
        self.assertEqual(comp.models["model3"], None)
        self.assertEqual(comp.models.get_type("model1"), TestModel1)
        self.assertEqual(comp.models.get_type("model2"), TestModel2)
        self.assertEqual(comp.models.get_type("model3"), Model)
        self.assertTrue(comp.models.get_mutable("model1"))

    def test_component_subcomponents(self):
        """Test component management of subcomponents."""

        class TestComponent(Component):
            pass

        comp = TestComponent("TestComp")
        subcomps = [TestComponent("SubComp{}".format(i)) for i in range(5)]
        self.assertEqual(len(comp.subcomponents), 0)
        comp.add_subcomponent(subcomps[0])
        comp.add_subcomponent(subcomps[1])
        with self.assertRaises(ComponentHierarchyError):
            comp.add_subcomponent(subcomps[1])
        comp.add_subcomponent(subcomps[2], name="foo")
        self.assertEqual(len(comp.subcomponents), 3)
        for subcomp in subcomps[0:2]:
            self.assertEqual(comp.subcomponents[subcomp.name], subcomp)
        self.assertEqual(comp.subcomponents["foo"], subcomps[2])
        for subcomp in subcomps[0:3]:
            self.assertEqual(subcomp.supercomponent, comp)
            self.assertTrue(comp.has_subcomponent(subcomp))
        # Override subcomponent
        comp.add_subcomponent(subcomps[3], name="foo")
        self.assertEqual(comp.subcomponents["foo"], subcomps[3])
        self.assertFalse(comp.has_subcomponent(subcomps[2]))
        self.assertEqual(subcomps[2].supercomponent, None)
        self.assertEqual(subcomps[3].supercomponent, comp)
        # Test removing a subcomponent
        comp.rem_subcomponent("foo")
        self.assertTrue("foo" not in comp.subcomponents)
        self.assertTrue("foo" not in comp.subcomponents)
        self.assertFalse(comp.has_subcomponent(subcomps[3]))
        self.assertEqual(subcomps[3].supercomponent, None)
        self.assertEqual(len(comp.subcomponents), 2)
        # Test construction of multi-depth composite component using subcomp dict
        subcomponents = {
            "testsubcomp": comp,  # contains subcomps 0 and 1
            subcomps[2].name: subcomps[2],
            subcomps[3].name: subcomps[3],
            subcomps[4].name: subcomps[4],
        }
        comp2 = TestComponent("TestComp2", subcomponents=subcomponents)
        self.assertEqual(len(comp2.subcomponents), 4)
        self.assertEqual(comp2.subcomponents["testsubcomp"], comp)
        for subcomp in subcomps[2:5]:
            self.assertEqual(comp2.subcomponents[subcomp.name], subcomp)
        for subcomp in subcomps:
            self.assertTrue(comp2.has_subcomponent(subcomp))
            self.assertTrue(subcomp.has_supercomponent(comp2))

    def test_component_reset(self):
        """Test reset of component."""

        class TestComponent(Component):
            def __init__(self, name):
                super().__init__(name)
                self.foo = 5
                portA, portB = self.add_ports(["A", "B"])
                portA.tx_output(Message("apple"))
                portB.tx_input(Message("pear"))

            def reset(self):
                super().reset()
                self.foo = 0

        def check_init(comp):
            return (len(comp.ports) == 2 and
                    comp.foo == 5 and
                    len(comp.ports["A"].output_queue) == 1 and
                    len(comp.ports["B"].input_queue) == 1)

        def check_reset(comp):
            return (len(comp.ports) == 2 and
                    comp.foo == 0 and
                    len(comp.ports["A"].output_queue) == 0 and
                    len(comp.ports["B"].input_queue) == 0)

        comps = [TestComponent("TestComp{}".format(i)) for i in range(4)]
        comps[0].add_subcomponent(comps[1])
        comps[0].add_subcomponent(comps[2])
        comps[1].add_subcomponent(comps[3])
        self.assertEqual(len(comps[0].subcomponents), 2)
        self.assertEqual(len(comps[1].subcomponents), 1)
        for comp in comps:
            self.assertTrue(check_init(comp))
        comps[0].reset()
        for comp in comps:
            self.assertTrue(check_reset(comp))

    def test_ports_of_simple_channel(self):
        """Test ports of a simple channels."""
        delay = 5
        chan = SimpleChannel("TestChannel", delay=delay)
        received = []

        def get_output(message):
            nonlocal received
            received.append(message)

        chan.ports["recv"].bind_output_handler(get_output)
        chan.send(self.items[0])
        ns.sim_run()
        self.assertEqual(len(received), 1)
        self.assertEqual(type(received[0]), Message)
        self.assertEqual(received[0].items, [self.items[0]])
        self.assertAlmostEqual(ns.sim_time(), delay)

    def test_port_linking_simple_channel_chain(self):
        """Test linking of ports for chain of simple channels."""
        # Create channels
        delays = [5, 3, 1.5]
        channels = [SimpleChannel("TestChannel{}".format(i), delay=delays[i]) for i, delay in enumerate(delays)]
        # Connect channels
        for i in range(0, len(channels) - 1):
            channels[i].ports["recv"].connect(channels[i + 1].ports["send"])
        # Prepare for output
        received = []

        def get_output(message):
            nonlocal received
            received.append(message)

        channels[-1].ports["recv"].bind_output_handler(get_output)
        # Send two messages along channel chain
        channels[0].ports["send"].tx_input(Message(self.items[:2]))
        channels[0].ports["send"].tx_input(Message(self.items[2:]))
        ns.sim_run()
        self.assertEqual(len(received), 2)
        self.assertEqual(type(received[0]), Message)
        self.assertEqual(type(received[1]), Message)
        self.assertEqual(received[0].items, self.items[:2])
        self.assertEqual(received[1].items, self.items[2:])
        self.assertAlmostEqual(ns.sim_time(), sum(delays))

    def test_port_forwarding_composite_component(self):
        """Test port forwarding for composite component."""
        ccomp = CompositeComponent("TestCompComponent")
        received_A = []
        received_B = []

        def get_output_A(message):
            nonlocal received_A
            received_A.append(message)

        def get_output_B(message):
            nonlocal received_B
            received_B.append(message)

        # Bind output handlers:
        ccomp.ports["A"].bind_output_handler(get_output_A)
        ccomp.ports["B"].bind_output_handler(get_output_B)
        # Send input message one way
        ccomp.ports["A"].tx_input(Message(self.items[:2]))
        ns.sim_run()
        self.assertEqual(len(received_B), 1)
        self.assertEqual(type(received_B[0]), Message)
        self.assertEqual(received_B[0].items, self.items[:2])
        self.assertAlmostEqual(ns.sim_time(), 3)
        # Send input message the other way
        ccomp.ports["B"].tx_input(Message(self.items[2:]))
        ns.sim_run()
        self.assertEqual(len(received_A), 1)
        self.assertEqual(type(received_A[0]), Message)
        self.assertEqual(received_A[0].items, self.items[2:])
        self.assertAlmostEqual(ns.sim_time(), 3 + 7)

    def test_incorrect_hierarchy(self):
        """Test components being added as subcomponents to children/parents/self"""
        comp = CompositeComponent("comp")
        comp2 = CompositeComponent("comp2")
        comp3 = CompositeComponent("comp3")
        comp.add_subcomponent(comp2)
        comp2.add_subcomponent(comp3)

        with self.assertRaises(ComponentHierarchyError):
            comp.add_subcomponent(comp)

        with self.assertRaises(ComponentHierarchyError):
            comp.add_subcomponent(comp3)

        with self.assertRaises(ComponentHierarchyError):
            comp3.add_subcomponent(comp)

    def test_ports_disconnected_on_remove_component(self):
        """Tests if ports are correctly disconnected when components are removed"""
        parent = Component("parent")
        step_parent = Component("adoption parent", port_names=["to_me"])
        me = Component("me", port_names=["to_sister", "to_stepbrother"])
        sister = Component("sister", port_names=["to_me"])
        step_brother = Component("step_brother", port_names=["to_me"])
        son = Component("son", port_names=["to_daughter"])
        daughter = Component("daughter", port_names=["to_son"])

        parent.add_subcomponent(
            me,
            forward_input=[("to_me", "to_parent")],
            forward_output=[("to_me", "to_parent")],
            add_ports=True,
        )
        parent.add_subcomponent(
            sister,
            forward_input=[("to_sister", "to_parent")],
            forward_output=[("to_sister", "to_parent")],
            add_ports=True,
        )
        me.add_subcomponent(
            son,
            forward_input=[("to_son", "to_me")],
            forward_output=[("to_son", "to_me")],
            add_ports=True,
        )
        me.add_subcomponent(
            daughter,
            forward_input=[("to_daughter", "to_me")],
            forward_output=[("to_daughter", "to_me")],
            add_ports=True,
        )
        step_parent.add_subcomponent(
            step_brother,
            forward_input=[("to_stepbrother", "to_parent")],
            forward_output=[("to_stepbrother", "to_parent")],
            add_ports=True,
        )

        me.ports["to_sister"].connect(sister.ports["to_me"])
        son.ports["to_daughter"].connect(daughter.ports["to_son"])
        son.ports["to_me"].tx_output("HI, FROM: SON, output")
        me.ports["to_son"].tx_input("HI SON, FROM: ME, input")
        me.ports["to_sister"].tx_output("HI SIS, FROM: ME, output")
        sister.ports["to_me"].tx_output("HI BRO, FROM: SIS, output")
        me.ports["to_parent"].tx_output("HI DAD, FROM: ME, output")
        parent.ports["to_me"].tx_input("HI YOU, FROM: DAD, input")
        me.ports["to_stepbrother"].tx_output("HI BRO, FROM: ME, output")
        self.assertListEqual(me.ports["to_son"].rx_output().items, ["HI, FROM: SON, output"])
        self.assertListEqual(son.ports["to_me"].rx_input().items, ["HI SON, FROM: ME, input"])
        self.assertListEqual(me.ports["to_sister"].rx_input().items, ["HI BRO, FROM: SIS, output"])
        self.assertListEqual(sister.ports["to_me"].rx_input().items, ["HI SIS, FROM: ME, output"])
        self.assertListEqual(parent.ports["to_me"].rx_output().items, ["HI DAD, FROM: ME, output"])
        self.assertListEqual(me.ports["to_parent"].rx_input().items, ["HI YOU, FROM: DAD, input"])
        self.assertIsNone(step_parent.ports["to_me"].rx_input())
        self.assertIsNone(step_parent.ports["to_me"].rx_output())
        self.assertIsNone(step_brother.ports["to_me"].rx_input())
        self.assertIsNone(step_brother.ports["to_me"].rx_output())
        ns.sim_run(4)
        # Remove subcomponent and check if message don't arrive anymore
        parent.rem_subcomponent(me.name)
        son.ports["to_me"].tx_output("HI, FROM: SON, output 2")
        me.ports["to_son"].tx_input("HI SON, FROM: ME, input 2")
        me.ports["to_sister"].tx_output("HI SIS, FROM: ME, output 2")
        sister.ports["to_me"].tx_output("HI BRO, FROM: SIS, output 2")
        me.ports["to_parent"].tx_output("HI DAD, FROM: ME, output 2")
        parent.ports["to_me"].tx_input("HI YOU, FROM: DAD, input 2")
        me.ports["to_stepbrother"].tx_output("HI BRO, FROM: ME, output 2")
        self.assertListEqual(me.ports["to_son"].rx_output().items, ["HI, FROM: SON, output 2"])
        self.assertListEqual(son.ports["to_me"].rx_input().items, ["HI SON, FROM: ME, input 2"])
        self.assertIsNone(me.ports["to_sister"].rx_input())
        self.assertIsNone(sister.ports["to_me"].rx_input())
        self.assertIsNone(parent.ports["to_me"].rx_output())
        self.assertIsNone(me.ports["to_parent"].rx_input())
        self.assertIsNone(step_parent.ports["to_me"].rx_input())
        self.assertIsNone(step_parent.ports["to_me"].rx_output())
        self.assertIsNone(step_brother.ports["to_me"].rx_input())
        self.assertIsNone(step_brother.ports["to_me"].rx_output())
        # Add subcomponent to new component
        step_parent.add_subcomponent(
            me,
            forward_input=[("to_me", "to_parent")],
            forward_output=[("to_me", "to_parent")],
            add_ports=True,
        )
        me.ports["to_stepbrother"].connect(step_brother.ports["to_me"])
        ns.sim_run(8)
        son.ports["to_me"].tx_output("HI, FROM: SON, output 3")
        me.ports["to_son"].tx_input("HI SON, FROM: ME, input 3")
        me.ports["to_sister"].tx_output("HI SIS, FROM: ME, output 3")
        sister.ports["to_me"].tx_output("HI BRO, FROM: SIS, output 3")
        me.ports["to_parent"].tx_output("HI NEW DAD, FROM: ME, output 3")
        parent.ports["to_me"].tx_input("HI YOU, FROM: DAD, input 3")
        step_parent.ports["to_me"].tx_input("HI YOU, FROM: NEW DAD, input 3")
        step_brother.ports["to_me"].tx_output("HI YOU, FROM: BRO, input 3")
        me.ports["to_stepbrother"].tx_output("HI BRO, FROM: ME, output 3")
        self.assertListEqual(me.ports["to_son"].rx_output().items, ["HI, FROM: SON, output 3"])
        self.assertListEqual(son.ports["to_me"].rx_input().items, ["HI SON, FROM: ME, input 3"])
        self.assertIsNone(me.ports["to_sister"].rx_input())
        self.assertIsNone(sister.ports["to_me"].rx_input())
        self.assertIsNone(parent.ports["to_me"].rx_output())
        self.assertListEqual(me.ports["to_stepbrother"].rx_input().items, ["HI YOU, FROM: BRO, input 3"])
        self.assertListEqual(step_brother.ports["to_me"].rx_input().items, ["HI BRO, FROM: ME, output 3"])
        self.assertListEqual(
            step_parent.ports["to_me"].rx_output().items,
            ["HI NEW DAD, FROM: ME, output 3"],
        )
        self.assertListEqual(me.ports["to_parent"].rx_input().items, ["HI YOU, FROM: NEW DAD, input 3"])

    def test_forward_ports_on_addcomponent(self):
        """Tests for the forward_input/output_ports parameter"""
        comp = Component("comp")
        comp2 = Component("comp2")
        with self.assertRaises(KeyError):
            comp.add_subcomponent(comp2, forward_input=[("A", "B")])
        comp = Component("comp")
        comp2 = Component("comp2")
        comp.add_subcomponent(comp2, forward_input=[("A", "B")], add_ports=True)
        self.assertIn("A", comp.ports)
        self.assertIn("B", comp2.ports)
        self.assertNotIn("A", comp2.ports)
        self.assertNotIn("B", comp.ports)
        comp.ports["A"].tx_input("HI")
        self.assertEqual(comp2.ports["B"].rx_input().items[0], "HI")

        comp = Component("comp", port_names=["A"])
        comp2 = Component("comp2", port_names=["B"])
        comp.add_subcomponent(comp2, forward_output=[("A", "B")])
        self.assertIn("A", comp.ports)
        self.assertIn("B", comp2.ports)
        self.assertNotIn("A", comp2.ports)
        self.assertNotIn("B", comp.ports)
        comp2.ports["B"].tx_output("HI")
        self.assertEqual(comp.ports["A"].rx_output().items[0], "HI")

        comp = Component("comp")
        comp2 = Component("comp2")
        comp.add_subcomponent(
            comp2,
            forward_input=[("p1", "c1"), ("p2", "c2")],
            forward_output=[("pa", "ca"), ("pb", "cb")],
            add_ports=True,
        )
        self.assertEqual(len(comp.ports), 4)
        self.assertEqual(len(comp2.ports), 4)
        self.assertIn("p1", comp.ports)
        self.assertIn("p2", comp.ports)
        self.assertIn("pa", comp.ports)
        self.assertIn("pb", comp.ports)
        self.assertIn("c1", comp2.ports)
        self.assertIn("c2", comp2.ports)
        self.assertIn("ca", comp2.ports)
        self.assertIn("cb", comp2.ports)

    def test_child_component_changes_parent(self):
        """Test correct behaviour if a subcomponent gets a new parent"""
        comp1 = Component("1")
        comp2 = Component("2")
        comp3 = Component("3")
        comp1.add_subcomponent(comp2)
        self.assertIs(comp2.supercomponent, comp1)
        self.assertIn(comp2.name, comp1.subcomponents)
        self.assertNotIn(comp2.name, comp3.subcomponents)
        with self.assertRaises(ComponentHierarchyError):
            comp3.add_subcomponent(comp2)
        comp1.rem_subcomponent(comp2.name)
        comp3.add_subcomponent(comp2)
        self.assertIs(comp2.supercomponent, comp3)
        self.assertNotIn(comp2.name, comp1.subcomponents)
        self.assertIn(comp2.name, comp3.subcomponents)


if __name__ == "__main__":
    unittest.main()
