# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: ccoding.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Defines coding utilities for classical components.

"""
import abc

__all__ = [
    "CodedItem",
    "ClassicalCodingFactory",
]


class CodedItem(metaclass=abc.ABCMeta):
    """An general object used for converting object types to a specific encoding.

    Subclass this abstract base class to define different encodings.

    Parameters
    ----------
    item : Any
        Item to encode in a coded object.

    """

    def __init__(self, item):
        if not isinstance(item, self.object_types):
            raise TypeError("Type {} does not match {} item type {}"
                            .format(self.object_types, self.__class__, type(item)))
        self._item = item
        self._encoded_item = None

    @property
    @abc.abstractmethod
    def has_encoding(self):
        """bool: whether item has an encoding."""
        # Override this method
        pass

    @property
    @abc.abstractmethod
    def object_types(self):
        """tuple of type: Object types that can be converted."""
        # Override this method
        pass

    @property
    @abc.abstractmethod
    def encoding_type(self):
        """type: Object type of encoded item."""
        # Override this method
        pass

    @property
    def encoded_item(self):
        """Encoded object."""
        if self._encoded_item is None and self.has_encoding:
            self._encoded_item = self.encode()
        return self._encoded_item

    @encoded_item.setter
    def encoded_item(self, value):
        if not isinstance(value, self.encoding_type):
            raise ValueError("{} is not a {}".format(value, self.encoding_type))
        self._encoded_item = value

    @property
    def item(self):
        """Original (decoded) item."""
        return self._item

    @abc.abstractmethod
    def encode(self):
        """Encode the item.

        Returns
        -------
        Any
            Encoded item.

        """
        # Override this method
        pass

    @abc.abstractmethod
    def decode(self, encoded_item=None):
        """Decode an encoded item.

        If no encoding is available, the original item
        is simply returned.

        Parameters
        ----------
        encoded_item : Any or None, optional
            Item to decode. If ``None``,
            the held encoded item is decoded.

        Returns
        -------
        object
            Decoded item.

        """
        # Override this method
        pass

    @abc.abstractmethod
    def apply_loss_model(self, loss_model, delta_time=0., **properties):
        """Apply a loss model to the encoded item.

        Modifies the encoded item in-place.

        Parameters
        ----------
        loss_model : :obj:`~netsquid.components.models.cerrormodels.ClassicalErrorModel`
            Loss model to apply to encoded item.
        delta_time : float, optional
            Time item has spent on channel [ns].
        \\*\\*properties
            Component properties to pass to model.

        Returns
        -------
        bool
            Whether the whole encoded item is lost.

        """
        pass


class ClassicalCodingFactory(metaclass=abc.ABCMeta):
    """Interface for a class that converts data into a classical code object.

    """

    @classmethod
    def create_coded_item(cls, item):
        """Creates the classical coded object for given data.

        Parameters
        ----------
        item : Any
            The item we want to encapsulate into a classical coded item.

        Returns
        -------
        :obj:`~netsquid.components.ccoding.CodedItem`
            An instantiation of the classical coded item appropriate for the provided item.

        """
        pass
