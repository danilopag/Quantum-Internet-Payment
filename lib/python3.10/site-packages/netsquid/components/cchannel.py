# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: cchannel.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Defines a classical channel that is intended to transmit classical items with a possible encoding.
It can model the classical noise and loss of the encoded items.

"""
import logging
# from netsquid.util.simlog import logger
from netsquid.components.channel import Channel
from netsquid.components.models.cerrormodels import ClassicalErrorModel
from netsquid.components.ccoding import ClassicalCodingFactory, CodedItem

__all__ = [
    "ClassicalChannel",
]

logger = logging.getLogger(__name__)


class ClassicalChannel(Channel):
    """A one-way classical channel capable of transmitting classical items, with a
    possible encoding, with delay, loss and noise.

    Functions similarly to :obj:`~netsquid.components.channels.Channel` but
    for encoded items.

    Parameters
    ----------
    name : str
        Name of channel for identification purposes.
    delay : float, optional
        Fixed transmission delay to use if ``delay_model`` is ``None`` [ns].
    length : float, optional
        Length of channel [km]. May be used by delay, loss and noise models.
    models :  dict or None, optional
        Models associated with this component. Will first specify them by their
        type and them set them.
        See the Models section to see which (key, Model) pair it recognizes.
    classical_code : :obj:`~netsquid.components.ccoding.ClassicalCodingFactory` or None, optional
        Specifies how the items put on the channel are encoded into the items that
        are sent over the channel.
    transmit_empty_items : bool, optional
        Whether to transmit items equal to ``None``. This includes items that become
        None after input prepocessing. Default is False.
    properties : dict or None, optional
        Extra properties associated with this component.

    Properties
    ----------
    length : int
        Length of the channel.

    Ports
    -----
    send
        Input port for transmitting messages.
    recv
        Output port for receiving messages.

    Models
    ------
    delay_model : :obj:`~netsquid.components.models.delaymodels.DelayModel` or None, optional
        Callable object that generates a transmission delay.
        If ``None``, :obj:`~netsquid.components.models.delaymodels.FixedDelayModel` is used.
        Non-trivial use of this functionality can result in messages arriving out of order.
    classical_noise_model : :obj:`~netsquid.components.models.cerrormodels.ClassicalErrorModel` or None, optional
        Callable object that applies classical noise to (encoded) items.
        If ``None``, then no noise is applied to the items.
        If the sent items are encoded they are processed individually by the model.
        Otherwise the model processes all the items at once.
    classical_loss_model : :obj:`~netsquid.components.models.cerrormodels.ClassicalErrorModel` or None, optional
        Callable object that computes whether part or all of an (encoded) item is lost.
        If ``None``, then there is no classical loss.

    Notes
    -----
        Channel supports multiple concurrent transmissions. A FIFO order is
        guaranteed. Delays generated by a ``delay_model`` that do not conform
        to FIFO will raise an exception.

    """

    def __init__(self, name, delay=0, length=0, models=None, classical_code=None, transmit_empty_items=False,
                 properties=None, **kwargs):
        if models is None:
            models = {}
        self.specify_model('classical_noise_model', model_type=ClassicalErrorModel)
        self.specify_model('classical_loss_model', model_type=ClassicalErrorModel)
        super().__init__(name=name, delay=delay, length=length, models=models,
                         transmit_empty_items=transmit_empty_items, properties=properties, **kwargs)
        self._classical_code = classical_code

    @property
    def classical_code(self):
        """Classical coding to apply to encode and decode inputs items.

        Returns
        -------
        :obj:`~netsquid.components.ccoding.ClassicalCodingFactory` or None
            Used to encode and decode the transmitted
            items. If ``None``, no coding is used.

        """
        return self._classical_code

    @classical_code.setter
    def classical_code(self, value):
        if value is not None and not isinstance(value, ClassicalCodingFactory):
            raise TypeError("{} is not a ClassicalCodingFactory".format(value))
        self._classical_code = value

    @property
    def use_classical_code(self):
        """bool: whether a classical code is used."""
        return (self._classical_code is not None and
                (self.models["classical_noise_model"] is not None or
                 self.models["classical_loss_model"] is not None))

    def preprocess_inputs(self, delay, items):
        """Preprocess the classical put items.

        If loss or noise models present, then converts (encodes) items
        and checks for lost items.
        Uses ``classical_code`` for the conversion.
        The items will then be converted back (decoded) on output
        (see ``postprocess_outputs``).

        Parameters
        ----------
        delay : float
            Time that bit(s) will spend transmitting on channel.
        items : list of items
            Items to be transmitted. If required, list items are encoded
            for application of loss and noise.

        Returns
        -------
        list of items
            The preprocessed items being transmitted.

        """
        if self.use_classical_code:
            # Encode all classical items:
            items = [self.classical_code.create_coded_item(item) for item in items if item is not None]
        if self.models["classical_loss_model"] is not None:
            if self.use_classical_code:
                for i, item in enumerate(items):
                    if isinstance(item, CodedItem):
                        if item.has_encoding:
                            if item.apply_loss_model(self.models["classical_loss_model"], delay,
                                                     **self.properties):
                                items[i] = None
                        else:
                            logger.warning("Item {} has no encoding: did not apply classical loss ".format(item))
            else:
                # Apply loss models to all items
                self.models["classical_loss_model"](items, delay, **self.properties)
        if not self.transmit_empty_items:
            items = [item for item in items if item is not None]
        return items

    def postprocess_outputs(self, delta_time, items):
        """Postprocess outputs as they are taken off the channel.

        If items are in an encoded format they are converted back
        to their original form, using the ``classical_code`` for the conversion.
        If a classical noise model is specified then it is
        applied before decoding, if applicable.

        Parameters
        ----------
        delta_time : float
            Time that qubits spent on the channel.
        items : tuple of {Any, bool}
            (Encoded) items being transmitted.

        Returns
        -------
        list of items
            Postprocessed classical items.

        Notes
        -----
            Encoded items that cannot be decoded are discarded from the output.

        """
        if self.models["classical_noise_model"] is not None:
            if self.use_classical_code:
                # Pass each encoded item separately through the noise model
                for item in items:
                    if isinstance(item, CodedItem) and item.has_encoding:
                        self.models["classical_noise_model"](item.encoded_item, delta_time,
                                                             **self.properties)
                    else:
                        logger.warning("Item {} has no encoding: did not apply classical noise".format(item))
            else:
                # Pass list of items through the noise model
                self.models["classical_noise_model"](items=items, delta_time=delta_time,
                                                     **self.properties)
        if self.use_classical_code:
            decoded_items = []
            for item in items:
                try:
                    item = item.decode()
                except ValueError:
                    continue
                decoded_items.append(item)
            items = decoded_items
        return items
