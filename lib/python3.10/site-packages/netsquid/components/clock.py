# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: clock.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""This module specifies a clock component, which can be used by other components to keep time.

"""
import netsquid as ns
from pydynaa import EventType, EventHandler
from netsquid.components.component import Component, Message
from netsquid.util.constrainedmap import nonnegative_constr
from netsquid.components.models.delaymodels import DelayModel, FixedDelayModel
__all__ = [
    "Clock"
]


class Clock(Component):
    """A component that can be used by other components to keep time.

    The clock works by sending messages to its "cout"  port at specific time intervals.
    A timing model can be used to model timing inaccuracies.

    Parameters
    ----------
    name : str
        Name of the clock component.
    frequency : float
        Frequency at which ticks are generated when not providing a ``timing_model`` [Hz].
    models : dict or None, optional
        Models associated with this component. Will first specify them by their
        type and them set them.
        See the Models section to see which (key, Model) pair it recognizes.
    start_delay : float, optional
        Time after which the clock will output its first tick [ns].
    max_ticks : int, optional
        Maximum number of ticks before the clock stops automatically. Default is -1, which represents infinity.
    properties : dict or None, optional
        Extra properties associated with this component.
        If a ``start_delay`` is in ``properties`` this will overwrite the ``start_delay`` given to the constructor as
        argument.

    Properties
    ----------
    start_delay : float
        Time (>= 0) after which the clock will output its first tick [ns].

    Ports
    -----
    cout
        Output port for announcing a tick.

    Models
    ------
    timing_model : obj:`~netsquid.components.models.delaymodels.DelayModel` or None, optional
        Model used to calculate the time between ticks. When no model is given a fixed delay
        of 1 / ``frequency`` is used.

    """
    evtype_tick = EventType("TICK", "Time interval elapsed - next step")

    def __init__(self, name, frequency=None, models=None, start_delay=0, max_ticks=-1, properties=None):
        if properties is None:
            properties = {}
        if models is None:
            models = {}
        if "start_delay" not in properties:
            self.add_property("start_delay", value=start_delay, value_constraints=nonnegative_constr)
        # Specify and add models
        if "timing_model" not in models or models["timing_model"] is None:
            if frequency is None:
                raise ValueError("To run a clock you have to provide at least a frequency or timing model.")
            else:
                models["timing_model"] = FixedDelayModel(delay=1e9 / frequency)
        self.specify_model("timing_model", DelayModel)
        super().__init__(name, properties=properties, port_names=["cout"], models=models)
        self._is_running = False
        self._num_ticks = 0
        self._max_ticks = max_ticks
        self._time_handler = EventHandler(self._tick)

    @property
    def frequency(self):
        """float: (mean) frequency at which the clock ticks [Hz].

        """
        return 1e9 / self.models["timing_model"].get_mean()

    @frequency.setter
    def frequency(self, value):
        if value <= 0:
            raise ValueError("The frequency should be larger than zero, not {}.".format(value))
        self.models["timing_model"].set_mean(1e9 / value)

    @property
    def is_running(self):
        """bool: Whether this Clock is currently running."""
        return self._is_running

    @property
    def num_ticks(self):
        """int: Number of ticks this clock has produced."""
        return self._num_ticks

    def get_period(self):
        """Returns a period based on the clock's timing model [ns].

        """
        return self.models["timing_model"](**self.properties)

    def start(self):
        """Start clock and kick off the timer which will start after a ``start_delay`` as specified in this clock's properties.

        """
        if self._is_running:
            raise ClockAlreadyRunningError
        self._is_running = True
        self._wait(self._time_handler, entity=self, event_type=self.evtype_tick)
        self._schedule_after(self.properties["start_delay"], self.evtype_tick)

    def stop(self):
        """ Stop clock and dismiss handler.

        """
        if not self._is_running:
            return
        self._is_running = False
        self._dismiss(self._time_handler, entity=self, event_type=self.evtype_tick)

    def reset(self):
        """Reset this clock and all its ports to its initial conditions (including the status at construction).

        Also stops the clock if it is running.

        """
        self.stop()
        super().reset()
        self._num_ticks = 0

    def _tick(self, event):
        # Function to be executed when time elapsed. Will reschedule.
        self._num_ticks += 1
        self.ports["cout"].tx_output(Message([ns.sim_time()], tick_number=self._num_ticks))
        if self._num_ticks >= self._max_ticks >= 0:
            self.stop()
        if self._is_running:
            self._schedule_after(self.get_period(), self.evtype_tick)


class ClockError(Exception):
    # General Clock error.
    pass


class ClockAlreadyRunningError(ClockError):
    # Exception raised on errors related to Clock already running.
    pass
