# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: cqchannel.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Defines a combined classical and quantum channel, which is essentially the
combination of a :obj:`~netsquid.components.cchannel.classicalchannel` and
:obj:`~netsquid.components.qchannel.QuantumChannel`, and is
intended for concurrently transmitting a classical message along with qubits.
It facilitates classical and quantum noise and loss.

"""
from netsquid.components.cchannel import ClassicalChannel
from netsquid.components.qchannel import QuantumChannel

__all__ = [
    "CombinedChannel",
]


class CombinedChannel(ClassicalChannel, QuantumChannel):
    """A one-way channel capable of transmitting both classical and
    quantum messages with the same delay and separate noise and loss models.

    If a probabilistic delay is applied, then it will be applied
    to both the classical and quantum message equally ie they arrive at the same time.
    Losses are applied to the quantum and classical part of the message independently.

    While this is never the case in reality, it forms an approximation to the standard
    situation in which by timing association, classical and quantum messages can be matched
    to each other.

    Messages that are put into this channel are of the form [classical, quantum].

    Parameters
    ----------
    name : str
        Name of channel for identification purposes.
    delay : float, optional
        Fixed transmission delay to use if ``delay_model`` is ``None`` [ns].
    length : float, optional
        Length of channel [km]. May be used by delay, loss and noise models.
    models : dict or None, optional
        Models associated with this component. Will first specify them by their
        type and them set them.
        See the Models section to see which (key, Model) pair it recognizes.
    classical_code : :obj:`~netsquid.components.ccoding.ClassicalCodingFactory`
        Specifies how the data put on the channel are converted into objects that
        will actually be sent over the channel.
    transmit_empty_items : bool, optional
        Whether to transmit items equal to ``None``. This includes items that become
        None after input prepocessing. Default is False.
    properties : dict or None, optional
        Extra properties associated with this component.

    Models
    ------
    delay_model : :obj:`~netsquid.components.models.delaymodels.DelayModel` or None, optional
        Callable object that generates a transmission delay.
        If ``None``, :obj:`~netsquid.components.models.delaymodels.FixedDelayModel` is used.
        Non-trivial use of this functionality can result in messages arriving
        out of order.
    classical_noise_model : :obj:`~netsquid.components.models.cerrormodels.ClassicalErrorModel` or None, optional
        Callable object that applies classical noise to the bits in an encoded item.
        If ``None``, then no noise is applied to the bitstreams. (**Note:** if `classical_code`
        is None, then no classical noise is applied)
    classical_loss_model : :obj:`~netsquid.components.models.cerrormodels.ClassicalErrorModel` or None, optional
        Callable object that computes whether the bits in an encoded item are lost.
        If ``None``, then there is no classical loss. (**Note:** if `classical_code`
        is None, then no classical loss is applied)
    quantum_noise_model : :obj:`~netsquid.components.models.qerrormodels.QuantumErrorModel` or None, optional
        Callable object that probabilisticly applies quantum noise to qubit(s).
        If ``None``, then no noise is applied to the qubit(s).
    quantum_loss_model : :obj:`~netsquid.components.models.qerrormodels.QuantumErrorModel` or None, optional
        Callable object that computes whether the qubit(s) are (collectively) lost.
        If ``None``, then there is no qubit loss.
    Notes
    -----
        QChannel supports multiple concurrent transmissions. A FIFO order is
        guaranteed. Delays generated by a ``delay_model`` that do not conform
        to FIFO will raise an exception.

    """

    def __init__(self, name, delay=0, length=0, models=None,
                 classical_code=None, transmit_empty_items=False, properties=None, **kwargs):
        # Calling super constructors should specify all needed models
        if models is None:
            models = {}
        super().__init__(name=name, delay=delay, length=length, models=models,
                         classical_code=classical_code, transmit_empty_items=transmit_empty_items,
                         properties=properties, **kwargs)

    def preprocess_inputs(self, delay, items):
        """Preprocess the sent items.

        To apply a special code to the converted bitstream see ``classical_coding``.

        Parameters
        ----------
        delay : float
            Time that bit(s) will spend transmitting on channel.
        items : list of tuple(Any, :obj:`~netsquid.qubits.qubit.Qubit`\\(s))
            Classical and quantum items to be transmitted. Does not support a list of
            such tuples

        Returns
        -------
        items
            The preprocessed bitstream being transmitted.

        """
        result_items = []
        for item in items:
            classical, qubits = item
            if not isinstance(qubits, list):
                qubits = [qubits]
            qubits = QuantumChannel.preprocess_inputs(self, delay, qubits)
            # if len(qubits) == 1:
            #    qubits = qubits[0]
            if not isinstance(classical, list):
                classical = [classical]
            classical = ClassicalChannel.preprocess_inputs(self, delay, classical)
            result_items.append((classical, qubits))
        return result_items

    def postprocess_outputs(self, delta_time, items):
        """Postprocess outputs as they are taken off the channel.

        Parameters
        ----------
        delta_time : float
            Time that message spent on the channel.
        items : list of tuple(Any, list of :obj:`~netsquid.qubits.qubit.Qubit`)
            Classical and quantum items ready for output.

        Returns
        -------
        list of items
            Postprocessed classical and quantum items.

        """
        new_items = []
        for (classical, qubits) in items:
            qubits = QuantumChannel.postprocess_outputs(self, delta_time, qubits)
            classical = ClassicalChannel.postprocess_outputs(self, delta_time, classical)
            if len(classical) == 1:
                classical = classical[0]
            elif len(classical) == 0:
                classical = None
            new_items.append((classical, qubits))
        return new_items

    def send(self, items, header=None, **kwargs):
        """Puts (classical, quantum) item onto the channel.

        Parameters
        ----------
        items : tuple(Any, :obj:`~netsquid.qubits.qubit.Qubit`\\(s))
            Joined classical and quantum message.
        header : Immutable or None, optional
            The header to use to store these items. This header can be used to select just the
            currently send items upon *receive*. If ``None`` no key is used.

        Notes
        -----
            It is possible for item(s) to be retrieved before their ready event occurs
            (see *receive()*).

        """
        if len(items) != 2:
            raise ValueError("Put items {} not in format (classical, quantum)".format(items))
        super().send(items=[items], header=header, **kwargs)

    def receive(self, header=None, **kwargs):
        """Retrieves (classical, quantum) item(s) on the channel output.

        An item can only be retrieved once. A key can be used to retrieve
        selected items (see *send*), otherwise all available item(s) are retrieved.

        Parameters
        ----------
        header : Immutable or None, optional
            Header of the items to retrieve. If ``None``, all available items
            will be retrieved.

        Returns
        -------
        list of tuple(Any or list of Any or None, list of :obj:`~netsquid.qubits.qubit.Qubit`\\)
            The classical and quantum items retrieved from the channel.
            The qubits are given as a list. The classical information is given as a list
            if there are two or more items, and as ``None`` if no items.
        float
            The time the item spent on the channel. If the channel output
            is empty then 0 is returned [ns].

        Notes
        -----
            Item(s) can be retrieved when the current *time instant* matches their
            arrival time. Because events scheduled at the same time instant may occur
            in a random order, it is possible for items(s) to be retrieved before their
            ready event occurs. In this case the ready event still occurs but the
            output will be empty.

            If receive is called without a ``header`` for a message with keys, then the items
            are returned per header in the order the headers were first send. For instance,
            for the sequence of (header, item) puts: ('A', 1), ('B', 2), ('C', 3), ('A', 4),
            a receive with no key would return [1, 4, 2, 3].

        """
        return super().receive(header=header, **kwargs)
