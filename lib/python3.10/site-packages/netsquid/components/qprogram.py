# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: qprogram.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Defines a quantum program that runs on a quantum processor.

Quantum programs are written using
:obj:`~netsquid.components.instructions.Instruction`\\s,
and, similar to instructions, are intended to be agnostic to the type of
:obj:`~netsquid.components.qprocessor.QuantumProcessor` they run on.

Quantum programs support control logic using yield statements, and can
indicate if instructions sequences should be executed in parallel
-- a feature the executing quantum processor must also support.

Examples
--------

Below we gives examples of how to create quantum program.
For examples of how to run a quantum program on a quantum
processor see :obj:`~netsquid.components.qprocessor`.

Example imports:

>>> from netsquid.components.qprogram import *
>>> from netsquid.components.instructions import *

In its most basic form a quantum program can be created as a single sequence
of instructions:

>>> prog = QuantumProgram(num_qubits=2)
>>> q1, q2 = prog.get_qubit_indices()
>>> prog.apply(INSTR_X, q1)
>>> prog.apply(INSTR_CNOT, [q1, q2])
>>> prog.apply(INSTR_MEASURE, q1, output_key="m1")
>>> prog.apply(INSTR_MEASURE, q2, output_key="m2")

Such a single sequence of instructions can also be created by subclassing the
:obj:`~netsquid.components.qprogram.QuantumProgram` class:

>>> class CustomQProgram(QuantumProgram):
...     default_num_qubits = 2
...
...     def program(self):
...         q1, q2 = self.get_qubit_indices(2)
...         self.apply(INSTR_X, q1)
...         self.apply(INSTR_CNOT, [q1, q2])
...         self.apply(INSTR_SIGNAL)
...         self.apply(INSTR_MEASURE, q1, output_key="m1")
...         self.apply(INSTR_MEASURE, q2, output_key="m2")
...         yield self.run()

Multiple sequences are defined using repeated yield statements calling
the ``run()`` method.
Instructions store their output in a local state dictionary called ``output``.
Control logic can be used to select what instructions are called.

>>> class ControlledQProgram(QuantumProgram):
...     default_num_qubits = 3
...
...     def program(self):
...         q1, q2, q3 = self.get_qubit_indices(3)
...         self.apply(INSTR_H, q1)
...         self.apply(INSTR_MEASURE, q1, output_key="m1")
...         yield self.run()
...         # Depending on outcome on q1 either flip q2 or q3
...         if self.output["m1"][0] == 0:
...             self.apply(INSTR_X, q2)
...         else:
...             self.apply(INSTR_X, q3)
...         self.apply(INSTR_MEASURE, q2, output_key="m2")
...         self.apply(INSTR_MEASURE, q3, output_key="m3")
...         yield self.run()

The ``parallel`` parameter in the ``run()`` method can be used to control whether
the quantum processor attempts to run the sequence in parallel.
To do so, it must have matching :obj:`~netsquid.components.qprocessor.PhysicalInstruction`\\s
that support this.

>>> class ParallelQProgram(QuantumProgram):
...     default_num_qubits = 4
...
...     def program(self):
...         q1, q2, q3, q4 = self.get_qubit_indices(4)
...         self.apply(INSTR_X, q1)
...         self.apply(INSTR_X, q4)
...         self.apply(INSTR_CNOT, [q1, q2])
...         self.apply(INSTR_CNOT, [q3, q4])
...         self.apply(INSTR_H, q3)
...         self.apply(INSTR_H, q4)
...         yield self.run(parallel=False)
...         self.apply(INSTR_MEASURE, q1, output_key="m1")
...         self.apply(INSTR_MEASURE, q2, output_key="m2")
...         self.apply(INSTR_MEASURE_X, q3, output_key="m3")
...         self.apply(INSTR_MEASURE_X, q4, output_key="m4")
...         yield self.run(parallel=True)

The parameter ``physical`` can be used to indicate whether a quantum processor
should match the instruction to a :obj:`~netsquid.components.qprocessor.PhysicalInstruction`
or to instead execute it instantly and without noise, i.e. non-physical.

>>> class CheatingQProgram(QuantumProgram):
...     default_num_qubits = 2
...
...     def program(self):
...         q1, q2 = self.get_qubit_indices(2)
...         self.apply(INSTR_X, q1)
...         self.apply(INSTR_SIGNAL, physical=False)
...         self.apply(INSTR_Z, q1, physical=False)
...         self.apply(INSTR_CNOT, [q1, q2])
...         self.apply(INSTR_MEASURE, q1, output_key="m1", physical=False)
...         self.apply(INSTR_MEASURE, q2, output_key="m2", physical=False)
...         yield self.run()

A program can load in another program using the
:meth:`~netsquid.components.qprogram.QuantumProgram.load` method. Loaded programs
share the output dict.
Loading programs works to arbitrary depth.

>>> class LoadingQProgram(QuantumProgram):
...     default_num_qubits = 2
...
...     def program(self):
...         # Run a regular sequence
...         q1, q2 = self.get_qubit_indices(2)
...         self.apply(INSTR_X, q1)
...         yield self.run()
...         # Load and run another program
...         yield from self.load(CustomQProgram)

Programs can accept keyword arguments

>>> class ParamProgram(QuantumProgram):
...
...     def program(self, a, b=1):
...         self.output["a"] = a
...         self.output["b"] = b
...         yield self.run()

Programs can be concatenated using the addition operator,
where one of the operands can also be a class instead of an instance:

>>> prog3 = prog1 + prog2  # doctest: +SKIP

Programs can be repeated using the multiplication operator:

>>> prog2 = prog1 * 5  # doctest: +SKIP

In all cases the output dict is shared among the combined programs.

"""
import copy
import types
from collections import namedtuple
__all__ = [
    "QuantumProgram",
    "QuantumProgramError",
]

ProgramInstruction = namedtuple("ProgramInstruction",
                                "instruction qubit_indices output_key physical parameters")
"""tuple: specifies an instruction applied on a quantum program."""

RunParameters = namedtuple("RunParameters", "instruction_list parallel lazy")
"""tuple: specifies the return values of the run command of a quantum program.

    Parameters
    ----------
    instruction_list : list of tuple(:obj:`~netsquid.components.qprogram.ProgramInstruction`)
        List of tuples specifying instruction name, program qubit indices,
        callback function.
    parallel : bool
        Whether processor should attempt to run instructions
        in parallel (if physically supported).
    lazy : bool
        Whether the processor should attempt to run instruction sequence lazily
        (i.e. apply them all at once at the same event).

"""


class QuantumProgram:
    """Program that executes on a quantum processor.

    Written using :obj:`~netsquid.components.instructions.Instruction`\\s,
    and similarly intended to be agnostic to the type of
    :obj:`~netsquid.components.qprocessor.QuantumProcessor` it runs on.

    Passed as input to
    :meth:`~netsquid.components.qprocessor.QuantumProcessor.execute_program`.

    Parameters
    ----------
    num_qubits : int or None, optional
        Number of qubits quantum program requires to run on.
        If -1, it can run on any number of qubits.
        If ``None`` and ``qubit_mapping`` is ``None``, ``default_num_qubits`` is used.
    parallel : bool, optional
        Whether processor should attempt to run instructions
        in parallel if physical instructions support it.
        This can be manually overridden in a program.
    qubit_mapping : list of int or None, optional
        Order of qubit indices that is returned with get_qubit_indices().
        Useful when concatenating programs.

    Attributes
    ----------
    output : dict
        Dictionary containing instruction outputs.
    parallel : bool
        Whether processor should attempt to run instructions
        in parallel if physical instructions support it.
        This can be manually overridden in a program.

    Examples
    --------

    Two programs can be concatenated to create a new program using the addition operator:

    >>> prog1 = FirstProgram()  # subclass of QuantumProgram  # doctest: +SKIP
    >>> prog2 = SecondProgram()  # subclass of QuantumProgram  # doctest: +SKIP
    >>> prog3 = prog1 + prog2  # doctest: +SKIP

    A new program that repeats another program multiple times can
    be created using the multiplication operator:

    >>> prog1 = FirstProgram()  # subclass of QuantumProgram  # doctest: +SKIP
    >>> prog2 = prog1 * 5  # doctest: +SKIP
    >>> prog3 = 12 * prog2  # doctest: +SKIP

    """
    default_num_qubits = -1
    """int: default number of qubits program requires. If -1 it can run on any number of qubits."""

    def __init__(self, num_qubits=None, parallel=True, qubit_mapping=None):
        self.parallel = parallel
        if num_qubits is not None:
            self._num_qubits = num_qubits
        elif qubit_mapping is not None:
            self._num_qubits = len(qubit_mapping)
        else:
            self._num_qubits = self.default_num_qubits
        self._apply_list = []
        self._custom_program = True
        self.output = {}
        if qubit_mapping is None and self.num_qubits > 0:
            qubit_mapping = [i for i in range(self._num_qubits)]
        if qubit_mapping is not None:
            self._check_qubit_mapping(qubit_mapping)
        self._qubit_mapping = qubit_mapping
        self.reset()

    def program(self, **kwargs):
        """Program to be executed.

        Override this method to add additional control logic.

        By default runs a single sequences of instructions that
        have been added using ``apply()``.

        Notes
        -----
            Returns a generator.

        """
        # If program() is overridden, keywords arguments can be passed, not in this default program
        if kwargs:
            raise TypeError(f"program() got an unexpected keyword argument(s): {[k for k in kwargs]}")
        # Override with custom program code here.
        # _custom_program should be True for custom programs:
        self._custom_program = False
        yield self.run(parallel=self.parallel)

    @property
    def num_qubits(self):
        """int: number of qubits program requires. If -1 can run on any number of qubits."""
        return self._num_qubits

    def get_qubit_indices(self, num_qubits=None):
        """Convenience method that returns the program's qubit indices.

        Parameters
        ----------
        num_qubits : int or None, optional
            Number of qubit indices to return. If ``None``
            will try to return all indices corresponding
            to ``self.num_qubits``, raising an exception
            if this is not bounded.

        Returns
        -------
        list of int
            Indices of program qubits.

        Raises
        ------
        ValueError
            If too many indices are requested, or if all indices are requested and
            this number is not bounded.

        """
        if num_qubits is None:
            num_qubits = self._num_qubits
        if num_qubits < 0 or (0 <= self._num_qubits < num_qubits):
            raise ValueError(f"Cannot return {num_qubits} qubit indices, program has {self._num_qubits} qubits")
        if self._qubit_mapping is not None:
            return self._qubit_mapping[:num_qubits]
        else:
            return list(range(num_qubits))

    def apply(self, instruction, qubit_indices=None, output_key="last", physical=True, **parameters):
        """Prepare to apply an instruction.

        Prepares a callback function that will be called when the instruction
        is executed by a quantum processor.

        Parameters
        ----------
        instruction : :obj:`~netsquid.components.instructions.Instruction`
            Next instruction to be called during program execution.
        qubit_indices : int or list of int or None, optional
            Program qubit indices to apply instruction to. If None or an empty list,
            then the instruction does not act on any qubit indices.
        output_key : str, optional
            Dictionary key to store instruction output with. Default is to store
            all outputs using ``last``.
        physical : bool, optional
            Whether a quantum processor should interpret this instruction as being
            physical. If non-physical it should execute it instantly and and without noise.
        \\*\\*parameters
            Additional keyword arguments to pass to the instruction.

        Returns
        -------
        str
            Name of the instruction to be applied.
        list of int
            Program qubit indices instruction to be applied to.
        function
            Callback function that applies the instruction to a quantum processor.

        Notes
        -----
            The prepared callback also accepts ``runtime_params`` keyword arguments
            that will override any matching keywords in ``parameters``.

        """
        if qubit_indices is None:
            qubit_indices = []
        elif isinstance(qubit_indices, int):
            qubit_indices = [qubit_indices]
        if instruction.num_positions != -1 and instruction.num_positions != len(qubit_indices):
            raise ValueError("Instruction.num_positions ({}) does not match length of qubit_indices ({})"
                             .format(instruction.num_positions, len(qubit_indices)))

        # def callback(qproc, output, **runtime_params):
        #     # Callback that executes the function
        #     # NOTE runtime_params override apply-time parameters
        #     # NOTE the processor provides the output dict, as this reference may change e.g. if the
        #     # the program is loaded into another program.
        #     # Returns the instruction result
        #     positions = qproc.program_mapping(qubit_indices)
        #     result = instruction(qproc, positions=positions, **{**parameters, **runtime_params})
        #     #self.output[output_key] = result
        #     output[output_key] = result
        #     if output_key != "last":
        #         #self.output["last"] = result
        #         output["last"] = result
        #     return result

        self._apply_list.append(
            ProgramInstruction(instruction, qubit_indices, output_key, physical, parameters))

    def load(self, program):
        """Load in and run another quantum program within this program.

        To be called within an overridden ``program()`` method.
        Should be prepepended by ``yield from`` (see example below).

        The ``output`` dict is shared between both programs.

        Parameters
        ----------
        program : :obj:`~netsquid.components.qprogram.QuantumProgram`
            Another quantum program to load in and run.
            Can be an instance or a (sub)class of
            :obj:`~netsquid.components.qprogram.QuantumProgram`.
            If it is an instance, a copy is made.

        Returns
        -------
        generator
            A generator for the loaded program.

        Raises
        ------
        :obj:`~netsquid.components.qprogram.QuantumProgramError`
            If ``program`` is invalid. This exception will be caught by
            a running program and cause it to fail.

        Examples
        --------

        It is possible to load a :obj:`~netsquid.components.qprogram.QuantumProgram` instance or class.

        >>> def program(self):
        ...     # ...
        ...     yield from self.load(my_program_instance)
        ...     yield from self.load(MyCustomProgram)

        """
        if isinstance(program, QuantumProgram):
            program = copy.deepcopy(program)
        elif issubclass(program, QuantumProgram):
            program = program()
        else:
            raise QuantumProgramError("{} is not a valid QuantumProgram class or instance".format(program))
        if program.num_qubits != -1 and self.num_qubits != -1 and program.num_qubits != self.num_qubits:
            raise QuantumProgramError("Loaded program acts on an incompatible number of qubits: {} vs {}"
                                      .format(program.num_qubits, self.num_qubits))
        gen = program()
        program.output = self.output
        return gen

    def run(self, parallel=True, lazy=False):
        """Carry out all applied instructions within the program to this point.

        Called within an overridden ``program()`` method.
        Should be prepepended by ``yield`` (see example below).

        Parameters
        ----------
        parallel : bool, optional
            Whether processor should attempt to run instructions
            in parallel (if physically supported).
            Default True.
        lazy : bool, optional
            Whether to perform all instructions at once.
            Useful to keep qubit states small between combining and reducing.
            (Qubits in other processors that share the same qubit state
            do not get the chance to increase the state exponentially)
            All instructions will be executed at the current time instance
            without having to run the simulator.
            Noise will be applied accordingly for the duration of and between the instructions.
            However any other calls in an instruction to :func:`~netsquid.util.simtools.sim_time`
            or scheduling events with schedule_now and schedule_after **will be incorrect**.
            Make absolutely sure that no such calls exists in the instructions.
            It will not be checked, so there is no guarantee that the simulation is correct otherwise.
            Default False.

        Returns
        -------
        :obj:`~netsquid.components.qprogram.RunParameters`
            tuple with the following entries:

            list of tuple(:obj:`~netsquid.components.qprogram.ProgramInstruction`)
                List of tuples specifying instruction name, program qubit indices,
                callback function.
            bool
                Whether processor should attempt to run instructions
                in parallel (if physically supported).
            bool
                Whether the processor should attempt to run instruction lazily
                (i.e. apply them all at once at the same event).


        Examples
        --------

        >>> def program(self):
        ...     self.apply(INSTR_X, [0])
        ...     yield self.run(parallel=False)

        """
        apply_list = self._apply_list
        if self._custom_program:
            self._apply_list = []
        return RunParameters(apply_list, parallel, lazy)

    def reset(self):
        """Reset state of program.

        """
        self.output.clear()
        self.output["last"] = None

    def _check_qubit_mapping(self, qubit_mapping):
        # Check validity of the given 'qubit_mapping' parameter, raising
        # appropriate exception if invalid
        # List can be empty
        if not isinstance(qubit_mapping, (list, tuple)):
            raise TypeError("Expected a list or tuple for qubit_mapping, got {}".
                            format(qubit_mapping))
        if len(qubit_mapping) != len(set(qubit_mapping)):
            raise ValueError("qubit_mapping {} contains duplicate entries".format(qubit_mapping))
        if (
                len(qubit_mapping) > self._num_qubits or
                min(qubit_mapping) < 0
        ):
            raise ValueError(f"{qubit_mapping} maps to invalid program indices.")

    def __add__(self, other):
        # Concatenate two programs, returning a new program
        # Copy or instantiate the other program
        if isinstance(other, QuantumProgram):
            # Copy other program
            progB = copy.deepcopy(other)
        elif issubclass(other, QuantumProgram):
            progB = other()
        else:
            raise TypeError("{} is not a valid QuantumProgram class or instance".format(other))
        # Copy this program
        progA = copy.deepcopy(self)
        progA.reset()
        progB.reset()
        # Share outputs of generators (after resetting state)
        progB.output = progA.output

        def program(self):
            yield from progA.program()
            yield from progB.program()

        if progA._qubit_mapping is not None and progB._qubit_mapping is not None:
            num_qubits = len(set(progA._qubit_mapping + progB._qubit_mapping))
        else:
            num_qubits = max(progA.num_qubits, progB.num_qubits)
        new_prog = QuantumProgram(num_qubits)
        new_prog.program = types.MethodType(program, new_prog)
        new_prog.output = progA.output
        return new_prog

    def __radd__(self, other):
        # Supports adding a class to instance on other side
        if issubclass(other, QuantumProgram):
            other = other()
        return other.__add__(self)

    def __mul__(self, factor):
        # Create a new quantum program that repeats this one
        # a 'factor' of times
        if not isinstance(factor, int):
            raise TypeError("factor {} is not an integer".format(factor))
        elif factor <= 0:
            raise ValueError("factor {} must be greater than zero".format(factor))
        # Copy this program
        progs = [copy.deepcopy(self)] * factor
        for prog in progs:
            prog.reset()

        def program(self):
            for i in range(factor):
                yield from progs[i].program()

        new_prog = QuantumProgram(progs[0].num_qubits)
        new_prog.program = types.MethodType(program, new_prog)
        new_prog.output = progs[0].output
        return new_prog

    def __rmul__(self, factor):
        return self.__mul__(factor)

    def __iter__(self):
        # Return generator if iterated
        # TODO also reset() here?
        return self.program()

    def __call__(self, **kwargs):
        # Return generator if called
        self.reset()
        return self.program(**kwargs)


class QuantumProgramError(Exception):
    """An exception that, if raised, will cause a quantum program to fail.

    """
    pass
