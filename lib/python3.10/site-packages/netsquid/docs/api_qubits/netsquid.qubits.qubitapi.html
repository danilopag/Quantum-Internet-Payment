<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>netsquid.qubits.qubitapi &mdash; NetSquid 1.1.7 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=370aedac"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="netsquid.qubits.operators" href="netsquid.qubits.operators.html" />
    <link rel="prev" title="netsquid.qubits.qformalism" href="netsquid.qubits.qformalism.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #E3E3E3" >

          
          
          <a href="../index.html" class="icon icon-home">
            NetSquid
              <img src="../_static/squid-150.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.1.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../INSTALL.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RELEASE.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AUTHORS.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LICENSE.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Learn NetSquid</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quick_start.html">NetSquid in 10 minutes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.intro.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.qubits.html">Qubits and quantum computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.pydynaa.html">Discrete event simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.components.html">Modelling of network components</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.nodes.html">Nodes and Connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.quantumprocessor.html">The Quantum Processor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.simulation.html">A full simulation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../learn.examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.teleportation.html">Teleportation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.repeater.html">Repeater with purification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.repeater_chain.html">Repeater chain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.simple_link.html">A simple link layer protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.magic_simple_link.html">Faster Link layer Protocol using abstraction</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../api_reference.html">NetSquid package</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../netsquid.qubits.html">netsquid.qubits</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.qformalism.html">netsquid.qubits.qformalism</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">netsquid.qubits.qubitapi</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.operators.html">netsquid.qubits.operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.cliffords.html">netsquid.qubits.cliffords</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.ketstates.html">netsquid.qubits.ketstates</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.state_sampler.html">netsquid.qubits.state_sampler</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.qubit.html">netsquid.qubits.qubit</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.qstate.html">netsquid.qubits.qstate</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.qrepr.html">netsquid.qubits.qrepr</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.kettools.html">netsquid.qubits.kettools</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.dmtools.html">netsquid.qubits.dmtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.sparsedmtools.html">netsquid.qubits.sparsedmtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.stabtools.html">netsquid.qubits.stabtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.gslctools.html">netsquid.qubits.gslctools</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.qreprutil.html">netsquid.qubits.qreprutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.ketutil.html">netsquid.qubits.ketutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.dmutil.html">netsquid.qubits.dmutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.sparseutil.html">netsquid.qubits.sparseutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.gslcutil.html">netsquid.qubits.gslcutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.qubits.opmath.html">netsquid.qubits.opmath</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.components.html">netsquid.components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.component.html">netsquid.components.component</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.channel.html">netsquid.components.channel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qchannel.html">netsquid.components.qchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.cchannel.html">netsquid.components.cchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.cqchannel.html">netsquid.components.cqchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qmemory.html">netsquid.components.qmemory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.instructions.html">netsquid.components.instructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qprogram.html">netsquid.components.qprogram</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qprocessor.html">netsquid.components.qprocessor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.clock.html">netsquid.components.clock</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qsource.html">netsquid.components.qsource</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qdetector.html">netsquid.components.qdetector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.switch.html">netsquid.components.switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.ccoding.html">netsquid.components.ccoding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.components.models.html">netsquid.components.models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.model.html">netsquid.components.models.model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.delaymodels.html">netsquid.components.models.delaymodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.errormodels.html">netsquid.components.models.errormodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.qerrormodels.html">netsquid.componentsmodels.qerrormodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.cerrormodels.html">netsquid.components.models.cerrormodels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.nodes.html">netsquid.nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.node.html">netsquid.nodes.node</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.connections.html">netsquid.nodes.connections</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.network.html">netsquid.nodes.network</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.protocols.html">netsquid.protocols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html">netsquid.protocols.protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.nodeprotocols.html">netsquid.protocols.nodeprotocols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html">netsquid.protocols.serviceprotocol</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.util.html">netsquid.util</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simtools.html">netsquid.util.simtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simlog.html">netsquid.util.simlog</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simstats.html">netsquid.util.simstats</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.datacollector.html">netsquid.util.datacollector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.cycache.html">netsquid.util.cycache</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.cymath.html">netsquid.util.cymath</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html">netsquid.util.constrainedmap</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.examples.html">netsquid.examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.teleportation.html">netsquid.examples.teleportation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.entanglenodes.html">netsquid.examples.entanglenodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.purify.html">netsquid.examples.purify</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.repeater.html">netsquid.examples.repeater</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.repeater_chain.html">netsquid.examples.repeater_chain</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.simple_link.html">netsquid.examples.simple_link</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.magic_simple_link.html">netsquid.examples.magic_simple_link</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api_pydynaa.html">pyDynAA package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html">pydynaa.Entity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-event">pydynaa.Event</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventtype">pydynaa.EventType</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventexpression">pydynaa.EventExpression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventhandler">pydynaa.EventHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-expressionhandler">pydynaa.ExpressionHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-simulationengine">pydynaa.SimulationEngine</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">For developers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../INSTALL-SOURCE.html">Installation from source</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CHANGELOG.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #E3E3E3" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">NetSquid</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../api_reference.html">NetSquid package</a></li>
          <li class="breadcrumb-item"><a href="../netsquid.qubits.html">netsquid.qubits</a></li>
      <li class="breadcrumb-item active">netsquid.qubits.qubitapi</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api_qubits/netsquid.qubits.qubitapi.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="netsquid.qubits.qformalism.html" class="btn btn-neutral float-left" title="netsquid.qubits.qformalism" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="netsquid.qubits.operators.html" class="btn btn-neutral float-right" title="netsquid.qubits.operators" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-netsquid.qubits.qubitapi">
<span id="netsquid-qubits-qubitapi"></span><h1>netsquid.qubits.qubitapi<a class="headerlink" href="#module-netsquid.qubits.qubitapi" title="Link to this heading"></a></h1>
<p>General API for manipulating qubits indepedent of their quantum state
<em>formalism</em>.</p>
<p class="rubric">Examples</p>
<p>Several of the API functions provide example code snippets.
These snippets should run unedited if you set up a Python
interpreter with the following imports:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.qubits.qubitapi</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.qubits.qformalism</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.qubits</span> <span class="kn">import</span> <span class="n">operators</span> <span class="k">as</span> <span class="n">ops</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.qubits</span> <span class="kn">import</span> <span class="n">ketstates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.qubits</span> <span class="kn">import</span> <span class="n">Stabilizer</span>
</pre></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.create_qubits">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">create_qubits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.create_qubits" title="Link to this definition"></a></dt>
<dd><p>Creates a system of qubits.</p>
<p>By default each qubit is assigned its own independent <span class="math notranslate nohighlight">\(\vert 0\rangle\)</span> quantum state
using the currently set formalism.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_qubits</strong> (<em>int</em>) – Number of qubits to create.</p></li>
<li><p><strong>system_name</strong> (<em>str or None, optional</em>) – Name to distinguish these qubits from others they will encounter.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default system name <code class="docutils literal notranslate"><span class="pre">QS#&lt;i&gt;-</span></code> is chosen,
where <code class="docutils literal notranslate"><span class="pre">&lt;i&gt;</span></code> is an incrementing number.</p></li>
<li><p><strong>no_state</strong> (<em>bool, optional</em>) – If True the created qubits are not assigned a quantum state, which
can be assigned later using <a class="reference internal" href="#netsquid.qubits.qubitapi.assign_qstate" title="netsquid.qubits.qubitapi.assign_qstate"><code class="xref py py-func docutils literal notranslate"><span class="pre">assign_qstate()</span></code></a>.
Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The created qubits.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The name of each qubit is its <code class="docutils literal notranslate"><span class="pre">system_name</span></code> appended with
an index (starting from 0).</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">q3</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">system_name</span><span class="o">=</span><span class="s2">&quot;Q&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">q2</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">q3</span><span class="o">.</span><span class="n">name</span>
<span class="go">(&#39;Q0&#39;, &#39;Q1&#39;, &#39;Q2&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q1</span><span class="o">.</span><span class="n">qstate</span><span class="o">.</span><span class="n">qrepr</span><span class="o">.</span><span class="n">reduced_dm</span><span class="p">())</span>
<span class="go">[[1.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q2</span><span class="o">.</span><span class="n">qstate</span><span class="o">.</span><span class="n">qrepr</span><span class="o">.</span><span class="n">reduced_dm</span><span class="p">())</span>
<span class="go">[[1.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q3</span><span class="o">.</span><span class="n">qstate</span><span class="o">.</span><span class="n">qrepr</span><span class="o">.</span><span class="n">reduced_dm</span><span class="p">())</span>
<span class="go">[[1.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">reduced_dm</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">]))</span>
<span class="go">[[1.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j 0.+0.j 0.+0.j]]</span>
</pre></div>
</div>
<p>If no <code class="docutils literal notranslate"><span class="pre">system_name</span></code> is specified a default name is chosen:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q3</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">q2</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">q3</span><span class="o">.</span><span class="n">name</span>  
<span class="go">(&#39;QS#0-0&#39;, &#39;QS#0-1&#39;, &#39;QS#1-0&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.assign_qstate">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">assign_qstate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qrepr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">formalism</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.assign_qstate" title="Link to this definition"></a></dt>
<dd><p>Assign a specific quantum state to qubits.</p>
<p>Qubits will be discarded from their current shared quantum states if applicable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubits</strong> (list of <a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Qubits to assign the quantum state to.</p></li>
<li><p><strong>qrepr</strong> (<a class="reference internal" href="netsquid.qubits.qrepr.html#netsquid.qubits.qrepr.QRepr" title="netsquid.qubits.qrepr.QRepr"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRepr</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.array</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Stabilizer</span></code>,) –     <a class="reference internal" href="netsquid.qubits.state_sampler.html#netsquid.qubits.state_sampler.StateSampler" title="netsquid.qubits.state_sampler.StateSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StateSampler</span></code></a>, None
Representation of quantum state to assign to the created qubits.
If an array, it can be a ket vector or a density matrix with a size matching the number of qubits.
The given representation will be converted into the specified <a class="reference internal" href="netsquid.qubits.qrepr.html#netsquid.qubits.qrepr.QRepr" title="netsquid.qubits.qrepr.QRepr"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRepr</span></code></a>,
or raise an exception if this is not possible.</p></li>
<li><p><strong>formalism</strong> (<a class="reference internal" href="netsquid.qubits.qrepr.html#netsquid.qubits.qrepr.QRepr" title="netsquid.qubits.qrepr.QRepr"><code class="xref py py-class docutils literal notranslate"><span class="pre">QRepr</span></code></a> or None, optional) – Formalism to use for the assigned quantum state. If None (default), the currently set formalism
is used (recommended).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The shared quantum state assigned to the qubits.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="netsquid.qubits.qstate.html#netsquid.qubits.qstate.QState" title="netsquid.qubits.qstate.QState"><code class="xref py py-class docutils literal notranslate"><span class="pre">QState</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If <code class="docutils literal notranslate"><span class="pre">qrepr</span></code> is in an invalid format.</p></li>
<li><p><strong>NotImplementedError</strong> – If the required quantum state conversion has not been implemented.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If a mixed state is provided for a pure state formalism, a pure state is
sampled from it.</p>
<p class="rubric">Examples</p>
<p>Starting with two qubits (each in <code class="docutils literal notranslate"><span class="pre">|0&gt;</span></code>) we wish to assign them a new shared state
e.g. the maximally mixed state represented using a density matrix.
If we are in the KET formalism, then a pure state will be randomly sampled from
the specified density matrix (using an eigendecomposition).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.qubits</span> <span class="kn">import</span> <span class="n">set_qstate_formalism</span><span class="p">,</span> <span class="n">QFormalism</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_qstate_formalism</span><span class="p">(</span><span class="n">QFormalism</span><span class="o">.</span><span class="n">KET</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q1</span><span class="o">.</span><span class="n">qstate</span><span class="o">.</span><span class="n">qrepr</span><span class="p">)</span>
<span class="go">KetRepr(num_qubits=1,</span>
<span class="go">ket=</span>
<span class="go">[[1.+0.j]</span>
<span class="go"> [0.+0.j]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">assign_qstate</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q1</span><span class="o">.</span><span class="n">qstate</span><span class="o">.</span><span class="n">qrepr</span><span class="p">)</span>  
<span class="go">KetRepr(num_qubits=2,</span>
<span class="go">ket=</span>
<span class="go">[[0.+0.j]</span>
<span class="go"> [1.+0.j]</span>
<span class="go"> [0.+0.j]</span>
<span class="go"> [0.+0.j]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q1</span><span class="o">.</span><span class="n">qstate</span> <span class="o">==</span> <span class="n">q2</span><span class="o">.</span><span class="n">qstate</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>To assign a quantum state to new qubits, the <code class="docutils literal notranslate"><span class="pre">no_state</span></code> parameter of
<a class="reference internal" href="#netsquid.qubits.qubitapi.create_qubits" title="netsquid.qubits.qubitapi.create_qubits"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_qubits()</span></code></a> can be used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">set_qstate_formalism</span><span class="p">(</span><span class="n">QFormalism</span><span class="o">.</span><span class="n">DM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">no_state</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q1</span><span class="o">.</span><span class="n">qstate</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.qubits</span> <span class="kn">import</span> <span class="n">StabRepr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stab_repr</span> <span class="o">=</span> <span class="n">StabRepr</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">assign_qstate</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">stab_repr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">reduced_dm</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">]))</span>
<span class="go">[[0.5+0.j 0. +0.j 0. +0.j 0.5+0.j]</span>
<span class="go"> [0. +0.j 0. +0.j 0. +0.j 0. +0.j]</span>
<span class="go"> [0. +0.j 0. +0.j 0. +0.j 0. +0.j]</span>
<span class="go"> [0.5+0.j 0. +0.j 0. +0.j 0.5+0.j]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q1</span><span class="o">.</span><span class="n">qstate</span> <span class="o">==</span> <span class="n">q2</span><span class="o">.</span><span class="n">qstate</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.operate">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">operate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.operate" title="Link to this definition"></a></dt>
<dd><p>Apply an operator to a qubit or list of qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubits</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a> or list of <a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Single qubit or a list of qubits upon which to operate. The order of the
qubits with respect to the operator is important.</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="netsquid.qubits.operators.html#netsquid.qubits.operators.Operator" title="netsquid.qubits.operators.Operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Operator</span></code></a>) – Operator acting on qubits</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>TypeError</strong> – If <code class="docutils literal notranslate"><span class="pre">qubits</span></code> is not a qubit or a non-empty list of qubits.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Before an operator is applied to more than one qubit, the quantum states
of the interacting qubits are combined.</p>
<p class="rubric">Examples</p>
<p>Let us begin by operating on single qubits. In the first case we
use the predefined <code class="docutils literal notranslate"><span class="pre">X</span></code> operator and in the second case we define a new
operator <code class="docutils literal notranslate"><span class="pre">R</span></code>. Note that the quantum states of the two qubits remain separate.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># |00&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operate</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">reduced_dm</span><span class="p">(</span><span class="n">q1</span><span class="p">))</span>
<span class="go">[[0.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 1.+0.j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Operator</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">ops</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operate</span><span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">reduced_dm</span><span class="p">(</span><span class="n">q2</span><span class="p">))</span>
<span class="go">[[0.85355339+0.j         0.        +0.35355339j]</span>
<span class="go"> [0.        -0.35355339j 0.14644661+0.j        ]]</span>
</pre></div>
</div>
<p>Note that we could have also created the same rotation operator <code class="docutils literal notranslate"><span class="pre">R</span></code> with
<code class="docutils literal notranslate"><span class="pre">Operator</span></code> arithmetic using already defined operators:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">ops</span><span class="o">.</span><span class="n">I</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">ops</span><span class="o">.</span><span class="n">X</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="go">(((0.92)*I)-((0.00+0.38j)*X))</span>
</pre></div>
</div>
<p>or, simpler yet, using the helper function</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">create_rotation_op</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="go">R_y[0.39]</span>
</pre></div>
</div>
<p>Next we operate on two qubits simultaneously. The order that we specify the
qubits should match with the desired vector space action of the operator.
For instance, for the <code class="docutils literal notranslate"><span class="pre">CNOT</span></code> gate the first qubit is the <em>control</em> and the
second the <em>target</em>. After the qubit operation below, the two qubits will
share the same quantum state.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># |00&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operate</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operate</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">ops</span><span class="o">.</span><span class="n">CNOT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">reduced_dm</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">]))</span>
<span class="go">[[0.5+0.j 0. +0.j 0. +0.j 0.5+0.j]</span>
<span class="go"> [0. +0.j 0. +0.j 0. +0.j 0. +0.j]</span>
<span class="go"> [0. +0.j 0. +0.j 0. +0.j 0. +0.j]</span>
<span class="go"> [0.5+0.j 0. +0.j 0. +0.j 0.5+0.j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q1</span><span class="o">.</span><span class="n">qstate</span> <span class="o">==</span> <span class="n">q2</span><span class="o">.</span><span class="n">qstate</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check fidelity with the Bell state b00 = (|00&gt; + |11&gt;)/sqrt(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">fidelity</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">ketstates</span><span class="o">.</span><span class="n">b00</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>To illustrate that the order in which the qubits are listed matters, let us
reverse the order of both the Hadamard and the CNOT gates. Thus <code class="docutils literal notranslate"><span class="pre">q2</span></code> is
now the <em>control</em> and <code class="docutils literal notranslate"><span class="pre">q1</span></code> the target. We observe that this gives the same
Bell state. Finally we apply a controlled Z gate (<code class="docutils literal notranslate"><span class="pre">CZ</span></code>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operate</span><span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operate</span><span class="p">([</span><span class="n">q2</span><span class="p">,</span> <span class="n">q1</span><span class="p">],</span> <span class="n">ops</span><span class="o">.</span><span class="n">CNOT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check fidelity with the Bell state b00 = (|00&gt; + |11&gt;)/sqrt(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">fidelity</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">ketstates</span><span class="o">.</span><span class="n">b00</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operate</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">ops</span><span class="o">.</span><span class="n">CZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">reduced_dm</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">]))</span>
<span class="go">[[ 0.5+0.j  0. +0.j  0. +0.j -0.5+0.j]</span>
<span class="go"> [ 0. +0.j  0. +0.j  0. +0.j  0. +0.j]</span>
<span class="go"> [ 0. +0.j  0. +0.j  0. +0.j  0. +0.j]</span>
<span class="go"> [-0.5+0.j  0. +0.j  0. +0.j  0.5+0.j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check fidelity with the Bell state b10 = (|00&gt; - |11&gt;)/sqrt(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">fidelity</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">ketstates</span><span class="o">.</span><span class="n">b10</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>We can construct controlled gates using the controlled variable.
For example, a controlled T gate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CT</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ctrl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">CT</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="go">CT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">CT</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
<span class="go">Controlled T gate: q1 = control, q2 = target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">CT</span><span class="o">.</span><span class="n">arr</span><span class="p">)</span>  
<span class="go">[[1.        +0.j         0.        +0.j         0.        +0.j       0.       +0.j        ]</span>
<span class="go"> [0.        +0.j         1.        +0.j         0.        +0.j       0.       +0.j        ]</span>
<span class="go"> [0.        +0.j         0.        +0.j         1.        +0.j       0.       +0.j        ]</span>
<span class="go"> [0.        +0.j         0.        +0.j         0.        +0.j       0.7071...+0.7071...j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.stochastic_operate">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">stochastic_operate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operators</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.stochastic_operate" title="Link to this definition"></a></dt>
<dd><p>Stochastically apply a list of quantum operators to a qubit or list of qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubits</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a> or list of <a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Single qubit or a list of qubits upon which to operate. The order of the
qubits with respect to the operator is important.</p></li>
<li><p><strong>operators</strong> (list of <a class="reference internal" href="netsquid.qubits.operators.html#netsquid.qubits.operators.Operator" title="netsquid.qubits.operators.Operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Operator</span></code></a>) – Operators acting on the qubit(s).</p></li>
<li><p><strong>p_weights</strong> (<em>tuple of float or None, optional</em>) – Probability weights for each operator. Must sum to 1.
The default (None) is a uniform distribution.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If given <code class="docutils literal notranslate"><span class="pre">p_weights</span></code> tuple has an incorrect length or does not
    sum to one.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For the given list of <code class="docutils literal notranslate"><span class="pre">operators</span></code>, \(O_i\), and <code class="docutils literal notranslate"><span class="pre">p_weights</span></code>,
\(p_i\) (with \(\sum_i p_i = 1\)),
this function does the quantum operation
\(\varepsilon(\rho) = \sum_i p_i O_i \rho \, O_i^\dagger\).
For pure states it mimics this operation by randomly selecting a
single operator \(O_i\) with probability \(p_i\) and applying
this to the <code class="docutils literal notranslate"><span class="pre">qubits</span></code>.</p>
<p class="rubric">Examples</p>
<p>Depolarize a qubit using the density matrix formalism:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">set_qstate_formalism</span><span class="p">(</span><span class="n">QFormalism</span><span class="o">.</span><span class="n">DM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stochastic_operate</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="p">[</span><span class="n">ops</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">Z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">reduced_dm</span><span class="p">(</span><span class="n">q1</span><span class="p">))</span>
<span class="go">[[0.5+0.j 0. +0.j]</span>
<span class="go"> [0. +0.j 0.5+0.j]]</span>
</pre></div>
</div>
<p>Randomly select a controlled gate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operate</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">ops</span><span class="o">.</span><span class="n">X</span> <span class="o">^</span> <span class="n">ops</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stochastic_operate</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="p">[</span><span class="n">ops</span><span class="o">.</span><span class="n">CNOT</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">CZ</span><span class="p">],</span> <span class="n">p_weights</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.multi_operate">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">multi_operate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operators</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.multi_operate" title="Link to this definition"></a></dt>
<dd><p>Apply a (weighted) list of quantum operators to a qubit or list of qubits.</p>
<p>This represents a general quantum operation on an ensemble of states.
The result will in general be a mixed state. In the case of a pure state formalism,
a pure state is sampled from the resulting mixed state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubits</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a> or list of <a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Single qubit or a list of qubits upon which to operate. The order of the
qubits with respect to the operator is important.</p></li>
<li><p><strong>operators</strong> (list or tuple of <a class="reference internal" href="netsquid.qubits.operators.html#netsquid.qubits.operators.Operator" title="netsquid.qubits.operators.Operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Operator</span></code></a>) – Operators acting on qubits.</p></li>
<li><p><strong>weights</strong> (<em>tuple of float or None, optional</em>) – Weights for each operator. The default (<code class="docutils literal notranslate"><span class="pre">None</span></code>) is for each
operator to have a weight of 1.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If given <code class="docutils literal notranslate"><span class="pre">weights</span></code> tuple has an incorrect length.</p></li>
<li><p><strong>NotImplementedError</strong> – If quantum state formalism can not represent ensemble states e.g.
    <code class="xref py py-obj docutils literal notranslate"><span class="pre">STAB</span></code>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For the given list of <code class="docutils literal notranslate"><span class="pre">operators</span></code>, \(O_i\), and abitrary <code class="docutils literal notranslate"><span class="pre">weights</span></code>,
\(w_i\), this function peforms the quantum operation
\(\varepsilon(\rho) = \sum_i w_i O_i \rho \, O_i^\dagger\).</p>
<p class="rubric">Examples</p>
<p>Do generalized amplitude damping:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">set_qstate_formalism</span><span class="p">(</span><span class="n">QFormalism</span><span class="o">.</span><span class="n">DM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">gamma</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E0</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Operator</span><span class="p">(</span><span class="s2">&quot;E0_AD&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E1</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Operator</span><span class="p">(</span><span class="s2">&quot;E1_AD&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E2</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Operator</span><span class="p">(</span><span class="s2">&quot;E2_AD&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E3</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Operator</span><span class="p">(</span><span class="s2">&quot;E3_AD&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multi_operate</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="p">[</span><span class="n">E0</span><span class="p">,</span> <span class="n">E1</span><span class="p">,</span> <span class="n">E2</span><span class="p">,</span> <span class="n">E3</span><span class="p">],</span>
<span class="gp">... </span>              <span class="n">weights</span><span class="o">=</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">prob</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">prob</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">reduced_dm</span><span class="p">(</span><span class="n">q1</span><span class="p">))</span>
<span class="go">[[0.95+0.j 0.  +0.j]</span>
<span class="go"> [0.  +0.j 0.05+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.measure">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">measure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Operator('Z',</span> <span class="pre">array([[1.</span> <span class="pre">+</span> <span class="pre">0.j,</span> <span class="pre">0.</span> <span class="pre">+</span> <span class="pre">0.j],</span> <span class="pre">[0.</span> <span class="pre">+</span> <span class="pre">0.j,</span> <span class="pre">-1.</span> <span class="pre">+</span> <span class="pre">0.j]]))</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_combined</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.measure" title="Link to this definition"></a></dt>
<dd><p>Projectively measure a qubit.</p>
<p>The observable operator should be a Hermitian operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubit</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Qubit to measure (within its quantum state).</p></li>
<li><p><strong>observable</strong> (<a class="reference internal" href="netsquid.qubits.operators.html#netsquid.qubits.operators.Operator" title="netsquid.qubits.operators.Operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Operator</span></code></a>, optional) – Hermitian operator to measure qubit with. Default is the
<code class="docutils literal notranslate"><span class="pre">Z</span></code> observable.</p></li>
<li><p><strong>keep_combined</strong> (<em>bool, optional</em>) – Whether to keep this qubit in its shared quantum state after
the measurement instead of splitting it into a new state. Not
applicable if <code class="docutils literal notranslate"><span class="pre">discard</span></code> is set to True.</p></li>
<li><p><strong>discard</strong> (<em>bool, optional</em>) – Whether to discard the qubit after measurement. If True the quantum
state of the measured qubit will be <code class="docutils literal notranslate"><span class="pre">None</span></code>, which is more efficient
than assigning a new single qubit state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>int</em> – 0 if positive eigenstate measured, otherwise 1.</p></li>
<li><p><em>float</em> – Probability with which this result occurred.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <code class="docutils literal notranslate"><span class="pre">qubit.qstate</span></code> is None.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Measure the second qubit from the <code class="docutils literal notranslate"><span class="pre">|00&gt;</span></code> state in the
<code class="docutils literal notranslate"><span class="pre">X</span></code> basis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># separate states |0&gt;, |0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">combine_qubits</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">])</span>  <span class="c1"># state |00&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">measure</span><span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="n">observable</span><span class="o">=</span><span class="n">ops</span><span class="o">.</span><span class="n">X</span><span class="p">)</span> 
<span class="go">(0, 0.5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">reduced_dm</span><span class="p">(</span><span class="n">q2</span><span class="p">))</span>  
<span class="go">[[0.5+0.j 0.5+0.j]</span>
<span class="go"> [0.5+0.j 0.5+0.j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">reduced_dm</span><span class="p">(</span><span class="n">q1</span><span class="p">))</span>  
<span class="go">[[1.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j]]</span>
</pre></div>
</div>
<p>Do the same as before, but keep the quantum states combined:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># separate states |0&gt;, |0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">combine_qubits</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">])</span>  <span class="c1"># state |00&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">measure</span><span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="n">observable</span><span class="o">=</span><span class="n">ops</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">keep_combined</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
<span class="go">(0, 0.499...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">reduced_dm</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">]))</span>  
<span class="go">[[0.5+0.j 0.5+0.j  0. +0.j  0. +0.j]</span>
<span class="go"> [0.5+0.j 0.5+0.j  0. +0.j  0. +0.j]</span>
<span class="go"> [0. +0.j 0. +0.j  0. +0.j  0. +0.j]</span>
<span class="go"> [0. +0.j 0. +0.j  0. +0.j  0. +0.j]]</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> operator of <a class="reference internal" href="netsquid.qubits.operators.html#netsquid.qubits.operators.Operator" title="netsquid.qubits.operators.Operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Operator</span></code></a>
has been overloaded to give a shorthand alternative for performing observable
measurements given a suitable Hermitian operator:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">measure</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
<span class="go">(0, 1.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">measure</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>  
<span class="go">(0, 0.499...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.gmeasure">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">gmeasure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meas_operators</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_operators</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.gmeasure" title="Link to this definition"></a></dt>
<dd><p>Make a general qubit measurement with the specified measurement operators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubits</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a> or list of <a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Single qubit or a list of qubits upon which to operate. The order of the
qubits with respect to the measurement operators is important.</p></li>
<li><p><strong>meas_operators</strong> (list (or tuple) of <a class="reference internal" href="netsquid.qubits.operators.html#netsquid.qubits.operators.Operator" title="netsquid.qubits.operators.Operator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operator</span></code></a> or <a class="reference internal" href="netsquid.qubits.operators.html#netsquid.qubits.operators.Operator" title="netsquid.qubits.operators.Operator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operator</span></code></a>) – List of measurement operators with which to measure, or a single observable, i.e. an operator with valid projectors.
The measurement operatators <code class="docutils literal notranslate"><span class="pre">M_i</span></code> should satisfy the
completeness relation <code class="docutils literal notranslate"><span class="pre">Sum_i^N</span> <span class="pre">M_i.H</span> <span class="pre">*</span> <span class="pre">M_i</span> <span class="pre">=</span> <span class="pre">I</span></code>.
The single observable should be a Hermitian matrix.</p></li>
<li><p><strong>check_operators</strong> (<em>bool, optional</em>) – If a list of operators is specified, then check if they satisfy the
completeness relation defined above. Default if False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>int</em> – Index of the measurement operator that succeeded.</p></li>
<li><p><em>float</em> – Probability with which this result occurred.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>TypeError</strong> – If <code class="docutils literal notranslate"><span class="pre">qubits</span></code> is not a qubit or a non-empty list of qubits.</p></li>
<li><p><strong>ValueError</strong> – If the <code class="docutils literal notranslate"><span class="pre">meas_operators</span></code> are checked and don’t satisfy the constraints.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Unlike the <code class="docutils literal notranslate"><span class="pre">measure</span></code> function, a general measurement will not
split the qubit from its shared quantum state.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># |00&gt; state</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Measure q2 in the standard basis (P_0 = |0&gt;&lt;0|, P_1 = |1&gt;&lt;1|)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P_0</span><span class="p">,</span> <span class="n">P_1</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Z</span><span class="o">.</span><span class="n">projectors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gmeasure</span><span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="p">[</span><span class="n">P_0</span><span class="p">,</span> <span class="n">P_1</span><span class="p">])</span>
<span class="go">(0, 1.0)</span>
</pre></div>
</div>
<p>Perform a parity check in the standard basis on both qubits.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gmeasure</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">ops</span><span class="o">.</span><span class="n">Z</span> <span class="o">^</span> <span class="n">ops</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
<span class="go">(0, 1.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.discard">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">discard</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubit</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.discard" title="Link to this definition"></a></dt>
<dd><p>Drop a qubit from its shared quantum state.</p>
<p>The discarded qubit’s quantum state will become <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>qubit</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Qubit to discard.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>How a qubit is <em>dropped</em> is formalism specific.
In the DM formalism the qubit is traced out.
In the pure state formalisms the qubit is first measured (in
standard basis) if the quantum state is shared with one or more
qubits, which is equivalent to calling <code class="docutils literal notranslate"><span class="pre">measure(q,</span> <span class="pre">discard=True)</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">qubit</span></code> is the only qubit in the quantum state, then
the only action is to assign its quantum state to <code class="docutils literal notranslate"><span class="pre">None</span></code>.
For efficiency the quantum state object itself is not modified
in this case but simply assumed to be lost i.e. it will continue
to reference the dropped qubit (but not vice versa).</p>
<p class="rubric">Examples</p>
<p>Discard the second qubit from the <code class="docutils literal notranslate"><span class="pre">|00&gt;</span></code> state in the:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># separate states |0&gt;, |0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">combine_qubits</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">])</span>  <span class="c1"># state |00&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">discard</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q1</span><span class="o">.</span><span class="n">qstate</span><span class="p">)</span>
<span class="go">QState([Qubit(&#39;QS#14-0&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q2</span><span class="o">.</span><span class="n">qstate</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.reduced_dm">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">reduced_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.reduced_dm" title="Link to this definition"></a></dt>
<dd><p>Returns the reduced density matrix for the given qubit(s).</p>
<p>This is the result of tracing out all other qubits from
the shared quantum state of <code class="docutils literal notranslate"><span class="pre">qubits</span></code>.</p>
<p>This is the recommended way to get the density matrix for a collection of qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>qubits</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a> or list of <a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – List of qubits to find the reduced state for. The order of the qubits
will define the vector space for the reduced state.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Density matrix representing the reduced density matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.array</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The combined qubits are first <em>combined</em> if necessary.
It does not otherwise modify the qubits or the shared quantum state.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operate</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operate</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">ops</span><span class="o">.</span><span class="n">CNOT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">reduced_dm</span><span class="p">(</span><span class="n">q1</span><span class="p">))</span>
<span class="go">[[0.5+0.j 0. +0.j]</span>
<span class="go"> [0. +0.j 0.5+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.apply_pauli_noise">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">apply_pauli_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_weights</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.apply_pauli_noise" title="Link to this definition"></a></dt>
<dd><p>Randomly apply pauli noise to a qubit according probability weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubit</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Qubit to apply noise to.</p></li>
<li><p><strong>p_weights</strong> (<em>tuple of float</em>) – Probability distribution of I, X, Y, Z given that qubit depolarizes.
Must sum to one.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the specified <cite>p_weights</cite> typle has incorrect length or does
    not sum to one.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In formalisms that do not support ensemble states the depolarization is
simulated by randomly applying Pauli gate operations.</p>
<p class="rubric">Example</p>
<p>Apply <code class="docutils literal notranslate"><span class="pre">X</span></code> noise to a qubit with a 50% probability:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_pauli_noise</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p>Depolarize a qubit:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_pauli_noise</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>Depolarize a qubit with probability <code class="docutils literal notranslate"><span class="pre">p</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mf">0.8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_pauli_noise</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="mf">0.75</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">p</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.depolarize">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">depolarize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.depolarize" title="Link to this definition"></a></dt>
<dd><p>Randomly depolarize a qubit with a given probability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubit</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Qubit to depolarize.</p></li>
<li><p><strong>prob</strong> (<em>float</em>) – Probability that qubit will depolarize.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Note that the probability that the quantum state of a qubit is actually
changed due to application of a Pauli operator is 0.75 * <cite>prob</cite>.</p>
<p>In formalisms that do not support ensemble states the depolarization is
simulated by randomly applying Pauli gate operations.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># |0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">depolarize</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.80</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.dephase">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">dephase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.dephase" title="Link to this definition"></a></dt>
<dd><p>Randomly apply a Z-gate to a qubit with a given probability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubit</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Qubit to dephase.</p></li>
<li><p><strong>prob</strong> (<em>float</em>) – Probability <span class="math notranslate nohighlight">\(p\)</span> that Z gate is applied.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><span class="math notranslate nohighlight">\(p = 0\)</span> is no dephasing, <span class="math notranslate nohighlight">\(p = 1\)</span> is a Z gate,
<span class="math notranslate nohighlight">\(p = 1/2\)</span> is max dephasing.</p>
<p>In formalisms that do not support ensemble states the dephasing is
simulated by randomly applying a Z gate operation.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># |0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dephase</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.80</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.amplitude_dampen">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">amplitude_dampen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache_precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.amplitude_dampen" title="Link to this definition"></a></dt>
<dd><p>Apply generalized amplitude damping to a qubit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubit</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Qubit to apply amplitude damping to.</p></li>
<li><p><strong>gamma</strong> (<em>float</em>) – Damping parameter.</p></li>
<li><p><strong>prob</strong> (<em>float, optional</em>) – Probability <span class="math notranslate nohighlight">\(p\)</span> defining the stationary state (see below).</p></li>
<li><p><strong>cache</strong> (<em>bool, optional</em>) – Whether to use caching to speed up computation for identical
<code class="docutils literal notranslate"><span class="pre">gamma</span></code> and <code class="docutils literal notranslate"><span class="pre">prob</span></code> parameters (up to <code class="docutils literal notranslate"><span class="pre">cache_precision</span></code>).</p></li>
<li><p><strong>cache_precision</strong> (<em>int, optional</em>) – Decimal place precision to round caching lookup parameter(s) to.
If set to -1, then no rounding is performed.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NotImplementedError</strong> – If the quantum state formalism being used cannot do amplitude damping e.g.
    stabilizer state formalisms.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Applies the quantum operation <span class="math notranslate nohighlight">\(\varepsilon(\rho) = \sum_i E_i \rho \, E_i^\dagger\)</span>
using the elements:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
E_0 &amp;= \sqrt{p}\begin{bmatrix} 1 &amp; 0 \\ 0 &amp; \sqrt{1 - \gamma} \end{bmatrix} &amp;
E_1 &amp;= \sqrt{p}\begin{bmatrix} 0 &amp; \sqrt{\gamma} \\ 0 &amp; 0 \end{bmatrix} \\
E_2 &amp;= \sqrt{1-p}\begin{bmatrix} \sqrt{1 - \gamma} &amp; 0 \\ 0 &amp; 1 \end{bmatrix} &amp;
E_3 &amp;= \sqrt{1-p}\begin{bmatrix} 0 &amp; 0 \\ \sqrt{\gamma} &amp; 0 \end{bmatrix}
\end{aligned}\end{split}\]</div>
<p>The stationary state that is unaffected by
generalized amplitude damping is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\rho_\infty = \begin{bmatrix} p &amp; 0 \\ 0 &amp; 1-p \end{bmatrix},\end{split}\]</div>
<p>such that <span class="math notranslate nohighlight">\(\varepsilon(\rho_\infty) = \rho_\infty\)</span>.</p>
<p>For pure quantum state formalisms (i.e. <code class="xref py py-obj docutils literal notranslate"><span class="pre">KET</span></code>)
an ancilla bit is used to apply the amplitude damping.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">set_qstate_formalism</span><span class="p">(</span><span class="n">QFormalism</span><span class="o">.</span><span class="n">DM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># |0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude_dampen</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">reduced_dm</span><span class="p">(</span><span class="n">q1</span><span class="p">))</span>
<span class="go">[[1.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operate</span><span class="p">([</span><span class="n">q1</span><span class="p">],</span> <span class="n">ops</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>  <span class="c1"># -&gt; |1&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude_dampen</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">reduced_dm</span><span class="p">(</span><span class="n">q1</span><span class="p">))</span>
<span class="go">[[0.1+0.j 0. +0.j]</span>
<span class="go"> [0. +0.j 0.9+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.apply_dda_noise">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">apply_dda_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deph</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ampl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.apply_dda_noise" title="Link to this definition"></a></dt>
<dd><p>Applies depolarising, dephasing and amplitude-damping noise to a qubit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubit</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a> or list of <a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Qubit(s) to apply (independent) noise to.</p></li>
<li><p><strong>depol</strong> (<em>float</em>) – Depolarising parameter.</p></li>
<li><p><strong>deph</strong> (<em>float</em>) – Dephasing parameter.</p></li>
<li><p><strong>ampl</strong> (<em>float</em>) – Damping parameter.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NotImplementedError</strong> – If amplitude damping parameter non-zero and the quantum state formalism being used
    cannot do amplitude damping e.g. stabilizer state formalisms.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Does not include generalized amplitude-damping noise. The order of applying the
noise is fixed: depolarize, dephase then amplitude dampen, which might matter.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.delay_depolarize">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">delay_depolarize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depolar_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.delay_depolarize" title="Link to this definition"></a></dt>
<dd><p>Randomly depolarize a qubit for a delay with a given depolarization rate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubit</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Qubit to depolarize.</p></li>
<li><p><strong>depolar_rate</strong> (<em>float</em>) – Depolarization rate <span class="math notranslate nohighlight">\(R\)</span> for qubit (see notes below) [Hz].
The probability of not depolarizing follows an exponential distribution, such
that a <code class="docutils literal notranslate"><span class="pre">delay</span></code> of 1/<code class="docutils literal notranslate"><span class="pre">depolar_rate</span></code> gives a depolarizing probability of 63%.</p></li>
<li><p><strong>delay</strong> (<em>float</em>) – Time delay <span class="math notranslate nohighlight">\(\Delta t\)</span> during which qubit could have depolarized [ns]
(see notes below).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Probability that the qubit was depolarized.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The depolarizing probability is calculated as <span class="math notranslate nohighlight">\(p = 1 - \exp(-\Delta t\, R)\)</span>,
where <span class="math notranslate nohighlight">\(R\)</span> is the depolarization rate and <span class="math notranslate nohighlight">\(\Delta t\)</span> the delay.</p>
<p>In formalisms that do not support ensemble states the depolarization is
simulated by randomly applying Pauli gate operations.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># |0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delay_depolarize</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">depolar_rate</span><span class="o">=</span><span class="mf">0.10</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">10e9</span><span class="p">)</span>  <span class="c1"># delay of 10 seconds</span>
<span class="go">0.6321...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.delay_dephase">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">delay_dephase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dephase_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.delay_dephase" title="Link to this definition"></a></dt>
<dd><p>Randomly dephase a qubit for a delay with a given dephasing rate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubit</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Qubit to dephase.</p></li>
<li><p><strong>dephase_rate</strong> (<em>float</em>) – Dephasing rate <span class="math notranslate nohighlight">\(R\)</span> for qubit (see notes below) [Hz].
The probability of not dephasing follows an exponential distribution, such
that a <code class="docutils literal notranslate"><span class="pre">delay</span></code> of 1/<code class="docutils literal notranslate"><span class="pre">dephase_rate</span></code> gives a dephasing probability of 63%.</p></li>
<li><p><strong>delay</strong> (<em>float</em>) – Time delay <span class="math notranslate nohighlight">\(\Delta t\)</span> during which qubit could have dephased [ns]
(see notes below).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Probability that the qubit was dephased.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The dephasing probability is calculated as <span class="math notranslate nohighlight">\(p = 1 - \exp(-\Delta t\, R\)</span>,
where <span class="math notranslate nohighlight">\(R\)</span> is the dephasing rate and <span class="math notranslate nohighlight">\(\Delta t\)</span> the delay.</p>
<p>In formalisms that do not support ensemble states the dephasing is
simulated by randomly applying Pauli gate operations.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># |0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delay_dephase</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">dephase_rate</span><span class="o">=</span><span class="mf">0.10</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">10e9</span><span class="p">)</span>  <span class="c1"># delay of 10 seconds</span>
<span class="go">0.6321...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.fidelity">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">fidelity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">squared</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.fidelity" title="Link to this definition"></a></dt>
<dd><p>Calculate fidelity between the qubit(s) quantum state and a reference state.</p>
<p>The fidelity is calculated as implemented in each QState formalism (KET, DM, STAB)
These formalisms implement a method to reduce a large qubit state to a size matching the reference state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubits</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a> or list of <a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Single qubit or a list of qubits for which to compute the fidelity.
If a list of qubits is given their quantum states will be <em>combined</em>
(in the given order) to ensure they share the same state.</p></li>
<li><p><strong>reference_state</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.array</span></code> or <a class="reference internal" href="netsquid.qubits.qrepr.html#netsquid.qubits.qrepr.QRepr" title="netsquid.qubits.qrepr.QRepr"><code class="xref py py-class docutils literal notranslate"><span class="pre">netsquid.qubits.qrepr.QRepr</span></code></a>) – Ket vector or density matrix state with which fidelity is computed.</p></li>
<li><p><strong>squared</strong> (<em>bool, optional</em>) – If True the squared Fidelity is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Fidelity (or squared fidelity).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If number of qubits does not match size of reference state.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function does not modify the qubits or the shared quantum state.</p>
<p class="rubric">Examples</p>
<p>We check the fidelity of two qubits with the Bell state
<code class="docutils literal notranslate"><span class="pre">b00</span> <span class="pre">=</span> <span class="pre">(|00&gt;</span> <span class="pre">+</span> <span class="pre">|11&gt;)/sqrt(2)</span></code> before and after applying
the necessary gate operations.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># |00&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">fidelity</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">ketstates</span><span class="o">.</span><span class="n">b00</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0.71</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operate</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operate</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">ops</span><span class="o">.</span><span class="n">CNOT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">fidelity</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">ketstates</span><span class="o">.</span><span class="n">b00</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>We can also check the fidelity for the reduced state of each
qubit separately.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">fidelity</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">ketstates</span><span class="o">.</span><span class="n">s0</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">fidelity</span><span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="n">ketstates</span><span class="o">.</span><span class="n">s0</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.exp_value">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">exp_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.exp_value" title="Link to this definition"></a></dt>
<dd><p>Calculate the expectation value of an operator over the (reduced) state of qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubits</strong> (<a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a> or list of <a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Single qubit or a list of qubits with which to compute the expectation value.
The order of the qubits with respect to the operator is important.</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="netsquid.qubits.operators.html#netsquid.qubits.operators.Operator" title="netsquid.qubits.operators.Operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Operator</span></code></a>) – Operator to calculate expectation value for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expectation value for the given operator.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function does not modify the qubits or the shared quantum state.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.qubits.qubitapi.combine_qubits">
<span class="sig-prename descclassname"><span class="pre">netsquid.qubits.qubitapi.</span></span><span class="sig-name descname"><span class="pre">combine_qubits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.qubits.qubitapi.combine_qubits" title="Link to this definition"></a></dt>
<dd><p>Join a list of qubits together so that they share the same quantum state.</p>
<p>This procedure will generally be performed automatically.
The order that qubits are internally represented by the resulting
shared quantum state may differ from the order of the <code class="docutils literal notranslate"><span class="pre">qubits</span></code> list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>qubits</strong> (list of <a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – List of qubit to combine.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The combined qubits ordered as they are in their new shared state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If any qubits already share the same quantum states then their
combination is ignored.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q2</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q3</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">combine_qubits</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">q3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q1</span><span class="o">.</span><span class="n">qstate</span><span class="o">.</span><span class="n">qrepr</span><span class="o">.</span><span class="n">reduced_dm</span><span class="p">())</span>
<span class="go">[[1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go"> [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="netsquid.qubits.qformalism.html" class="btn btn-neutral float-left" title="netsquid.qubits.qformalism" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="netsquid.qubits.operators.html" class="btn btn-neutral float-right" title="netsquid.qubits.operators" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2021, TNO and TUDelft (QuTech).</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: 1.1.7
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
      <dd><a href="/1-1-stable/">1.1.5</a></dd>
      <dd><a href="/1-0-stable/">1.0.7</a></dd>
      <dd><a href="/0-10-stable/">0.10.4</a></dd>
      <dd><a href="/0-9-stable/">0.9.11</a></dd>
      <dd><a href="/0-8-stable/">0.8.7</a></dd>
      <dd><a href="/0-7-stable/">0.7.5</a></dd>
      <dd><a href="/0-6-stable/">0.6.4</a></dd>
      <dd><a href="/0-5-stable/">0.5.2</a></dd>
      <dd><a href="/0-4-stable/">0.4.2</a></dd>
      <dd><a href="/0-3-stable/">0.3.5</a></dd>
      <dd><a href="/latest-release/">latest release</a></dd>
      <dd><a href="/master/">master branch</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".highlight-default .highlight").each(function() {
            if ($(this).find(".gp").length > 0) {
             $(this).prepend("<div class='codebtn btn btn-neutral float-right'><div class='gp'>>>></div><div>");
             $(this).children("pre").contents().filter(function() {return this.nodeType === 3;}).wrap("<span></span>").end();
            }
        });
        $(".highlight-default .highlight .codebtn").click(function() {
            $(this).parent().children("pre").find(".gp").toggleClass("hidden");
            var traceback_elem = $(this).parent().children("pre").find(".gt, .go");
            traceback_elem.toggleClass("hidden");
            traceback_elem.nextUntil(".gp, .go").toggleClass("hidden");

        })
    });
</script>


</body>
</html>