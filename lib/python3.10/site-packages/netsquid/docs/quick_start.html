<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NetSquid in 10 minutes &mdash; NetSquid 1.1.7 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="_static/style.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=370aedac"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Tutorial" href="tutorial.intro.html" />
    <link rel="prev" title="NETSQUID SOFTWARE END USER LICENSE CONDITIONS" href="LICENSE.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #E3E3E3" >

          
          
          <a href="index.html" class="icon icon-home">
            NetSquid
              <img src="_static/squid-150.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.1.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="README.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="INSTALL.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="AUTHORS.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="LICENSE.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Learn NetSquid</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">NetSquid in 10 minutes</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.intro.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial.qubits.html">Qubits and quantum computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.pydynaa.html">Discrete event simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.components.html">Modelling of network components</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.nodes.html">Nodes and Connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.quantumprocessor.html">The Quantum Processor</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.simulation.html">A full simulation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="learn.examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="learn_examples/learn.examples.teleportation.html">Teleportation</a></li>
<li class="toctree-l2"><a class="reference internal" href="learn_examples/learn.examples.repeater.html">Repeater with purification</a></li>
<li class="toctree-l2"><a class="reference internal" href="learn_examples/learn.examples.repeater_chain.html">Repeater chain</a></li>
<li class="toctree-l2"><a class="reference internal" href="learn_examples/learn.examples.simple_link.html">A simple link layer protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="learn_examples/learn.examples.magic_simple_link.html">Faster Link layer Protocol using abstraction</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api_reference.html">NetSquid package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="netsquid.qubits.html">netsquid.qubits</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.qformalism.html">netsquid.qubits.qformalism</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.qubitapi.html">netsquid.qubits.qubitapi</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.operators.html">netsquid.qubits.operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.cliffords.html">netsquid.qubits.cliffords</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.ketstates.html">netsquid.qubits.ketstates</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.state_sampler.html">netsquid.qubits.state_sampler</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.qubit.html">netsquid.qubits.qubit</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.qstate.html">netsquid.qubits.qstate</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.qrepr.html">netsquid.qubits.qrepr</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.kettools.html">netsquid.qubits.kettools</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.dmtools.html">netsquid.qubits.dmtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.sparsedmtools.html">netsquid.qubits.sparsedmtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.stabtools.html">netsquid.qubits.stabtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.gslctools.html">netsquid.qubits.gslctools</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.qreprutil.html">netsquid.qubits.qreprutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.ketutil.html">netsquid.qubits.ketutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.dmutil.html">netsquid.qubits.dmutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.sparseutil.html">netsquid.qubits.sparseutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.gslcutil.html">netsquid.qubits.gslcutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.opmath.html">netsquid.qubits.opmath</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="netsquid.components.html">netsquid.components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.component.html">netsquid.components.component</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.channel.html">netsquid.components.channel</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.qchannel.html">netsquid.components.qchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.cchannel.html">netsquid.components.cchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.cqchannel.html">netsquid.components.cqchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.qmemory.html">netsquid.components.qmemory</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.instructions.html">netsquid.components.instructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.qprogram.html">netsquid.components.qprogram</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.qprocessor.html">netsquid.components.qprocessor</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.clock.html">netsquid.components.clock</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.qsource.html">netsquid.components.qsource</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.qdetector.html">netsquid.components.qdetector</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.switch.html">netsquid.components.switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.ccoding.html">netsquid.components.ccoding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="netsquid.components.models.html">netsquid.components.models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_models/netsquid.components.models.model.html">netsquid.components.models.model</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_models/netsquid.components.models.delaymodels.html">netsquid.components.models.delaymodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_models/netsquid.components.models.errormodels.html">netsquid.components.models.errormodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_models/netsquid.components.models.qerrormodels.html">netsquid.componentsmodels.qerrormodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_models/netsquid.components.models.cerrormodels.html">netsquid.components.models.cerrormodels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="netsquid.nodes.html">netsquid.nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_nodes/netsquid.nodes.node.html">netsquid.nodes.node</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_nodes/netsquid.nodes.connections.html">netsquid.nodes.connections</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_nodes/netsquid.nodes.network.html">netsquid.nodes.network</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="netsquid.protocols.html">netsquid.protocols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_protocols/netsquid.protocols.protocol.html">netsquid.protocols.protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_protocols/netsquid.protocols.nodeprotocols.html">netsquid.protocols.nodeprotocols</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_protocols/netsquid.protocols.serviceprotocol.html">netsquid.protocols.serviceprotocol</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="netsquid.util.html">netsquid.util</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_util/netsquid.util.simtools.html">netsquid.util.simtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_util/netsquid.util.simlog.html">netsquid.util.simlog</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_util/netsquid.util.simstats.html">netsquid.util.simstats</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_util/netsquid.util.datacollector.html">netsquid.util.datacollector</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_util/netsquid.util.cycache.html">netsquid.util.cycache</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_util/netsquid.util.cymath.html">netsquid.util.cymath</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_util/netsquid.util.constrainedmap.html">netsquid.util.constrainedmap</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="netsquid.examples.html">netsquid.examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_examples/netsquid.examples.teleportation.html">netsquid.examples.teleportation</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_examples/netsquid.examples.entanglenodes.html">netsquid.examples.entanglenodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_examples/netsquid.examples.purify.html">netsquid.examples.purify</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_examples/netsquid.examples.repeater.html">netsquid.examples.repeater</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_examples/netsquid.examples.repeater_chain.html">netsquid.examples.repeater_chain</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_examples/netsquid.examples.simple_link.html">netsquid.examples.simple_link</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_examples/netsquid.examples.magic_simple_link.html">netsquid.examples.magic_simple_link</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api_pydynaa.html">pyDynAA package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pydynaa.html">pydynaa.Entity</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydynaa.html#pydynaa-event">pydynaa.Event</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydynaa.html#pydynaa-eventtype">pydynaa.EventType</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydynaa.html#pydynaa-eventexpression">pydynaa.EventExpression</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydynaa.html#pydynaa-eventhandler">pydynaa.EventHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydynaa.html#pydynaa-expressionhandler">pydynaa.ExpressionHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydynaa.html#pydynaa-simulationengine">pydynaa.SimulationEngine</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">For developers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="INSTALL-SOURCE.html">Installation from source</a></li>
<li class="toctree-l1"><a class="reference internal" href="CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHANGELOG.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #E3E3E3" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">NetSquid</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">NetSquid in 10 minutes</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/quick_start.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="LICENSE.html" class="btn btn-neutral float-left" title="NETSQUID SOFTWARE END USER LICENSE CONDITIONS" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tutorial.intro.html" class="btn btn-neutral float-right" title="Tutorial" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="netsquid-in-10-minutes">
<h1>NetSquid in 10 minutes<a class="headerlink" href="#netsquid-in-10-minutes" title="Link to this heading"></a></h1>
<p>Welcome to this quick start guide to NetSquid.
In this guide we will give a brief outline of how to use NetSquid.
For a more in-depth introduction you can follow the <a class="reference external" href="tutorial.intro.html">tutorial</a> or experiment with the provided <a class="reference external" href="netsquid.examples.html">examples</a>.
To run the code examples presented in this guide you will need to have NetSquid installed, which you can do by following <a class="reference external" href="INSTALL.html">these instructions</a>.
If you have any questions along the way please feel free to ask them on the <a class="reference external" href="https://forum.netsquid.org/viewforum.php?f=1">NetSquid forum</a>.</p>
<p>We will give a brief walk-through of how to set up and run a quantum network simulation that plays a game of ping-pong between two ‘players’ using a qubit.
If the concept of a qubit is completely new to you it may help to first refer to the <a class="reference external" href="tutorial.intro.html">start of the tutorial</a> for a short introduction.
The game is played by the two players, <em>Ping</em> and <em>Pong</em>, who take turns measuring the qubit in the their preferred basis – the standard (Z) or Hadamard (X) bases respectively – and then sending the qubit on to the other via a shared quantum channel.
We can model this game in a network. Where the players are represented by nodes, and they are connected with the quantum channel.
A cartoon of this setup is illustrated below:</p>
<a class="reference internal image-reference" href="_images/pingpong_cartoon.png"><img alt="_images/pingpong_cartoon.png" class="align-center" src="_images/pingpong_cartoon.png" style="width: 450px;" /></a>
<p>To model and simulate this example we will introduce and utilise the four key pieces that make up NetSquid:
the <em>qubits</em> that store and carry quantum information,
a <em>simulation engine</em> that accurately accounts for the passage of time,
<em>components</em> that physically model the quantum network, and
<em>protocols</em> that describe the classical control at the various nodes in the network (the software).</p>
<section id="qubits">
<h2>Qubits<a class="headerlink" href="#qubits" title="Link to this heading"></a></h2>
<p>Qubits are the actors of any quantum network simulation:
they can be dynamically created or destroyed,
transmitted via quantum channels or stay put in quantum memories,
decohere with age,
and entangle with each other as they interact.
By default qubits are created in the <span class="math notranslate nohighlight">\(\vert 0 \rangle\)</span> state e.g.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">netsquid</span> <span class="k">as</span> <span class="nn">ns</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qubits</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qubits</span>
<span class="go">[Qubit(&#39;QS#0-0&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qubit</span> <span class="o">=</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># To check the state is |0&gt; we check its density matrix using reduced_dm():</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">reduced_dm</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="go">array([[1.+0.j, 0.+0.j],</span>
<span class="go">       [0.+0.j, 0.+0.j]])</span>
</pre></div>
</div>
<p>The quantum state of qubits can be directly manipulated using quantum operators.
For example, to transform the qubit’s state from <span class="math notranslate nohighlight">\(\vert 0 \rangle\)</span> to <span class="math notranslate nohighlight">\(\vert 1 \rangle\)</span> we can use the <a class="reference internal" href="api_qubits/netsquid.qubits.operators.html#netsquid.qubits.operators.X" title="netsquid.qubits.operators.X"><code class="xref py py-class docutils literal notranslate"><span class="pre">X</span></code></a> operator:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">ns</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">reduced_dm</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="go">array([[0.+0.j, 0.+0.j],</span>
<span class="go">       [0.+0.j, 1.+0.j]])</span>
</pre></div>
</div>
<p>Note that quantum operators are purely linear algebra transformations.
In a quantum computer the operators are performed by <em>quantum gates</em>.
These physical quantum gates often introduce some noise to the qubits;
the <a class="reference external" href="tutorial.intro.html">tutorial</a>  explains how gates can be physically modeled with noise, losses and delays.</p>
<p>For the ping-pong game the two nodes will be performing projective measurements on their qubit.
A qubit can be directly measured using the <em>measure()</em> function.
This function returns the measurement result as either 0 or 1, as well as the probability with which it got the specific measurement result.
The default measurement basis is the standard basis (Z).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">measurement_result</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">measurement_result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;|0&gt;&quot;</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;|1&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Measured </span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2"> with probability </span><span class="si">{</span><span class="n">prob</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">Measured |1&gt; with probability 1.0</span>
</pre></div>
</div>
<p>To measure in the Hadamard (X) basis we can change the measurement observable parameter:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">measurement_result</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">observable</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">measurement_result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;|+&gt;&quot;</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;|-&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Measured </span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2"> with probability </span><span class="si">{</span><span class="n">prob</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">Measured |-&gt; with probability 0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">reduced_dm</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="go">array([[ 0.5+0.j, -0.5+0.j],</span>
<span class="go">       [-0.5+0.j,  0.5+0.j]])</span>
</pre></div>
</div>
<p>The outcome of the measurement is now random.
When running the above code yourself you might measure <span class="math notranslate nohighlight">\(\vert + \rangle\)</span> instead.</p>
<p>For more information about qubits you can look at the <a class="reference external" href="tutorial.qubits.html">qubits tutorial</a> or the <a class="reference external" href="netsquid.qubits.html">qubit documentation</a>.</p>
</section>
<section id="simulation-engine">
<h2>Simulation engine<a class="headerlink" href="#simulation-engine" title="Link to this heading"></a></h2>
<p>To track the time evolution of qubit quantum states and account for communication and processing delays in a network a <em>discrete event simulation engine</em> is used.
In a nutshell the simulator schedules events at specific times on a timeline, and progresses time by chronologically stepping through these events.
Simulation entities can listen for and react to these events, and optionally schedule future events in the process.
This is illustrated in the cartoon below where the <em>Ping</em> and <em>Pong</em> players are each simulation entities that handle ping and pong events,
and in turn schedule new future pong and ping events, respectively.</p>
<img alt="_images/pydynaa_cartoon.png" class="align-center" src="_images/pydynaa_cartoon.png" />
<p><em>Ping</em> hits the qubit to <em>Pong</em> and schedules an event 14ns in the future.
The simulator steps to this event on the timeline and increases the simulation time by 14ns.
<em>Pong</em> was waiting for that event; upon receiving the event he handles it by hitting the qubit back and scheduling another event 17ns in the future.
The simulation steps to this event again and the whole process is repeated.</p>
<p>For more information about the simulation engine you can look at the <a class="reference external" href="tutorial.pydynaa.html">discrete event tutorial</a> or the <a class="reference external" href="api_pydynaa.html">pyDynAA documentation</a>.</p>
</section>
<section id="components">
<h2>Components<a class="headerlink" href="#components" title="Link to this heading"></a></h2>
<p>In order to simulate the ping-pong example we will first need to model a quantum network to run it on.
Such a network can be set up in NetSquid by linking the provided <em>component</em> base classes together.
Components in NetSquid are simulation entities that model the hardware of the network physically.
They can be composed of functional <em>models</em> that characterise their behaviour, IO <em>ports</em> for communication, and, in the case of <em>composite components</em>, other subcomponents.
The main components we will need for our example are two one-way quantum channels to transmit the qubit in both directions.
For convenience we can wrap these two channels in a single connection component,
that connects to two node components representing the Ping and Pong players.
The diagram below gives a schematic illustration of our network setup in terms of components:</p>
<a class="reference internal image-reference" href="_images/pingpong_schematic.png"><img alt="_images/pingpong_schematic.png" class="align-center" src="_images/pingpong_schematic.png" style="width: 500px;" /></a>
<p>Let us set up this network in NetSquid.
First start by creating the two remote nodes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.nodes</span> <span class="kn">import</span> <span class="n">Node</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">node_ping</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Ping&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">node_pong</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Pong&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>To transmit our qubit between these nodes we will use quantum channel components.
To determine the transmission delay for these channels we will define a custom <em>delay model</em> that depends on the length of each channel.
Let us set the average qubit speed to be 50% of the speed of light in vacuum
with a standard deviation of 5%.
A custom class that models the transmission delay is then:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components.models</span> <span class="kn">import</span> <span class="n">DelayModel</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">PingPongDelayModel</span><span class="p">(</span><span class="n">DelayModel</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">speed_of_light_fraction</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span class="gp">... </span>        <span class="c1"># (the speed of light is about 300,000 km/s)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;speed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">speed_of_light_fraction</span> <span class="o">*</span> <span class="mf">3e5</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;std&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">standard_deviation</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">required_properties</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span>  <span class="c1"># in km</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">generate_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">avg_speed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;speed&quot;</span><span class="p">]</span>
<span class="gp">... </span>        <span class="n">std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;std&quot;</span><span class="p">]</span>
<span class="gp">... </span>        <span class="c1"># The &#39;rng&#39; property contains a random number generator</span>
<span class="gp">... </span>        <span class="c1"># We can use that to generate a random speed</span>
<span class="gp">... </span>        <span class="n">speed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;rng&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">avg_speed</span><span class="p">,</span> <span class="n">avg_speed</span> <span class="o">*</span> <span class="n">std</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">delay</span> <span class="o">=</span> <span class="mf">1e9</span> <span class="o">*</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">speed</span>  <span class="c1"># in nanoseconds</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">delay</span>
</pre></div>
</div>
<p>We are now ready to create the quantum channels.
We set the length of each one-way quantum channel to be 2.74 meters, the length of a standard ping-pong table.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components</span> <span class="kn">import</span> <span class="n">QuantumChannel</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distance</span> <span class="o">=</span> <span class="mf">2.74</span> <span class="o">/</span> <span class="mi">1000</span>  <span class="c1"># default unit of length in channels is km</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delay_model</span> <span class="o">=</span> <span class="n">PingPongDelayModel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">channel_1</span> <span class="o">=</span> <span class="n">QuantumChannel</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;qchannel[ping to pong]&quot;</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">length</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">models</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;delay_model&quot;</span><span class="p">:</span> <span class="n">delay_model</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">channel_2</span> <span class="o">=</span> <span class="n">QuantumChannel</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;qchannel[pong to ping]&quot;</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">length</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">models</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;delay_model&quot;</span><span class="p">:</span> <span class="n">delay_model</span><span class="p">})</span>
</pre></div>
</div>
<p>A <em>connection</em> component provides a convenient way to wrap the two channels into one component that we can connect between the two nodes.
We also choose names for the ports that the nodes will use to send and receive the qubit.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.nodes</span> <span class="kn">import</span> <span class="n">DirectConnection</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">connection</span> <span class="o">=</span> <span class="n">DirectConnection</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;conn[ping|pong]&quot;</span><span class="p">,</span>
<span class="gp">... </span>                              <span class="n">channel_AtoB</span><span class="o">=</span><span class="n">channel_1</span><span class="p">,</span>
<span class="gp">... </span>                              <span class="n">channel_BtoA</span><span class="o">=</span><span class="n">channel_2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">node_ping</span><span class="o">.</span><span class="n">connect_to</span><span class="p">(</span><span class="n">remote_node</span><span class="o">=</span><span class="n">node_pong</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">local_port_name</span><span class="o">=</span><span class="s2">&quot;qubitIO&quot;</span><span class="p">,</span> <span class="n">remote_port_name</span><span class="o">=</span><span class="s2">&quot;qubitIO&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The connection goes both ways,
so <em>Ping</em> and <em>Pong</em> can now send and receive qubits to/from each other by using their “qubitIO” ports.</p>
<p>For more information about components you can look at the <a class="reference external" href="tutorial.components.html">components tutorial</a> or the <a class="reference external" href="netsquid.components.html">components documentation</a>.</p>
</section>
<section id="protocols">
<h2>Protocols<a class="headerlink" href="#protocols" title="Link to this heading"></a></h2>
<p>To describe the game-playing behaviour of the two nodes we will use <em>protocols</em>:
virtual simulation entities that will handle the incoming qubits at each node.
Protocols model the <strong>software</strong> to be run on the physical components.
We could also choose to forward the qubit to another component at the node, such as a quantum memory or a detector, but we skip such a modelling option for the sake of simplicity.
The protocol we need at each node should wait for any incoming qubits on the node’s port.
When a qubit arrives it should measure it in the preferred basis,
then directly send it back through the same port.
The following <em>PingPongProtocol</em> does this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.protocols</span> <span class="kn">import</span> <span class="n">NodeProtocol</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">PingPongProtocol</span><span class="p">(</span><span class="n">NodeProtocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">observable</span><span class="p">,</span> <span class="n">qubit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">observable</span> <span class="o">=</span> <span class="n">observable</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qubit</span> <span class="o">=</span> <span class="n">qubit</span>
<span class="gp">... </span>        <span class="c1"># Define matching pair of strings for pretty printing of basis states:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;|0&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;|1&gt;&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">observable</span> <span class="o">==</span> <span class="n">ns</span><span class="o">.</span><span class="n">Z</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;|+&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;|-&gt;&quot;</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="c1"># Send (TX) qubit to the other node via port&#39;s output:</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qubitIO&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tx_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="c1"># Wait (yield) until input has arrived on our port:</span>
<span class="gp">... </span>            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qubitIO&quot;</span><span class="p">])</span>
<span class="gp">... </span>            <span class="c1"># Receive (RX) qubit on the port&#39;s input:</span>
<span class="gp">... </span>            <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qubitIO&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">rx_input</span><span class="p">()</span>
<span class="gp">... </span>            <span class="n">qubit</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>            <span class="n">meas</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">observable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">observable</span><span class="p">)</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">()</span><span class="si">:</span><span class="s2">5.1f</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> measured &quot;</span>
<span class="gp">... </span>                  <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">meas</span><span class="p">]</span><span class="si">}</span><span class="s2"> with probability </span><span class="si">{</span><span class="n">prob</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">... </span>            <span class="c1"># Send (TX) qubit to the other node via connection:</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qubitIO&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tx_output</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
</pre></div>
</div>
<p>The constructor of this protocol (i.e. the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method) can optionally be given a qubit,
in which case it will use this qubit to kick the game off.
The protocol is started with the <code class="docutils literal notranslate"><span class="pre">start</span></code> method, which will call <code class="docutils literal notranslate"><span class="pre">run</span></code>.
The <code class="docutils literal notranslate"><span class="pre">run</span></code> method will run until the first <code class="docutils literal notranslate"><span class="pre">yield</span></code> where it will wait until it receives the qubit.
Once the qubit is received the method continues; the qubit is measured and sent back.
Once it is sent back the <code class="docutils literal notranslate"><span class="pre">run</span></code> method will encounter the <code class="docutils literal notranslate"><span class="pre">yield</span></code> once more and will wait again until it receives the qubit.
This process repeats ad infinitum until one of the protocol stops.</p>
<p>We can assign this protocol to both of our node components:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qubits</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ping_protocol</span> <span class="o">=</span> <span class="n">PingPongProtocol</span><span class="p">(</span><span class="n">node_ping</span><span class="p">,</span> <span class="n">observable</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">qubit</span><span class="o">=</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pong_protocol</span> <span class="o">=</span> <span class="n">PingPongProtocol</span><span class="p">(</span><span class="n">node_pong</span><span class="p">,</span> <span class="n">observable</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>We are now ready to start the game.</p>
<p>For more information about protocols you can look at the <a class="reference external" href="tutorial.protocols.html">protocols tutorial</a> or the <a class="reference external" href="netsquid.protocols.html">protocols documentation</a>.</p>
</section>
<section id="running-the-simulation">
<h2>Running the simulation<a class="headerlink" href="#running-the-simulation" title="Link to this heading"></a></h2>
<p>The protocols we assigned to our two nodes, <em>Ping</em> and <em>Pong</em>, first need to be started.
Once that is done we can instruct the simulation engine to run.
By default the engine will run until there are no more scheduled events.
Because in our case the two entities continue to schedule new events forever (caused by the <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">True</span></code> in the <code class="docutils literal notranslate"><span class="pre">run()</span></code> method of our protocol),
we should specify either an end time or a duration. Below we set the duration to 300 nano seconds:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ping_protocol</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pong_protocol</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">run_stats</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">sim_run</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
<span class="go"> 17.4: Pong measured |+&gt; with probability 0.50</span>
<span class="go"> 33.8: Ping measured |1&gt; with probability 0.50</span>
<span class="go"> 51.3: Pong measured |-&gt; with probability 0.50</span>
<span class="go"> 69.7: Ping measured |0&gt; with probability 0.50</span>
<span class="go"> 87.8: Pong measured |-&gt; with probability 0.50</span>
<span class="go">104.8: Ping measured |1&gt; with probability 0.50</span>
<span class="go">122.7: Pong measured |-&gt; with probability 0.50</span>
<span class="go">140.7: Ping measured |1&gt; with probability 0.50</span>
<span class="go">157.7: Pong measured |+&gt; with probability 0.50</span>
<span class="go">176.1: Ping measured |1&gt; with probability 0.50</span>
<span class="go">197.1: Pong measured |+&gt; with probability 0.50</span>
<span class="go">214.8: Ping measured |1&gt; with probability 0.50</span>
<span class="go">231.2: Pong measured |+&gt; with probability 0.50</span>
<span class="go">250.9: Ping measured |1&gt; with probability 0.50</span>
<span class="go">267.8: Pong measured |-&gt; with probability 0.50</span>
<span class="go">284.9: Ping measured |1&gt; with probability 0.50</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">sim_run()</span></code> function also returns some useful statistics that we can optionally print to diagnose our simulation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">run_stats</span><span class="p">)</span>

<span class="go">Simulation summary</span>
<span class="go">==================</span>

<span class="go">Elapsed wallclock time: ...</span>
<span class="go">Elapsed simulation time: 3.00e+02 [ns]</span>
<span class="go">Triggered events: 32</span>
<span class="go">Handled callbacks: 32</span>
<span class="go">Total quantum operations: 16</span>
<span class="go">Frequent quantum operations: MEASURE = 16</span>
<span class="go">Max qstate size: 1 qubits</span>
<span class="go">Mean qstate size: 1.00 qubits</span>
</pre></div>
</div>
<p>This concludes the getting started guide.
For a much more detailed introduction please see <a class="reference external" href="tutorial.intro.html">the tutorial</a>.
For more elaborate examples see the <a class="reference external" href="netsquid.examples.html">section with examples</a>.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="LICENSE.html" class="btn btn-neutral float-left" title="NETSQUID SOFTWARE END USER LICENSE CONDITIONS" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tutorial.intro.html" class="btn btn-neutral float-right" title="Tutorial" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2021, TNO and TUDelft (QuTech).</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: 1.1.7
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
      <dd><a href="/1-1-stable/">1.1.5</a></dd>
      <dd><a href="/1-0-stable/">1.0.7</a></dd>
      <dd><a href="/0-10-stable/">0.10.4</a></dd>
      <dd><a href="/0-9-stable/">0.9.11</a></dd>
      <dd><a href="/0-8-stable/">0.8.7</a></dd>
      <dd><a href="/0-7-stable/">0.7.5</a></dd>
      <dd><a href="/0-6-stable/">0.6.4</a></dd>
      <dd><a href="/0-5-stable/">0.5.2</a></dd>
      <dd><a href="/0-4-stable/">0.4.2</a></dd>
      <dd><a href="/0-3-stable/">0.3.5</a></dd>
      <dd><a href="/latest-release/">latest release</a></dd>
      <dd><a href="/master/">master branch</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".highlight-default .highlight").each(function() {
            if ($(this).find(".gp").length > 0) {
             $(this).prepend("<div class='codebtn btn btn-neutral float-right'><div class='gp'>>>></div><div>");
             $(this).children("pre").contents().filter(function() {return this.nodeType === 3;}).wrap("<span></span>").end();
            }
        });
        $(".highlight-default .highlight .codebtn").click(function() {
            $(this).parent().children("pre").find(".gp").toggleClass("hidden");
            var traceback_elem = $(this).parent().children("pre").find(".gt, .go");
            traceback_elem.toggleClass("hidden");
            traceback_elem.nextUntil(".gp, .go").toggleClass("hidden");

        })
    });
</script>


</body>
</html>