<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>netsquid.examples.repeater_chain &mdash; NetSquid 1.1.7 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=370aedac"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="netsquid.examples.simple_link" href="netsquid.examples.simple_link.html" />
    <link rel="prev" title="netsquid.examples.repeater" href="netsquid.examples.repeater.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #E3E3E3" >

          
          
          <a href="../index.html" class="icon icon-home">
            NetSquid
              <img src="../_static/squid-150.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.1.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../INSTALL.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RELEASE.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AUTHORS.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LICENSE.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Learn NetSquid</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quick_start.html">NetSquid in 10 minutes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.intro.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.qubits.html">Qubits and quantum computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.pydynaa.html">Discrete event simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.components.html">Modelling of network components</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.nodes.html">Nodes and Connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.quantumprocessor.html">The Quantum Processor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.simulation.html">A full simulation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../learn.examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.teleportation.html">Teleportation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.repeater.html">Repeater with purification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.repeater_chain.html">Repeater chain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.simple_link.html">A simple link layer protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.magic_simple_link.html">Faster Link layer Protocol using abstraction</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../api_reference.html">NetSquid package</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../netsquid.qubits.html">netsquid.qubits</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qformalism.html">netsquid.qubits.qformalism</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qubitapi.html">netsquid.qubits.qubitapi</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.operators.html">netsquid.qubits.operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.cliffords.html">netsquid.qubits.cliffords</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.ketstates.html">netsquid.qubits.ketstates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.state_sampler.html">netsquid.qubits.state_sampler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qubit.html">netsquid.qubits.qubit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qstate.html">netsquid.qubits.qstate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qrepr.html">netsquid.qubits.qrepr</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.kettools.html">netsquid.qubits.kettools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.dmtools.html">netsquid.qubits.dmtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.sparsedmtools.html">netsquid.qubits.sparsedmtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.stabtools.html">netsquid.qubits.stabtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.gslctools.html">netsquid.qubits.gslctools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qreprutil.html">netsquid.qubits.qreprutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.ketutil.html">netsquid.qubits.ketutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.dmutil.html">netsquid.qubits.dmutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.sparseutil.html">netsquid.qubits.sparseutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.gslcutil.html">netsquid.qubits.gslcutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.opmath.html">netsquid.qubits.opmath</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.components.html">netsquid.components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.component.html">netsquid.components.component</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.channel.html">netsquid.components.channel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qchannel.html">netsquid.components.qchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.cchannel.html">netsquid.components.cchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.cqchannel.html">netsquid.components.cqchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qmemory.html">netsquid.components.qmemory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.instructions.html">netsquid.components.instructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qprogram.html">netsquid.components.qprogram</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qprocessor.html">netsquid.components.qprocessor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.clock.html">netsquid.components.clock</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qsource.html">netsquid.components.qsource</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qdetector.html">netsquid.components.qdetector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.switch.html">netsquid.components.switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.ccoding.html">netsquid.components.ccoding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.components.models.html">netsquid.components.models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.model.html">netsquid.components.models.model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.delaymodels.html">netsquid.components.models.delaymodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.errormodels.html">netsquid.components.models.errormodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.qerrormodels.html">netsquid.componentsmodels.qerrormodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.cerrormodels.html">netsquid.components.models.cerrormodels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.nodes.html">netsquid.nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.node.html">netsquid.nodes.node</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.connections.html">netsquid.nodes.connections</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.network.html">netsquid.nodes.network</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.protocols.html">netsquid.protocols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html">netsquid.protocols.protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.nodeprotocols.html">netsquid.protocols.nodeprotocols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html">netsquid.protocols.serviceprotocol</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.util.html">netsquid.util</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simtools.html">netsquid.util.simtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simlog.html">netsquid.util.simlog</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simstats.html">netsquid.util.simstats</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.datacollector.html">netsquid.util.datacollector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.cycache.html">netsquid.util.cycache</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.cymath.html">netsquid.util.cymath</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html">netsquid.util.constrainedmap</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="reference internal" href="../netsquid.examples.html">netsquid.examples</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="netsquid.examples.teleportation.html">netsquid.examples.teleportation</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.examples.entanglenodes.html">netsquid.examples.entanglenodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.examples.purify.html">netsquid.examples.purify</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.examples.repeater.html">netsquid.examples.repeater</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">netsquid.examples.repeater_chain</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.examples.simple_link.html">netsquid.examples.simple_link</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.examples.magic_simple_link.html">netsquid.examples.magic_simple_link</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api_pydynaa.html">pyDynAA package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html">pydynaa.Entity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-event">pydynaa.Event</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventtype">pydynaa.EventType</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventexpression">pydynaa.EventExpression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventhandler">pydynaa.EventHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-expressionhandler">pydynaa.ExpressionHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-simulationengine">pydynaa.SimulationEngine</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">For developers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../INSTALL-SOURCE.html">Installation from source</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CHANGELOG.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #E3E3E3" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">NetSquid</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../api_reference.html">NetSquid package</a></li>
          <li class="breadcrumb-item"><a href="../netsquid.examples.html">netsquid.examples</a></li>
      <li class="breadcrumb-item active">netsquid.examples.repeater_chain</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api_examples/netsquid.examples.repeater_chain.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="netsquid.examples.repeater.html" class="btn btn-neutral float-left" title="netsquid.examples.repeater" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="netsquid.examples.simple_link.html" class="btn btn-neutral float-right" title="netsquid.examples.simple_link" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-netsquid.examples.repeater_chain">
<span id="netsquid-examples-repeater-chain"></span><h1>netsquid.examples.repeater_chain<a class="headerlink" href="#module-netsquid.examples.repeater_chain" title="Link to this heading"></a></h1>
<p>In this example we show how a simple quantum repeater chain network can be setup and simulated in NetSquid.
The module file used in this example can be located as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">netsquid</span> <span class="k">as</span> <span class="nn">ns</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This example module is located at: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
<span class="gp">... </span>      <span class="n">ns</span><span class="o">.</span><span class="n">examples</span><span class="o">.</span><span class="n">repeater_chain</span><span class="o">.</span><span class="vm">__file__</span><span class="p">))</span>
<span class="go">This example module is located at: .../netsquid/examples/repeater_chain.py</span>
</pre></div>
</div>
<p>In the <a class="reference external" href="netsquid.examples.repeater.html">repeater example</a> we simulated a single quantum repeater on a network topology consisting of two nodes
connected via a single repeater node (see for instance <a class="reference external" href="https://arxiv.org/abs/quant-ph/9803056">[Briegel et al.]</a> for more background).
To simulate a repeater chain we will extend this network topology to be a line of <em>N</em> nodes as shown below:</p>
<a class="reference internal image-reference" href="../_images/aafig-5225dd26c7e6031bedbb3069f01c6f6865d36af2.svg"><img alt="../_images/aafig-5225dd26c7e6031bedbb3069f01c6f6865d36af2.svg" height="90.0" src="../_images/aafig-5225dd26c7e6031bedbb3069f01c6f6865d36af2.svg" width="930.0" /></a>
<p>We will refer to the outer nodes as <em>end nodes</em>, and sometimes also as Alice and Bob for convenience,
and the in between nodes as the <em>repeater nodes</em>.
The lines between the nodes represent both an entangling connection and a classical connection,
as introduced in the <a class="reference external" href="netsquid.examples.teleportation.html">teleportation example</a>.
The repeaters will use a so-called <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_teleportation">entanglement swapping scheme</a> to entangle the end nodes,
which consists of the following steps:</p>
<ol class="arabic simple">
<li><p>generating entanglement with both of its neighbours,</p></li>
<li><p>measuring its two locally stored qubits in the Bell basis,</p></li>
<li><p>sending its own measurement outcomes to its right neighbour, and also forwarding on outcomes received from its left neighbour in this way.</p></li>
</ol>
<p>Let us create the repeater chain network.
We need to create the <em>N</em> nodes, each with a quantum processor, and every pair of nodes
in the chain must be linked using an entangling connection and a classical connection.
In each entangling connection an entangled qubit generating source is available.
A schematic illustration of a repeater and its connections is shown below:</p>
<a class="reference internal image-reference" href="../_images/aafig-90baf27884520107d2f730db4e3a0aa141783e2b.svg"><img alt="../_images/aafig-90baf27884520107d2f730db4e3a0aa141783e2b.svg" height="188.0" src="../_images/aafig-90baf27884520107d2f730db4e3a0aa141783e2b.svg" width="874.0" /></a>
<p>We will re-use the Connection subclasses
<a class="reference internal" href="netsquid.examples.teleportation.html#netsquid.examples.teleportation.EntanglingConnection" title="netsquid.examples.teleportation.EntanglingConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">EntanglingConnection</span></code></a> and <a class="reference internal" href="netsquid.examples.teleportation.html#netsquid.examples.teleportation.ClassicalConnection" title="netsquid.examples.teleportation.ClassicalConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClassicalConnection</span></code></a>
created in the <a class="reference external" href="tutorial.simulation.html">teleportation tutorial</a> and
use the following function to create quantum processors for each node:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_qprocessor</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Factory to create a quantum processor for each node in the repeater chain network.</span>

<span class="sd">    Has two memory positions and the physical instructions necessary for teleportation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the quantum processor.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~netsquid.components.qprocessor.QuantumProcessor`</span>
<span class="sd">        A quantum processor to specification.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">noise_rate</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="n">gate_duration</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">gate_noise_model</span> <span class="o">=</span> <span class="n">DephaseNoiseModel</span><span class="p">(</span><span class="n">noise_rate</span><span class="p">)</span>
    <span class="n">mem_noise_model</span> <span class="o">=</span> <span class="n">DepolarNoiseModel</span><span class="p">(</span><span class="n">noise_rate</span><span class="p">)</span>
    <span class="n">physical_instructions</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">PhysicalInstruction</span><span class="p">(</span><span class="n">INSTR_X</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">gate_duration</span><span class="p">,</span>
                            <span class="n">quantum_noise_model</span><span class="o">=</span><span class="n">gate_noise_model</span><span class="p">),</span>
        <span class="n">PhysicalInstruction</span><span class="p">(</span><span class="n">INSTR_Z</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">gate_duration</span><span class="p">,</span>
                            <span class="n">quantum_noise_model</span><span class="o">=</span><span class="n">gate_noise_model</span><span class="p">),</span>
        <span class="n">PhysicalInstruction</span><span class="p">(</span><span class="n">INSTR_MEASURE_BELL</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">gate_duration</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="n">qproc</span> <span class="o">=</span> <span class="n">QuantumProcessor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">num_positions</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fallback_to_nonphysical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">mem_noise_models</span><span class="o">=</span><span class="p">[</span><span class="n">mem_noise_model</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                             <span class="n">phys_instructions</span><span class="o">=</span><span class="n">physical_instructions</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qproc</span>
</pre></div>
</div>
<p>We create a network component and add the nodes and connections to it.
This way we can easily keep track of all our components in the network, which will be useful when collecting data later.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setup_network</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">node_distance</span><span class="p">,</span> <span class="n">source_frequency</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Setup repeater chain network.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_nodes : int</span>
<span class="sd">        Number of nodes in the network, at least 3.</span>
<span class="sd">    node_distance : float</span>
<span class="sd">        Distance between nodes [km].</span>
<span class="sd">    source_frequency : float</span>
<span class="sd">        Frequency at which the sources create entangled qubits [Hz].</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~netsquid.nodes.network.Network`</span>
<span class="sd">        Network component with all nodes and connections as subcomponents.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_nodes</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can&#39;t create repeater chain with </span><span class="si">{</span><span class="n">num_nodes</span><span class="si">}</span><span class="s2"> nodes.&quot;</span><span class="p">)</span>
    <span class="n">network</span> <span class="o">=</span> <span class="n">Network</span><span class="p">(</span><span class="s2">&quot;Repeater_chain_network&quot;</span><span class="p">)</span>
    <span class="c1"># Create nodes with quantum processors</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">):</span>
        <span class="c1"># Prepend leading zeros to the number</span>
        <span class="n">num_zeros</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node_</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">0</span><span class="si">{</span><span class="n">num_zeros</span><span class="si">}</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">qmemory</span><span class="o">=</span><span class="n">create_qprocessor</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;qproc_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)))</span>
    <span class="n">network</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="c1"># Create quantum and classical connections:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">node_right</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Create quantum connection</span>
        <span class="n">qconn</span> <span class="o">=</span> <span class="n">EntanglingConnection</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;qconn_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">node_distance</span><span class="p">,</span>
                                     <span class="n">source_frequency</span><span class="o">=</span><span class="n">source_frequency</span><span class="p">)</span>
        <span class="c1"># Add a noise model which depolarizes the qubits exponentially</span>
        <span class="c1"># depending on the connection length</span>
        <span class="k">for</span> <span class="n">channel_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;qchannel_C2A&#39;</span><span class="p">,</span> <span class="s1">&#39;qchannel_C2B&#39;</span><span class="p">]:</span>
            <span class="n">qconn</span><span class="o">.</span><span class="n">subcomponents</span><span class="p">[</span><span class="n">channel_name</span><span class="p">]</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="s1">&#39;quantum_noise_model&#39;</span><span class="p">]</span> <span class="o">=</span>\
                <span class="n">FibreDepolarizeModel</span><span class="p">()</span>
        <span class="n">port_name</span><span class="p">,</span> <span class="n">port_r_name</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">node_right</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="n">qconn</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;quantum&quot;</span><span class="p">)</span>
        <span class="c1"># Forward qconn directly to quantum memories for right and left inputs:</span>
        <span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span><span class="o">.</span><span class="n">forward_input</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin0&quot;</span><span class="p">])</span>  <span class="c1"># R input</span>
        <span class="n">node_right</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="n">port_r_name</span><span class="p">]</span><span class="o">.</span><span class="n">forward_input</span><span class="p">(</span>
            <span class="n">node_right</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin1&quot;</span><span class="p">])</span>  <span class="c1"># L input</span>
        <span class="c1"># Create classical connection</span>
        <span class="n">cconn</span> <span class="o">=</span> <span class="n">ClassicalConnection</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;cconn_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">node_distance</span><span class="p">)</span>
        <span class="n">port_name</span><span class="p">,</span> <span class="n">port_r_name</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">node_right</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="n">cconn</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;classical&quot;</span><span class="p">,</span>
            <span class="n">port_name_node1</span><span class="o">=</span><span class="s2">&quot;ccon_R&quot;</span><span class="p">,</span> <span class="n">port_name_node2</span><span class="o">=</span><span class="s2">&quot;ccon_L&quot;</span><span class="p">)</span>
        <span class="c1"># Forward cconn to right most node</span>
        <span class="k">if</span> <span class="s2">&quot;ccon_L&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;ccon_L&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">bind_input_handler</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">message</span><span class="p">,</span> <span class="n">_node</span><span class="o">=</span><span class="n">node</span><span class="p">:</span> <span class="n">_node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;ccon_R&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tx_output</span><span class="p">(</span><span class="n">message</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">network</span>
</pre></div>
</div>
<p>We have used a custom noise model in this example, which helps to exaggerate the effectiveness of the repeater chain.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FibreDepolarizeModel</span><span class="p">(</span><span class="n">QuantumErrorModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Custom non-physical error model used to show the effectiveness</span>
<span class="sd">    of repeater chains.</span>

<span class="sd">    The default values are chosen to make a nice figure,</span>
<span class="sd">    and don&#39;t represent any physical system.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p_depol_init : float, optional</span>
<span class="sd">        Probability of depolarization on entering a fibre.</span>
<span class="sd">        Must be between 0 and 1. Default 0.009</span>
<span class="sd">    p_depol_length : float, optional</span>
<span class="sd">        Probability of depolarization per km of fibre.</span>
<span class="sd">        Must be between 0 and 1. Default 0.025</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_depol_init</span><span class="o">=</span><span class="mf">0.009</span><span class="p">,</span> <span class="n">p_depol_length</span><span class="o">=</span><span class="mf">0.025</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;p_depol_init&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_depol_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;p_depol_length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_depol_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">required_properties</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">error_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="n">delta_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Uses the length property to calculate a depolarization probability,</span>
<span class="sd">        and applies it to the qubits.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qubits : tuple of :obj:`~netsquid.qubits.qubit.Qubit`</span>
<span class="sd">            Qubits to apply noise to.</span>
<span class="sd">        delta_time : float, optional</span>
<span class="sd">            Time qubits have spent on a component [ns]. Not used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">qubits</span><span class="p">:</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;p_depol_init&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span>
                <span class="mi">10</span><span class="p">,</span> <span class="o">-</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;p_depol_length&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">depolarize</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="n">prob</span><span class="p">)</span>
</pre></div>
</div>
<p>The next step is to setup the protocols.
To easily manage all the protocols, we add them as subprotocols of one main protocol.
In this way, we can start them at the same time, and the main protocol will stop when all subprotocols have finished.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setup_repeater_protocol</span><span class="p">(</span><span class="n">network</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Setup repeater protocol on repeater chain network.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    network : :class:`~netsquid.nodes.network.Network`</span>
<span class="sd">        Repeater chain network to put protocols on.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~netsquid.protocols.protocol.Protocol`</span>
<span class="sd">        Protocol holding all subprotocols used in the network.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">protocol</span> <span class="o">=</span> <span class="n">LocalProtocol</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="c1"># Add SwapProtocol to all repeater nodes. Note: we use unique names,</span>
    <span class="c1"># since the subprotocols would otherwise overwrite each other in the main protocol.</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">subprotocol</span> <span class="o">=</span> <span class="n">SwapProtocol</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Swap_</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">protocol</span><span class="o">.</span><span class="n">add_subprotocol</span><span class="p">(</span><span class="n">subprotocol</span><span class="p">)</span>
    <span class="c1"># Add CorrectProtocol to Bob</span>
    <span class="n">subprotocol</span> <span class="o">=</span> <span class="n">CorrectProtocol</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
    <span class="n">protocol</span><span class="o">.</span><span class="n">add_subprotocol</span><span class="p">(</span><span class="n">subprotocol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">protocol</span>
</pre></div>
</div>
<p>The definition of the swapping subprotocol that will run on each repeater node:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SwapProtocol</span><span class="p">(</span><span class="n">NodeProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform Swap on a repeater node.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node : :class:`~netsquid.nodes.node.Node` or None, optional</span>
<span class="sd">        Node this protocol runs on.</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of this protocol.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qmem_input_port_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin1&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qmem_input_port_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin0&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_program</span> <span class="o">=</span> <span class="n">QuantumProgram</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_program</span><span class="o">.</span><span class="n">get_qubit_indices</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_program</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">INSTR_MEASURE_BELL</span><span class="p">,</span> <span class="p">[</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">output_key</span><span class="o">=</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qmem_input_port_l</span><span class="p">)</span> <span class="o">&amp;</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qmem_input_port_r</span><span class="p">))</span>
            <span class="c1"># Perform Bell measurement</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">execute_program</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_program</span><span class="p">,</span> <span class="n">qubit_mapping</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">m</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_program</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="s2">&quot;m&quot;</span><span class="p">]</span>
            <span class="c1"># Send result to right node on end</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;ccon_R&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tx_output</span><span class="p">(</span><span class="n">Message</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
</pre></div>
</div>
<p>The definition of the correction subprotocol responsible for applying the classical corrections at Bob:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CorrectProtocol</span><span class="p">(</span><span class="n">NodeProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform corrections for a swap on an end-node.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node : :class:`~netsquid.nodes.node.Node` or None, optional</span>
<span class="sd">        Node this protocol runs on.</span>
<span class="sd">    num_nodes : int</span>
<span class="sd">        Number of nodes in the repeater chain network.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;CorrectProtocol&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">=</span> <span class="n">num_nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x_corr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_corr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_program</span> <span class="o">=</span> <span class="n">SwapCorrectProgram</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;ccon_L&quot;</span><span class="p">])</span>
            <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;ccon_L&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">rx_input</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">items</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">ks</span><span class="o">.</span><span class="n">BellIndex</span><span class="o">.</span><span class="n">B01</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="n">ks</span><span class="o">.</span><span class="n">BellIndex</span><span class="o">.</span><span class="n">B11</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_x_corr</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">ks</span><span class="o">.</span><span class="n">BellIndex</span><span class="o">.</span><span class="n">B10</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="n">ks</span><span class="o">.</span><span class="n">BellIndex</span><span class="o">.</span><span class="n">B11</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_z_corr</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_corr</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_corr</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_program</span><span class="o">.</span><span class="n">set_corrections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x_corr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_corr</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">execute_program</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_program</span><span class="p">,</span> <span class="n">qubit_mapping</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">send_signal</span><span class="p">(</span><span class="n">Signals</span><span class="o">.</span><span class="n">SUCCESS</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_x_corr</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_z_corr</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Note that for the corrections we only need to apply each of the <span class="math notranslate nohighlight">\(X\)</span> or <span class="math notranslate nohighlight">\(Z\)</span> operators maximally once.
This is due to the anti-commutativity and self-inverse of these Pauli matrices, i.e.
<span class="math notranslate nohighlight">\(ZX = -XZ\)</span> and <span class="math notranslate nohighlight">\(XX=ZZ=I\)</span>, which allows us to cancel repeated occurrences up to a global phase (-1).
The program that executes the correction on Bob’s quantum processor is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SwapCorrectProgram</span><span class="p">(</span><span class="n">QuantumProgram</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Quantum processor program that applies all swap corrections.&quot;&quot;&quot;</span>
    <span class="n">default_num_qubits</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">set_corrections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_corr</span><span class="p">,</span> <span class="n">z_corr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_corr</span> <span class="o">=</span> <span class="n">x_corr</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_corr</span> <span class="o">=</span> <span class="n">z_corr</span> <span class="o">%</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">program</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">q1</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_qubit_indices</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_corr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">INSTR_X</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_corr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">INSTR_Z</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>With our network and protocols ready, we can add a data collector to define when and which data we want to collect.
We can wait for the signal sent by the <em>CorrectProtocol</em> when it finishes, and if it has, compute the fidelity of the
qubits at Alice and Bob with respect to the expected Bell state.
Using our network and main protocol we can easily find Alice and the CorrectionProtocol as subcomponents.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setup_datacollector</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Setup the datacollector to calculate the fidelity</span>
<span class="sd">    when the CorrectionProtocol has finished.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    network : :class:`~netsquid.nodes.network.Network`</span>
<span class="sd">        Repeater chain network to put protocols on.</span>

<span class="sd">    protocol : :class:`~netsquid.protocols.protocol.Protocol`</span>
<span class="sd">        Protocol holding all subprotocols used in the network.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~netsquid.util.datacollector.DataCollector`</span>
<span class="sd">        Datacollector recording fidelity data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure nodes are ordered in the chain:</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>

    <span class="k">def</span> <span class="nf">calc_fidelity</span><span class="p">(</span><span class="n">evexpr</span><span class="p">):</span>
        <span class="n">qubit_a</span><span class="p">,</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">peek</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">qubit_b</span><span class="p">,</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">peek</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">fidelity</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">fidelity</span><span class="p">([</span><span class="n">qubit_a</span><span class="p">,</span> <span class="n">qubit_b</span><span class="p">],</span> <span class="n">ks</span><span class="o">.</span><span class="n">b00</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;fidelity&quot;</span><span class="p">:</span> <span class="n">fidelity</span><span class="p">}</span>

    <span class="n">dc</span> <span class="o">=</span> <span class="n">DataCollector</span><span class="p">(</span><span class="n">calc_fidelity</span><span class="p">,</span> <span class="n">include_entity_name</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">dc</span><span class="o">.</span><span class="n">collect_on</span><span class="p">(</span><span class="n">pydynaa</span><span class="o">.</span><span class="n">EventExpression</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">protocol</span><span class="o">.</span><span class="n">subprotocols</span><span class="p">[</span><span class="s1">&#39;CorrectProtocol&#39;</span><span class="p">],</span>
                                          <span class="n">event_type</span><span class="o">=</span><span class="n">Signals</span><span class="o">.</span><span class="n">SUCCESS</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">dc</span>
</pre></div>
</div>
<p>We want to run the experiment for multiple numbers of nodes and distances.
Let us first define a function to run a single simulation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_simulation</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">node_distance</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">num_iters</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run the simulation experiment and return the collected data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_nodes : int, optional</span>
<span class="sd">        Number nodes in the repeater chain network. At least 3. Default 4.</span>
<span class="sd">    node_distance : float, optional</span>
<span class="sd">        Distance between nodes, larger than 0. Default 20 [km].</span>
<span class="sd">    num_iters : int, optional</span>
<span class="sd">        Number of simulation runs. Default 100.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`pandas.DataFrame`</span>
<span class="sd">        Dataframe with recorded fidelity data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ns</span><span class="o">.</span><span class="n">sim_reset</span><span class="p">()</span>
    <span class="n">est_runtime</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">num_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">node_distance</span> <span class="o">*</span> <span class="mf">5e3</span>
    <span class="n">network</span> <span class="o">=</span> <span class="n">setup_network</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">node_distance</span><span class="o">=</span><span class="n">node_distance</span><span class="p">,</span>
                            <span class="n">source_frequency</span><span class="o">=</span><span class="mf">1e9</span> <span class="o">/</span> <span class="n">est_runtime</span><span class="p">)</span>
    <span class="n">protocol</span> <span class="o">=</span> <span class="n">setup_repeater_protocol</span><span class="p">(</span><span class="n">network</span><span class="p">)</span>
    <span class="n">dc</span> <span class="o">=</span> <span class="n">setup_datacollector</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">protocol</span><span class="p">)</span>
    <span class="n">protocol</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">ns</span><span class="o">.</span><span class="n">sim_run</span><span class="p">(</span><span class="n">est_runtime</span> <span class="o">*</span> <span class="n">num_iters</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dc</span><span class="o">.</span><span class="n">dataframe</span>
</pre></div>
</div>
<p>Finally we will run multiple simulations and plot them in a figure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_plot</span><span class="p">(</span><span class="n">num_iters</span><span class="o">=</span><span class="mi">2000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run the simulation for multiple nodes and distances and show them in a figure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    num_iters : int, optional</span>
<span class="sd">        Number of iterations per simulation configuration.</span>
<span class="sd">        At least 1. Default 2000.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">distance</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">50</span><span class="p">]:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">num_node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="n">num_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">run_simulation</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="n">num_node</span><span class="p">,</span>
                                            <span class="n">node_distance</span><span class="o">=</span><span class="n">distance</span> <span class="o">/</span> <span class="n">num_node</span><span class="p">,</span>
                                            <span class="n">num_iters</span><span class="o">=</span><span class="n">num_iters</span><span class="p">)[</span><span class="s1">&#39;fidelity&#39;</span><span class="p">]</span>
        <span class="c1"># For errorbars we use the standard error of the mean (sem)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;sem&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="s1">&#39;fidelity&#39;</span><span class="p">})</span>
        <span class="n">data</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">&#39;fidelity&#39;</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="s1">&#39;sem&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">distance</span><span class="si">}</span><span class="s2"> km&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;number of nodes&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;fidelity&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Repeater chain with different total lengths&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Using the ket vector formalism produces the following figure:</p>
<a class="reference internal image-reference" href="../_images/rep_chain_example_ket.png"><img alt="../_images/rep_chain_example_ket.png" class="align-center" src="../_images/rep_chain_example_ket.png" style="width: 600px;" /></a>
<p>Because the quantum states don’t have an opportunity to grow very large in our simulation,
it is also possible for this simple example to improve on our results using the density matrix formalism.
Instead of running the simulation for 2000 iterations, it is now sufficient to run it for only a few.
As we see in the figure below, the error-bars now become negligible:</p>
<a class="reference internal image-reference" href="../_images/rep_chain_example_dm.png"><img alt="../_images/rep_chain_example_dm.png" class="align-center" src="../_images/rep_chain_example_dm.png" style="width: 600px;" /></a>
<dl class="py class">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">netsquid.examples.repeater_chain.</span></span><span class="sig-name descname"><span class="pre">SwapProtocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="../api_protocols/netsquid.protocols.nodeprotocols.html#netsquid.protocols.nodeprotocols.NodeProtocol" title="netsquid.protocols.nodeprotocols.NodeProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeProtocol</span></code></a></p>
<p>Perform Swap on a repeater node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<a class="reference internal" href="../api_nodes/netsquid.nodes.node.html#netsquid.nodes.node.Node" title="netsquid.nodes.node.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a> or None, optional) – Node this protocol runs on.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of this protocol.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.run" title="Link to this definition"></a></dt>
<dd><p>Generator or function that runs the protocol.</p>
<p>Starting the protocol will execute this function.
If a generator it will run it up to the first yield.
All yields should return a <a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a>,
the generator will only continue when the expression has been triggered.</p>
<p>If a function is returned, this protocol may still yield on the generator
of its sub-protocols.</p>
<p>Sub-protocols are not started automatically when this method is overridden.
Either start them manually in the overridden run() or call start_subprotocols() to start them all at once.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>If this method returns a generator, then the final return of
the generator will be set as the value of
<code class="xref py py-attr docutils literal notranslate"><span class="pre">FINISHED</span></code>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.add_signal">
<span class="sig-name descname"><span class="pre">add_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.add_signal" title="Link to this definition"></a></dt>
<dd><p>Adds a signal type to the protocol that it can signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Enum</span></code>) – The label to use to reference the signal.</p></li>
<li><p><strong>event_type</strong> (<a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> or None, optional) – Event type to use for the signal type. If None, an event type is created unless
the <code class="docutils literal notranslate"><span class="pre">label</span></code> is an <code class="xref py py-obj docutils literal notranslate"><span class="pre">Enum</span></code> with a <a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> as value,
in which case this is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event type of the added signal type.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.add_subprotocol">
<span class="sig-name descname"><span class="pre">add_subprotocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subprotocol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.add_subprotocol" title="Link to this definition"></a></dt>
<dd><p>Add a sub-protocol to this protocol.</p>
<p>Neither protocol should be running and both protocols must be able to
signal to each other (see <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subprotocol</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol to add as a sub-protocol.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Reference name (key) to use for sub-protocol. If None, the name
of the sub-protocol is used.
If a sub-protocol using the same <code class="docutils literal notranslate"><span class="pre">name</span></code> already
exists it is overridden.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstraintError" title="netsquid.util.constrainedmap.ConstraintError"><strong>ConstraintError</strong></a> – If either of the protocols is running, or if the protocols cannot signal
    to each other in both directions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.await_mempos_busy_toggle">
<span class="sig-name descname"><span class="pre">await_mempos_busy_toggle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">QuantumMemory</span> <span class="pre">qmemory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list</span> <span class="pre">positions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.await_mempos_busy_toggle" title="Link to this definition"></a></dt>
<dd><p>Create an event expression that waits for one of the memory positions
on a quantum memory to change the value of the busy state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qmemory</strong> (<a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>) – The quantum memory to wait for.</p></li>
<li><p><strong>positions</strong> (<em>list of int</em>) – The memory positions to wait for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for one of the memory positions to toggle its busy flag.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – The <code class="docutils literal notranslate"><span class="pre">qmemory</span></code> parameter is not of type <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>.</p></li>
<li><p><strong>IndexError</strong> – If the positions given don’t match a valid <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition" title="netsquid.components.qmemory.MemoryPosition"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryPosition</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Memory positions can enable if they schedule events when the busy flag is toggled by
setting <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition.busy_event_enabled" title="netsquid.components.qmemory.MemoryPosition.busy_event_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">busy_event_enabled</span></code></a>.
Because by default <cite>busy_event_enabled</cite> is False, we enable it here.
It is disabled when <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.reset" title="netsquid.components.qmemory.QuantumMemory.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> is called, otherwise it must be manually disabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.await_mempos_in_use_toggle">
<span class="sig-name descname"><span class="pre">await_mempos_in_use_toggle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">QuantumMemory</span> <span class="pre">qmemory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list</span> <span class="pre">positions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.await_mempos_in_use_toggle" title="Link to this definition"></a></dt>
<dd><p>Wait for when one of the positions of a quantum memory toggle their in_use flag.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qmemory</strong> (<a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>) – The quantum memory to wait for.</p></li>
<li><p><strong>positions</strong> (<em>list of int</em>) – The positions to wait for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for one of the memory positions to toggle its in_use flag.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – qmemory is not of type <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>.</p></li>
<li><p><strong>IndexError</strong> – If the positions given don’t match a valid <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition" title="netsquid.components.qmemory.MemoryPosition"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryPosition</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Memory positions can enable if they schedule events when the in_use flag is toggled by
setting <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition.in_use_event_enabled" title="netsquid.components.qmemory.MemoryPosition.in_use_event_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">in_use_event_enabled</span></code></a>.
Because by default <cite>in_use_event_enabled</cite> is False, we enable it here.
It is disabled when <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.reset" title="netsquid.components.qmemory.QuantumMemory.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> is called, otherwise it must be manually disabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.await_port_input">
<span class="sig-name descname"><span class="pre">await_port_input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.await_port_input" title="Link to this definition"></a></dt>
<dd><p>Create an event expression that waits until the specified port receives a message input.</p>
<p>The event expression will also trigger if the message is passed through the port.
The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>port</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Port</span></code>) – Port to listen to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>EventExpression that the protocol yields on.
The message of the port can be fetched with <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port.rx_input" title="netsquid.components.component.Port.rx_input"><code class="xref py py-func docutils literal notranslate"><span class="pre">rx_input()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyProtocol</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">protocols</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">msg_header</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span> <span class="o">=</span> <span class="n">msg_header</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">rx_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A message was input via port </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.await_port_output">
<span class="sig-name descname"><span class="pre">await_port_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.await_port_output" title="Link to this definition"></a></dt>
<dd><p>Create an event expression that waits until the specified port has a message output.</p>
<p>The event expression will also trigger if the message is passed through the port.
The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>port</strong> (<a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port" title="netsquid.components.component.Port"><code class="xref py py-class docutils literal notranslate"><span class="pre">Port</span></code></a>) – Port to listen to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression that the protocol yields on.
The message of the port can be fetched with <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port.rx_output" title="netsquid.components.component.Port.rx_output"><code class="xref py py-func docutils literal notranslate"><span class="pre">rx_output()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyProtocol</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">protocols</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">msg_header</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span> <span class="o">=</span> <span class="n">msg_header</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">rx_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A message was output via port </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.await_program">
<span class="sig-name descname"><span class="pre">await_program</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">await_done=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">await_fail=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.await_program" title="Link to this definition"></a></dt>
<dd><p>Create an event expression that waits for a program on a quantum processor to stop running.</p>
<p>The expression must be <em>yielded</em> on to come into effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>processor</strong> (<a class="reference internal" href="../api_components/netsquid.components.qprocessor.html#netsquid.components.qprocessor.QuantumProcessor" title="netsquid.components.qprocessor.QuantumProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumProcessor</span></code></a>) – The processor that runs the program</p></li>
<li><p><strong>await_done</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, default True) – Whether to wait for the program to successfully finish.</p></li>
<li><p><strong>await_fail</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, default False) – Whether to wait for the program to fail.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for the quantum program to stop.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both <cite>await_done</cite> and <cite>await_fail</cite> are set to True, it will wait until the program either finishes or fails.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.await_signal">
<span class="sig-name descname"><span class="pre">await_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Protocol</span> <span class="pre">sender</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_label=Signals.FINISHED</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.await_signal" title="Link to this definition"></a></dt>
<dd><p>Create an event expression that waits until a sender has sent a specified signal.</p>
<p>The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sender</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol that will send the signal.</p></li>
<li><p><strong>signal_label</strong> (<em>int or str or Enum, optional</em>) – The signal label to wait for.
Default is <code class="xref py py-attr docutils literal notranslate"><span class="pre">FINISHED</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>EventExpression that the protocol yields on.
The signal result can be retrieved from the protocol with <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.get_signal_result" title="netsquid.protocols.protocol.Protocol.get_signal_result"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_signal_result()</span></code></a>
or with <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.get_signal_by_event" title="netsquid.protocols.protocol.Protocol.get_signal_by_event"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_signal_by_event()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.await_timer">
<span class="sig-name descname"><span class="pre">await_timer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double</span> <span class="pre">duration=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double</span> <span class="pre">end_time=0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.await_timer" title="Link to this definition"></a></dt>
<dd><p>Schedule an event to trigger at a specified time and create an event expression to wait for it.</p>
<p>The expression must be <em>yielded</em> on to come into effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>duration</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>, optional) – Amount of time (in Nanoseconds) the protocol should sleep</p></li>
<li><p><strong>end_time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>, optional) – Ignored if duration bigger than 0, time instance at which the event triggers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression that the protocol yields on</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.can_signal_to">
<span class="sig-name descname"><span class="pre">can_signal_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.can_signal_to" title="Link to this definition"></a></dt>
<dd><p>Whether this protocol can send a signal to another protocol.</p>
<p>A local protocol can only signal to another local protocol if they have
one or more nodes in common.
A local protocol can always signal to a standard (non-local) protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>protocol</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol queried as to whether this protocol can send a signal to.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether this protocol can signal to the other protocol.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.check_assigned">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">check_assigned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.check_assigned" title="Link to this definition"></a></dt>
<dd><p>Helper method to check if inputs properly assigned.</p>
<p>Checks that inputs are not None and that they have correct type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<em>object or list of objects</em>) – Inputs to check.</p></li>
<li><p><strong>input_type</strong> (<em>type or None, optional</em>) – Type that inputs should be. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, type is not
checked.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if all <code class="docutils literal notranslate"><span class="pre">inputs</span></code> specified, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.get_signal_by_event">
<span class="sig-name descname"><span class="pre">get_signal_by_event</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">receiver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.get_signal_by_event" title="Link to this definition"></a></dt>
<dd><p>Get the signal result based on the event that triggered it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>event</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code>) – The event that triggered the signalling</p></li>
<li><p><strong>receiver</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> or None, optional) – The protocol wanting to receive the signal value. If not None,
will check if signalling is possible using
<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple with the label and result of the signal that was signalled with the given event.
None if the event is no longer associated with a signal result.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.SignalResult" title="netsquid.protocols.protocol.SignalResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SignalResult</span></code></a> or None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>To avoid storing all signal results and their events, only the most recent signal results are stored.
This means if a signal is sent all previous signal results are deleted, and the previous events are
no longer associated with a signal result.
Signals in the same time instance can co-exist.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.get_signal_result">
<span class="sig-name descname"><span class="pre">get_signal_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">receiver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.get_signal_result" title="Link to this definition"></a></dt>
<dd><p>Get the result of the last signal sent with this label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Signals" title="netsquid.protocols.protocol.Signals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signals</span></code></a>) – Label that the signal was broadcasted with.</p></li>
<li><p><strong>receiver</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> or None, optional) – The protocol wanting to receive the signal value. If not None,
will check if signalling is possible to this protocol using
<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value that was sent with the signal.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RunTimeError</strong> – When attempting to get the result of a local signal from a nonlocal environment</p></li>
<li><p><strong>TypeError</strong> – When attempting to get the result of something else than a protocol</p></li>
<li><p><strong>KeyError</strong> – When the signal label is unknown i.e. hasn’t been added yet with
    <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.add_signal" title="netsquid.protocols.protocol.Protocol.add_signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_signal()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.is_connected">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_connected</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.is_connected" title="Link to this definition"></a></dt>
<dd><p>Whether protocol has been properly configured and can be started.</p>
<p>Requires that all specified nodes have been set (are not None).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if protocol is fully and correctly connected, otherwise False.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.is_running">
<span class="sig-name descname"><span class="pre">is_running</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.is_running" title="Link to this definition"></a></dt>
<dd><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code> True if protocol is running, otherwise False.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.max_nodes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_nodes</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.max_nodes" title="Link to this definition"></a></dt>
<dd><p>maximum number of nodes this local protocol can run on.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.name" title="Link to this definition"></a></dt>
<dd><p>Name of protocol for identification and display purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.node">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">node</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.node" title="Link to this definition"></a></dt>
<dd><p>single node this protocol is running on.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_nodes/netsquid.nodes.node.html#netsquid.nodes.node.Node" title="netsquid.nodes.node.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.nodes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nodes</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.nodes" title="Link to this definition"></a></dt>
<dd><p>nodes local to this protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.remove">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.remove" title="Link to this definition"></a></dt>
<dd><p>Removes the entity from the simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.reset" title="Link to this definition"></a></dt>
<dd><p>Stops and starts the protocol leaving it in a clean state.</p>
<p>Will stop the protocol with the specified status,
or Status.FAIL if not specified. Leaves the protocol in the Protocol.IDLE state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.send_signal">
<span class="sig-name descname"><span class="pre">send_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.send_signal" title="Link to this definition"></a></dt>
<dd><p>Send a signal to other protocols to indicate a status change or announce a result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal_label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Signals" title="netsquid.protocols.protocol.Signals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signals</span></code></a>) – Label, key or status that is broadcasted to the world. Other protocols can wait for this signal.</p></li>
<li><p><strong>result</strong> (<em>Any or None, optional</em>) – Result or intermediate results of the protocol that you want to broadcast with this signal</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <code class="docutils literal notranslate"><span class="pre">signal_label</span></code> does not correspond to a signal of this protocol.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When a protocol is finished (i.e. its run() returns),
the protocol sends a signal with label <code class="xref py py-attr docutils literal notranslate"><span class="pre">FINISHED</span></code>.
The result is set to the return value.</p>
<p>When a signal is sent with a label that was sent earlier, the result of the first signal is overwritten.
Signal results sent in the same time instance can be individually retrieved using the triggering event.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.signals">
<span class="sig-name descname"><span class="pre">signals</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.signals" title="Link to this definition"></a></dt>
<dd><p>signals this protocol can send (<a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> indexed by label).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.specify_node">
<span class="sig-name descname"><span class="pre">specify_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.specify_node" title="Link to this definition"></a></dt>
<dd><p>Specify a node required by this protocol.</p>
<p>The protocol cannot start until all specified nodes are set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Key to index the node with.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If specifying this node will exceed the maximum number of nodes
    <a class="reference internal" href="../api_protocols/netsquid.protocols.nodeprotocols.html#netsquid.protocols.nodeprotocols.LocalProtocol.max_nodes" title="netsquid.protocols.nodeprotocols.LocalProtocol.max_nodes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_nodes</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.start" title="Link to this definition"></a></dt>
<dd><p>Start the protocol.</p>
<p>Will register the protocol and run up to the first yield.
Will not start any sub-protocols. Sub-protocols are started in the run().
When run() is not overridden it will start all sub-protocol in parallel automatically.
If it is overridden the sub-protocols should be started manually in the method;
this to give control on when sub-protocols should run in parallel or in sequence</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>This protocol is returned for convenience.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a></p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError</strong> – If the protocol has not been properly connected.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.start_subprotocols">
<span class="sig-name descname"><span class="pre">start_subprotocols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.start_subprotocols" title="Link to this definition"></a></dt>
<dd><p>Start all the sub-protocols in parallel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.stop">
<span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.stop" title="Link to this definition"></a></dt>
<dd><p>Stop the protocol as well as any running sub-protocols.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.subprotocols">
<span class="sig-name descname"><span class="pre">subprotocols</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.subprotocols" title="Link to this definition"></a></dt>
<dd><p>sub-protocols of this protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapProtocol.uid">
<span class="sig-name descname"><span class="pre">uid</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapProtocol.uid" title="Link to this definition"></a></dt>
<dd><p>returns a unique identifier for this entity in the simulation.</p>
<p>Each entity has a unique identifier in the simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapCorrectProgram">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">netsquid.examples.repeater_chain.</span></span><span class="sig-name descname"><span class="pre">SwapCorrectProgram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_qubits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_mapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapCorrectProgram" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="../api_components/netsquid.components.qprogram.html#netsquid.components.qprogram.QuantumProgram" title="netsquid.components.qprogram.QuantumProgram"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumProgram</span></code></a></p>
<p>Quantum processor program that applies all swap corrections.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapCorrectProgram.default_num_qubits">
<span class="sig-name descname"><span class="pre">default_num_qubits</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapCorrectProgram.default_num_qubits" title="Link to this definition"></a></dt>
<dd><p>default number of qubits program requires. If -1 it can run on any number of qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapCorrectProgram.program">
<span class="sig-name descname"><span class="pre">program</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapCorrectProgram.program" title="Link to this definition"></a></dt>
<dd><p>Program to be executed.</p>
<p>Override this method to add additional control logic.</p>
<p>By default runs a single sequences of instructions that
have been added using <code class="docutils literal notranslate"><span class="pre">apply()</span></code>.</p>
<p class="rubric">Notes</p>
<p>Returns a generator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapCorrectProgram.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instruction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'last'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">physical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapCorrectProgram.apply" title="Link to this definition"></a></dt>
<dd><p>Prepare to apply an instruction.</p>
<p>Prepares a callback function that will be called when the instruction
is executed by a quantum processor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>instruction</strong> (<a class="reference internal" href="../api_components/netsquid.components.instructions.html#netsquid.components.instructions.Instruction" title="netsquid.components.instructions.Instruction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Instruction</span></code></a>) – Next instruction to be called during program execution.</p></li>
<li><p><strong>qubit_indices</strong> (<em>int or list of int or None, optional</em>) – Program qubit indices to apply instruction to. If None or an empty list,
then the instruction does not act on any qubit indices.</p></li>
<li><p><strong>output_key</strong> (<em>str, optional</em>) – Dictionary key to store instruction output with. Default is to store
all outputs using <code class="docutils literal notranslate"><span class="pre">last</span></code>.</p></li>
<li><p><strong>physical</strong> (<em>bool, optional</em>) – Whether a quantum processor should interpret this instruction as being
physical. If non-physical it should execute it instantly and and without noise.</p></li>
<li><p><strong>**parameters</strong> – Additional keyword arguments to pass to the instruction.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>str</em> – Name of the instruction to be applied.</p></li>
<li><p><em>list of int</em> – Program qubit indices instruction to be applied to.</p></li>
<li><p><em>function</em> – Callback function that applies the instruction to a quantum processor.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The prepared callback also accepts <code class="docutils literal notranslate"><span class="pre">runtime_params</span></code> keyword arguments
that will override any matching keywords in <code class="docutils literal notranslate"><span class="pre">parameters</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapCorrectProgram.get_qubit_indices">
<span class="sig-name descname"><span class="pre">get_qubit_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_qubits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapCorrectProgram.get_qubit_indices" title="Link to this definition"></a></dt>
<dd><p>Convenience method that returns the program’s qubit indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_qubits</strong> (<em>int or None, optional</em>) – Number of qubit indices to return. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
will try to return all indices corresponding
to <code class="docutils literal notranslate"><span class="pre">self.num_qubits</span></code>, raising an exception
if this is not bounded.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Indices of program qubits.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of int</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If too many indices are requested, or if all indices are requested and
    this number is not bounded.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapCorrectProgram.load">
<span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">program</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapCorrectProgram.load" title="Link to this definition"></a></dt>
<dd><p>Load in and run another quantum program within this program.</p>
<p>To be called within an overridden <code class="docutils literal notranslate"><span class="pre">program()</span></code> method.
Should be prepepended by <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> (see example below).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">output</span></code> dict is shared between both programs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>program</strong> (<a class="reference internal" href="../api_components/netsquid.components.qprogram.html#netsquid.components.qprogram.QuantumProgram" title="netsquid.components.qprogram.QuantumProgram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QuantumProgram</span></code></a>) – Another quantum program to load in and run.
Can be an instance or a (sub)class of
<a class="reference internal" href="../api_components/netsquid.components.qprogram.html#netsquid.components.qprogram.QuantumProgram" title="netsquid.components.qprogram.QuantumProgram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QuantumProgram</span></code></a>.
If it is an instance, a copy is made.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A generator for the loaded program.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>generator</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_components/netsquid.components.qprogram.html#netsquid.components.qprogram.QuantumProgramError" title="netsquid.components.qprogram.QuantumProgramError"><strong>QuantumProgramError</strong></a> – If <code class="docutils literal notranslate"><span class="pre">program</span></code> is invalid. This exception will be caught by
    a running program and cause it to fail.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>It is possible to load a <a class="reference internal" href="../api_components/netsquid.components.qprogram.html#netsquid.components.qprogram.QuantumProgram" title="netsquid.components.qprogram.QuantumProgram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QuantumProgram</span></code></a> instance or class.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">program</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># ...</span>
<span class="gp">... </span>    <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">my_program_instance</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">MyCustomProgram</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapCorrectProgram.num_qubits">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_qubits</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapCorrectProgram.num_qubits" title="Link to this definition"></a></dt>
<dd><p>number of qubits program requires. If -1 can run on any number of qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapCorrectProgram.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapCorrectProgram.reset" title="Link to this definition"></a></dt>
<dd><p>Reset state of program.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.SwapCorrectProgram.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lazy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.SwapCorrectProgram.run" title="Link to this definition"></a></dt>
<dd><p>Carry out all applied instructions within the program to this point.</p>
<p>Called within an overridden <code class="docutils literal notranslate"><span class="pre">program()</span></code> method.
Should be prepepended by <code class="docutils literal notranslate"><span class="pre">yield</span></code> (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parallel</strong> (<em>bool, optional</em>) – Whether processor should attempt to run instructions
in parallel (if physically supported).
Default True.</p></li>
<li><p><strong>lazy</strong> (<em>bool, optional</em>) – Whether to perform all instructions at once.
Useful to keep qubit states small between combining and reducing.
(Qubits in other processors that share the same qubit state
do not get the chance to increase the state exponentially)
All instructions will be executed at the current time instance
without having to run the simulator.
Noise will be applied accordingly for the duration of and between the instructions.
However any other calls in an instruction to <a class="reference internal" href="../api_util/netsquid.util.simtools.html#netsquid.util.simtools.sim_time" title="netsquid.util.simtools.sim_time"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_time()</span></code></a>
or scheduling events with schedule_now and schedule_after <strong>will be incorrect</strong>.
Make absolutely sure that no such calls exists in the instructions.
It will not be checked, so there is no guarantee that the simulation is correct otherwise.
Default False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>tuple with the following entries:</p>
<dl class="simple">
<dt>list of tuple(<code class="xref py py-obj docutils literal notranslate"><span class="pre">ProgramInstruction</span></code>)</dt><dd><p>List of tuples specifying instruction name, program qubit indices,
callback function.</p>
</dd>
<dt>bool</dt><dd><p>Whether processor should attempt to run instructions
in parallel (if physically supported).</p>
</dd>
<dt>bool</dt><dd><p>Whether the processor should attempt to run instruction lazily
(i.e. apply them all at once at the same event).</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RunParameters</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">program</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">INSTR_X</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">netsquid.examples.repeater_chain.</span></span><span class="sig-name descname"><span class="pre">CorrectProtocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_nodes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="../api_protocols/netsquid.protocols.nodeprotocols.html#netsquid.protocols.nodeprotocols.NodeProtocol" title="netsquid.protocols.nodeprotocols.NodeProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeProtocol</span></code></a></p>
<p>Perform corrections for a swap on an end-node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<a class="reference internal" href="../api_nodes/netsquid.nodes.node.html#netsquid.nodes.node.Node" title="netsquid.nodes.node.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a> or None, optional) – Node this protocol runs on.</p></li>
<li><p><strong>num_nodes</strong> (<em>int</em>) – Number of nodes in the repeater chain network.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.run" title="Link to this definition"></a></dt>
<dd><p>Generator or function that runs the protocol.</p>
<p>Starting the protocol will execute this function.
If a generator it will run it up to the first yield.
All yields should return a <a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a>,
the generator will only continue when the expression has been triggered.</p>
<p>If a function is returned, this protocol may still yield on the generator
of its sub-protocols.</p>
<p>Sub-protocols are not started automatically when this method is overridden.
Either start them manually in the overridden run() or call start_subprotocols() to start them all at once.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>If this method returns a generator, then the final return of
the generator will be set as the value of
<code class="xref py py-attr docutils literal notranslate"><span class="pre">FINISHED</span></code>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.add_signal">
<span class="sig-name descname"><span class="pre">add_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.add_signal" title="Link to this definition"></a></dt>
<dd><p>Adds a signal type to the protocol that it can signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Enum</span></code>) – The label to use to reference the signal.</p></li>
<li><p><strong>event_type</strong> (<a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> or None, optional) – Event type to use for the signal type. If None, an event type is created unless
the <code class="docutils literal notranslate"><span class="pre">label</span></code> is an <code class="xref py py-obj docutils literal notranslate"><span class="pre">Enum</span></code> with a <a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> as value,
in which case this is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event type of the added signal type.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.add_subprotocol">
<span class="sig-name descname"><span class="pre">add_subprotocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subprotocol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.add_subprotocol" title="Link to this definition"></a></dt>
<dd><p>Add a sub-protocol to this protocol.</p>
<p>Neither protocol should be running and both protocols must be able to
signal to each other (see <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subprotocol</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol to add as a sub-protocol.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Reference name (key) to use for sub-protocol. If None, the name
of the sub-protocol is used.
If a sub-protocol using the same <code class="docutils literal notranslate"><span class="pre">name</span></code> already
exists it is overridden.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstraintError" title="netsquid.util.constrainedmap.ConstraintError"><strong>ConstraintError</strong></a> – If either of the protocols is running, or if the protocols cannot signal
    to each other in both directions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.await_mempos_busy_toggle">
<span class="sig-name descname"><span class="pre">await_mempos_busy_toggle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">QuantumMemory</span> <span class="pre">qmemory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list</span> <span class="pre">positions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.await_mempos_busy_toggle" title="Link to this definition"></a></dt>
<dd><p>Create an event expression that waits for one of the memory positions
on a quantum memory to change the value of the busy state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qmemory</strong> (<a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>) – The quantum memory to wait for.</p></li>
<li><p><strong>positions</strong> (<em>list of int</em>) – The memory positions to wait for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for one of the memory positions to toggle its busy flag.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – The <code class="docutils literal notranslate"><span class="pre">qmemory</span></code> parameter is not of type <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>.</p></li>
<li><p><strong>IndexError</strong> – If the positions given don’t match a valid <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition" title="netsquid.components.qmemory.MemoryPosition"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryPosition</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Memory positions can enable if they schedule events when the busy flag is toggled by
setting <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition.busy_event_enabled" title="netsquid.components.qmemory.MemoryPosition.busy_event_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">busy_event_enabled</span></code></a>.
Because by default <cite>busy_event_enabled</cite> is False, we enable it here.
It is disabled when <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.reset" title="netsquid.components.qmemory.QuantumMemory.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> is called, otherwise it must be manually disabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.await_mempos_in_use_toggle">
<span class="sig-name descname"><span class="pre">await_mempos_in_use_toggle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">QuantumMemory</span> <span class="pre">qmemory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list</span> <span class="pre">positions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.await_mempos_in_use_toggle" title="Link to this definition"></a></dt>
<dd><p>Wait for when one of the positions of a quantum memory toggle their in_use flag.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qmemory</strong> (<a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>) – The quantum memory to wait for.</p></li>
<li><p><strong>positions</strong> (<em>list of int</em>) – The positions to wait for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for one of the memory positions to toggle its in_use flag.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – qmemory is not of type <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>.</p></li>
<li><p><strong>IndexError</strong> – If the positions given don’t match a valid <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition" title="netsquid.components.qmemory.MemoryPosition"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryPosition</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Memory positions can enable if they schedule events when the in_use flag is toggled by
setting <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition.in_use_event_enabled" title="netsquid.components.qmemory.MemoryPosition.in_use_event_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">in_use_event_enabled</span></code></a>.
Because by default <cite>in_use_event_enabled</cite> is False, we enable it here.
It is disabled when <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.reset" title="netsquid.components.qmemory.QuantumMemory.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> is called, otherwise it must be manually disabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.await_port_input">
<span class="sig-name descname"><span class="pre">await_port_input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.await_port_input" title="Link to this definition"></a></dt>
<dd><p>Create an event expression that waits until the specified port receives a message input.</p>
<p>The event expression will also trigger if the message is passed through the port.
The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>port</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Port</span></code>) – Port to listen to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>EventExpression that the protocol yields on.
The message of the port can be fetched with <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port.rx_input" title="netsquid.components.component.Port.rx_input"><code class="xref py py-func docutils literal notranslate"><span class="pre">rx_input()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyProtocol</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">protocols</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">msg_header</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span> <span class="o">=</span> <span class="n">msg_header</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">rx_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A message was input via port </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.await_port_output">
<span class="sig-name descname"><span class="pre">await_port_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.await_port_output" title="Link to this definition"></a></dt>
<dd><p>Create an event expression that waits until the specified port has a message output.</p>
<p>The event expression will also trigger if the message is passed through the port.
The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>port</strong> (<a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port" title="netsquid.components.component.Port"><code class="xref py py-class docutils literal notranslate"><span class="pre">Port</span></code></a>) – Port to listen to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression that the protocol yields on.
The message of the port can be fetched with <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port.rx_output" title="netsquid.components.component.Port.rx_output"><code class="xref py py-func docutils literal notranslate"><span class="pre">rx_output()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyProtocol</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">protocols</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">msg_header</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span> <span class="o">=</span> <span class="n">msg_header</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">rx_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A message was output via port </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.await_program">
<span class="sig-name descname"><span class="pre">await_program</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">await_done=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">await_fail=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.await_program" title="Link to this definition"></a></dt>
<dd><p>Create an event expression that waits for a program on a quantum processor to stop running.</p>
<p>The expression must be <em>yielded</em> on to come into effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>processor</strong> (<a class="reference internal" href="../api_components/netsquid.components.qprocessor.html#netsquid.components.qprocessor.QuantumProcessor" title="netsquid.components.qprocessor.QuantumProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumProcessor</span></code></a>) – The processor that runs the program</p></li>
<li><p><strong>await_done</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, default True) – Whether to wait for the program to successfully finish.</p></li>
<li><p><strong>await_fail</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, default False) – Whether to wait for the program to fail.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for the quantum program to stop.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both <cite>await_done</cite> and <cite>await_fail</cite> are set to True, it will wait until the program either finishes or fails.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.await_signal">
<span class="sig-name descname"><span class="pre">await_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Protocol</span> <span class="pre">sender</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_label=Signals.FINISHED</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.await_signal" title="Link to this definition"></a></dt>
<dd><p>Create an event expression that waits until a sender has sent a specified signal.</p>
<p>The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sender</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol that will send the signal.</p></li>
<li><p><strong>signal_label</strong> (<em>int or str or Enum, optional</em>) – The signal label to wait for.
Default is <code class="xref py py-attr docutils literal notranslate"><span class="pre">FINISHED</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>EventExpression that the protocol yields on.
The signal result can be retrieved from the protocol with <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.get_signal_result" title="netsquid.protocols.protocol.Protocol.get_signal_result"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_signal_result()</span></code></a>
or with <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.get_signal_by_event" title="netsquid.protocols.protocol.Protocol.get_signal_by_event"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_signal_by_event()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.await_timer">
<span class="sig-name descname"><span class="pre">await_timer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double</span> <span class="pre">duration=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double</span> <span class="pre">end_time=0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.await_timer" title="Link to this definition"></a></dt>
<dd><p>Schedule an event to trigger at a specified time and create an event expression to wait for it.</p>
<p>The expression must be <em>yielded</em> on to come into effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>duration</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>, optional) – Amount of time (in Nanoseconds) the protocol should sleep</p></li>
<li><p><strong>end_time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>, optional) – Ignored if duration bigger than 0, time instance at which the event triggers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression that the protocol yields on</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.can_signal_to">
<span class="sig-name descname"><span class="pre">can_signal_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.can_signal_to" title="Link to this definition"></a></dt>
<dd><p>Whether this protocol can send a signal to another protocol.</p>
<p>A local protocol can only signal to another local protocol if they have
one or more nodes in common.
A local protocol can always signal to a standard (non-local) protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>protocol</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol queried as to whether this protocol can send a signal to.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether this protocol can signal to the other protocol.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.check_assigned">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">check_assigned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.check_assigned" title="Link to this definition"></a></dt>
<dd><p>Helper method to check if inputs properly assigned.</p>
<p>Checks that inputs are not None and that they have correct type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<em>object or list of objects</em>) – Inputs to check.</p></li>
<li><p><strong>input_type</strong> (<em>type or None, optional</em>) – Type that inputs should be. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, type is not
checked.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if all <code class="docutils literal notranslate"><span class="pre">inputs</span></code> specified, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.get_signal_by_event">
<span class="sig-name descname"><span class="pre">get_signal_by_event</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">receiver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.get_signal_by_event" title="Link to this definition"></a></dt>
<dd><p>Get the signal result based on the event that triggered it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>event</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code>) – The event that triggered the signalling</p></li>
<li><p><strong>receiver</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> or None, optional) – The protocol wanting to receive the signal value. If not None,
will check if signalling is possible using
<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple with the label and result of the signal that was signalled with the given event.
None if the event is no longer associated with a signal result.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.SignalResult" title="netsquid.protocols.protocol.SignalResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SignalResult</span></code></a> or None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>To avoid storing all signal results and their events, only the most recent signal results are stored.
This means if a signal is sent all previous signal results are deleted, and the previous events are
no longer associated with a signal result.
Signals in the same time instance can co-exist.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.get_signal_result">
<span class="sig-name descname"><span class="pre">get_signal_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">receiver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.get_signal_result" title="Link to this definition"></a></dt>
<dd><p>Get the result of the last signal sent with this label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Signals" title="netsquid.protocols.protocol.Signals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signals</span></code></a>) – Label that the signal was broadcasted with.</p></li>
<li><p><strong>receiver</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> or None, optional) – The protocol wanting to receive the signal value. If not None,
will check if signalling is possible to this protocol using
<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value that was sent with the signal.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RunTimeError</strong> – When attempting to get the result of a local signal from a nonlocal environment</p></li>
<li><p><strong>TypeError</strong> – When attempting to get the result of something else than a protocol</p></li>
<li><p><strong>KeyError</strong> – When the signal label is unknown i.e. hasn’t been added yet with
    <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.add_signal" title="netsquid.protocols.protocol.Protocol.add_signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_signal()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.is_connected">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_connected</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.is_connected" title="Link to this definition"></a></dt>
<dd><p>Whether protocol has been properly configured and can be started.</p>
<p>Requires that all specified nodes have been set (are not None).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if protocol is fully and correctly connected, otherwise False.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.is_running">
<span class="sig-name descname"><span class="pre">is_running</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.is_running" title="Link to this definition"></a></dt>
<dd><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code> True if protocol is running, otherwise False.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.max_nodes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_nodes</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.max_nodes" title="Link to this definition"></a></dt>
<dd><p>maximum number of nodes this local protocol can run on.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.name" title="Link to this definition"></a></dt>
<dd><p>Name of protocol for identification and display purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.node">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">node</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.node" title="Link to this definition"></a></dt>
<dd><p>single node this protocol is running on.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_nodes/netsquid.nodes.node.html#netsquid.nodes.node.Node" title="netsquid.nodes.node.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.nodes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nodes</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.nodes" title="Link to this definition"></a></dt>
<dd><p>nodes local to this protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.remove">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.remove" title="Link to this definition"></a></dt>
<dd><p>Removes the entity from the simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.reset" title="Link to this definition"></a></dt>
<dd><p>Stops and starts the protocol leaving it in a clean state.</p>
<p>Will stop the protocol with the specified status,
or Status.FAIL if not specified. Leaves the protocol in the Protocol.IDLE state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.send_signal">
<span class="sig-name descname"><span class="pre">send_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.send_signal" title="Link to this definition"></a></dt>
<dd><p>Send a signal to other protocols to indicate a status change or announce a result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal_label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Signals" title="netsquid.protocols.protocol.Signals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signals</span></code></a>) – Label, key or status that is broadcasted to the world. Other protocols can wait for this signal.</p></li>
<li><p><strong>result</strong> (<em>Any or None, optional</em>) – Result or intermediate results of the protocol that you want to broadcast with this signal</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <code class="docutils literal notranslate"><span class="pre">signal_label</span></code> does not correspond to a signal of this protocol.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When a protocol is finished (i.e. its run() returns),
the protocol sends a signal with label <code class="xref py py-attr docutils literal notranslate"><span class="pre">FINISHED</span></code>.
The result is set to the return value.</p>
<p>When a signal is sent with a label that was sent earlier, the result of the first signal is overwritten.
Signal results sent in the same time instance can be individually retrieved using the triggering event.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.signals">
<span class="sig-name descname"><span class="pre">signals</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.signals" title="Link to this definition"></a></dt>
<dd><p>signals this protocol can send (<a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> indexed by label).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.specify_node">
<span class="sig-name descname"><span class="pre">specify_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.specify_node" title="Link to this definition"></a></dt>
<dd><p>Specify a node required by this protocol.</p>
<p>The protocol cannot start until all specified nodes are set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Key to index the node with.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If specifying this node will exceed the maximum number of nodes
    <a class="reference internal" href="../api_protocols/netsquid.protocols.nodeprotocols.html#netsquid.protocols.nodeprotocols.LocalProtocol.max_nodes" title="netsquid.protocols.nodeprotocols.LocalProtocol.max_nodes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_nodes</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.start" title="Link to this definition"></a></dt>
<dd><p>Start the protocol.</p>
<p>Will register the protocol and run up to the first yield.
Will not start any sub-protocols. Sub-protocols are started in the run().
When run() is not overridden it will start all sub-protocol in parallel automatically.
If it is overridden the sub-protocols should be started manually in the method;
this to give control on when sub-protocols should run in parallel or in sequence</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>This protocol is returned for convenience.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a></p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError</strong> – If the protocol has not been properly connected.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.start_subprotocols">
<span class="sig-name descname"><span class="pre">start_subprotocols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.start_subprotocols" title="Link to this definition"></a></dt>
<dd><p>Start all the sub-protocols in parallel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.stop">
<span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.stop" title="Link to this definition"></a></dt>
<dd><p>Stop the protocol as well as any running sub-protocols.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.subprotocols">
<span class="sig-name descname"><span class="pre">subprotocols</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.subprotocols" title="Link to this definition"></a></dt>
<dd><p>sub-protocols of this protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.CorrectProtocol.uid">
<span class="sig-name descname"><span class="pre">uid</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.CorrectProtocol.uid" title="Link to this definition"></a></dt>
<dd><p>returns a unique identifier for this entity in the simulation.</p>
<p>Each entity has a unique identifier in the simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.FibreDepolarizeModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">netsquid.examples.repeater_chain.</span></span><span class="sig-name descname"><span class="pre">FibreDepolarizeModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p_depol_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.009</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_depol_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.025</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.FibreDepolarizeModel" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="../api_models/netsquid.components.models.qerrormodels.html#netsquid.components.models.qerrormodels.QuantumErrorModel" title="netsquid.components.models.qerrormodels.QuantumErrorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumErrorModel</span></code></a></p>
<p>Custom non-physical error model used to show the effectiveness
of repeater chains.</p>
<p>The default values are chosen to make a nice figure,
and don’t represent any physical system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p_depol_init</strong> (<em>float, optional</em>) – Probability of depolarization on entering a fibre.
Must be between 0 and 1. Default 0.009</p></li>
<li><p><strong>p_depol_length</strong> (<em>float, optional</em>) – Probability of depolarization per km of fibre.
Must be between 0 and 1. Default 0.025</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.FibreDepolarizeModel.required_properties">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">required_properties</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.FibreDepolarizeModel.required_properties" title="Link to this definition"></a></dt>
<dd><p>Parameters that need to be passed to the model when the
model is called.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.FibreDepolarizeModel.error_operation">
<span class="sig-name descname"><span class="pre">error_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.FibreDepolarizeModel.error_operation" title="Link to this definition"></a></dt>
<dd><p>Uses the length property to calculate a depolarization probability,
and applies it to the qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubits</strong> (tuple of <a class="reference internal" href="../api_qubits/netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Qubits to apply noise to.</p></li>
<li><p><strong>delta_time</strong> (<em>float, optional</em>) – Time qubits have spent on a component [ns]. Not used.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.FibreDepolarizeModel.add_property">
<span class="sig-name descname"><span class="pre">add_property</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mutable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.FibreDepolarizeModel.add_property" title="Link to this definition"></a></dt>
<dd><p>Add a property to this model.</p>
<p>Properties can be accessed and modified via the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">properties</span></code> attribute.</p>
<p>If a property with this name already exists, an attempt will be made to
set the new value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Name of the property.</p></li>
<li><p><strong>value</strong> (<em>Any</em>) – Value of the property.</p></li>
<li><p><strong>mutable</strong> (<em>bool, optional</em>) – Whether the property is mutable. Default True.</p></li>
<li><p><strong>value_type</strong> (<em>type or tuple thereof, optional</em>) – Allowed types of this property. Not constrained by default.</p></li>
<li><p><strong>value_constraints</strong> (<cite>~netsquid.util.constrainedmap.ValueConstraint</cite> or list of <cite>~netsquid.util.constrainedmap.ValueConstraint</cite> , optional) – Constraint checks to verify if value is a valid value. Not constrained by default.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.FibreDepolarizeModel.compute_model">
<span class="sig-name descname"><span class="pre">compute_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.FibreDepolarizeModel.compute_model" title="Link to this definition"></a></dt>
<dd><p>Perform the action of the model.</p>
<p>This is the method called when the object is used as a callable function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubits</strong> (list of <a class="reference internal" href="../api_qubits/netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a> or None) – Qubits to apply error to.</p></li>
<li><p><strong>delta_time</strong> (<em>float, optional</em>) – Time qubits have spent on a component [ns].</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>TypeError</strong> – If the list <cite>items</cite> contains anything other than <a class="reference internal" href="../api_qubits/netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a> or <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For the model to work, the **kwargs need to include all the
parameters listed in the attribute <em>required properties</em> of the
model.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.FibreDepolarizeModel.concatenation_class">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">concatenation_class</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.FibreDepolarizeModel.concatenation_class" title="Link to this definition"></a></dt>
<dd><p>Type of the object that is returned when concatenating this model</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Concatenating two (subclasses of) QuantumErrorModel results in a QuantumErrorModel.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_models/netsquid.components.models.qerrormodels.html#netsquid.components.models.qerrormodels.QuantumErrorModel" title="netsquid.components.models.qerrormodels.QuantumErrorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumErrorModel</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.FibreDepolarizeModel.is_concatenated">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_concatenated</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.FibreDepolarizeModel.is_concatenated" title="Link to this definition"></a></dt>
<dd><p>If this model is concatenated by adding multiple models together</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether this model consist of multiple models</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.FibreDepolarizeModel.lose_qubit">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">lose_qubit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_loss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.FibreDepolarizeModel.lose_qubit" title="Link to this definition"></a></dt>
<dd><p>Helper function to lose a qubit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubits</strong> (list of <a class="reference internal" href="../api_qubits/netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qubit</span></code></a>) – Qubits from which a qubit should be lost.</p></li>
<li><p><strong>qubit_index</strong> (<em>int</em>) – Index of the qubit that should be lost.</p></li>
<li><p><strong>prob_loss</strong> (<em>float, optional</em>) – Probability with which the qubit is lost, used in case of number state.</p></li>
<li><p><strong>rng</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>, optional) – The random number generator to use. Default <cite>simtools.get_random_state()</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In the case of a standard qubit item, it is discarded from its shared quantum state (if applicable).</p>
<p>If the qubit represents a number state (e.g. presence of a photon), the qubit is amplitude dampened
according to the loss probability.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.FibreDepolarizeModel.properties">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">properties</span></span><a class="headerlink" href="#netsquid.examples.repeater_chain.FibreDepolarizeModel.properties" title="Link to this definition"></a></dt>
<dd><p>Properties of the model.
They are independent of the object that is calling/using the model.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.FibreDepolarizeModel.validate">
<span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">properties</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.FibreDepolarizeModel.validate" title="Link to this definition"></a></dt>
<dd><p>Verifies that the given properties match the required properties.</p>
<p>The validate method is only called when a model is “attached” to a component.
The model verifies that all the <em>required properties</em> have been
defined as a part of the components properties.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>**properties</strong> – Input properties to be validated.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns True if all the <em>required properties</em> have been passed to
the model. Otherwise returns False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.create_qprocessor">
<span class="sig-prename descclassname"><span class="pre">netsquid.examples.repeater_chain.</span></span><span class="sig-name descname"><span class="pre">create_qprocessor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.create_qprocessor" title="Link to this definition"></a></dt>
<dd><p>Factory to create a quantum processor for each node in the repeater chain network.</p>
<p>Has two memory positions and the physical instructions necessary for teleportation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name of the quantum processor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A quantum processor to specification.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_components/netsquid.components.qprocessor.html#netsquid.components.qprocessor.QuantumProcessor" title="netsquid.components.qprocessor.QuantumProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumProcessor</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.setup_network">
<span class="sig-prename descclassname"><span class="pre">netsquid.examples.repeater_chain.</span></span><span class="sig-name descname"><span class="pre">setup_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_frequency</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.setup_network" title="Link to this definition"></a></dt>
<dd><p>Setup repeater chain network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_nodes</strong> (<em>int</em>) – Number of nodes in the network, at least 3.</p></li>
<li><p><strong>node_distance</strong> (<em>float</em>) – Distance between nodes [km].</p></li>
<li><p><strong>source_frequency</strong> (<em>float</em>) – Frequency at which the sources create entangled qubits [Hz].</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Network component with all nodes and connections as subcomponents.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_nodes/netsquid.nodes.network.html#netsquid.nodes.network.Network" title="netsquid.nodes.network.Network"><code class="xref py py-class docutils literal notranslate"><span class="pre">Network</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.setup_repeater_protocol">
<span class="sig-prename descclassname"><span class="pre">netsquid.examples.repeater_chain.</span></span><span class="sig-name descname"><span class="pre">setup_repeater_protocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">network</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.setup_repeater_protocol" title="Link to this definition"></a></dt>
<dd><p>Setup repeater protocol on repeater chain network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>network</strong> (<a class="reference internal" href="../api_nodes/netsquid.nodes.network.html#netsquid.nodes.network.Network" title="netsquid.nodes.network.Network"><code class="xref py py-class docutils literal notranslate"><span class="pre">Network</span></code></a>) – Repeater chain network to put protocols on.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Protocol holding all subprotocols used in the network.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.setup_datacollector">
<span class="sig-prename descclassname"><span class="pre">netsquid.examples.repeater_chain.</span></span><span class="sig-name descname"><span class="pre">setup_datacollector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">network</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.setup_datacollector" title="Link to this definition"></a></dt>
<dd><p>Setup the datacollector to calculate the fidelity
when the CorrectionProtocol has finished.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>network</strong> (<a class="reference internal" href="../api_nodes/netsquid.nodes.network.html#netsquid.nodes.network.Network" title="netsquid.nodes.network.Network"><code class="xref py py-class docutils literal notranslate"><span class="pre">Network</span></code></a>) – Repeater chain network to put protocols on.</p></li>
<li><p><strong>protocol</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol holding all subprotocols used in the network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Datacollector recording fidelity data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.datacollector.html#netsquid.util.datacollector.DataCollector" title="netsquid.util.datacollector.DataCollector"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollector</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.run_simulation">
<span class="sig-prename descclassname"><span class="pre">netsquid.examples.repeater_chain.</span></span><span class="sig-name descname"><span class="pre">run_simulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.run_simulation" title="Link to this definition"></a></dt>
<dd><p>Run the simulation experiment and return the collected data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_nodes</strong> (<em>int, optional</em>) – Number nodes in the repeater chain network. At least 3. Default 4.</p></li>
<li><p><strong>node_distance</strong> (<em>float, optional</em>) – Distance between nodes, larger than 0. Default 20 [km].</p></li>
<li><p><strong>num_iters</strong> (<em>int, optional</em>) – Number of simulation runs. Default 100.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dataframe with recorded fidelity data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="netsquid.examples.repeater_chain.create_plot">
<span class="sig-prename descclassname"><span class="pre">netsquid.examples.repeater_chain.</span></span><span class="sig-name descname"><span class="pre">create_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netsquid.examples.repeater_chain.create_plot" title="Link to this definition"></a></dt>
<dd><p>Run the simulation for multiple nodes and distances and show them in a figure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_iters</strong> (<em>int, optional</em>) – Number of iterations per simulation configuration.
At least 1. Default 2000.</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="netsquid.examples.repeater.html" class="btn btn-neutral float-left" title="netsquid.examples.repeater" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="netsquid.examples.simple_link.html" class="btn btn-neutral float-right" title="netsquid.examples.simple_link" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2021, TNO and TUDelft (QuTech).</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: 1.1.7
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
      <dd><a href="/1-1-stable/">1.1.5</a></dd>
      <dd><a href="/1-0-stable/">1.0.7</a></dd>
      <dd><a href="/0-10-stable/">0.10.4</a></dd>
      <dd><a href="/0-9-stable/">0.9.11</a></dd>
      <dd><a href="/0-8-stable/">0.8.7</a></dd>
      <dd><a href="/0-7-stable/">0.7.5</a></dd>
      <dd><a href="/0-6-stable/">0.6.4</a></dd>
      <dd><a href="/0-5-stable/">0.5.2</a></dd>
      <dd><a href="/0-4-stable/">0.4.2</a></dd>
      <dd><a href="/0-3-stable/">0.3.5</a></dd>
      <dd><a href="/latest-release/">latest release</a></dd>
      <dd><a href="/master/">master branch</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".highlight-default .highlight").each(function() {
            if ($(this).find(".gp").length > 0) {
             $(this).prepend("<div class='codebtn btn btn-neutral float-right'><div class='gp'>>>></div><div>");
             $(this).children("pre").contents().filter(function() {return this.nodeType === 3;}).wrap("<span></span>").end();
            }
        });
        $(".highlight-default .highlight .codebtn").click(function() {
            $(this).parent().children("pre").find(".gp").toggleClass("hidden");
            var traceback_elem = $(this).parent().children("pre").find(".gt, .go");
            traceback_elem.toggleClass("hidden");
            traceback_elem.nextUntil(".gp, .go").toggleClass("hidden");

        })
    });
</script>


</body>
</html>