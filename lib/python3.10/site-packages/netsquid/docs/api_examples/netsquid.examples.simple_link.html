<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>netsquid.examples.simple_link &mdash; NetSquid 1.1.7 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=370aedac"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="netsquid.examples.magic_simple_link" href="netsquid.examples.magic_simple_link.html" />
    <link rel="prev" title="netsquid.examples.repeater_chain" href="netsquid.examples.repeater_chain.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #E3E3E3" >

          
          
          <a href="../index.html" class="icon icon-home">
            NetSquid
              <img src="../_static/squid-150.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.1.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../INSTALL.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RELEASE.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AUTHORS.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LICENSE.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Learn NetSquid</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quick_start.html">NetSquid in 10 minutes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.intro.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.qubits.html">Qubits and quantum computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.pydynaa.html">Discrete event simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.components.html">Modelling of network components</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.nodes.html">Nodes and Connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.quantumprocessor.html">The Quantum Processor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.simulation.html">A full simulation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../learn.examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.teleportation.html">Teleportation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.repeater.html">Repeater with purification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.repeater_chain.html">Repeater chain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.simple_link.html">A simple link layer protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="../learn_examples/learn.examples.magic_simple_link.html">Faster Link layer Protocol using abstraction</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../api_reference.html">NetSquid package</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../netsquid.qubits.html">netsquid.qubits</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qformalism.html">netsquid.qubits.qformalism</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qubitapi.html">netsquid.qubits.qubitapi</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.operators.html">netsquid.qubits.operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.cliffords.html">netsquid.qubits.cliffords</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.ketstates.html">netsquid.qubits.ketstates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.state_sampler.html">netsquid.qubits.state_sampler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qubit.html">netsquid.qubits.qubit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qstate.html">netsquid.qubits.qstate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qrepr.html">netsquid.qubits.qrepr</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.kettools.html">netsquid.qubits.kettools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.dmtools.html">netsquid.qubits.dmtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.sparsedmtools.html">netsquid.qubits.sparsedmtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.stabtools.html">netsquid.qubits.stabtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.gslctools.html">netsquid.qubits.gslctools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qreprutil.html">netsquid.qubits.qreprutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.ketutil.html">netsquid.qubits.ketutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.dmutil.html">netsquid.qubits.dmutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.sparseutil.html">netsquid.qubits.sparseutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.gslcutil.html">netsquid.qubits.gslcutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.opmath.html">netsquid.qubits.opmath</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.components.html">netsquid.components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.component.html">netsquid.components.component</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.channel.html">netsquid.components.channel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qchannel.html">netsquid.components.qchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.cchannel.html">netsquid.components.cchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.cqchannel.html">netsquid.components.cqchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qmemory.html">netsquid.components.qmemory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.instructions.html">netsquid.components.instructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qprogram.html">netsquid.components.qprogram</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qprocessor.html">netsquid.components.qprocessor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.clock.html">netsquid.components.clock</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qsource.html">netsquid.components.qsource</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qdetector.html">netsquid.components.qdetector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.switch.html">netsquid.components.switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.ccoding.html">netsquid.components.ccoding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.components.models.html">netsquid.components.models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.model.html">netsquid.components.models.model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.delaymodels.html">netsquid.components.models.delaymodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.errormodels.html">netsquid.components.models.errormodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.qerrormodels.html">netsquid.componentsmodels.qerrormodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.cerrormodels.html">netsquid.components.models.cerrormodels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.nodes.html">netsquid.nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.node.html">netsquid.nodes.node</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.connections.html">netsquid.nodes.connections</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.network.html">netsquid.nodes.network</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.protocols.html">netsquid.protocols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html">netsquid.protocols.protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.nodeprotocols.html">netsquid.protocols.nodeprotocols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html">netsquid.protocols.serviceprotocol</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.util.html">netsquid.util</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simtools.html">netsquid.util.simtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simlog.html">netsquid.util.simlog</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simstats.html">netsquid.util.simstats</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.datacollector.html">netsquid.util.datacollector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.cycache.html">netsquid.util.cycache</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.cymath.html">netsquid.util.cymath</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html">netsquid.util.constrainedmap</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="reference internal" href="../netsquid.examples.html">netsquid.examples</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="netsquid.examples.teleportation.html">netsquid.examples.teleportation</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.examples.entanglenodes.html">netsquid.examples.entanglenodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.examples.purify.html">netsquid.examples.purify</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.examples.repeater.html">netsquid.examples.repeater</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.examples.repeater_chain.html">netsquid.examples.repeater_chain</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">netsquid.examples.simple_link</a></li>
<li class="toctree-l3"><a class="reference internal" href="netsquid.examples.magic_simple_link.html">netsquid.examples.magic_simple_link</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api_pydynaa.html">pyDynAA package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html">pydynaa.Entity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-event">pydynaa.Event</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventtype">pydynaa.EventType</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventexpression">pydynaa.EventExpression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventhandler">pydynaa.EventHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-expressionhandler">pydynaa.ExpressionHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-simulationengine">pydynaa.SimulationEngine</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">For developers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../INSTALL-SOURCE.html">Installation from source</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CHANGELOG.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #E3E3E3" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">NetSquid</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../api_reference.html">NetSquid package</a></li>
          <li class="breadcrumb-item"><a href="../netsquid.examples.html">netsquid.examples</a></li>
      <li class="breadcrumb-item active">netsquid.examples.simple_link</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api_examples/netsquid.examples.simple_link.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="netsquid.examples.repeater_chain.html" class="btn btn-neutral float-left" title="netsquid.examples.repeater_chain" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="netsquid.examples.magic_simple_link.html" class="btn btn-neutral float-right" title="netsquid.examples.magic_simple_link" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="netsquid-examples-simple-link">
<h1>netsquid.examples.simple_link<a class="headerlink" href="#netsquid-examples-simple-link" title="Link to this heading"></a></h1>
<p>In this example we will look at achieving robust entanglement
generation by defining a simple quantum <em>link layer</em> protocol.
This example is inspired by the quantum link layer proposed by <a class="reference external" href="https://arxiv.org/abs/1903.09778">Dahlberg et al</a>.
In this paper the following quantum network stack is defined in analogy to the classical OSI stack:</p>
<a class="reference internal image-reference" href="../_images/layers_LL.png"><img alt="The five layers of the quantum network stack." class="align-center" src="../_images/layers_LL.png" style="width: 400px;" /></a>
<p>The bottom or <em>physical layer</em> is responsible for executing entanglement generation <em>attempts</em> when requested.
These attempts can succeed or fail, and this information is propagated to the <em>link layer</em>,
which is responsible for generating this entanglement in a robust manner.
The link layer receives requests from the network layer to
create entanglement and will respond with success once this is achieved.</p>
<p>In this example will be explore simplified implementations for the physical and link layer protocols.
Before we dive into the protocols let us describe an example physical network in NetSquid,
which will have the following layout:</p>
<a class="reference internal image-reference" href="../_images/aafig-e136a9d79a1b68165fcb04c47d8657cb7d2036ca.svg"><img alt="../_images/aafig-e136a9d79a1b68165fcb04c47d8657cb7d2036ca.svg" class="align-center" height="113.79999999999998" src="../_images/aafig-e136a9d79a1b68165fcb04c47d8657cb7d2036ca.svg" width="505.79999999999995" /></a>
<p>Alice and Bob will use a <em>single-click scheme</em> to generate <em>heralded entanglement</em> (see paper).
The quantum and classical channels and the detector required to generate
the entanglement are contained within a heralded connection.
We will request the entanglement generator at Alice, who will use the classical connection to
synchronize the requests with Bob.
A node contains a Quantum Processor which is connected to the heralded connection.</p>
<a class="reference internal image-reference" href="../_images/aafig-89271adffc8daabf412851542a5f2a6eab0899c3.svg"><img alt="../_images/aafig-89271adffc8daabf412851542a5f2a6eab0899c3.svg" class="align-center" height="113.79999999999998" src="../_images/aafig-89271adffc8daabf412851542a5f2a6eab0899c3.svg" width="437.19999999999993" /></a>
<p>The network is setup as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_example_network</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the example network.</span>

<span class="sd">    Alice and Bob need a QuantumProcessor to store the qubits they produce.</span>
<span class="sd">    Their qubits are send through a heralded connection,</span>
<span class="sd">    which needs to be connected to Alice and Bob.</span>
<span class="sd">    It is assumed qubits are send to the connection,</span>
<span class="sd">    and it returns classical messages.</span>
<span class="sd">    In this example we won&#39;t use noise on the quantum memories,</span>
<span class="sd">    so instead of defining PhysicalInstructions we</span>
<span class="sd">    fallback to nonphysical ones.</span>
<span class="sd">    In order to synchronize their attempts a classical connection is added.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_qubits : int</span>
<span class="sd">        The number of entangled qubit pairs we expect this network to make. Default 3.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~netsquid.nodes.network.Network`</span>
<span class="sd">        The example network for a simple link.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">network</span> <span class="o">=</span> <span class="n">Network</span><span class="p">(</span><span class="s1">&#39;SimpleLinkNetwork&#39;</span><span class="p">)</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">([</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">])</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># in km</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">node</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">QuantumProcessor</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;qmem_</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                                               <span class="n">num_positions</span><span class="o">=</span><span class="n">num_qubits</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                               <span class="n">fallback_to_nonphysical</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">HeraldedConnection</span><span class="p">(</span><span class="s2">&quot;HeraldedConnection&quot;</span><span class="p">,</span> <span class="n">length_to_a</span><span class="o">=</span><span class="n">distance</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                              <span class="n">length_to_b</span><span class="o">=</span><span class="n">distance</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">time_window</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">network</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">connection</span><span class="o">=</span><span class="n">conn</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;quantum&#39;</span><span class="p">)</span>
    <span class="n">network</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">delay</span><span class="o">=</span><span class="n">distance</span> <span class="o">/</span> <span class="mi">200000</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;classical&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">network</span>
</pre></div>
</div>
<p>Let us now define the needed protocols.
The <em>physical layer</em> and the <em>link layer</em> work together very closely, therefore we will give a
full overview of both protocols first, before diving into their implementation.</p>
<p>The <em>link layer</em> should respond to CREATE requests, which are issued from the <em>network</em> layer.
A CREATE request specifies in our case the number of qubits pairs we want to generate.
For this example we assume the request to generate three qubits just arrived at Alice.
The protocol works as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The link layer receives the request from the network layer.</p></li>
<li><p>The request is synchronized with the other node.</p></li>
<li><p>Every 100 ns the physical layer sends a trigger to the link layer.</p></li>
<li><p>On the trigger from the physical layer the link layer responds with the first queued request.</p></li>
<li><p>The link layers send a response to their physical layer with instructions.</p></li>
<li><p>The physical layer protocols create a qubit-photon pair using their quantum processors
and send the photon to the heralded connection.</p></li>
<li><p>When both photons arrive at the detector of the heralded connection, they are measured.</p></li>
<li><p>The heralded connection informs the physical layer of the measurement outcome.</p></li>
<li><p>The measurement outcome is propagated to the link layer, which can now
decide to send a response to the network layer.</p></li>
<li><p>Repeat step 5-9 until the desired number of pairs is created.</p></li>
</ol>
</div></blockquote>
<p>The physical layer we implement using the <code class="docutils literal notranslate"><span class="pre">MidpointHeraldingProtocol</span></code> (MHP) protocol, whereas
the link layer is implemented using an <code class="docutils literal notranslate"><span class="pre">EGProtocol</span></code>, where EG is an acronym for entanglement generation.
The MHP should trigger the EGP on a fixed timer, and start
the entanglement generation process on a response from the EGP.
This is implemented as shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MidpointHeraldingProtocol</span><span class="p">(</span><span class="n">NodeProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Attempt to generate entanglement via a HeraldingConnection.</span>

<span class="sd">    This protocol sends a trigger to an EGProtocol every ``time_step`` nanoseconds.</span>
<span class="sd">    On a response the protocol creates a qubit in memory, entangles it with a photon,</span>
<span class="sd">    and sends this photon to the qout port of the quantum memory.</span>
<span class="sd">    This port is expected to forward the photon to the heralded connection.</span>
<span class="sd">    This connection is expected to return an outcome of the photon measurement,</span>
<span class="sd">    which returns 1 or 2 (each denotes an entangled state) for success.</span>
<span class="sd">    The photon will be generated on position 0, and the qubits on 1 .. N.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node : `~netsquid.nodes.node.Node`</span>
<span class="sd">        The node this protocol runs on.</span>
<span class="sd">    time_step : int</span>
<span class="sd">        The period of the triggers in nanoseconds.</span>
<span class="sd">    q_port_name : str</span>
<span class="sd">        The name of the port connected to the heraled connection.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    trigger_label : str</span>
<span class="sd">        The label of the trigger signal</span>
<span class="sd">    answer_label : str</span>
<span class="sd">        The label of the answer signal</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">q_port_name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span> <span class="o">=</span> <span class="n">time_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;qout&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">forward_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="n">q_port_name</span><span class="p">])</span>
        <span class="c1"># And we will wait for an outcome on the input port</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port_name</span> <span class="o">=</span> <span class="n">q_port_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_port_name</span> <span class="o">=</span> <span class="n">q_port_name</span>
        <span class="c1"># We have to remember if we already send a photon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_label</span> <span class="o">=</span> <span class="s2">&quot;TRIGGER&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">answer_label</span> <span class="o">=</span> <span class="s2">&quot;ANSWER&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trigger_label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">answer_label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_task_label</span> <span class="o">=</span> <span class="s1">&#39;do_task_label&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_task_label</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">EmitProgram</span><span class="p">(</span><span class="n">QuantumProgram</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Program to create a qubit and emit an entangled photon to the &#39;qout&#39; port.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">program</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># Emit from q2 using q1</span>
            <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_qubit_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">INSTR_INIT</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">INSTR_EMIT</span><span class="p">,</span> <span class="p">[</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">])</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sends triggers periodically or starts an entanglement attempt.</span>

<span class="sd">        The triggers are skipped during the entanglement attempt for simplicity.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        :class:`~pydynaa.core.EventExpression`</span>
<span class="sd">            Await a timer signal or a response from the connection.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1">#  Instead of a duration we specify the time explicitly</span>
            <span class="c1">#  to be a mulitple of the time_step.</span>
            <span class="n">time</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">()</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span>
            <span class="n">wait_timer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_timer</span><span class="p">(</span><span class="n">end_time</span><span class="o">=</span><span class="n">time</span><span class="p">)</span>
            <span class="n">wait_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_task_label</span><span class="p">)</span>
            <span class="n">evexpr</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">wait_timer</span> <span class="o">|</span> <span class="n">wait_signal</span>
            <span class="k">if</span> <span class="n">evexpr</span><span class="o">.</span><span class="n">second_term</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="c1"># Start the entanglement attempt</span>
                <span class="n">qpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_signal_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_task_label</span><span class="p">)</span>
                <span class="n">prog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EmitProgram</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">execute_program</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qubit_mapping</span><span class="o">=</span><span class="p">[</span><span class="n">qpos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">q_port_name</span><span class="p">]</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
                <span class="n">message</span> <span class="o">=</span> <span class="n">port</span><span class="o">.</span><span class="n">rx_input</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">message</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;photonoutcome&#39;</span><span class="p">:</span>
                    <span class="n">outcome</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outcome</span> <span class="o">=</span> <span class="s1">&#39;FAIL&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">send_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">answer_label</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="p">(</span><span class="n">outcome</span><span class="p">,</span> <span class="n">qpos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">send_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trigger_label</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">do_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qpos</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Start the task.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qpos : int</span>
<span class="sd">            The number indicating which qubit pair we are making.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_task_label</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="n">qpos</span><span class="p">)</span>
</pre></div>
</div>
<p>The EGP is defined as a <em>service</em>: a protocol that defines the interface the network layer can use more explicitly.
We can split our protocol into two parts: handling input of requests and handling the requests themselves.
We will use the service to handle the input of requests, and the actual
handling of the requests will be implemented by a protocol.
In <a class="reference external" href="learn.examples.magic_simple_link.html">an extention of this example</a> we will reuse
the service but create a new protocol.
Our EGP can’t handle multiple requests at once, so we use a queue to schedule the requests.
The service is implemented as shown below with an abstract request handler:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EGService</span><span class="p">(</span><span class="n">ServiceProtocol</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract interface for an Entanglement Generation Service.</span>

<span class="sd">    Defines the available request and response types, and implements the queue mechanism.</span>
<span class="sd">    Every request will be assigned a unique create_id, which is</span>
<span class="sd">    returned when a request is put to this service.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node : :class:`~netsquid.nodes.node.Node`</span>
<span class="sd">        The node this protocol runs on.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        The name of this protocol. Default EGService.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    req_create : namedtuple</span>
<span class="sd">        A request to create entanglement with a remote node.</span>
<span class="sd">    res_ok : namedtuple</span>
<span class="sd">        A response to indicate a create request has finished.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define the requests and responses as class attributes so</span>
    <span class="c1"># they are identical for every EGProtocol instance</span>
    <span class="n">req_create</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;LinkLayerCreate&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;purpose_id&#39;</span><span class="p">,</span> <span class="s1">&#39;number&#39;</span><span class="p">])</span>
    <span class="n">res_ok</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;LinkLayerOk&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;purpose_id&#39;</span><span class="p">,</span> <span class="s1">&#39;create_id&#39;</span><span class="p">,</span> <span class="s1">&#39;logical_qubit_id&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># Register the request and response</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_request</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">req_create</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_response</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_ok</span><span class="p">)</span>
        <span class="c1"># We will use a queue for requests</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_new_req_signal</span> <span class="o">=</span> <span class="s2">&quot;New request in queue&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new_req_signal</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_id</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">handle_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Schedule the request on the queue.</span>

<span class="sd">        Schedule the request in a queue and</span>
<span class="sd">        signal to :meth:`~netsquid.examples.simple_link.EGProtocol.run`</span>
<span class="sd">        new items have been put into the queue.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        request :</span>
<span class="sd">            The object representing the request.</span>
<span class="sd">        identifier : str</span>
<span class="sd">            The identifier for this request.</span>
<span class="sd">        start_time : float, optional</span>
<span class="sd">            The time at which the request can be executed. Default current simulation time.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Additional arguments which can be set by the service.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The dictionary with additional arguments.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called after</span>
<span class="sd">        :meth:`~netsquid.protocols.serviceprotocol.ServiceProtocol.put` which</span>
<span class="sd">        does the type checking etc.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start_time</span><span class="p">,</span> <span class="p">(</span><span class="n">identifier</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new_req_signal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wait for a new request signal, then run the requests one by one.</span>

<span class="sd">        Assumes request handlers are generators and not functions.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_req_signal</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start_time</span><span class="p">,</span> <span class="p">(</span><span class="n">handler_id</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">():</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_timer</span><span class="p">(</span><span class="n">end_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">)</span>
                <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_handlers</span><span class="p">[</span><span class="n">handler_id</span><span class="p">]</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span>
                <span class="n">gen</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">})</span>
                <span class="k">yield from</span> <span class="n">gen</span>

    <span class="k">def</span> <span class="nf">_get_next_create_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Return a unique create id.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_id</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_id</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">purpose_id</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">create_id</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Implement the entanglement generation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        purpose_id : int</span>
<span class="sd">            Integer representing which purpose this entanglement is for.</span>
<span class="sd">            Used to communicate to the higher layers.</span>
<span class="sd">        number : int</span>
<span class="sd">            Number of qubit pairs to make.</span>
<span class="sd">        create_id : int</span>
<span class="sd">            The unique identifier provided by the service.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Drain for any optional parameters.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>The synchronization and request handling can now be defined in the protocol:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EGProtocol</span><span class="p">(</span><span class="n">EGService</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implement an Entanglement Generation service.</span>

<span class="sd">    Upon a *LinkLayerCreate* request generates pairs of entangled qubits, of which one</span>
<span class="sd">    is locally stored and the other is stored at the remote node.</span>
<span class="sd">    Requests are fulfulled in FIFO order, and upon completion</span>
<span class="sd">    a response signal is sent.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node : :class:`~netsquid.nodes.node.Node`</span>
<span class="sd">        The node this protocol runs on.</span>
<span class="sd">    c_port_name : str</span>
<span class="sd">        The name of the port which is connected to the remote node.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        The name of this protocol. Default EGProtocol.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">c_port_name</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># Require a Physical Layer protocol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mh_name</span> <span class="o">=</span> <span class="s2">&quot;MH_Protocol&quot;</span>
        <span class="c1"># Setup queue synchronization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="n">c_port_name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_port</span><span class="o">.</span><span class="n">bind_input_handler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle_msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_phys_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mh_protocol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a physical layer protocol as a subprotocol.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mh_protocol :</span>
<span class="sd">            The protocol which implements a physical layer.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subprotocol</span><span class="p">(</span><span class="n">mh_protocol</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mh_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Synchronize the request with the other service and schedule it on the queue.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        request :</span>
<span class="sd">            The object representing the request.</span>
<span class="sd">        identifier : str</span>
<span class="sd">            The identifier for this request.</span>
<span class="sd">        start_time : float, optional</span>
<span class="sd">            The time at which the request can be executed. Default current time.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Additional arguments not part of the original request.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The dictionary with additional arguments.</span>
<span class="sd">            For the create request this is the unique create id.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;create_id&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;create_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_create_id</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">travel_time</span> <span class="o">=</span> <span class="mi">10000</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">()</span> <span class="o">+</span> <span class="n">travel_time</span>
            <span class="c1"># Make sure Message don&#39;t combine by specifying a header.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_port</span><span class="o">.</span><span class="n">tx_output</span><span class="p">(</span>
                <span class="n">Message</span><span class="p">([</span><span class="n">request</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="n">request</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">handle_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_handle_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handle incoming messages from the other service.</span>

<span class="sd">        The services use these messages to ensure they start</span>
<span class="sd">        the same request at the same time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        msg : Message</span>
<span class="sd">            A Message from another ServiceProtocol containing request</span>
<span class="sd">            and scheduling data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">request</span><span class="p">,</span> <span class="n">handler_id</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">items</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handle_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">handler_id</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make sure we have an subprotocol before running our program.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mh_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subprotocols</span> <span class="ow">or</span> \
                <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subprotocols</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mh_name</span><span class="p">],</span> <span class="n">Protocol</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;EGProtocol requires a physical layer protocol to be added.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_subprotocols</span><span class="p">()</span>
        <span class="k">yield from</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">purpose_id</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handler for create requests.</span>

<span class="sd">        Create qubits together with a remote node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        purpose_id : int</span>
<span class="sd">            The number used to to tag this request for a specific purpose in a higher layer.</span>
<span class="sd">        number : int</span>
<span class="sd">            The number of qubits to make in this request.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        :class:`~pydynaa.core.EventExpression`</span>
<span class="sd">            The expressions required to execute the create request.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :obj:`~netsquid.examples.simple_link.EGProtocol.res_ok`</span>
<span class="sd">            The response object indicating we successfully made the requested qubits.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">create_id</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;create_id&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_id</span> <span class="o">=</span> <span class="n">create_id</span>
        <span class="n">curpairs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sub_proto</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subprotocols</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mh_name</span><span class="p">]</span>
        <span class="n">wait_trigger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_signal</span><span class="p">(</span><span class="n">sub_proto</span><span class="p">,</span> <span class="n">sub_proto</span><span class="o">.</span><span class="n">trigger_label</span><span class="p">)</span>
        <span class="n">wait_answer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_signal</span><span class="p">(</span><span class="n">sub_proto</span><span class="p">,</span> <span class="n">sub_proto</span><span class="o">.</span><span class="n">answer_label</span><span class="p">)</span>
        <span class="c1"># Start the main loop</span>
        <span class="k">while</span> <span class="n">curpairs</span> <span class="o">&lt;</span> <span class="n">number</span><span class="p">:</span>
            <span class="n">evexpr</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">wait_trigger</span> <span class="o">|</span> <span class="n">wait_answer</span>
            <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">evexpr</span><span class="o">.</span><span class="n">triggered_events</span><span class="p">:</span>
                <span class="n">qpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">curpairs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">qpos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_ok</span><span class="p">(</span><span class="n">purpose_id</span><span class="p">,</span> <span class="n">create_id</span><span class="p">,</span> <span class="n">qpos</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">send_response</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
                    <span class="n">curpairs</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_handle_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">curpairs</span><span class="p">):</span>
        <span class="c1"># Communicate with the physical layer on trigger and answers signals.</span>
        <span class="n">sub_proto</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subprotocols</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mh_name</span><span class="p">]</span>
        <span class="n">label</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">sub_proto</span><span class="o">.</span><span class="n">get_signal_by_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">receiver</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="n">sub_proto</span><span class="o">.</span><span class="n">trigger_label</span><span class="p">:</span>
            <span class="n">sub_proto</span><span class="o">.</span><span class="n">do_task</span><span class="p">(</span><span class="n">qpos</span><span class="o">=</span><span class="n">curpairs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">label</span> <span class="o">==</span> <span class="n">sub_proto</span><span class="o">.</span><span class="n">answer_label</span><span class="p">:</span>
            <span class="n">outcome</span><span class="p">,</span> <span class="n">qpos</span> <span class="o">=</span> <span class="n">value</span>
            <span class="c1"># outcome of 1 is |01&gt;+|10&gt;, 2 is |01&gt;-|10&gt;.</span>
            <span class="c1"># Other outcomes are non-entangled states.</span>
            <span class="k">if</span> <span class="n">outcome</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">outcome</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">qpos</span>
        <span class="k">return</span> <span class="kc">None</span>
</pre></div>
</div>
<p>We have skipped over the heralded connection, so we will address it now.
The connection contains a detector in order to measure the incoming photons.
In this example we have the detector in the middle of the connection.</p>
<a class="reference internal image-reference" href="../_images/aafig-acfb1e06d944ba845256afa3260bb5e5d2e83560.svg"><img alt="../_images/aafig-acfb1e06d944ba845256afa3260bb5e5d2e83560.svg" class="align-center" height="230.0" src="../_images/aafig-acfb1e06d944ba845256afa3260bb5e5d2e83560.svg" width="1266.0" /></a>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HeraldedConnection</span><span class="p">(</span><span class="n">Connection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A connection that takes in two qubits, and returns a message</span>
<span class="sd">    how they were measured at a detector.</span>

<span class="sd">    Either no clicks, a single click or double click, or an error</span>
<span class="sd">    when the qubits didn&#39;t arrive within the time window.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        The name of this connection</span>
<span class="sd">    length_to_a : float</span>
<span class="sd">        The length in km between the detector and side A. We assume a speed of 200000 km/s</span>
<span class="sd">    length_to_b : float</span>
<span class="sd">        The length in km between the detector and side B. We assume a speed of 200000 km/s</span>
<span class="sd">    time_window : float, optional</span>
<span class="sd">        The interval where qubits are still able to be measured correctly.</span>
<span class="sd">        Must be positive. Default is 0.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">length_to_a</span><span class="p">,</span> <span class="n">length_to_b</span><span class="p">,</span> <span class="n">time_window</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">delay_a</span> <span class="o">=</span> <span class="n">length_to_a</span> <span class="o">/</span> <span class="mi">200000</span> <span class="o">*</span> <span class="mf">1e9</span>
        <span class="n">delay_b</span> <span class="o">=</span> <span class="n">length_to_b</span> <span class="o">/</span> <span class="mi">200000</span> <span class="o">*</span> <span class="mf">1e9</span>
        <span class="n">channel_a</span> <span class="o">=</span> <span class="n">ClassicalChannel</span><span class="p">(</span><span class="s2">&quot;ChannelA&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="n">delay_a</span><span class="p">)</span>
        <span class="n">channel_b</span> <span class="o">=</span> <span class="n">ClassicalChannel</span><span class="p">(</span><span class="s2">&quot;ChannelB&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="n">delay_b</span><span class="p">)</span>
        <span class="n">qchannel_a</span> <span class="o">=</span> <span class="n">QuantumChannel</span><span class="p">(</span><span class="s2">&quot;QChannelA&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="n">delay_a</span><span class="p">)</span>
        <span class="n">qchannel_b</span> <span class="o">=</span> <span class="n">QuantumChannel</span><span class="p">(</span><span class="s2">&quot;QChannelB&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="n">delay_b</span><span class="p">)</span>
        <span class="c1"># Add all channels as subcomponents</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">channel_a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">channel_b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">qchannel_a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">qchannel_b</span><span class="p">)</span>
        <span class="c1"># Add midpoint detector</span>
        <span class="n">detector</span> <span class="o">=</span> <span class="n">BSMDetector</span><span class="p">(</span><span class="s2">&quot;Midpoint&quot;</span><span class="p">,</span> <span class="n">system_delay</span><span class="o">=</span><span class="n">time_window</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">detector</span><span class="p">)</span>
        <span class="c1"># Connect the ports</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">forward_input</span><span class="p">(</span><span class="n">qchannel_a</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;send&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">forward_input</span><span class="p">(</span><span class="n">qchannel_b</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;send&#39;</span><span class="p">])</span>
        <span class="n">qchannel_a</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;recv&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">detector</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;qin0&#39;</span><span class="p">])</span>
        <span class="n">qchannel_b</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;recv&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">detector</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;qin1&#39;</span><span class="p">])</span>
        <span class="n">channel_a</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;send&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">detector</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;cout0&#39;</span><span class="p">])</span>
        <span class="n">channel_b</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;send&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">detector</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;cout1&#39;</span><span class="p">])</span>
        <span class="n">channel_a</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;recv&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">forward_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
        <span class="n">channel_b</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;recv&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">forward_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The main part of the heralded connection is the BSMDetector, so in the code shown below we will address it.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BSMDetector</span><span class="p">(</span><span class="n">QuantumDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A component that performs Bell basis measurements.</span>

<span class="sd">    Measure two incoming qubits in the Bell basis if they</span>
<span class="sd">    arrive within the specified measurement delay.</span>
<span class="sd">    Only informs the connections that send a qubit of the measurement result.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">system_delay</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">dead_time</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">models</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">output_meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">error_on_fail</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">num_input_ports</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_output_ports</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                         <span class="n">meas_operators</span><span class="o">=</span><span class="n">create_meas_ops</span><span class="p">(),</span>
                         <span class="n">system_delay</span><span class="o">=</span><span class="n">system_delay</span><span class="p">,</span> <span class="n">dead_time</span><span class="o">=</span><span class="n">dead_time</span><span class="p">,</span>
                         <span class="n">models</span><span class="o">=</span><span class="n">models</span><span class="p">,</span> <span class="n">output_meta</span><span class="o">=</span><span class="n">output_meta</span><span class="p">,</span>
                         <span class="n">error_on_fail</span><span class="o">=</span><span class="n">error_on_fail</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="n">properties</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sender_ids</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">preprocess_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Preprocess and capture the qubit metadata</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">preprocess_inputs</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">port_name</span><span class="p">,</span> <span class="n">qubit_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qubits_per_port</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qubit_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sender_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">port_name</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">inform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port_outcomes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inform the MHP of the measurement result.</span>

<span class="sd">        We only send a result to the node that send a qubit.</span>
<span class="sd">        If the result is empty we change the result and header.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        port_outcomes : dict</span>
<span class="sd">            A dictionary with the port names as keys</span>
<span class="sd">            and the post-processed measurement outcomes as values</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">port_name</span><span class="p">,</span> <span class="n">outcomes</span> <span class="ow">in</span> <span class="n">port_outcomes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outcomes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">outcomes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;TIMEOUT&#39;</span><span class="p">]</span>
                <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;error&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;photonoutcome&#39;</span>
            <span class="c1"># Extract the ids from the port names (cout...)</span>
            <span class="k">if</span> <span class="n">port_name</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sender_ids</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">Message</span><span class="p">(</span><span class="n">outcomes</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span><span class="o">.</span><span class="n">tx_output</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clear sender ids after the measurement has finished.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sender_ids</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</pre></div>
</div>
<p>Together these parts allow for robust entanglement generation.
We still need to setup the protocols.
A mockup Network layer will send the request to the link layer at Alice.
By making the EGP a subprotocol of the Network layer it will automatically stop when
the Network layer has no more requests.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NetworkProtocol</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Send requests to an EG service protocol.</span>

<span class="sd">    Will automatically stop the services and their sub-protocols</span>
<span class="sd">    when the requests are finished.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name to identify this protocol.</span>
<span class="sd">    entangle_protocol : :class:`~netsquid.examples.simple_link.EGService`</span>
<span class="sd">        The service that will get the requests from this network.</span>
<span class="sd">    remote_entangle_protocol : :class:`~netsquid.examples.simple_link.EGService`</span>
<span class="sd">       The service that will create the pairs together with the entangle_protocol.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">entangle_protocol</span><span class="p">,</span> <span class="n">remote_entangle_protocol</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subprotocol</span><span class="p">(</span><span class="n">entangle_protocol</span><span class="p">,</span> <span class="s2">&quot;EGP_Alice&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subprotocol</span><span class="p">(</span><span class="n">remote_entangle_protocol</span><span class="p">,</span> <span class="s2">&quot;EGP_Bob&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Start the protocols and put requests to Alice.&quot;&quot;&quot;</span>
        <span class="n">proto</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subprotocols</span><span class="p">[</span><span class="s1">&#39;EGP_Alice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subprotocols</span><span class="p">[</span><span class="s1">&#39;EGP_Bob&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="c1"># Start with a single request</span>
        <span class="n">req_1</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">req_create</span><span class="p">(</span><span class="n">purpose_id</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">create_id</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">req_1</span><span class="p">)[</span><span class="s1">&#39;create_id&#39;</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Waiting for responses with create_id </span><span class="si">{</span><span class="n">create_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_results</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">req_1</span><span class="p">)</span>
        <span class="n">req_2</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">req_create</span><span class="p">(</span><span class="n">purpose_id</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">create_id</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">req_2</span><span class="p">)[</span><span class="s1">&#39;create_id&#39;</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Waiting for responses with create_id </span><span class="si">{</span><span class="n">create_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">req_3</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">req_create</span><span class="p">(</span><span class="n">purpose_id</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">create_id</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">req_3</span><span class="p">)[</span><span class="s1">&#39;create_id&#39;</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Waiting for responses with create_id </span><span class="si">{</span><span class="n">create_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_results</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">req_2</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_results</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">req_3</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished all network requests&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">show_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Show the qubits which are entangled as a result of the request.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        proto : :class:`~netsquid.examples.simple_link.EGProtocol`</span>
<span class="sd">            The entanglement generation service</span>
<span class="sd">        request : :class:`~netsquid.examples.simple_link.EGService.req_create`</span>
<span class="sd">            The request</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        :class:`~pydynaa.core.EventExpression`</span>
<span class="sd">            The eventexpressions required to wait for the response signals.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ok_signal</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">res_ok</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Qubits between Alice and Bob with purpose_id </span><span class="si">{</span><span class="n">request</span><span class="o">.</span><span class="n">purpose_id</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_signal</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">ok_signal</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">get_signal_result</span><span class="p">(</span><span class="n">ok_signal</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">qubits</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">logical_qubit_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">qstate</span><span class="o">.</span><span class="n">qubits</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">()</span><span class="si">:</span><span class="s2">8.0f</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">qubits</span><span class="si">}</span><span class="s2"> with create_id </span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">create_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally we put the protocols on the nodes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setup_protocol</span><span class="p">(</span><span class="n">network</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Configure the protocols.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    network : :class:`~netsquid.nodes.network.Network`</span>
<span class="sd">        The network to configure the protocols on. Should consist of two nodes</span>
<span class="sd">        called Alice and Bob.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~netsquid.protocols.protocol.Protocol`</span>
<span class="sd">        A protocol describing the complete simple link setup.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">nodes</span>
    <span class="c1"># Setup Alice</span>
    <span class="n">q_ports</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">get_connected_ports</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;quantum&#39;</span><span class="p">)</span>
    <span class="n">c_ports</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">get_connected_ports</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;classical&#39;</span><span class="p">)</span>
    <span class="n">alice_mhp</span> <span class="o">=</span> <span class="n">MidpointHeraldingProtocol</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;Alice&#39;</span><span class="p">],</span> <span class="mi">500</span><span class="p">,</span> <span class="n">q_ports</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">alice_egp</span> <span class="o">=</span> <span class="n">EGProtocol</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;Alice&#39;</span><span class="p">],</span> <span class="n">c_ports</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">alice_egp</span><span class="o">.</span><span class="n">add_phys_layer</span><span class="p">(</span><span class="n">alice_mhp</span><span class="p">)</span>
    <span class="c1"># Setup Bob</span>
    <span class="n">bob_mhp</span> <span class="o">=</span> <span class="n">MidpointHeraldingProtocol</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;Bob&#39;</span><span class="p">],</span> <span class="mi">470</span><span class="p">,</span> <span class="n">q_ports</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">bob_egp</span> <span class="o">=</span> <span class="n">EGProtocol</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;Bob&#39;</span><span class="p">],</span> <span class="n">c_ports</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">bob_egp</span><span class="o">.</span><span class="n">add_phys_layer</span><span class="p">(</span><span class="n">bob_mhp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">NetworkProtocol</span><span class="p">(</span><span class="s2">&quot;SimpleLinkProtocol&quot;</span><span class="p">,</span> <span class="n">alice_egp</span><span class="p">,</span> <span class="n">bob_egp</span><span class="p">)</span>
</pre></div>
</div>
<p>We can run our simulation by calling the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_simulation</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run the example simulation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ns</span><span class="o">.</span><span class="n">sim_reset</span><span class="p">()</span>
    <span class="n">ns</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  <span class="c1"># Set the seed so we get the same outcome</span>
    <span class="n">ns</span><span class="o">.</span><span class="n">set_qstate_formalism</span><span class="p">(</span><span class="n">QFormalism</span><span class="o">.</span><span class="n">DM</span><span class="p">)</span>
    <span class="n">network</span> <span class="o">=</span> <span class="n">create_example_network</span><span class="p">()</span>
    <span class="n">protocol</span> <span class="o">=</span> <span class="n">setup_protocol</span><span class="p">(</span><span class="n">network</span><span class="p">)</span>
    <span class="n">protocol</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">ns</span><span class="o">.</span><span class="n">sim_run</span><span class="p">()</span>
</pre></div>
</div>
<p>Which will give us the following output:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.examples.simple_link</span> <span class="kn">import</span> <span class="n">run_simulation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">run_simulation</span><span class="p">()</span>
<span class="go">Waiting for responses with create_id 1</span>
<span class="go">Qubits between Alice and Bob with purpose_id 4:</span>
<span class="go">   2078020: [Qubit(&#39;QS#790-0&#39;), Qubit(&#39;QS#791-0&#39;)] with create_id 1</span>
<span class="go">   7506520: [Qubit(&#39;QS#2874-0&#39;), Qubit(&#39;QS#2875-0&#39;)] with create_id 1</span>
<span class="go">  18363520: [Qubit(&#39;QS#7042-0&#39;), Qubit(&#39;QS#7043-0&#39;)] with create_id 1</span>
<span class="go">Waiting for responses with create_id 2</span>
<span class="go">Waiting for responses with create_id 3</span>
<span class="go">Qubits between Alice and Bob with purpose_id 6:</span>
<span class="go">  20400020: [Qubit(&#39;QS#7820-0&#39;), Qubit(&#39;QS#7822-0&#39;)] with create_id 2</span>
<span class="go">  22437010: [Qubit(&#39;QS#8604-0&#39;), Qubit(&#39;QS#8602-0&#39;)] with create_id 2</span>
<span class="go">Qubits between Alice and Bob with purpose_id 4:</span>
<span class="go">  25828520: [Qubit(&#39;QS#9904-0&#39;), Qubit(&#39;QS#9906-0&#39;)] with create_id 3</span>
<span class="go">Finished all network requests</span>
</pre></div>
</div>
<p>We could give this Protocol much more functionality to better represent the design of the paper.
For example, in the request one could specify a minimum fidelity or maximum generation time.
To reach a minimum fidelity one requires some kind of entanglement distillation.
Changing the bright state population of the qubit-photon pair can change the success probability, and
thus change the generation time.
Using entanglement swapping it is possible to create entanglement between nodes which aren’t directly connected.
This process builds upon the robust entanglement generation scheme shown in this example.</p>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">netsquid.examples.simple_link.</span></span><span class="sig-name descname"><span class="pre">EGService</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceProtocol" title="netsquid.protocols.serviceprotocol.ServiceProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">ServiceProtocol</span></code></a></p>
<p>Abstract interface for an Entanglement Generation Service.</p>
<p>Defines the available request and response types, and implements the queue mechanism.
Every request will be assigned a unique create_id, which is
returned when a request is put to this service.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<a class="reference internal" href="../api_nodes/netsquid.nodes.node.html#netsquid.nodes.node.Node" title="netsquid.nodes.node.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a>) – The node this protocol runs on.</p></li>
<li><p><strong>name</strong> (<em>str, optional</em>) – The name of this protocol. Default EGService.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">req_create</span></span></dt>
<dd><p>A request to create entanglement with a remote node.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>namedtuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">res_ok</span></span></dt>
<dd><p>A response to indicate a create request has finished.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>namedtuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">req_create</span></span></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">LinkLayerCreate</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">res_ok</span></span></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">LinkLayerOk</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">handle_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">request</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Schedule the request on the queue.</p>
<p>Schedule the request in a queue and
signal to <code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code>
new items have been put into the queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>request</strong> – The object representing the request.</p></li>
<li><p><strong>identifier</strong> (<em>str</em>) – The identifier for this request.</p></li>
<li><p><strong>start_time</strong> (<em>float, optional</em>) – The time at which the request can be executed. Default current simulation time.</p></li>
<li><p><strong>kwargs</strong> (<em>dict, optional</em>) – Additional arguments which can be set by the service.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The dictionary with additional arguments.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method is called after
<a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceProtocol.put" title="netsquid.protocols.serviceprotocol.ServiceProtocol.put"><code class="xref py py-meth docutils literal notranslate"><span class="pre">put()</span></code></a> which
does the type checking etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Wait for a new request signal, then run the requests one by one.</p>
<p>Assumes request handlers are generators and not functions.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">purpose_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">create_id</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Implement the entanglement generation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>purpose_id</strong> (<em>int</em>) – Integer representing which purpose this entanglement is for.
Used to communicate to the higher layers.</p></li>
<li><p><strong>number</strong> (<em>int</em>) – Number of qubit pairs to make.</p></li>
<li><p><strong>create_id</strong> (<em>int</em>) – The unique identifier provided by the service.</p></li>
<li><p><strong>kwargs</strong> (<em>dict, optional</em>) – Drain for any optional parameters.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Adds a signal type to the protocol that it can signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Enum</span></code>) – The label to use to reference the signal.</p></li>
<li><p><strong>event_type</strong> (<a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> or None, optional) – Event type to use for the signal type. If None, an event type is created unless
the <code class="docutils literal notranslate"><span class="pre">label</span></code> is an <code class="xref py py-obj docutils literal notranslate"><span class="pre">Enum</span></code> with a <a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> as value,
in which case this is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event type of the added signal type.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_subprotocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subprotocol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Add a sub-protocol to this protocol.</p>
<p>Neither protocol should be running and both protocols must be able to
signal to each other (see <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subprotocol</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol to add as a sub-protocol.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Reference name (key) to use for sub-protocol. If None, the name
of the sub-protocol is used.
If a sub-protocol using the same <code class="docutils literal notranslate"><span class="pre">name</span></code> already
exists it is overridden.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstraintError" title="netsquid.util.constrainedmap.ConstraintError"><strong>ConstraintError</strong></a> – If either of the protocols is running, or if the protocols cannot signal
    to each other in both directions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_mempos_busy_toggle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">QuantumMemory</span> <span class="pre">qmemory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list</span> <span class="pre">positions</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits for one of the memory positions
on a quantum memory to change the value of the busy state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qmemory</strong> (<a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>) – The quantum memory to wait for.</p></li>
<li><p><strong>positions</strong> (<em>list of int</em>) – The memory positions to wait for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for one of the memory positions to toggle its busy flag.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – The <code class="docutils literal notranslate"><span class="pre">qmemory</span></code> parameter is not of type <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>.</p></li>
<li><p><strong>IndexError</strong> – If the positions given don’t match a valid <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition" title="netsquid.components.qmemory.MemoryPosition"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryPosition</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Memory positions can enable if they schedule events when the busy flag is toggled by
setting <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition.busy_event_enabled" title="netsquid.components.qmemory.MemoryPosition.busy_event_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">busy_event_enabled</span></code></a>.
Because by default <cite>busy_event_enabled</cite> is False, we enable it here.
It is disabled when <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.reset" title="netsquid.components.qmemory.QuantumMemory.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> is called, otherwise it must be manually disabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_mempos_in_use_toggle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">QuantumMemory</span> <span class="pre">qmemory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list</span> <span class="pre">positions</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Wait for when one of the positions of a quantum memory toggle their in_use flag.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qmemory</strong> (<a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>) – The quantum memory to wait for.</p></li>
<li><p><strong>positions</strong> (<em>list of int</em>) – The positions to wait for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for one of the memory positions to toggle its in_use flag.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – qmemory is not of type <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>.</p></li>
<li><p><strong>IndexError</strong> – If the positions given don’t match a valid <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition" title="netsquid.components.qmemory.MemoryPosition"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryPosition</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Memory positions can enable if they schedule events when the in_use flag is toggled by
setting <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition.in_use_event_enabled" title="netsquid.components.qmemory.MemoryPosition.in_use_event_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">in_use_event_enabled</span></code></a>.
Because by default <cite>in_use_event_enabled</cite> is False, we enable it here.
It is disabled when <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.reset" title="netsquid.components.qmemory.QuantumMemory.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> is called, otherwise it must be manually disabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_port_input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits until the specified port receives a message input.</p>
<p>The event expression will also trigger if the message is passed through the port.
The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>port</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Port</span></code>) – Port to listen to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>EventExpression that the protocol yields on.
The message of the port can be fetched with <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port.rx_input" title="netsquid.components.component.Port.rx_input"><code class="xref py py-func docutils literal notranslate"><span class="pre">rx_input()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyProtocol</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">protocols</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">msg_header</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span> <span class="o">=</span> <span class="n">msg_header</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">rx_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A message was input via port </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_port_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits until the specified port has a message output.</p>
<p>The event expression will also trigger if the message is passed through the port.
The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>port</strong> (<a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port" title="netsquid.components.component.Port"><code class="xref py py-class docutils literal notranslate"><span class="pre">Port</span></code></a>) – Port to listen to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression that the protocol yields on.
The message of the port can be fetched with <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port.rx_output" title="netsquid.components.component.Port.rx_output"><code class="xref py py-func docutils literal notranslate"><span class="pre">rx_output()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyProtocol</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">protocols</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">msg_header</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span> <span class="o">=</span> <span class="n">msg_header</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">rx_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A message was output via port </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_program</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">await_done=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">await_fail=False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits for a program on a quantum processor to stop running.</p>
<p>The expression must be <em>yielded</em> on to come into effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>processor</strong> (<a class="reference internal" href="../api_components/netsquid.components.qprocessor.html#netsquid.components.qprocessor.QuantumProcessor" title="netsquid.components.qprocessor.QuantumProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumProcessor</span></code></a>) – The processor that runs the program</p></li>
<li><p><strong>await_done</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, default True) – Whether to wait for the program to successfully finish.</p></li>
<li><p><strong>await_fail</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, default False) – Whether to wait for the program to fail.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for the quantum program to stop.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both <cite>await_done</cite> and <cite>await_fail</cite> are set to True, it will wait until the program either finishes or fails.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Protocol</span> <span class="pre">sender</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_label=Signals.FINISHED</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits until a sender has sent a specified signal.</p>
<p>The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sender</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol that will send the signal.</p></li>
<li><p><strong>signal_label</strong> (<em>int or str or Enum, optional</em>) – The signal label to wait for.
Default is <code class="xref py py-attr docutils literal notranslate"><span class="pre">FINISHED</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>EventExpression that the protocol yields on.
The signal result can be retrieved from the protocol with <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.get_signal_result" title="netsquid.protocols.protocol.Protocol.get_signal_result"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_signal_result()</span></code></a>
or with <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.get_signal_by_event" title="netsquid.protocols.protocol.Protocol.get_signal_by_event"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_signal_by_event()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_timer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double</span> <span class="pre">duration=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double</span> <span class="pre">end_time=0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Schedule an event to trigger at a specified time and create an event expression to wait for it.</p>
<p>The expression must be <em>yielded</em> on to come into effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>duration</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>, optional) – Amount of time (in Nanoseconds) the protocol should sleep</p></li>
<li><p><strong>end_time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>, optional) – Ignored if duration bigger than 0, time instance at which the event triggers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression that the protocol yields on</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">can_signal_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Whether this protocol can send a signal to another protocol.</p>
<p>A local protocol can only signal to another local protocol if they have
one or more nodes in common.
A local protocol can always signal to a standard (non-local) protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>protocol</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol queried as to whether this protocol can send a signal to.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether this protocol can signal to the other protocol.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">check_assigned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Helper method to check if inputs properly assigned.</p>
<p>Checks that inputs are not None and that they have correct type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<em>object or list of objects</em>) – Inputs to check.</p></li>
<li><p><strong>input_type</strong> (<em>type or None, optional</em>) – Type that inputs should be. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, type is not
checked.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if all <code class="docutils literal notranslate"><span class="pre">inputs</span></code> specified, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Return the name of a class or object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>obj</strong> – Any object or class.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The name representing the class or object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_signal_by_event</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">receiver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get the signal result based on the event that triggered it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>event</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code>) – The event that triggered the signalling</p></li>
<li><p><strong>receiver</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> or None, optional) – The protocol wanting to receive the signal value. If not None,
will check if signalling is possible using
<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple with the label and result of the signal that was signalled with the given event.
None if the event is no longer associated with a signal result.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.SignalResult" title="netsquid.protocols.protocol.SignalResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SignalResult</span></code></a> or None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>To avoid storing all signal results and their events, only the most recent signal results are stored.
This means if a signal is sent all previous signal results are deleted, and the previous events are
no longer associated with a signal result.
Signals in the same time instance can co-exist.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_signal_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">receiver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get the result of the last signal sent with this label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Signals" title="netsquid.protocols.protocol.Signals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signals</span></code></a>) – Label that the signal was broadcasted with.</p></li>
<li><p><strong>receiver</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> or None, optional) – The protocol wanting to receive the signal value. If not None,
will check if signalling is possible to this protocol using
<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value that was sent with the signal.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RunTimeError</strong> – When attempting to get the result of a local signal from a nonlocal environment</p></li>
<li><p><strong>TypeError</strong> – When attempting to get the result of something else than a protocol</p></li>
<li><p><strong>KeyError</strong> – When the signal label is unknown i.e. hasn’t been added yet with
    <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.add_signal" title="netsquid.protocols.protocol.Protocol.add_signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_signal()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_connected</span></span></dt>
<dd><p>Whether protocol has been properly configured and can be started.</p>
<p>Requires that all specified nodes have been set (are not None).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if protocol is fully and correctly connected, otherwise False.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_running</span></span></dt>
<dd><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code> True if protocol is running, otherwise False.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_nodes</span></span></dt>
<dd><p>maximum number of nodes this local protocol can run on.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">name</span></span></dt>
<dd><p>Name of protocol for identification and display purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">node</span></span></dt>
<dd><p>single node this protocol is running on.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_nodes/netsquid.nodes.node.html#netsquid.nodes.node.Node" title="netsquid.nodes.node.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nodes</span></span></dt>
<dd><p>nodes local to this protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">put</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">request</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Put a request to the service.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>request</strong> – A request instance.</p></li>
<li><p><strong>name</strong> (<em>str or None, optional</em>) – The identifier for the handler.
If None (default), uses the
<a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceProtocol.get_name" title="netsquid.protocols.serviceprotocol.ServiceProtocol.get_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_name()</span></code></a> of the request.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value returned by <a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceProtocol.handle_request" title="netsquid.protocols.serviceprotocol.ServiceProtocol.handle_request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle_request()</span></code></a>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceError" title="netsquid.protocols.serviceprotocol.ServiceError"><strong>ServiceError</strong></a> – If the name doesn’t match to the request type.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">register_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Register a request for this service.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>req_type</strong> – The class representing the request.</p></li>
<li><p><strong>handler</strong> (<em>callable</em>) – The function used to respond to the request.</p></li>
<li><p><strong>name</strong> (<em>str or None, optional</em>) – An identifier for this request.
If None (default) uses
<a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceProtocol.get_name" title="netsquid.protocols.serviceprotocol.ServiceProtocol.get_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_name()</span></code></a> of the request.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceError" title="netsquid.protocols.serviceprotocol.ServiceError"><strong>ServiceError</strong></a> – If the name is already registered.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">register_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">res_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Register a response for this service.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>res_type</strong> – The class representing the response.</p></li>
<li><p><strong>name</strong> (<em>str or None, optional</em>) – The identifier to use when sending a signal.
If None (default) uses
<a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceProtocol.get_name" title="netsquid.protocols.serviceprotocol.ServiceProtocol.get_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_name()</span></code></a> of the request.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceError" title="netsquid.protocols.serviceprotocol.ServiceError"><strong>ServiceError</strong></a> – If the name has already been registered.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Removes the entity from the simulation.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">request_handlers</span></span></dt>
<dd><p>map of handler callbacks of registered requests.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">request_types</span></span></dt>
<dd><p>map of the available service requests.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Stops and starts the protocol leaving it in a clean state.</p>
<p>Will stop the protocol with the specified status,
or Status.FAIL if not specified. Leaves the protocol in the Protocol.IDLE state.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">response_types</span></span></dt>
<dd><p>map of the available service responses.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">send_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Send a response via a signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>response</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">collections.namedtuple</span></code> or object) – The response instance.</p></li>
<li><p><strong>name</strong> (<em>str or None, optional</em>) – The identifier used for this response.
Default <a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceProtocol.get_name" title="netsquid.protocols.serviceprotocol.ServiceProtocol.get_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_name()</span></code></a> of the request.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceError" title="netsquid.protocols.serviceprotocol.ServiceError"><strong>ServiceError</strong></a> – If the name doesn’t match to the request type.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">send_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Send a signal to other protocols to indicate a status change or announce a result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal_label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Signals" title="netsquid.protocols.protocol.Signals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signals</span></code></a>) – Label, key or status that is broadcasted to the world. Other protocols can wait for this signal.</p></li>
<li><p><strong>result</strong> (<em>Any or None, optional</em>) – Result or intermediate results of the protocol that you want to broadcast with this signal</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <code class="docutils literal notranslate"><span class="pre">signal_label</span></code> does not correspond to a signal of this protocol.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When a protocol is finished (i.e. its run() returns),
the protocol sends a signal with label <code class="xref py py-attr docutils literal notranslate"><span class="pre">FINISHED</span></code>.
The result is set to the return value.</p>
<p>When a signal is sent with a label that was sent earlier, the result of the first signal is overwritten.
Signal results sent in the same time instance can be individually retrieved using the triggering event.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">signals</span></span></dt>
<dd><p>signals this protocol can send (<a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> indexed by label).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">specify_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Specify a node required by this protocol.</p>
<p>The protocol cannot start until all specified nodes are set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Key to index the node with.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If specifying this node will exceed the maximum number of nodes
    <a class="reference internal" href="../api_protocols/netsquid.protocols.nodeprotocols.html#netsquid.protocols.nodeprotocols.LocalProtocol.max_nodes" title="netsquid.protocols.nodeprotocols.LocalProtocol.max_nodes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_nodes</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Start the protocol.</p>
<p>Will register the protocol and run up to the first yield.
Will not start any sub-protocols. Sub-protocols are started in the run().
When run() is not overridden it will start all sub-protocol in parallel automatically.
If it is overridden the sub-protocols should be started manually in the method;
this to give control on when sub-protocols should run in parallel or in sequence</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>This protocol is returned for convenience.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a></p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError</strong> – If the protocol has not been properly connected.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">start_subprotocols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Start all the sub-protocols in parallel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Stop the protocol as well as any running sub-protocols.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">subprotocols</span></span></dt>
<dd><p>sub-protocols of this protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">uid</span></span></dt>
<dd><p>returns a unique identifier for this entity in the simulation.</p>
<p>Each entity has a unique identifier in the simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">netsquid.examples.simple_link.</span></span><span class="sig-name descname"><span class="pre">EGProtocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_port_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">EGService</span></code></p>
<p>Implement an Entanglement Generation service.</p>
<p>Upon a <em>LinkLayerCreate</em> request generates pairs of entangled qubits, of which one
is locally stored and the other is stored at the remote node.
Requests are fulfulled in FIFO order, and upon completion
a response signal is sent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<a class="reference internal" href="../api_nodes/netsquid.nodes.node.html#netsquid.nodes.node.Node" title="netsquid.nodes.node.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a>) – The node this protocol runs on.</p></li>
<li><p><strong>c_port_name</strong> (<em>str</em>) – The name of the port which is connected to the remote node.</p></li>
<li><p><strong>name</strong> (<em>str, optional</em>) – The name of this protocol. Default EGProtocol.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_phys_layer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mh_protocol</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Add a physical layer protocol as a subprotocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mh_protocol</strong> – The protocol which implements a physical layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">handle_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">request</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Synchronize the request with the other service and schedule it on the queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>request</strong> – The object representing the request.</p></li>
<li><p><strong>identifier</strong> (<em>str</em>) – The identifier for this request.</p></li>
<li><p><strong>start_time</strong> (<em>float, optional</em>) – The time at which the request can be executed. Default current time.</p></li>
<li><p><strong>kwargs</strong> (<em>dict, optional</em>) – Additional arguments not part of the original request.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The dictionary with additional arguments.
For the create request this is the unique create id.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Make sure we have an subprotocol before running our program.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">purpose_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Handler for create requests.</p>
<p>Create qubits together with a remote node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>purpose_id</strong> (<em>int</em>) – The number used to to tag this request for a specific purpose in a higher layer.</p></li>
<li><p><strong>number</strong> (<em>int</em>) – The number of qubits to make in this request.</p></li>
</ul>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a> – The expressions required to execute the create request.</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The response object indicating we successfully made the requested qubits.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">res_ok</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Adds a signal type to the protocol that it can signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Enum</span></code>) – The label to use to reference the signal.</p></li>
<li><p><strong>event_type</strong> (<a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> or None, optional) – Event type to use for the signal type. If None, an event type is created unless
the <code class="docutils literal notranslate"><span class="pre">label</span></code> is an <code class="xref py py-obj docutils literal notranslate"><span class="pre">Enum</span></code> with a <a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> as value,
in which case this is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event type of the added signal type.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_subprotocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subprotocol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Add a sub-protocol to this protocol.</p>
<p>Neither protocol should be running and both protocols must be able to
signal to each other (see <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subprotocol</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol to add as a sub-protocol.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Reference name (key) to use for sub-protocol. If None, the name
of the sub-protocol is used.
If a sub-protocol using the same <code class="docutils literal notranslate"><span class="pre">name</span></code> already
exists it is overridden.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstraintError" title="netsquid.util.constrainedmap.ConstraintError"><strong>ConstraintError</strong></a> – If either of the protocols is running, or if the protocols cannot signal
    to each other in both directions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_mempos_busy_toggle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">QuantumMemory</span> <span class="pre">qmemory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list</span> <span class="pre">positions</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits for one of the memory positions
on a quantum memory to change the value of the busy state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qmemory</strong> (<a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>) – The quantum memory to wait for.</p></li>
<li><p><strong>positions</strong> (<em>list of int</em>) – The memory positions to wait for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for one of the memory positions to toggle its busy flag.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – The <code class="docutils literal notranslate"><span class="pre">qmemory</span></code> parameter is not of type <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>.</p></li>
<li><p><strong>IndexError</strong> – If the positions given don’t match a valid <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition" title="netsquid.components.qmemory.MemoryPosition"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryPosition</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Memory positions can enable if they schedule events when the busy flag is toggled by
setting <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition.busy_event_enabled" title="netsquid.components.qmemory.MemoryPosition.busy_event_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">busy_event_enabled</span></code></a>.
Because by default <cite>busy_event_enabled</cite> is False, we enable it here.
It is disabled when <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.reset" title="netsquid.components.qmemory.QuantumMemory.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> is called, otherwise it must be manually disabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_mempos_in_use_toggle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">QuantumMemory</span> <span class="pre">qmemory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list</span> <span class="pre">positions</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Wait for when one of the positions of a quantum memory toggle their in_use flag.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qmemory</strong> (<a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>) – The quantum memory to wait for.</p></li>
<li><p><strong>positions</strong> (<em>list of int</em>) – The positions to wait for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for one of the memory positions to toggle its in_use flag.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – qmemory is not of type <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>.</p></li>
<li><p><strong>IndexError</strong> – If the positions given don’t match a valid <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition" title="netsquid.components.qmemory.MemoryPosition"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryPosition</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Memory positions can enable if they schedule events when the in_use flag is toggled by
setting <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition.in_use_event_enabled" title="netsquid.components.qmemory.MemoryPosition.in_use_event_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">in_use_event_enabled</span></code></a>.
Because by default <cite>in_use_event_enabled</cite> is False, we enable it here.
It is disabled when <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.reset" title="netsquid.components.qmemory.QuantumMemory.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> is called, otherwise it must be manually disabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_port_input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits until the specified port receives a message input.</p>
<p>The event expression will also trigger if the message is passed through the port.
The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>port</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Port</span></code>) – Port to listen to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>EventExpression that the protocol yields on.
The message of the port can be fetched with <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port.rx_input" title="netsquid.components.component.Port.rx_input"><code class="xref py py-func docutils literal notranslate"><span class="pre">rx_input()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyProtocol</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">protocols</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">msg_header</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span> <span class="o">=</span> <span class="n">msg_header</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">rx_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A message was input via port </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_port_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits until the specified port has a message output.</p>
<p>The event expression will also trigger if the message is passed through the port.
The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>port</strong> (<a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port" title="netsquid.components.component.Port"><code class="xref py py-class docutils literal notranslate"><span class="pre">Port</span></code></a>) – Port to listen to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression that the protocol yields on.
The message of the port can be fetched with <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port.rx_output" title="netsquid.components.component.Port.rx_output"><code class="xref py py-func docutils literal notranslate"><span class="pre">rx_output()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyProtocol</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">protocols</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">msg_header</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span> <span class="o">=</span> <span class="n">msg_header</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">rx_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A message was output via port </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_program</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">await_done=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">await_fail=False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits for a program on a quantum processor to stop running.</p>
<p>The expression must be <em>yielded</em> on to come into effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>processor</strong> (<a class="reference internal" href="../api_components/netsquid.components.qprocessor.html#netsquid.components.qprocessor.QuantumProcessor" title="netsquid.components.qprocessor.QuantumProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumProcessor</span></code></a>) – The processor that runs the program</p></li>
<li><p><strong>await_done</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, default True) – Whether to wait for the program to successfully finish.</p></li>
<li><p><strong>await_fail</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, default False) – Whether to wait for the program to fail.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for the quantum program to stop.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both <cite>await_done</cite> and <cite>await_fail</cite> are set to True, it will wait until the program either finishes or fails.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Protocol</span> <span class="pre">sender</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_label=Signals.FINISHED</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits until a sender has sent a specified signal.</p>
<p>The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sender</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol that will send the signal.</p></li>
<li><p><strong>signal_label</strong> (<em>int or str or Enum, optional</em>) – The signal label to wait for.
Default is <code class="xref py py-attr docutils literal notranslate"><span class="pre">FINISHED</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>EventExpression that the protocol yields on.
The signal result can be retrieved from the protocol with <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.get_signal_result" title="netsquid.protocols.protocol.Protocol.get_signal_result"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_signal_result()</span></code></a>
or with <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.get_signal_by_event" title="netsquid.protocols.protocol.Protocol.get_signal_by_event"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_signal_by_event()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_timer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double</span> <span class="pre">duration=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double</span> <span class="pre">end_time=0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Schedule an event to trigger at a specified time and create an event expression to wait for it.</p>
<p>The expression must be <em>yielded</em> on to come into effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>duration</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>, optional) – Amount of time (in Nanoseconds) the protocol should sleep</p></li>
<li><p><strong>end_time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>, optional) – Ignored if duration bigger than 0, time instance at which the event triggers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression that the protocol yields on</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">can_signal_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Whether this protocol can send a signal to another protocol.</p>
<p>A local protocol can only signal to another local protocol if they have
one or more nodes in common.
A local protocol can always signal to a standard (non-local) protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>protocol</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol queried as to whether this protocol can send a signal to.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether this protocol can signal to the other protocol.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">check_assigned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Helper method to check if inputs properly assigned.</p>
<p>Checks that inputs are not None and that they have correct type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<em>object or list of objects</em>) – Inputs to check.</p></li>
<li><p><strong>input_type</strong> (<em>type or None, optional</em>) – Type that inputs should be. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, type is not
checked.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if all <code class="docutils literal notranslate"><span class="pre">inputs</span></code> specified, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Return the name of a class or object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>obj</strong> – Any object or class.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The name representing the class or object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_signal_by_event</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">receiver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get the signal result based on the event that triggered it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>event</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code>) – The event that triggered the signalling</p></li>
<li><p><strong>receiver</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> or None, optional) – The protocol wanting to receive the signal value. If not None,
will check if signalling is possible using
<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple with the label and result of the signal that was signalled with the given event.
None if the event is no longer associated with a signal result.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.SignalResult" title="netsquid.protocols.protocol.SignalResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SignalResult</span></code></a> or None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>To avoid storing all signal results and their events, only the most recent signal results are stored.
This means if a signal is sent all previous signal results are deleted, and the previous events are
no longer associated with a signal result.
Signals in the same time instance can co-exist.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_signal_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">receiver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get the result of the last signal sent with this label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Signals" title="netsquid.protocols.protocol.Signals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signals</span></code></a>) – Label that the signal was broadcasted with.</p></li>
<li><p><strong>receiver</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> or None, optional) – The protocol wanting to receive the signal value. If not None,
will check if signalling is possible to this protocol using
<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value that was sent with the signal.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RunTimeError</strong> – When attempting to get the result of a local signal from a nonlocal environment</p></li>
<li><p><strong>TypeError</strong> – When attempting to get the result of something else than a protocol</p></li>
<li><p><strong>KeyError</strong> – When the signal label is unknown i.e. hasn’t been added yet with
    <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.add_signal" title="netsquid.protocols.protocol.Protocol.add_signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_signal()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_connected</span></span></dt>
<dd><p>Whether protocol has been properly configured and can be started.</p>
<p>Requires that all specified nodes have been set (are not None).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if protocol is fully and correctly connected, otherwise False.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_running</span></span></dt>
<dd><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code> True if protocol is running, otherwise False.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_nodes</span></span></dt>
<dd><p>maximum number of nodes this local protocol can run on.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">name</span></span></dt>
<dd><p>Name of protocol for identification and display purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">node</span></span></dt>
<dd><p>single node this protocol is running on.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_nodes/netsquid.nodes.node.html#netsquid.nodes.node.Node" title="netsquid.nodes.node.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nodes</span></span></dt>
<dd><p>nodes local to this protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">put</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">request</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Put a request to the service.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>request</strong> – A request instance.</p></li>
<li><p><strong>name</strong> (<em>str or None, optional</em>) – The identifier for the handler.
If None (default), uses the
<a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceProtocol.get_name" title="netsquid.protocols.serviceprotocol.ServiceProtocol.get_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_name()</span></code></a> of the request.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value returned by <a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceProtocol.handle_request" title="netsquid.protocols.serviceprotocol.ServiceProtocol.handle_request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle_request()</span></code></a>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceError" title="netsquid.protocols.serviceprotocol.ServiceError"><strong>ServiceError</strong></a> – If the name doesn’t match to the request type.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">register_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Register a request for this service.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>req_type</strong> – The class representing the request.</p></li>
<li><p><strong>handler</strong> (<em>callable</em>) – The function used to respond to the request.</p></li>
<li><p><strong>name</strong> (<em>str or None, optional</em>) – An identifier for this request.
If None (default) uses
<a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceProtocol.get_name" title="netsquid.protocols.serviceprotocol.ServiceProtocol.get_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_name()</span></code></a> of the request.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceError" title="netsquid.protocols.serviceprotocol.ServiceError"><strong>ServiceError</strong></a> – If the name is already registered.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">register_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">res_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Register a response for this service.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>res_type</strong> – The class representing the response.</p></li>
<li><p><strong>name</strong> (<em>str or None, optional</em>) – The identifier to use when sending a signal.
If None (default) uses
<a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceProtocol.get_name" title="netsquid.protocols.serviceprotocol.ServiceProtocol.get_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_name()</span></code></a> of the request.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceError" title="netsquid.protocols.serviceprotocol.ServiceError"><strong>ServiceError</strong></a> – If the name has already been registered.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Removes the entity from the simulation.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">req_create</span></span></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">LinkLayerCreate</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">request_handlers</span></span></dt>
<dd><p>map of handler callbacks of registered requests.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">request_types</span></span></dt>
<dd><p>map of the available service requests.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">res_ok</span></span></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">LinkLayerOk</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Stops and starts the protocol leaving it in a clean state.</p>
<p>Will stop the protocol with the specified status,
or Status.FAIL if not specified. Leaves the protocol in the Protocol.IDLE state.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">response_types</span></span></dt>
<dd><p>map of the available service responses.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">send_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">response</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Send a response via a signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>response</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">collections.namedtuple</span></code> or object) – The response instance.</p></li>
<li><p><strong>name</strong> (<em>str or None, optional</em>) – The identifier used for this response.
Default <a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceProtocol.get_name" title="netsquid.protocols.serviceprotocol.ServiceProtocol.get_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_name()</span></code></a> of the request.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html#netsquid.protocols.serviceprotocol.ServiceError" title="netsquid.protocols.serviceprotocol.ServiceError"><strong>ServiceError</strong></a> – If the name doesn’t match to the request type.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">send_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Send a signal to other protocols to indicate a status change or announce a result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal_label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Signals" title="netsquid.protocols.protocol.Signals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signals</span></code></a>) – Label, key or status that is broadcasted to the world. Other protocols can wait for this signal.</p></li>
<li><p><strong>result</strong> (<em>Any or None, optional</em>) – Result or intermediate results of the protocol that you want to broadcast with this signal</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <code class="docutils literal notranslate"><span class="pre">signal_label</span></code> does not correspond to a signal of this protocol.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When a protocol is finished (i.e. its run() returns),
the protocol sends a signal with label <code class="xref py py-attr docutils literal notranslate"><span class="pre">FINISHED</span></code>.
The result is set to the return value.</p>
<p>When a signal is sent with a label that was sent earlier, the result of the first signal is overwritten.
Signal results sent in the same time instance can be individually retrieved using the triggering event.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">signals</span></span></dt>
<dd><p>signals this protocol can send (<a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> indexed by label).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">specify_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Specify a node required by this protocol.</p>
<p>The protocol cannot start until all specified nodes are set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Key to index the node with.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If specifying this node will exceed the maximum number of nodes
    <a class="reference internal" href="../api_protocols/netsquid.protocols.nodeprotocols.html#netsquid.protocols.nodeprotocols.LocalProtocol.max_nodes" title="netsquid.protocols.nodeprotocols.LocalProtocol.max_nodes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_nodes</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Start the protocol.</p>
<p>Will register the protocol and run up to the first yield.
Will not start any sub-protocols. Sub-protocols are started in the run().
When run() is not overridden it will start all sub-protocol in parallel automatically.
If it is overridden the sub-protocols should be started manually in the method;
this to give control on when sub-protocols should run in parallel or in sequence</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>This protocol is returned for convenience.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a></p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError</strong> – If the protocol has not been properly connected.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">start_subprotocols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Start all the sub-protocols in parallel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Stop the protocol as well as any running sub-protocols.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">subprotocols</span></span></dt>
<dd><p>sub-protocols of this protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">uid</span></span></dt>
<dd><p>returns a unique identifier for this entity in the simulation.</p>
<p>Each entity has a unique identifier in the simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">netsquid.examples.simple_link.</span></span><span class="sig-name descname"><span class="pre">MidpointHeraldingProtocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_port_name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="../api_protocols/netsquid.protocols.nodeprotocols.html#netsquid.protocols.nodeprotocols.NodeProtocol" title="netsquid.protocols.nodeprotocols.NodeProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeProtocol</span></code></a></p>
<p>Attempt to generate entanglement via a HeraldingConnection.</p>
<p>This protocol sends a trigger to an EGProtocol every <code class="docutils literal notranslate"><span class="pre">time_step</span></code> nanoseconds.
On a response the protocol creates a qubit in memory, entangles it with a photon,
and sends this photon to the qout port of the quantum memory.
This port is expected to forward the photon to the heralded connection.
This connection is expected to return an outcome of the photon measurement,
which returns 1 or 2 (each denotes an entangled state) for success.
The photon will be generated on position 0, and the qubits on 1 .. N.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<cite>~netsquid.nodes.node.Node</cite>) – The node this protocol runs on.</p></li>
<li><p><strong>time_step</strong> (<em>int</em>) – The period of the triggers in nanoseconds.</p></li>
<li><p><strong>q_port_name</strong> (<em>str</em>) – The name of the port connected to the heraled connection.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">trigger_label</span></span></dt>
<dd><p>The label of the trigger signal</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">answer_label</span></span></dt>
<dd><p>The label of the answer signal</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">EmitProgram</span></span></dt>
<dd><p>Bases: <a class="reference internal" href="../api_components/netsquid.components.qprogram.html#netsquid.components.qprogram.QuantumProgram" title="netsquid.components.qprogram.QuantumProgram"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumProgram</span></code></a></p>
<p>Program to create a qubit and emit an entangled photon to the ‘qout’ port.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">program</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Program to be executed.</p>
<p>Override this method to add additional control logic.</p>
<p>By default runs a single sequences of instructions that
have been added using <code class="docutils literal notranslate"><span class="pre">apply()</span></code>.</p>
<p class="rubric">Notes</p>
<p>Returns a generator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instruction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'last'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">physical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Prepare to apply an instruction.</p>
<p>Prepares a callback function that will be called when the instruction
is executed by a quantum processor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>instruction</strong> (<a class="reference internal" href="../api_components/netsquid.components.instructions.html#netsquid.components.instructions.Instruction" title="netsquid.components.instructions.Instruction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Instruction</span></code></a>) – Next instruction to be called during program execution.</p></li>
<li><p><strong>qubit_indices</strong> (<em>int or list of int or None, optional</em>) – Program qubit indices to apply instruction to. If None or an empty list,
then the instruction does not act on any qubit indices.</p></li>
<li><p><strong>output_key</strong> (<em>str, optional</em>) – Dictionary key to store instruction output with. Default is to store
all outputs using <code class="docutils literal notranslate"><span class="pre">last</span></code>.</p></li>
<li><p><strong>physical</strong> (<em>bool, optional</em>) – Whether a quantum processor should interpret this instruction as being
physical. If non-physical it should execute it instantly and and without noise.</p></li>
<li><p><strong>**parameters</strong> – Additional keyword arguments to pass to the instruction.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>str</em> – Name of the instruction to be applied.</p></li>
<li><p><em>list of int</em> – Program qubit indices instruction to be applied to.</p></li>
<li><p><em>function</em> – Callback function that applies the instruction to a quantum processor.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The prepared callback also accepts <code class="docutils literal notranslate"><span class="pre">runtime_params</span></code> keyword arguments
that will override any matching keywords in <code class="docutils literal notranslate"><span class="pre">parameters</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">default_num_qubits</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">-1</span></em></dt>
<dd><p>default number of qubits program requires. If -1 it can run on any number of qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_qubit_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_qubits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Convenience method that returns the program’s qubit indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_qubits</strong> (<em>int or None, optional</em>) – Number of qubit indices to return. If <code class="docutils literal notranslate"><span class="pre">None</span></code>
will try to return all indices corresponding
to <code class="docutils literal notranslate"><span class="pre">self.num_qubits</span></code>, raising an exception
if this is not bounded.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Indices of program qubits.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of int</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If too many indices are requested, or if all indices are requested and
    this number is not bounded.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">program</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Load in and run another quantum program within this program.</p>
<p>To be called within an overridden <code class="docutils literal notranslate"><span class="pre">program()</span></code> method.
Should be prepepended by <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> (see example below).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">output</span></code> dict is shared between both programs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>program</strong> (<a class="reference internal" href="../api_components/netsquid.components.qprogram.html#netsquid.components.qprogram.QuantumProgram" title="netsquid.components.qprogram.QuantumProgram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QuantumProgram</span></code></a>) – Another quantum program to load in and run.
Can be an instance or a (sub)class of
<a class="reference internal" href="../api_components/netsquid.components.qprogram.html#netsquid.components.qprogram.QuantumProgram" title="netsquid.components.qprogram.QuantumProgram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QuantumProgram</span></code></a>.
If it is an instance, a copy is made.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A generator for the loaded program.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>generator</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_components/netsquid.components.qprogram.html#netsquid.components.qprogram.QuantumProgramError" title="netsquid.components.qprogram.QuantumProgramError"><strong>QuantumProgramError</strong></a> – If <code class="docutils literal notranslate"><span class="pre">program</span></code> is invalid. This exception will be caught by
    a running program and cause it to fail.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>It is possible to load a <a class="reference internal" href="../api_components/netsquid.components.qprogram.html#netsquid.components.qprogram.QuantumProgram" title="netsquid.components.qprogram.QuantumProgram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QuantumProgram</span></code></a> instance or class.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">program</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># ...</span>
<span class="gp">... </span>    <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">my_program_instance</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">MyCustomProgram</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_qubits</span></span></dt>
<dd><p>number of qubits program requires. If -1 can run on any number of qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Reset state of program.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lazy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Carry out all applied instructions within the program to this point.</p>
<p>Called within an overridden <code class="docutils literal notranslate"><span class="pre">program()</span></code> method.
Should be prepepended by <code class="docutils literal notranslate"><span class="pre">yield</span></code> (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parallel</strong> (<em>bool, optional</em>) – Whether processor should attempt to run instructions
in parallel (if physically supported).
Default True.</p></li>
<li><p><strong>lazy</strong> (<em>bool, optional</em>) – Whether to perform all instructions at once.
Useful to keep qubit states small between combining and reducing.
(Qubits in other processors that share the same qubit state
do not get the chance to increase the state exponentially)
All instructions will be executed at the current time instance
without having to run the simulator.
Noise will be applied accordingly for the duration of and between the instructions.
However any other calls in an instruction to <a class="reference internal" href="../api_util/netsquid.util.simtools.html#netsquid.util.simtools.sim_time" title="netsquid.util.simtools.sim_time"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_time()</span></code></a>
or scheduling events with schedule_now and schedule_after <strong>will be incorrect</strong>.
Make absolutely sure that no such calls exists in the instructions.
It will not be checked, so there is no guarantee that the simulation is correct otherwise.
Default False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>tuple with the following entries:</p>
<dl class="simple">
<dt>list of tuple(<code class="xref py py-obj docutils literal notranslate"><span class="pre">ProgramInstruction</span></code>)</dt><dd><p>List of tuples specifying instruction name, program qubit indices,
callback function.</p>
</dd>
<dt>bool</dt><dd><p>Whether processor should attempt to run instructions
in parallel (if physically supported).</p>
</dd>
<dt>bool</dt><dd><p>Whether the processor should attempt to run instruction lazily
(i.e. apply them all at once at the same event).</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RunParameters</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">program</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">INSTR_X</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Sends triggers periodically or starts an entanglement attempt.</p>
<p>The triggers are skipped during the entanglement attempt for simplicity.</p>
<dl class="field-list simple">
<dt class="field-odd">Yields<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a> – Await a timer signal or a response from the connection.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">do_task</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qpos</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Start the task.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>qpos</strong> (<em>int</em>) – The number indicating which qubit pair we are making.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Adds a signal type to the protocol that it can signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Enum</span></code>) – The label to use to reference the signal.</p></li>
<li><p><strong>event_type</strong> (<a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> or None, optional) – Event type to use for the signal type. If None, an event type is created unless
the <code class="docutils literal notranslate"><span class="pre">label</span></code> is an <code class="xref py py-obj docutils literal notranslate"><span class="pre">Enum</span></code> with a <a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> as value,
in which case this is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event type of the added signal type.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_subprotocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subprotocol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Add a sub-protocol to this protocol.</p>
<p>Neither protocol should be running and both protocols must be able to
signal to each other (see <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subprotocol</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol to add as a sub-protocol.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Reference name (key) to use for sub-protocol. If None, the name
of the sub-protocol is used.
If a sub-protocol using the same <code class="docutils literal notranslate"><span class="pre">name</span></code> already
exists it is overridden.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstraintError" title="netsquid.util.constrainedmap.ConstraintError"><strong>ConstraintError</strong></a> – If either of the protocols is running, or if the protocols cannot signal
    to each other in both directions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_mempos_busy_toggle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">QuantumMemory</span> <span class="pre">qmemory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list</span> <span class="pre">positions</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits for one of the memory positions
on a quantum memory to change the value of the busy state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qmemory</strong> (<a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>) – The quantum memory to wait for.</p></li>
<li><p><strong>positions</strong> (<em>list of int</em>) – The memory positions to wait for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for one of the memory positions to toggle its busy flag.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – The <code class="docutils literal notranslate"><span class="pre">qmemory</span></code> parameter is not of type <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>.</p></li>
<li><p><strong>IndexError</strong> – If the positions given don’t match a valid <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition" title="netsquid.components.qmemory.MemoryPosition"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryPosition</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Memory positions can enable if they schedule events when the busy flag is toggled by
setting <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition.busy_event_enabled" title="netsquid.components.qmemory.MemoryPosition.busy_event_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">busy_event_enabled</span></code></a>.
Because by default <cite>busy_event_enabled</cite> is False, we enable it here.
It is disabled when <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.reset" title="netsquid.components.qmemory.QuantumMemory.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> is called, otherwise it must be manually disabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_mempos_in_use_toggle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">QuantumMemory</span> <span class="pre">qmemory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list</span> <span class="pre">positions</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Wait for when one of the positions of a quantum memory toggle their in_use flag.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qmemory</strong> (<a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>) – The quantum memory to wait for.</p></li>
<li><p><strong>positions</strong> (<em>list of int</em>) – The positions to wait for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for one of the memory positions to toggle its in_use flag.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – qmemory is not of type <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>.</p></li>
<li><p><strong>IndexError</strong> – If the positions given don’t match a valid <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition" title="netsquid.components.qmemory.MemoryPosition"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryPosition</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Memory positions can enable if they schedule events when the in_use flag is toggled by
setting <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition.in_use_event_enabled" title="netsquid.components.qmemory.MemoryPosition.in_use_event_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">in_use_event_enabled</span></code></a>.
Because by default <cite>in_use_event_enabled</cite> is False, we enable it here.
It is disabled when <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.reset" title="netsquid.components.qmemory.QuantumMemory.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> is called, otherwise it must be manually disabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_port_input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits until the specified port receives a message input.</p>
<p>The event expression will also trigger if the message is passed through the port.
The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>port</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Port</span></code>) – Port to listen to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>EventExpression that the protocol yields on.
The message of the port can be fetched with <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port.rx_input" title="netsquid.components.component.Port.rx_input"><code class="xref py py-func docutils literal notranslate"><span class="pre">rx_input()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyProtocol</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">protocols</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">msg_header</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span> <span class="o">=</span> <span class="n">msg_header</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">rx_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A message was input via port </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_port_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits until the specified port has a message output.</p>
<p>The event expression will also trigger if the message is passed through the port.
The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>port</strong> (<a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port" title="netsquid.components.component.Port"><code class="xref py py-class docutils literal notranslate"><span class="pre">Port</span></code></a>) – Port to listen to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression that the protocol yields on.
The message of the port can be fetched with <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port.rx_output" title="netsquid.components.component.Port.rx_output"><code class="xref py py-func docutils literal notranslate"><span class="pre">rx_output()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyProtocol</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">protocols</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">msg_header</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span> <span class="o">=</span> <span class="n">msg_header</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">rx_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A message was output via port </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_program</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">await_done=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">await_fail=False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits for a program on a quantum processor to stop running.</p>
<p>The expression must be <em>yielded</em> on to come into effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>processor</strong> (<a class="reference internal" href="../api_components/netsquid.components.qprocessor.html#netsquid.components.qprocessor.QuantumProcessor" title="netsquid.components.qprocessor.QuantumProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumProcessor</span></code></a>) – The processor that runs the program</p></li>
<li><p><strong>await_done</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, default True) – Whether to wait for the program to successfully finish.</p></li>
<li><p><strong>await_fail</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, default False) – Whether to wait for the program to fail.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for the quantum program to stop.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both <cite>await_done</cite> and <cite>await_fail</cite> are set to True, it will wait until the program either finishes or fails.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Protocol</span> <span class="pre">sender</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_label=Signals.FINISHED</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits until a sender has sent a specified signal.</p>
<p>The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sender</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol that will send the signal.</p></li>
<li><p><strong>signal_label</strong> (<em>int or str or Enum, optional</em>) – The signal label to wait for.
Default is <code class="xref py py-attr docutils literal notranslate"><span class="pre">FINISHED</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>EventExpression that the protocol yields on.
The signal result can be retrieved from the protocol with <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.get_signal_result" title="netsquid.protocols.protocol.Protocol.get_signal_result"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_signal_result()</span></code></a>
or with <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.get_signal_by_event" title="netsquid.protocols.protocol.Protocol.get_signal_by_event"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_signal_by_event()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_timer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double</span> <span class="pre">duration=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double</span> <span class="pre">end_time=0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Schedule an event to trigger at a specified time and create an event expression to wait for it.</p>
<p>The expression must be <em>yielded</em> on to come into effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>duration</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>, optional) – Amount of time (in Nanoseconds) the protocol should sleep</p></li>
<li><p><strong>end_time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>, optional) – Ignored if duration bigger than 0, time instance at which the event triggers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression that the protocol yields on</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">can_signal_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Whether this protocol can send a signal to another protocol.</p>
<p>A local protocol can only signal to another local protocol if they have
one or more nodes in common.
A local protocol can always signal to a standard (non-local) protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>protocol</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol queried as to whether this protocol can send a signal to.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether this protocol can signal to the other protocol.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">check_assigned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Helper method to check if inputs properly assigned.</p>
<p>Checks that inputs are not None and that they have correct type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<em>object or list of objects</em>) – Inputs to check.</p></li>
<li><p><strong>input_type</strong> (<em>type or None, optional</em>) – Type that inputs should be. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, type is not
checked.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if all <code class="docutils literal notranslate"><span class="pre">inputs</span></code> specified, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_signal_by_event</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">receiver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get the signal result based on the event that triggered it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>event</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code>) – The event that triggered the signalling</p></li>
<li><p><strong>receiver</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> or None, optional) – The protocol wanting to receive the signal value. If not None,
will check if signalling is possible using
<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple with the label and result of the signal that was signalled with the given event.
None if the event is no longer associated with a signal result.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.SignalResult" title="netsquid.protocols.protocol.SignalResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SignalResult</span></code></a> or None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>To avoid storing all signal results and their events, only the most recent signal results are stored.
This means if a signal is sent all previous signal results are deleted, and the previous events are
no longer associated with a signal result.
Signals in the same time instance can co-exist.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_signal_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">receiver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get the result of the last signal sent with this label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Signals" title="netsquid.protocols.protocol.Signals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signals</span></code></a>) – Label that the signal was broadcasted with.</p></li>
<li><p><strong>receiver</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> or None, optional) – The protocol wanting to receive the signal value. If not None,
will check if signalling is possible to this protocol using
<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value that was sent with the signal.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RunTimeError</strong> – When attempting to get the result of a local signal from a nonlocal environment</p></li>
<li><p><strong>TypeError</strong> – When attempting to get the result of something else than a protocol</p></li>
<li><p><strong>KeyError</strong> – When the signal label is unknown i.e. hasn’t been added yet with
    <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.add_signal" title="netsquid.protocols.protocol.Protocol.add_signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_signal()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_connected</span></span></dt>
<dd><p>Whether protocol has been properly configured and can be started.</p>
<p>Requires that all specified nodes have been set (are not None).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if protocol is fully and correctly connected, otherwise False.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_running</span></span></dt>
<dd><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code> True if protocol is running, otherwise False.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_nodes</span></span></dt>
<dd><p>maximum number of nodes this local protocol can run on.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">name</span></span></dt>
<dd><p>Name of protocol for identification and display purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">node</span></span></dt>
<dd><p>single node this protocol is running on.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_nodes/netsquid.nodes.node.html#netsquid.nodes.node.Node" title="netsquid.nodes.node.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nodes</span></span></dt>
<dd><p>nodes local to this protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Removes the entity from the simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Stops and starts the protocol leaving it in a clean state.</p>
<p>Will stop the protocol with the specified status,
or Status.FAIL if not specified. Leaves the protocol in the Protocol.IDLE state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">send_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Send a signal to other protocols to indicate a status change or announce a result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal_label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Signals" title="netsquid.protocols.protocol.Signals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signals</span></code></a>) – Label, key or status that is broadcasted to the world. Other protocols can wait for this signal.</p></li>
<li><p><strong>result</strong> (<em>Any or None, optional</em>) – Result or intermediate results of the protocol that you want to broadcast with this signal</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <code class="docutils literal notranslate"><span class="pre">signal_label</span></code> does not correspond to a signal of this protocol.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When a protocol is finished (i.e. its run() returns),
the protocol sends a signal with label <code class="xref py py-attr docutils literal notranslate"><span class="pre">FINISHED</span></code>.
The result is set to the return value.</p>
<p>When a signal is sent with a label that was sent earlier, the result of the first signal is overwritten.
Signal results sent in the same time instance can be individually retrieved using the triggering event.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">signals</span></span></dt>
<dd><p>signals this protocol can send (<a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> indexed by label).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">specify_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Specify a node required by this protocol.</p>
<p>The protocol cannot start until all specified nodes are set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Key to index the node with.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If specifying this node will exceed the maximum number of nodes
    <a class="reference internal" href="../api_protocols/netsquid.protocols.nodeprotocols.html#netsquid.protocols.nodeprotocols.LocalProtocol.max_nodes" title="netsquid.protocols.nodeprotocols.LocalProtocol.max_nodes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_nodes</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Start the protocol.</p>
<p>Will register the protocol and run up to the first yield.
Will not start any sub-protocols. Sub-protocols are started in the run().
When run() is not overridden it will start all sub-protocol in parallel automatically.
If it is overridden the sub-protocols should be started manually in the method;
this to give control on when sub-protocols should run in parallel or in sequence</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>This protocol is returned for convenience.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a></p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError</strong> – If the protocol has not been properly connected.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">start_subprotocols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Start all the sub-protocols in parallel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Stop the protocol as well as any running sub-protocols.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">subprotocols</span></span></dt>
<dd><p>sub-protocols of this protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">uid</span></span></dt>
<dd><p>returns a unique identifier for this entity in the simulation.</p>
<p>Each entity has a unique identifier in the simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">netsquid.examples.simple_link.</span></span><span class="sig-name descname"><span class="pre">BSMDetector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system_delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dead_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">models</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_meta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_on_fail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">properties</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="../api_components/netsquid.components.qdetector.html#netsquid.components.qdetector.QuantumDetector" title="netsquid.components.qdetector.QuantumDetector"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumDetector</span></code></a></p>
<p>A component that performs Bell basis measurements.</p>
<p>Measure two incoming qubits in the Bell basis if they
arrive within the specified measurement delay.
Only informs the connections that send a qubit of the measurement result.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">preprocess_inputs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Preprocess and capture the qubit metadata</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">inform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">port_outcomes</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Inform the MHP of the measurement result.</p>
<p>We only send a result to the node that send a qubit.
If the result is empty we change the result and header.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>port_outcomes</strong> (<em>dict</em>) – A dictionary with the port names as keys
and the post-processed measurement outcomes as values</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">finish</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Clear sender ids after the measurement has finished.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_ports</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Add ports to this component.</p>
<p>Added ports are accessible via <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Component.ports" title="netsquid.components.component.Component.ports"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ports</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>names</strong> (<em>list of str</em>) – Names of ports.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of the ports with the given names.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port" title="netsquid.components.component.Port"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Port</span></code></a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If a port with this name already exists it is also returned in the list, but not overwritten.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_property</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mutable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Add a property to this component.</p>
<p>Properties can be accessed and modified via the
<a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Component.properties" title="netsquid.components.component.Component.properties"><code class="xref py py-attr docutils literal notranslate"><span class="pre">properties</span></code></a> attribute.</p>
<p>If a property with this name already exists, an attempt will be made to
set the new value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Name of the property.</p></li>
<li><p><strong>value</strong> (<em>Any</em>) – Value of the property.</p></li>
<li><p><strong>mutable</strong> (<em>bool, optional</em>) – Whether the property is mutable.</p></li>
<li><p><strong>value_type</strong> (<em>type, optional</em>) – Type of this property</p></li>
<li><p><strong>value_constraints</strong> (<cite>~netsquid.util.constrainedmap.ValueConstraint</cite> or list of <cite>~netsquid.util.constrainedmap.ValueConstraint</cite> , optional) – constraint checks to verify if value is a valid value</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_subcomponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forward_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forward_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_ports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Add a subcomponent to this component.</p>
<p>Subcomponents can be accessed using the
<a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Component.subcomponents" title="netsquid.components.component.Component.subcomponents"><code class="xref py py-attr docutils literal notranslate"><span class="pre">subcomponents</span></code></a> property.</p>
<p>If a component already exists with this name identifier it will be replaced.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>component</strong> (<a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Component" title="netsquid.components.component.Component"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Component</span></code></a>) – Component to add.</p></li>
<li><p><strong>name</strong> (<em>str or None, optional</em>) – Custom name identifier for component. If None (default),
the name of the component being added is used.
If a component using the same <code class="docutils literal notranslate"><span class="pre">name</span></code> already
exists it is overridden.</p></li>
<li><p><strong>forward_input</strong> (<em>list of tuple of str or None, optional</em>) – Names of ports to forward input from parent component to subcomponent.
Each tuple in this list consist of two port names:
The first port name is the port of the parentcomponent.
The second port name is the port of the subcomponent.</p></li>
<li><p><strong>forward_output</strong> (<em>list of tuple of str or None, optional</em>) – Names of ports to forward output from subcomponent to parent component.
Each tuple in this list consist of two port names:
The first port name is the port of the parentcomponent.
The second port name is the port of the subcomponent.</p></li>
<li><p><strong>add_ports</strong> (<em>bool, optional</em>) – If ports should be created if they do not yet exist.
Default False</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.ComponentHierarchyError" title="netsquid.components.component.ComponentHierarchyError"><strong>ComponentHierarchyError</strong></a> – If the component to be added is already related to this component
    as a sub or super component at any depth.
    Or if the component is already a subcomponent of an other component.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Instead of</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components</span> <span class="kn">import</span> <span class="n">Component</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span> <span class="o">=</span> <span class="n">Component</span><span class="p">(</span><span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="n">port_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;in_p&quot;</span><span class="p">,</span> <span class="s2">&quot;out_p&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child</span> <span class="o">=</span> <span class="n">Component</span><span class="p">(</span><span class="s2">&quot;child&quot;</span><span class="p">,</span> <span class="n">port_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;in_c&quot;</span><span class="p">,</span> <span class="s2">&quot;out_c&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;in_p&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">forward_input</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;in_c&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;out_c&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">forward_output</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;out_p&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>One can do</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span> <span class="o">=</span> <span class="n">Component</span><span class="p">(</span><span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="n">port_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;in_p&quot;</span><span class="p">,</span> <span class="s2">&quot;out_p&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child</span> <span class="o">=</span> <span class="n">Component</span><span class="p">(</span><span class="s2">&quot;child&quot;</span><span class="p">,</span> <span class="n">port_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;in_c&quot;</span><span class="p">,</span> <span class="s2">&quot;out_c&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">forward_input</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;in_p&quot;</span><span class="p">,</span> <span class="s2">&quot;in_c&quot;</span><span class="p">)],</span>
<span class="gp">... </span>    <span class="n">forward_output</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;out_p&quot;</span><span class="p">,</span> <span class="s2">&quot;out_c&quot;</span><span class="p">)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">has_subcomponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Whether argument is a subcomponent of this component at any level.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if component contained as a subcomponent at any level, otherwise False.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">has_supercomponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Whether argument is a supercomponent of this component at any level.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">in_dead_time</span></span></dt>
<dd><p>if the detector is in dead time.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">input_port_names</span></span></dt>
<dd><p>the names of the input ports.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_triggered</span></span></dt>
<dd><p>if the detector is triggered.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">measure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Perform a measurement on the received qubits.</p>
<p>Applies preprocessing to the qubits before the measurement, and
applies postprocessing to the measured classical outcomes.
After the measurement all qubits are discarded.</p>
<p>If an observable is specified, all qubits will be measured individually.
Otherwise, if measurement operators are specified, all qubits will be measured with these operators.
The qubits are ordered by port number and arrival time.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_components/netsquid.components.qdetector.html#netsquid.components.qdetector.QuantumDetectorError" title="netsquid.components.qdetector.QuantumDetectorError"><strong>QuantumDetectorError</strong></a> – If the number of qubits doesn’t match the measurement operators when <cite>error_on_fail</cite> is set.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">models</span></span></dt>
<dd><p>the models associated with this component.</p>
<p>Models that a component can hold are strictly define at construction.
To change the model use:
<code class="xref py py-meth docutils literal notranslate"><span class="pre">models[name_model]</span> <span class="pre">=</span> <span class="pre">model()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">name</span></span></dt>
<dd><p>Name of component for identification and display purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">output_port_names</span></span></dt>
<dd><p>the names of the output ports.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ports</span></span></dt>
<dd><p>ports belonging to this component.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">postprocess_outputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dict</span> <span class="pre">port_outcomes</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Processes the classical outcomes of the measurement before the message is send.</p>
<p>Applies a classical noise model if specified.</p>
<p>Override this method to change the preprocessing behaviour.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>port_outcomes</strong> (<em>dict</em>) – A dictionary with the port names as keys and a copy of the measurement outcomes as values</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">properties</span></span></dt>
<dd><p>the properties associated with this component.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">rem_subcomponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Remove a subcomponent from this component.</p>
<p>Outgoing port connections are disconnected to keep the hierarchy consistent;
That means that any port connections to the parent or siblings are disconnected.
Input ports to subcomponents remain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name identifier for component.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Removes the entity from the simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Reset the component.</p>
<p>Will reset all of its ports and (sub)components.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_input_models</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">models</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Convenience method to set models for the input ports</p>
<p>Instead of providing each model separately via the models property,
this method allows for providing a single model or a list of models.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>models</strong> (<a class="reference internal" href="../api_models/netsquid.components.models.qerrormodels.html#netsquid.components.models.qerrormodels.QuantumErrorModel" title="netsquid.components.models.qerrormodels.QuantumErrorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumErrorModel</span></code></a> or list of them) – The model or models applied for each port.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the model is not of type <a class="reference internal" href="../api_models/netsquid.components.models.qerrormodels.html#netsquid.components.models.qerrormodels.QuantumErrorModel" title="netsquid.components.models.qerrormodels.QuantumErrorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumErrorModel</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_output_models</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">models</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Convenience method to set models for the output ports</p>
<p>Instead of providing each model separately via the models property,
this method allows for providing a single model or a list of models.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>models</strong> (<a class="reference internal" href="../api_models/netsquid.components.models.cerrormodels.html#netsquid.components.models.cerrormodels.ClassicalErrorModel" title="netsquid.components.models.cerrormodels.ClassicalErrorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClassicalErrorModel</span></code></a> or list of them) – The model or models applied for each port.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the model is not of type <a class="reference internal" href="../api_models/netsquid.components.models.cerrormodels.html#netsquid.components.models.cerrormodels.ClassicalErrorModel" title="netsquid.components.models.cerrormodels.ClassicalErrorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClassicalErrorModel</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">specify_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Specify the model types needed by this component.</p>
<p>Models that are not first specified cannot be set. To set a model do
<cite>Component.models[name_model] = model</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Key of item.</p></li>
<li><p><strong>model_type</strong> (<cite>~netsquid.components.models.Model</cite>) – Type of model. If None, <cite>~netsquid.components.models.Model</cite> base class is set.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>KeyError</strong> – If a model with <code class="docutils literal notranslate"><span class="pre">name</span></code> has already been specified.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">subcomponents</span></span></dt>
<dd><p>Return list of subcomponents of this component and their identifiers.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Subcomponents of this component.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">supercomponent</span></span></dt>
<dd><p>parent component, if any.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Component" title="netsquid.components.component.Component"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Component</span></code></a> or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">trigger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Start the measurement process.</p>
<p>Schedules the measurement after the system delay.
When called the detector should be ready to measure.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_components/netsquid.components.qdetector.html#netsquid.components.qdetector.QuantumDetectorError" title="netsquid.components.qdetector.QuantumDetectorError"><strong>QuantumDetectorError</strong></a> – If the detector is already triggered.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">uid</span></span></dt>
<dd><p>returns a unique identifier for this entity in the simulation.</p>
<p>Each entity has a unique identifier in the simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">netsquid.examples.simple_link.</span></span><span class="sig-name descname"><span class="pre">create_meas_ops</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">visibility</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sets the photon beamsplitter POVM measurements.</p>
<p>We are assuming a lot here, see the Netsquid-Physlayer snippet for more info.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>visibility</strong> (<em>float, optional</em>) – The visibility of the qubits in the detector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">netsquid.examples.simple_link.</span></span><span class="sig-name descname"><span class="pre">HeraldedConnection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length_to_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length_to_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="../api_nodes/netsquid.nodes.connections.html#netsquid.nodes.connections.Connection" title="netsquid.nodes.connections.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a></p>
<p>A connection that takes in two qubits, and returns a message
how they were measured at a detector.</p>
<p>Either no clicks, a single click or double click, or an error
when the qubits didn’t arrive within the time window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – The name of this connection</p></li>
<li><p><strong>length_to_a</strong> (<em>float</em>) – The length in km between the detector and side A. We assume a speed of 200000 km/s</p></li>
<li><p><strong>length_to_b</strong> (<em>float</em>) – The length in km between the detector and side B. We assume a speed of 200000 km/s</p></li>
<li><p><strong>time_window</strong> (<em>float, optional</em>) – The interval where qubits are still able to be measured correctly.
Must be positive. Default is 0.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_ports</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Add ports to this component.</p>
<p>Added ports are accessible via <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Component.ports" title="netsquid.components.component.Component.ports"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ports</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>names</strong> (<em>list of str</em>) – Names of ports.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of the ports with the given names.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port" title="netsquid.components.component.Port"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Port</span></code></a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If a port with this name already exists it is also returned in the list, but not overwritten.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_property</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mutable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Add a property to this component.</p>
<p>Properties can be accessed and modified via the
<a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Component.properties" title="netsquid.components.component.Component.properties"><code class="xref py py-attr docutils literal notranslate"><span class="pre">properties</span></code></a> attribute.</p>
<p>If a property with this name already exists, an attempt will be made to
set the new value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Name of the property.</p></li>
<li><p><strong>value</strong> (<em>Any</em>) – Value of the property.</p></li>
<li><p><strong>mutable</strong> (<em>bool, optional</em>) – Whether the property is mutable.</p></li>
<li><p><strong>value_type</strong> (<em>type, optional</em>) – Type of this property</p></li>
<li><p><strong>value_constraints</strong> (<cite>~netsquid.util.constrainedmap.ValueConstraint</cite> or list of <cite>~netsquid.util.constrainedmap.ValueConstraint</cite> , optional) – constraint checks to verify if value is a valid value</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_subcomponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forward_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forward_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_ports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Add a subcomponent to this component.</p>
<p>Subcomponents can be accessed using the
<a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Component.subcomponents" title="netsquid.components.component.Component.subcomponents"><code class="xref py py-attr docutils literal notranslate"><span class="pre">subcomponents</span></code></a> property.</p>
<p>If a component already exists with this name identifier it will be replaced.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>component</strong> (<a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Component" title="netsquid.components.component.Component"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Component</span></code></a>) – Component to add.</p></li>
<li><p><strong>name</strong> (<em>str or None, optional</em>) – Custom name identifier for component. If None (default),
the name of the component being added is used.
If a component using the same <code class="docutils literal notranslate"><span class="pre">name</span></code> already
exists it is overridden.</p></li>
<li><p><strong>forward_input</strong> (<em>list of tuple of str or None, optional</em>) – Names of ports to forward input from parent component to subcomponent.
Each tuple in this list consist of two port names:
The first port name is the port of the parentcomponent.
The second port name is the port of the subcomponent.</p></li>
<li><p><strong>forward_output</strong> (<em>list of tuple of str or None, optional</em>) – Names of ports to forward output from subcomponent to parent component.
Each tuple in this list consist of two port names:
The first port name is the port of the parentcomponent.
The second port name is the port of the subcomponent.</p></li>
<li><p><strong>add_ports</strong> (<em>bool, optional</em>) – If ports should be created if they do not yet exist.
Default False</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.ComponentHierarchyError" title="netsquid.components.component.ComponentHierarchyError"><strong>ComponentHierarchyError</strong></a> – If the component to be added is already related to this component
    as a sub or super component at any depth.
    Or if the component is already a subcomponent of an other component.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Instead of</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components</span> <span class="kn">import</span> <span class="n">Component</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span> <span class="o">=</span> <span class="n">Component</span><span class="p">(</span><span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="n">port_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;in_p&quot;</span><span class="p">,</span> <span class="s2">&quot;out_p&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child</span> <span class="o">=</span> <span class="n">Component</span><span class="p">(</span><span class="s2">&quot;child&quot;</span><span class="p">,</span> <span class="n">port_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;in_c&quot;</span><span class="p">,</span> <span class="s2">&quot;out_c&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;in_p&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">forward_input</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;in_c&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;out_c&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">forward_output</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;out_p&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>One can do</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span> <span class="o">=</span> <span class="n">Component</span><span class="p">(</span><span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="n">port_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;in_p&quot;</span><span class="p">,</span> <span class="s2">&quot;out_p&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child</span> <span class="o">=</span> <span class="n">Component</span><span class="p">(</span><span class="s2">&quot;child&quot;</span><span class="p">,</span> <span class="n">port_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;in_c&quot;</span><span class="p">,</span> <span class="s2">&quot;out_c&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">forward_input</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;in_p&quot;</span><span class="p">,</span> <span class="s2">&quot;in_c&quot;</span><span class="p">)],</span>
<span class="gp">... </span>    <span class="n">forward_output</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;out_p&quot;</span><span class="p">,</span> <span class="s2">&quot;out_c&quot;</span><span class="p">)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">has_subcomponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Whether argument is a subcomponent of this component at any level.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if component contained as a subcomponent at any level, otherwise False.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">has_supercomponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Whether argument is a supercomponent of this component at any level.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">models</span></span></dt>
<dd><p>the models associated with this component.</p>
<p>Models that a component can hold are strictly define at construction.
To change the model use:
<code class="xref py py-meth docutils literal notranslate"><span class="pre">models[name_model]</span> <span class="pre">=</span> <span class="pre">model()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">name</span></span></dt>
<dd><p>Name of component for identification and display purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">port_A</span></span></dt>
<dd><p>port for IO at remote location A.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port" title="netsquid.components.component.Port"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Port</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">port_B</span></span></dt>
<dd><p>port for IO at remote location B.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port" title="netsquid.components.component.Port"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Port</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ports</span></span></dt>
<dd><p>ports belonging to this component.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">properties</span></span></dt>
<dd><p>the properties associated with this component.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">rem_subcomponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Remove a subcomponent from this component.</p>
<p>Outgoing port connections are disconnected to keep the hierarchy consistent;
That means that any port connections to the parent or siblings are disconnected.
Input ports to subcomponents remain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name identifier for component.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Removes the entity from the simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Reset the component.</p>
<p>Will reset all of its ports and (sub)components.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">specify_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Specify the model types needed by this component.</p>
<p>Models that are not first specified cannot be set. To set a model do
<cite>Component.models[name_model] = model</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Key of item.</p></li>
<li><p><strong>model_type</strong> (<cite>~netsquid.components.models.Model</cite>) – Type of model. If None, <cite>~netsquid.components.models.Model</cite> base class is set.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>KeyError</strong> – If a model with <code class="docutils literal notranslate"><span class="pre">name</span></code> has already been specified.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">subcomponents</span></span></dt>
<dd><p>Return list of subcomponents of this component and their identifiers.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Subcomponents of this component.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">supercomponent</span></span></dt>
<dd><p>parent component, if any.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Component" title="netsquid.components.component.Component"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Component</span></code></a> or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">uid</span></span></dt>
<dd><p>returns a unique identifier for this entity in the simulation.</p>
<p>Each entity has a unique identifier in the simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">netsquid.examples.simple_link.</span></span><span class="sig-name descname"><span class="pre">NetworkProtocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entangle_protocol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remote_entangle_protocol</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a></p>
<p>Send requests to an EG service protocol.</p>
<p>Will automatically stop the services and their sub-protocols
when the requests are finished.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Name to identify this protocol.</p></li>
<li><p><strong>entangle_protocol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">EGService</span></code>) – The service that will get the requests from this network.</p></li>
<li><p><strong>remote_entangle_protocol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">EGService</span></code>) – The service that will create the pairs together with the entangle_protocol.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Start the protocols and put requests to Alice.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">show_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proto</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">request</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Show the qubits which are entangled as a result of the request.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>proto</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">EGProtocol</span></code>) – The entanglement generation service</p></li>
<li><p><strong>request</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">req_create</span></code>) – The request</p></li>
</ul>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a> – The eventexpressions required to wait for the response signals.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Adds a signal type to the protocol that it can signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Enum</span></code>) – The label to use to reference the signal.</p></li>
<li><p><strong>event_type</strong> (<a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> or None, optional) – Event type to use for the signal type. If None, an event type is created unless
the <code class="docutils literal notranslate"><span class="pre">label</span></code> is an <code class="xref py py-obj docutils literal notranslate"><span class="pre">Enum</span></code> with a <a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> as value,
in which case this is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event type of the added signal type.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add_subprotocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subprotocol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Add a sub-protocol to this protocol.</p>
<p>Neither protocol should be running and both protocols must be able to
signal to each other (see <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subprotocol</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol to add as a sub-protocol.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Reference name (key) to use for sub-protocol. If None, the name
of the sub-protocol is used.
If a sub-protocol using the same <code class="docutils literal notranslate"><span class="pre">name</span></code> already
exists it is overridden.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstraintError" title="netsquid.util.constrainedmap.ConstraintError"><strong>ConstraintError</strong></a> – If either of the protocols is running, or if the protocols cannot signal
    to each other in both directions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_mempos_busy_toggle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">QuantumMemory</span> <span class="pre">qmemory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list</span> <span class="pre">positions</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits for one of the memory positions
on a quantum memory to change the value of the busy state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qmemory</strong> (<a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>) – The quantum memory to wait for.</p></li>
<li><p><strong>positions</strong> (<em>list of int</em>) – The memory positions to wait for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for one of the memory positions to toggle its busy flag.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – The <code class="docutils literal notranslate"><span class="pre">qmemory</span></code> parameter is not of type <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>.</p></li>
<li><p><strong>IndexError</strong> – If the positions given don’t match a valid <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition" title="netsquid.components.qmemory.MemoryPosition"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryPosition</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Memory positions can enable if they schedule events when the busy flag is toggled by
setting <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition.busy_event_enabled" title="netsquid.components.qmemory.MemoryPosition.busy_event_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">busy_event_enabled</span></code></a>.
Because by default <cite>busy_event_enabled</cite> is False, we enable it here.
It is disabled when <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.reset" title="netsquid.components.qmemory.QuantumMemory.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> is called, otherwise it must be manually disabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_mempos_in_use_toggle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">QuantumMemory</span> <span class="pre">qmemory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list</span> <span class="pre">positions</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Wait for when one of the positions of a quantum memory toggle their in_use flag.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qmemory</strong> (<a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>) – The quantum memory to wait for.</p></li>
<li><p><strong>positions</strong> (<em>list of int</em>) – The positions to wait for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for one of the memory positions to toggle its in_use flag.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – qmemory is not of type <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>.</p></li>
<li><p><strong>IndexError</strong> – If the positions given don’t match a valid <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition" title="netsquid.components.qmemory.MemoryPosition"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryPosition</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Memory positions can enable if they schedule events when the in_use flag is toggled by
setting <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition.in_use_event_enabled" title="netsquid.components.qmemory.MemoryPosition.in_use_event_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">in_use_event_enabled</span></code></a>.
Because by default <cite>in_use_event_enabled</cite> is False, we enable it here.
It is disabled when <a class="reference internal" href="../api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.reset" title="netsquid.components.qmemory.QuantumMemory.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> is called, otherwise it must be manually disabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_port_input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits until the specified port receives a message input.</p>
<p>The event expression will also trigger if the message is passed through the port.
The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>port</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Port</span></code>) – Port to listen to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>EventExpression that the protocol yields on.
The message of the port can be fetched with <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port.rx_input" title="netsquid.components.component.Port.rx_input"><code class="xref py py-func docutils literal notranslate"><span class="pre">rx_input()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyProtocol</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">protocols</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">msg_header</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span> <span class="o">=</span> <span class="n">msg_header</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">rx_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A message was input via port </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_port_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits until the specified port has a message output.</p>
<p>The event expression will also trigger if the message is passed through the port.
The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>port</strong> (<a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port" title="netsquid.components.component.Port"><code class="xref py py-class docutils literal notranslate"><span class="pre">Port</span></code></a>) – Port to listen to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression that the protocol yields on.
The message of the port can be fetched with <a class="reference internal" href="../api_components/netsquid.components.component.html#netsquid.components.component.Port.rx_output" title="netsquid.components.component.Port.rx_output"><code class="xref py py-func docutils literal notranslate"><span class="pre">rx_output()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyProtocol</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">protocols</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">msg_header</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span> <span class="o">=</span> <span class="n">msg_header</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">rx_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_header</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A message was output via port </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_program</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span> <span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">await_done=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">await_fail=False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits for a program on a quantum processor to stop running.</p>
<p>The expression must be <em>yielded</em> on to come into effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>processor</strong> (<a class="reference internal" href="../api_components/netsquid.components.qprocessor.html#netsquid.components.qprocessor.QuantumProcessor" title="netsquid.components.qprocessor.QuantumProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumProcessor</span></code></a>) – The processor that runs the program</p></li>
<li><p><strong>await_done</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, default True) – Whether to wait for the program to successfully finish.</p></li>
<li><p><strong>await_fail</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, default False) – Whether to wait for the program to fail.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The event expression that will wait for the quantum program to stop.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both <cite>await_done</cite> and <cite>await_fail</cite> are set to True, it will wait until the program either finishes or fails.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Protocol</span> <span class="pre">sender</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_label=Signals.FINISHED</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create an event expression that waits until a sender has sent a specified signal.</p>
<p>The expression must be <em>yielded</em> on to come into effect (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sender</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol that will send the signal.</p></li>
<li><p><strong>signal_label</strong> (<em>int or str or Enum, optional</em>) – The signal label to wait for.
Default is <code class="xref py py-attr docutils literal notranslate"><span class="pre">FINISHED</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>EventExpression that the protocol yields on.
The signal result can be retrieved from the protocol with <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.get_signal_result" title="netsquid.protocols.protocol.Protocol.get_signal_result"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_signal_result()</span></code></a>
or with <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.get_signal_by_event" title="netsquid.protocols.protocol.Protocol.get_signal_by_event"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_signal_by_event()</span></code></a></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">await_timer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double</span> <span class="pre">duration=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double</span> <span class="pre">end_time=0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Schedule an event to trigger at a specified time and create an event expression to wait for it.</p>
<p>The expression must be <em>yielded</em> on to come into effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>duration</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>, optional) – Amount of time (in Nanoseconds) the protocol should sleep</p></li>
<li><p><strong>end_time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>, optional) – Ignored if duration bigger than 0, time instance at which the event triggers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression that the protocol yields on</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../pydynaa.html#pydynaa.core.EventExpression" title="pydynaa.core.EventExpression"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventExpression</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">can_signal_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Whether this protocol can send a signal to another protocol.</p>
<p>By default all base <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> can signal to each other.
Can be overridden by protocols to enforce locality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>protocol</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>) – Protocol to send a signal to.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether this protocol can signal to the other protocol.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">check_assigned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Helper method to check if inputs properly assigned.</p>
<p>Checks that inputs are not None and that they have correct type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<em>object or list of objects</em>) – Inputs to check.</p></li>
<li><p><strong>input_type</strong> (<em>type or None, optional</em>) – Type that inputs should be. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, type is not
checked.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if all <code class="docutils literal notranslate"><span class="pre">inputs</span></code> specified, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_signal_by_event</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">receiver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get the signal result based on the event that triggered it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>event</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code>) – The event that triggered the signalling</p></li>
<li><p><strong>receiver</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> or None, optional) – The protocol wanting to receive the signal value. If not None,
will check if signalling is possible using
<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A named tuple with the label and result of the signal that was signalled with the given event.
None if the event is no longer associated with a signal result.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.SignalResult" title="netsquid.protocols.protocol.SignalResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SignalResult</span></code></a> or None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>To avoid storing all signal results and their events, only the most recent signal results are stored.
This means if a signal is sent all previous signal results are deleted, and the previous events are
no longer associated with a signal result.
Signals in the same time instance can co-exist.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_signal_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">receiver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get the result of the last signal sent with this label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Signals" title="netsquid.protocols.protocol.Signals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signals</span></code></a>) – Label that the signal was broadcasted with.</p></li>
<li><p><strong>receiver</strong> (<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> or None, optional) – The protocol wanting to receive the signal value. If not None,
will check if signalling is possible to this protocol using
<a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.can_signal_to" title="netsquid.protocols.protocol.Protocol.can_signal_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">can_signal_to()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value that was sent with the signal.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RunTimeError</strong> – When attempting to get the result of a local signal from a nonlocal environment</p></li>
<li><p><strong>TypeError</strong> – When attempting to get the result of something else than a protocol</p></li>
<li><p><strong>KeyError</strong> – When the signal label is unknown i.e. hasn’t been added yet with
    <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol.add_signal" title="netsquid.protocols.protocol.Protocol.add_signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_signal()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_connected</span></span></dt>
<dd><p>Whether protocol has been properly configured and can be started.</p>
<p>Default is True. Override to require a protocol subclass to be properly connected
before it can start.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if protocol is fully and correctly connected, otherwise False.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">is_running</span></span></dt>
<dd><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code> True if protocol is running, otherwise False.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">name</span></span></dt>
<dd><p>Name of protocol for identification and display purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Removes the entity from the simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Stops and starts the protocol leaving it in a clean state.</p>
<p>Will stop the protocol with the specified status,
or Status.FAIL if not specified. Leaves the protocol in the Protocol.IDLE state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">send_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Send a signal to other protocols to indicate a status change or announce a result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal_label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Signals" title="netsquid.protocols.protocol.Signals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signals</span></code></a>) – Label, key or status that is broadcasted to the world. Other protocols can wait for this signal.</p></li>
<li><p><strong>result</strong> (<em>Any or None, optional</em>) – Result or intermediate results of the protocol that you want to broadcast with this signal</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <code class="docutils literal notranslate"><span class="pre">signal_label</span></code> does not correspond to a signal of this protocol.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When a protocol is finished (i.e. its run() returns),
the protocol sends a signal with label <code class="xref py py-attr docutils literal notranslate"><span class="pre">FINISHED</span></code>.
The result is set to the return value.</p>
<p>When a signal is sent with a label that was sent earlier, the result of the first signal is overwritten.
Signal results sent in the same time instance can be individually retrieved using the triggering event.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">signals</span></span></dt>
<dd><p>signals this protocol can send (<a class="reference internal" href="../pydynaa.html#pydynaa.core.EventType" title="pydynaa.core.EventType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventType</span></code></a> indexed by label).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Start the protocol.</p>
<p>Will register the protocol and run up to the first yield.
Will not start any sub-protocols. Sub-protocols are started in the run().
When run() is not overridden it will start all sub-protocol in parallel automatically.
If it is overridden the sub-protocols should be started manually in the method;
this to give control on when sub-protocols should run in parallel or in sequence</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>This protocol is returned for convenience.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a></p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError</strong> – If the protocol has not been properly connected.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">start_subprotocols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Start all the sub-protocols in parallel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Stop the protocol as well as any running sub-protocols.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">subprotocols</span></span></dt>
<dd><p>sub-protocols of this protocol.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html#netsquid.util.constrainedmap.ConstrainedMap" title="netsquid.util.constrainedmap.ConstrainedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedMap</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">uid</span></span></dt>
<dd><p>returns a unique identifier for this entity in the simulation.</p>
<p>Each entity has a unique identifier in the simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">netsquid.examples.simple_link.</span></span><span class="sig-name descname"><span class="pre">create_example_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_qubits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create the example network.</p>
<p>Alice and Bob need a QuantumProcessor to store the qubits they produce.
Their qubits are send through a heralded connection,
which needs to be connected to Alice and Bob.
It is assumed qubits are send to the connection,
and it returns classical messages.
In this example we won’t use noise on the quantum memories,
so instead of defining PhysicalInstructions we
fallback to nonphysical ones.
In order to synchronize their attempts a classical connection is added.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_qubits</strong> (<em>int</em>) – The number of entangled qubit pairs we expect this network to make. Default 3.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The example network for a simple link.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_nodes/netsquid.nodes.network.html#netsquid.nodes.network.Network" title="netsquid.nodes.network.Network"><code class="xref py py-class docutils literal notranslate"><span class="pre">Network</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">netsquid.examples.simple_link.</span></span><span class="sig-name descname"><span class="pre">setup_protocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">network</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Configure the protocols.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>network</strong> (<a class="reference internal" href="../api_nodes/netsquid.nodes.network.html#netsquid.nodes.network.Network" title="netsquid.nodes.network.Network"><code class="xref py py-class docutils literal notranslate"><span class="pre">Network</span></code></a>) – The network to configure the protocols on. Should consist of two nodes
called Alice and Bob.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A protocol describing the complete simple link setup.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html#netsquid.protocols.protocol.Protocol" title="netsquid.protocols.protocol.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">netsquid.examples.simple_link.</span></span><span class="sig-name descname"><span class="pre">run_simulation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Run the example simulation.</p>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="netsquid.examples.repeater_chain.html" class="btn btn-neutral float-left" title="netsquid.examples.repeater_chain" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="netsquid.examples.magic_simple_link.html" class="btn btn-neutral float-right" title="netsquid.examples.magic_simple_link" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2021, TNO and TUDelft (QuTech).</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: 1.1.7
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
      <dd><a href="/1-1-stable/">1.1.5</a></dd>
      <dd><a href="/1-0-stable/">1.0.7</a></dd>
      <dd><a href="/0-10-stable/">0.10.4</a></dd>
      <dd><a href="/0-9-stable/">0.9.11</a></dd>
      <dd><a href="/0-8-stable/">0.8.7</a></dd>
      <dd><a href="/0-7-stable/">0.7.5</a></dd>
      <dd><a href="/0-6-stable/">0.6.4</a></dd>
      <dd><a href="/0-5-stable/">0.5.2</a></dd>
      <dd><a href="/0-4-stable/">0.4.2</a></dd>
      <dd><a href="/0-3-stable/">0.3.5</a></dd>
      <dd><a href="/latest-release/">latest release</a></dd>
      <dd><a href="/master/">master branch</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".highlight-default .highlight").each(function() {
            if ($(this).find(".gp").length > 0) {
             $(this).prepend("<div class='codebtn btn btn-neutral float-right'><div class='gp'>>>></div><div>");
             $(this).children("pre").contents().filter(function() {return this.nodeType === 3;}).wrap("<span></span>").end();
            }
        });
        $(".highlight-default .highlight .codebtn").click(function() {
            $(this).parent().children("pre").find(".gp").toggleClass("hidden");
            var traceback_elem = $(this).parent().children("pre").find(".gt, .go");
            traceback_elem.toggleClass("hidden");
            traceback_elem.nextUntil(".gp, .go").toggleClass("hidden");

        })
    });
</script>


</body>
</html>