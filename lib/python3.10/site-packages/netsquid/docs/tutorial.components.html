<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modelling of network components &mdash; NetSquid 1.1.7 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="_static/style.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=370aedac"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Nodes and Connections" href="tutorial.nodes.html" />
    <link rel="prev" title="Discrete event simulation" href="tutorial.pydynaa.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #E3E3E3" >

          
          
          <a href="index.html" class="icon icon-home">
            NetSquid
              <img src="_static/squid-150.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.1.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="README.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="INSTALL.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="RELEASE.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="AUTHORS.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="LICENSE.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Learn NetSquid</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quick_start.html">NetSquid in 10 minutes</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="tutorial.intro.html">Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="tutorial.qubits.html">Qubits and quantum computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.pydynaa.html">Discrete event simulation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Modelling of network components</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.nodes.html">Nodes and Connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.quantumprocessor.html">The Quantum Processor</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.simulation.html">A full simulation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="learn.examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="learn_examples/learn.examples.teleportation.html">Teleportation</a></li>
<li class="toctree-l2"><a class="reference internal" href="learn_examples/learn.examples.repeater.html">Repeater with purification</a></li>
<li class="toctree-l2"><a class="reference internal" href="learn_examples/learn.examples.repeater_chain.html">Repeater chain</a></li>
<li class="toctree-l2"><a class="reference internal" href="learn_examples/learn.examples.simple_link.html">A simple link layer protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="learn_examples/learn.examples.magic_simple_link.html">Faster Link layer Protocol using abstraction</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api_reference.html">NetSquid package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="netsquid.qubits.html">netsquid.qubits</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.qformalism.html">netsquid.qubits.qformalism</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.qubitapi.html">netsquid.qubits.qubitapi</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.operators.html">netsquid.qubits.operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.cliffords.html">netsquid.qubits.cliffords</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.ketstates.html">netsquid.qubits.ketstates</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.state_sampler.html">netsquid.qubits.state_sampler</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.qubit.html">netsquid.qubits.qubit</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.qstate.html">netsquid.qubits.qstate</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.qrepr.html">netsquid.qubits.qrepr</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.kettools.html">netsquid.qubits.kettools</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.dmtools.html">netsquid.qubits.dmtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.sparsedmtools.html">netsquid.qubits.sparsedmtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.stabtools.html">netsquid.qubits.stabtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.gslctools.html">netsquid.qubits.gslctools</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.qreprutil.html">netsquid.qubits.qreprutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.ketutil.html">netsquid.qubits.ketutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.dmutil.html">netsquid.qubits.dmutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.sparseutil.html">netsquid.qubits.sparseutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.gslcutil.html">netsquid.qubits.gslcutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_qubits/netsquid.qubits.opmath.html">netsquid.qubits.opmath</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="netsquid.components.html">netsquid.components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.component.html">netsquid.components.component</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.channel.html">netsquid.components.channel</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.qchannel.html">netsquid.components.qchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.cchannel.html">netsquid.components.cchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.cqchannel.html">netsquid.components.cqchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.qmemory.html">netsquid.components.qmemory</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.instructions.html">netsquid.components.instructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.qprogram.html">netsquid.components.qprogram</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.qprocessor.html">netsquid.components.qprocessor</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.clock.html">netsquid.components.clock</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.qsource.html">netsquid.components.qsource</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.qdetector.html">netsquid.components.qdetector</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.switch.html">netsquid.components.switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_components/netsquid.components.ccoding.html">netsquid.components.ccoding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="netsquid.components.models.html">netsquid.components.models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_models/netsquid.components.models.model.html">netsquid.components.models.model</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_models/netsquid.components.models.delaymodels.html">netsquid.components.models.delaymodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_models/netsquid.components.models.errormodels.html">netsquid.components.models.errormodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_models/netsquid.components.models.qerrormodels.html">netsquid.componentsmodels.qerrormodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_models/netsquid.components.models.cerrormodels.html">netsquid.components.models.cerrormodels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="netsquid.nodes.html">netsquid.nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_nodes/netsquid.nodes.node.html">netsquid.nodes.node</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_nodes/netsquid.nodes.connections.html">netsquid.nodes.connections</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_nodes/netsquid.nodes.network.html">netsquid.nodes.network</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="netsquid.protocols.html">netsquid.protocols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_protocols/netsquid.protocols.protocol.html">netsquid.protocols.protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_protocols/netsquid.protocols.nodeprotocols.html">netsquid.protocols.nodeprotocols</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_protocols/netsquid.protocols.serviceprotocol.html">netsquid.protocols.serviceprotocol</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="netsquid.util.html">netsquid.util</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_util/netsquid.util.simtools.html">netsquid.util.simtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_util/netsquid.util.simlog.html">netsquid.util.simlog</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_util/netsquid.util.simstats.html">netsquid.util.simstats</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_util/netsquid.util.datacollector.html">netsquid.util.datacollector</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_util/netsquid.util.cycache.html">netsquid.util.cycache</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_util/netsquid.util.cymath.html">netsquid.util.cymath</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_util/netsquid.util.constrainedmap.html">netsquid.util.constrainedmap</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="netsquid.examples.html">netsquid.examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api_examples/netsquid.examples.teleportation.html">netsquid.examples.teleportation</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_examples/netsquid.examples.entanglenodes.html">netsquid.examples.entanglenodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_examples/netsquid.examples.purify.html">netsquid.examples.purify</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_examples/netsquid.examples.repeater.html">netsquid.examples.repeater</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_examples/netsquid.examples.repeater_chain.html">netsquid.examples.repeater_chain</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_examples/netsquid.examples.simple_link.html">netsquid.examples.simple_link</a></li>
<li class="toctree-l3"><a class="reference internal" href="api_examples/netsquid.examples.magic_simple_link.html">netsquid.examples.magic_simple_link</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api_pydynaa.html">pyDynAA package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pydynaa.html">pydynaa.Entity</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydynaa.html#pydynaa-event">pydynaa.Event</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydynaa.html#pydynaa-eventtype">pydynaa.EventType</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydynaa.html#pydynaa-eventexpression">pydynaa.EventExpression</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydynaa.html#pydynaa-eventhandler">pydynaa.EventHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydynaa.html#pydynaa-expressionhandler">pydynaa.ExpressionHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydynaa.html#pydynaa-simulationengine">pydynaa.SimulationEngine</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">For developers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="INSTALL-SOURCE.html">Installation from source</a></li>
<li class="toctree-l1"><a class="reference internal" href="CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHANGELOG.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #E3E3E3" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">NetSquid</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="tutorial.intro.html">Tutorial</a></li>
      <li class="breadcrumb-item active">Modelling of network components</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/tutorial.components.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="tutorial.pydynaa.html" class="btn btn-neutral float-left" title="Discrete event simulation" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tutorial.nodes.html" class="btn btn-neutral float-right" title="Nodes and Connections" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="modelling-of-network-components">
<h1>Modelling of network components<a class="headerlink" href="#modelling-of-network-components" title="Link to this heading"></a></h1>
<p>In the previous tutorial section we have seen how we can use the discrete event simulator to teleport a qubit.
It involved manually instructing the involved entities to schedule the necessary events in time.
In this tutorial we will see how this simulation example can be greatly simplified by introducing network components, which are simulation entities that model the physical hardware of a quantum network.</p>
<p class="topic-title">Learning goals</p><ul class="simple">
<li><p>Setting up components such as channels and quantum memories
(<strong>essential</strong>).</p></li>
<li><p>Connecting components with ports
(<strong>essential</strong>).</p></li>
<li><p>The quantum source component and the state sampler
(<strong>advanced</strong>).</p></li>
</ul>
<nav class="contents local" id="table-of-contents">
<p class="topic-title">Table of contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#components" id="id1">Components</a></p></li>
<li><p><a class="reference internal" href="#channels" id="id2">Channels</a></p></li>
<li><p><a class="reference internal" href="#quantum-memory" id="id3">Quantum memory</a></p></li>
<li><p><a class="reference internal" href="#ports" id="id4">Ports</a></p></li>
<li><p><a class="reference internal" href="#ping-pong-using-components-and-ports" id="id5">Ping pong using components and ports</a></p></li>
<li><p><a class="reference internal" href="#quantum-teleportation-using-components" id="id6">Quantum teleportation using components <sup>*</sup></a></p></li>
</ul>
</nav>
<p><em>Advanced sections are denoted by an asterix (*).</em></p>
<section id="components">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Components</a><a class="headerlink" href="#components" title="Link to this heading"></a></h2>
<p>Components are represented in NetSquid by the <a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Component" title="netsquid.components.component.Component"><code class="xref py py-class docutils literal notranslate"><span class="pre">Component</span></code></a> base class,
which subclasses from <a class="reference internal" href="pydynaa.html#pydynaa.core.Entity" title="pydynaa.core.Entity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Entity</span></code></a>.
NetSquid defines several useful base classes that subclass from Component,
such as: quantum and classical channels, quantum memories, quantum sources, and quantum processors.
We introduce several of the classes below, and others such as the quantum processor in a later section of this tutorial.</p>
<p>Components are composed of four types of attributes:
<a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Component.properties" title="netsquid.components.component.Component.properties"><code class="xref py py-attr docutils literal notranslate"><span class="pre">properties</span></code></a> that define their physical characteristics,
<a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Component.models" title="netsquid.components.component.Component.models"><code class="xref py py-attr docutils literal notranslate"><span class="pre">models</span></code></a> that describe functional behaviour,
<a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Component.ports" title="netsquid.components.component.Component.ports"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ports</span></code></a> for input and output communication,
and possible <a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Component.subcomponents" title="netsquid.components.component.Component.subcomponents"><code class="xref py py-attr docutils literal notranslate"><span class="pre">subcomponents</span></code></a> that they are built out of.
The properties, models and ports of a component are explained in more detail below;
sub-components are covered in a the <a class="reference external" href="tutorial.nodes.html">next tutorial about nodes and connections</a>.</p>
</section>
<section id="channels">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Channels</a><a class="headerlink" href="#channels" title="Link to this heading"></a></h2>
<p>In the previous example we learnt how timing in NetSquid proceeds via discrete
events (<a class="reference internal" href="pydynaa.html#pydynaa.core.Event" title="pydynaa.core.Event"><code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code></a>), which are scheduled by simulation entities (<a class="reference internal" href="pydynaa.html#pydynaa.core.Entity" title="pydynaa.core.Entity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Entity</span></code></a>).
To send a message from Alice to Bob, we can schedule an event when Bob could pick up the message sent by Alice.
This functionality of sending a message with a delay can be modelled by a
channel (<a class="reference internal" href="api_components/netsquid.components.channel.html#netsquid.components.channel.Channel" title="netsquid.components.channel.Channel"><code class="xref py py-class docutils literal notranslate"><span class="pre">Channel</span></code></a>), which is
a subclass of the component (<a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Component" title="netsquid.components.component.Component"><code class="xref py py-class docutils literal notranslate"><span class="pre">Component</span></code></a>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">netsquid</span> <span class="k">as</span> <span class="nn">ns</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components</span> <span class="kn">import</span> <span class="n">Channel</span><span class="p">,</span> <span class="n">QuantumChannel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">channel</span> <span class="o">=</span> <span class="n">Channel</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;MyChannel&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>A channel is capable of sending a message in one direction i.e. from its input port at one end to its output port at the other end.
To send any Python object as a message we can put it on the channel’s input port using <a class="reference internal" href="api_components/netsquid.components.channel.html#netsquid.components.channel.Channel.send" title="netsquid.components.channel.Channel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&quot;hello world!&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ns</span><span class="o">.</span><span class="n">sim_run</span><span class="p">()</span>
</pre></div>
</div>
<p>Channels are a subclass of <a class="reference internal" href="pydynaa.html#pydynaa.core.Entity" title="pydynaa.core.Entity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Entity</span></code></a> and schedule events to transmit the message.
Therefore we will have to run the simulator for the message to arrive.
To receive the messages, we can call <a class="reference internal" href="api_components/netsquid.components.channel.html#netsquid.components.channel.Channel.receive" title="netsquid.components.channel.Channel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a>.
It returns the messages on the output, as well as the time the messages have been travelling through the channel.
As we did not specify a transmission delay model for the channel it has defaulted to no delay,
which means we can retrieve the message at the same time instance it was sent:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">items</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">receive</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">items</span>
<span class="go">[&#39;hello world!&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delay</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>There are multiple ways to add a delay to the channel.
One approach is to initialize the channel with a fixed delay:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Channel</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;DelayChannel&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Another approach is to specify a delay model (<a class="reference internal" href="api_models/netsquid.components.models.delaymodels.html#netsquid.components.models.delaymodels.DelayModel" title="netsquid.components.models.delaymodels.DelayModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DelayModel</span></code></a>),
a specific subclass of the <a class="reference internal" href="api_models/netsquid.components.models.model.html#netsquid.components.models.model.Model" title="netsquid.components.models.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> base class used to generate delays.
In general models are used by components to modify their behaviour.</p>
<p>Several delay models have been predefined for convenience.
The default is the fixed delay model, which is used if only the <cite>delay</cite> parameter is specified.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components.models.delaymodels</span> <span class="kn">import</span> <span class="n">FixedDelayModel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fixed_delaymodel</span> <span class="o">=</span> <span class="n">FixedDelayModel</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>A component’s models are stored in its <em>models</em> map attribute and indexed with the appropriate key.
It is possible to give a dictionary with models at initialization if preferred.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">channel</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="s1">&#39;delay_model&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fixed_delaymodel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&quot;hello world!&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ns</span><span class="o">.</span><span class="n">sim_run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">channel</span><span class="o">.</span><span class="n">receive</span><span class="p">()</span>
<span class="go">([&#39;hello world!&#39;], 10.0)</span>
</pre></div>
</div>
<p>An example of a model that randomly samples its delay is the Gaussian delay model,
which samples from a normal distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components.models.delaymodels</span> <span class="kn">import</span> <span class="n">GaussianDelayModel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gaussian_delaymodel</span> <span class="o">=</span> <span class="n">GaussianDelayModel</span><span class="p">(</span><span class="n">delay_mean</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">delay_std</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="api_models/netsquid.components.models.delaymodels.html#netsquid.components.models.delaymodels.FibreDelayModel" title="netsquid.components.models.delaymodels.FibreDelayModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">FibreDelayModel</span></code></a> models the delay present in fibre optic cables.
Its computed delay depends on the speed of light in fibre (<em>c</em>) and the length of the channel.
This length is a <em>property</em> of the channel that can be set at initialization (the default is zero) i.e.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Channel</span><span class="p">(</span><span class="s2">&quot;TutorialChannel&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>It can also be modified after initialization.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">channel</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
</pre></div>
</div>
<p>The fibre delay model defines a property for the speed of light in fibre, <em>c</em>, and requires the length property to exist.
The properties a model requires are defined in its <cite>required_properties</cite> attribute:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components.models.delaymodels</span> <span class="kn">import</span> <span class="n">FibreDelayModel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delay_model</span> <span class="o">=</span> <span class="n">FibreDelayModel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Speed of light in fibre: </span><span class="si">{</span><span class="n">delay_model</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> [km/s]&quot;</span><span class="p">)</span>
<span class="go">Speed of light in fibre: 200000.0 [km/s]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delay_model</span><span class="o">.</span><span class="n">required_properties</span>
<span class="go">[&#39;length&#39;]</span>
</pre></div>
</div>
<p>Aside from using channels to send classical messages as we have been doing so far,
we will naturally also want to transmit qubits (<a class="reference internal" href="api_qubits/netsquid.qubits.qubit.html#netsquid.qubits.qubit.Qubit" title="netsquid.qubits.qubit.Qubit"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qubit</span></code></a>).
To do so we will need our channel to model not only the transmission delay but also to account for any possible quantum noise or loss (attenuation) the qubits experience due to that delay and the channel’s physical characteristics.
For that purpose there is the <em>quantum channel</em> (<a class="reference internal" href="api_components/netsquid.components.qchannel.html#netsquid.components.qchannel.QuantumChannel" title="netsquid.components.qchannel.QuantumChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumChannel</span></code></a>),
which is intended for the transmission of qubits (and only qubits).
Besides modeling the transmission delay using a <em>delay model</em> (it subclasses Channel), it also specifies two new model types:</p>
<ul class="simple">
<li><p>a <em>quantum_noise_model</em> that models noise experienced by qubits during their transmission,</p></li>
<li><p>a <em>quantum_loss_model</em> that determines whether the transmitted qubits are lost.</p></li>
</ul>
<p>Both the noise and loss model are required to be of type <em>quantum error model</em> (<a class="reference internal" href="api_models/netsquid.components.models.qerrormodels.html#netsquid.components.models.qerrormodels.QuantumErrorModel" title="netsquid.components.models.qerrormodels.QuantumErrorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumErrorModel</span></code></a>),
a generic class capable of modeling both quantum noise and qubit loss.
Thus the loss model can in principle also be used to apply noise, and vice versa.
The technical difference between the two is that the loss model is applied to the message before it is transmitted,
while the noise model is applied just before it is received.
Because a channel will by default not transmit lost qubits, applying the loss model before transmission can be more efficient.</p>
<p>In order to determine their effects, both models have access to the transmission time and the channel properties.
An example of a loss model is the <a class="reference internal" href="api_models/netsquid.components.models.qerrormodels.html#netsquid.components.models.qerrormodels.FibreLossModel" title="netsquid.components.models.qerrormodels.FibreLossModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">FibreLossModel</span></code></a>.
It requires the <em>length</em> propery of the channel, similarly to the delay model used for fibre optic cables.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components.models.qerrormodels</span> <span class="kn">import</span> <span class="n">FibreLossModel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components.qchannel</span> <span class="kn">import</span> <span class="n">QuantumChannel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss_model</span> <span class="o">=</span> <span class="n">FibreLossModel</span><span class="p">(</span><span class="n">p_loss_init</span><span class="o">=</span><span class="mf">0.83</span><span class="p">,</span> <span class="n">p_loss_length</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qchannel</span> <span class="o">=</span> <span class="n">QuantumChannel</span><span class="p">(</span><span class="s2">&quot;MyQChannel&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">models</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;quantum_loss_model&#39;</span><span class="p">:</span> <span class="n">loss_model</span><span class="p">})</span>
</pre></div>
</div>
<p>Analogous to the quantum channel for qubits, there also exists the <em>classical channel</em> base class (<a class="reference internal" href="api_components/netsquid.components.cchannel.html#netsquid.components.cchannel.ClassicalChannel" title="netsquid.components.cchannel.ClassicalChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClassicalChannel</span></code></a>) for transmitting classical information.
It also allows specifying noise and loss models, but we will not be presenting such models in this tutorial.</p>
</section>
<section id="quantum-memory">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Quantum memory</a><a class="headerlink" href="#quantum-memory" title="Link to this heading"></a></h2>
<p>While quantum channels are used to transmit qubits, we also need a place to store qubits and to account for any decoherence they experience while they wait.
The component that is designed to handle qubit storage is the quantum memory (<a class="reference internal" href="api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory" title="netsquid.components.qmemory.QuantumMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumMemory</span></code></a>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components</span> <span class="kn">import</span> <span class="n">QuantumMemory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qmem</span> <span class="o">=</span> <span class="n">QuantumMemory</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;MyMemory&quot;</span><span class="p">,</span> <span class="n">num_positions</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>A quantum memory contains slots for storing qubits called <em>memory positions</em>
(<a class="reference internal" href="api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.MemoryPosition" title="netsquid.components.qmemory.MemoryPosition"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryPosition</span></code></a>).
We can add error models to the memory positions that will apply noise to qubits, which is (optionally) proportional to the time they have been idly waiting.
For example, let us consider the depolarize noise model
(<a class="reference internal" href="api_models/netsquid.components.models.qerrormodels.html#netsquid.components.models.qerrormodels.DepolarNoiseModel" title="netsquid.components.models.qerrormodels.DepolarNoiseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DepolarNoiseModel</span></code></a>),
which applies depolarizing noise to the qubit.
The speed at which the depolarization happens is called the depolarization rate, which if set
to the (arbitrary) value of 1 MHz means that after a microsecond there is a 63% probability of depolarization.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components.models.qerrormodels</span> <span class="kn">import</span> <span class="n">DepolarNoiseModel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">depolar_noise</span> <span class="o">=</span> <span class="n">DepolarNoiseModel</span><span class="p">(</span><span class="n">depolar_rate</span><span class="o">=</span><span class="mf">1e6</span><span class="p">)</span>  <span class="c1"># the depolar_rate is in Hz</span>
</pre></div>
</div>
<p>A quantum memory can have multiple memory positions that can each be assigned its own error model.
The models can be specified during initialisation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qmem</span> <span class="o">=</span> <span class="n">QuantumMemory</span><span class="p">(</span><span class="s2">&quot;DepolarMemory&quot;</span><span class="p">,</span> <span class="n">num_positions</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">memory_noise_models</span><span class="o">=</span><span class="p">[</span><span class="n">depolar_noise</span><span class="p">,</span> <span class="n">depolar_noise</span><span class="p">])</span>
</pre></div>
</div>
<p>The models can be added to memory positions as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">mem_pos</span> <span class="ow">in</span> <span class="n">qmem</span><span class="o">.</span><span class="n">mem_positions</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">mem_pos</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="s1">&#39;noise_model&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">depolar_noise</span>
</pre></div>
</div>
<p>To insert a qubit into a quantum memory, it can be <a class="reference internal" href="api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.put" title="netsquid.components.qmemory.QuantumMemory.put"><code class="xref py py-meth docutils literal notranslate"><span class="pre">put()</span></code></a> into the memory.
To get it back out again, we can <a class="reference internal" href="api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.pop" title="netsquid.components.qmemory.QuantumMemory.pop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code></a> it from the memory.
If we only want to verify it is in the memory, we can <a class="reference internal" href="api_components/netsquid.components.qmemory.html#netsquid.components.qmemory.QuantumMemory.peek" title="netsquid.components.qmemory.QuantumMemory.peek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peek()</span></code></a> at it.
Peeking can be very useful for debugging purposes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.qubits.qubitapi</span> <span class="kn">import</span> <span class="n">create_qubits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qubits</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qmem</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qmem</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[Qubit(&#39;QS#0-0&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qmem</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">positions</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[Qubit(&#39;QS#0-0&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qmem</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[None]</span>
</pre></div>
</div>
<p>The quantum memory can also be used to instantly operate on qubits.
This is different to applying physical gates to qubits, which will be explained in the quantum processor section.
To operate we need to select a qubit, and choose an operation to apply.
Let’s start with applying an X gate.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">netsquid.qubits.operators</span> <span class="k">as</span> <span class="nn">ops</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qmem</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qmem</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>In a later tutorial more advanced operations will be discussed, again including models.</p>
<p>Finally a quantum memory can also measure the qubits.
By default a measurement is performed in the standard (Z) basis.
The result of a measurement contains two lists with information.
The first list contains the measurement outcome for every qubit which was measured.
The second list contains the probability of getting that particular outcome.
We can measure the qubit we made in the previous example like so:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qmem</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">positions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">([1], [1.0])</span>
</pre></div>
</div>
<p>To change the measurement basis we can give an observable or measurement operators.
For instance to measure in the Hadamard (X) basis, we can specify the <code class="docutils literal notranslate"><span class="pre">X</span></code> observable:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qmem</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">positions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">observable</span><span class="o">=</span><span class="n">ops</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>  
<span class="go">([...], [0.5])</span>
</pre></div>
</div>
<p>Now we can manipulate qubits using a quantum memory!
Next we will show how to connect it to channels and finish our game of ping pong.</p>
</section>
<section id="ports">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Ports</a><a class="headerlink" href="#ports" title="Link to this heading"></a></h2>
<p>In the previous tutorial we have seen a game of quantum ping pong simulated using the discrete event paradigm using concepts such as entities, events, event handlers,
and event expressions.
Before revisiting this example with components, here is a quick recap:</p>
<blockquote>
<div><p>The Ping entity sends out a ping to the Pong entity. When Pong receives the ping, it measures their shared qubit in the Hadamard (X) basis, and then sends a pong back to the Ping entity.
On receiving the pong, the Ping entity measures the qubit in the standard (Z) basis, and repeats.</p>
</div></blockquote>
<a class="reference internal image-reference" href="_images/aafig-7b6265eeb23951a73c17d792d40fd611c4a6172c.svg" id="pingpong-example"><img alt="_images/aafig-7b6265eeb23951a73c17d792d40fd611c4a6172c.svg" class="align-center" height="202.0" id="pingpong-example" src="_images/aafig-7b6265eeb23951a73c17d792d40fd611c4a6172c.svg" width="1028.0" /></a>
<p>We have seen how to use a channel and the quantum memory.
For the game of ping pong we want the qubit to be physically transported between the two players using channels,
and to automatically transfer the qubit from the channel to the quantum memory when it arrives.
Both the channel and quantum memory are components, and all components share the same interface for communication,
namely ports (<a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Port" title="netsquid.components.component.Port"><code class="xref py py-class docutils literal notranslate"><span class="pre">Port</span></code></a>).
Ports allow for modularity, and the full power of ports will be shown in the next tutorial.
Here we will introduce ports and how to connect them.</p>
<a class="reference internal image-reference" href="_images/ports_connect.png"><img alt="_images/ports_connect.png" class="align-center" src="_images/ports_connect.png" style="height: 150px;" /></a>
<p>Previously we used the methods <cite>send()</cite> and <cite>receive()</cite> of the <em>Channel</em> class.
These are actually convenience methods that make use of the <em>send</em> and <em>recv</em> ports on a channel, respectively.
Thus instead of calling <em>send</em> and <em>receive</em>, it also possible to do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">channel</span> <span class="o">=</span> <span class="n">Channel</span><span class="p">(</span><span class="s2">&quot;TutorialChannel&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">channel</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;send&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tx_input</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ns</span><span class="o">.</span><span class="n">sim_run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">channel</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;recv&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rx_output</span><span class="p">()</span>
<span class="go">Message(items=[&#39;hello&#39;], header=None, ch_delta_time=3.0)</span>
</pre></div>
</div>
<p>Ports expect to transmit (TX) and receive (RX) <em>message</em> objects (<a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Message" title="netsquid.components.component.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>);
for convenience they will wrap a non-message input into a message (as done with “hello” above).
A message is made up of a list of items (the payload), and an optional dictionary of meta data fields.
The meta data is intended to be used for the users convenience – some built in components will also attach meta fields to messages that pass through them.</p>
<p>Ports are always attached to a component, so a distinction is made between transmitting a message <em>into</em> a component (<a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Port.tx_input" title="netsquid.components.component.Port.tx_input"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tx_input()</span></code></a>) or <em>out of</em> a component (<a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Port.tx_output" title="netsquid.components.component.Port.tx_output"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tx_output()</span></code></a>).
Similarly, there is a difference between receiving a message that has been output from a component (<a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Port.rx_output" title="netsquid.components.component.Port.rx_output"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rx_output()</span></code></a>) or that has been input into a component (<a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Port.rx_input" title="netsquid.components.component.Port.rx_input"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rx_input()</span></code></a>).
So whereas users of a channel we transmit input and receive output, the internal implementation of the channel, which we do not need to know about, will receive input and transmit output.</p>
<p>Two ports can be connected using the <a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Port.connect" title="netsquid.components.component.Port.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> method, which will directly pass transmitted output from one port to the received input of the other, and vice versa.
Note that the connecting ports must belong to different components, and these components should have the same sub-component hierarchy i.e. either they both belong to the same super-component, or both have no super-component (parent).</p>
<p>For our PingPong game we want to send the qubit via the channel and store it in the quantum memory on the receiving side.
As shown earlier, a quantum memory can use <cite>put()</cite> to store a qubit.
An alternative to put is to send a message containing a list of qubits to the <em>qin</em> port of the quantum memory,
or a message with a single qubit to a specific <em>qinX</em> port, where <em>X</em> is the index of a specific memory position.
When we connect this port to the receive port of the channel, the arrived qubit will be automatically stored.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">channel</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;recv&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">qmem</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;qin0&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>With the ports connected we can send our qubit via the channel and have it automatically passed onto the quantum memory on the other side:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qubit</span><span class="p">,</span> <span class="o">=</span> <span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="go">Qubit(&#39;QS#1-0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ns</span><span class="o">.</span><span class="n">sim_run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qmem</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[Qubit(&#39;QS#1-0&#39;)]</span>
</pre></div>
</div>
</section>
<section id="ping-pong-using-components-and-ports">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Ping pong using components and ports</a><a class="headerlink" href="#ping-pong-using-components-and-ports" title="Link to this heading"></a></h2>
<p>Let us now put these new features together for the ping pong example.
We again define a <em>PingEntity</em> and <em>PongEntity</em> with similar methods as in the previous section,
however now they will hold a quantum memory that has its output port connected to the input (<em>send</em> port) of a quantum channel.
Instead of waiting on each other’s ping and pong events as before,
we now tell each entity to wait for qubits arriving on their quantum memory’s input port <em>qin0</em>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components.component</span> <span class="kn">import</span> <span class="n">Port</span>
<span class="gp">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">PingEntity</span><span class="p">(</span><span class="n">pydynaa</span><span class="o">.</span><span class="n">Entity</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">length</span> <span class="o">=</span> <span class="mf">2e-3</span>  <span class="c1"># channel length [km]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># Create a memory and a quantum channel:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span> <span class="o">=</span> <span class="n">QuantumMemory</span><span class="p">(</span><span class="s2">&quot;PingMemory&quot;</span><span class="p">,</span> <span class="n">num_positions</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qchannel</span> <span class="o">=</span> <span class="n">QuantumChannel</span><span class="p">(</span><span class="s2">&quot;PingChannel&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
<span class="gp">... </span>                                       <span class="n">models</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;delay_model&quot;</span><span class="p">:</span> <span class="n">FibreDelayModel</span><span class="p">()})</span>
<span class="gp">... </span>        <span class="c1"># link output from qmemory (pop) to input of ping channel:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qout&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qchannel</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;send&quot;</span><span class="p">])</span>
<span class="gp">... </span>        <span class="c1"># Setup callback function to handle input on quantum memory port &quot;qin0&quot;:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_wait</span><span class="p">(</span><span class="n">pydynaa</span><span class="o">.</span><span class="n">EventHandler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle_input_qubit</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="n">entity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin0&quot;</span><span class="p">],</span> <span class="n">event_type</span><span class="o">=</span><span class="n">Port</span><span class="o">.</span><span class="n">evtype_input</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">notify_all_input</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># Start the game by having ping player send the first qubit (ping)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qchannel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">wait_for_pong</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_entity</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># Setup this entity to pass incoming qubits to its quantum memory</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">other_entity</span><span class="o">.</span><span class="n">qchannel</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;recv&quot;</span><span class="p">])</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_handle_input_qubit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># Callback function called by the pong handler when pong event is triggered</span>
<span class="gp">... </span>        <span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="p">[</span><span class="n">prob</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">positions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">observable</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">labels_z</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;|0&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;|1&gt;&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">()</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">: Pong event! PingEntity measured &quot;</span>
<span class="gp">... </span>              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">labels_z</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="si">}</span><span class="s2"> with probability </span><span class="si">{</span><span class="n">prob</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">positions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">PongEntity</span><span class="p">(</span><span class="n">pydynaa</span><span class="o">.</span><span class="n">Entity</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">length</span> <span class="o">=</span> <span class="mf">2e-3</span>  <span class="c1"># channel length [km]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># Create a memory and a quantum channel:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span> <span class="o">=</span> <span class="n">QuantumMemory</span><span class="p">(</span><span class="s2">&quot;PongMemory&quot;</span><span class="p">,</span> <span class="n">num_positions</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qchannel</span> <span class="o">=</span> <span class="n">QuantumChannel</span><span class="p">(</span><span class="s2">&quot;PingChannel&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
<span class="gp">... </span>                                       <span class="n">models</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;delay_model&quot;</span><span class="p">:</span> <span class="n">FibreDelayModel</span><span class="p">()})</span>
<span class="gp">... </span>        <span class="c1"># link output from qmemory (pop) to input of ping channel:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qout&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qchannel</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;send&quot;</span><span class="p">])</span>
<span class="gp">... </span>        <span class="c1"># Setup callback function to handle input on quantum memory:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_wait</span><span class="p">(</span><span class="n">pydynaa</span><span class="o">.</span><span class="n">EventHandler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle_input_qubit</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="n">entity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin0&quot;</span><span class="p">],</span> <span class="n">event_type</span><span class="o">=</span><span class="n">Port</span><span class="o">.</span><span class="n">evtype_input</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">notify_all_input</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">wait_for_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_entity</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># Setup this entity to pass incoming qubits to its quantum memory</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">other_entity</span><span class="o">.</span><span class="n">qchannel</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;recv&quot;</span><span class="p">])</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_handle_input_qubit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># Callback function called by the pong handler when pong event is triggered</span>
<span class="gp">... </span>        <span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="p">[</span><span class="n">prob</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">positions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">observable</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">labels_x</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;|+&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;|-&gt;&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">()</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">: Ping event! PongEntity measured &quot;</span>
<span class="gp">... </span>              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">labels_x</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="si">}</span><span class="s2"> with probability </span><span class="si">{</span><span class="n">prob</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">positions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Note that we have chosen to define two separate classes for clarity,
but given their similarity we could just as well have defined a single common class for better maintainability.</p>
<p>The simulation setup is the same as before, except that now the linking of pong with ping and vice versa is done by connecting ports instead of waiting on specific ping and pong events (which have been removed):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create entities and register them to each other</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ns</span><span class="o">.</span><span class="n">sim_reset</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ping</span> <span class="o">=</span> <span class="n">PingEntity</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pong</span> <span class="o">=</span> <span class="n">PongEntity</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ping</span><span class="o">.</span><span class="n">wait_for_pong</span><span class="p">(</span><span class="n">pong</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pong</span><span class="o">.</span><span class="n">wait_for_ping</span><span class="p">(</span><span class="n">ping</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a qubit and instruct the ping entity to start</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qubit</span><span class="p">,</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ping</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
</pre></div>
</div>
<p>Also running the simulation gives the same results:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ns</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">sim_run</span><span class="p">(</span><span class="mi">91</span><span class="p">)</span>
<span class="go">10.0: Ping event! PongEntity measured |+&gt; with probability 0.50</span>
<span class="go">20.0: Pong event! PingEntity measured |1&gt; with probability 0.50</span>
<span class="go">30.0: Ping event! PongEntity measured |-&gt; with probability 0.50</span>
<span class="go">40.0: Pong event! PingEntity measured |1&gt; with probability 0.50</span>
<span class="go">50.0: Ping event! PongEntity measured |+&gt; with probability 0.50</span>
<span class="go">60.0: Pong event! PingEntity measured |0&gt; with probability 0.50</span>
<span class="go">70.0: Ping event! PongEntity measured |+&gt; with probability 0.50</span>
<span class="go">80.0: Pong event! PingEntity measured |1&gt; with probability 0.50</span>
<span class="go">90.0: Ping event! PongEntity measured |-&gt; with probability 0.50</span>
</pre></div>
</div>
<p>In this example we saw how to describe simulation timing with components.
By using components building and modifying a network becomes easier and more structured.
Next we will use what we have learned to build a quantum teleportation scheme using components.</p>
</section>
<section id="quantum-teleportation-using-components">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Quantum teleportation using components <sup>*</sup></a><a class="headerlink" href="#quantum-teleportation-using-components" title="Link to this heading"></a></h2>
<p>In the previous tutorial on the discrete event simulation we worked with a quantum teleportation example.
In this tutorial we will also extend this example with components.
We reset the simulation engine and again switch to the density matrix formalism to demonstrate the effects on noise on the final fidelity without the need of sampling.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ns</span><span class="o">.</span><span class="n">set_qstate_formalism</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">QFormalism</span><span class="o">.</span><span class="n">DM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ns</span><span class="o">.</span><span class="n">sim_reset</span><span class="p">()</span>
</pre></div>
</div>
<p>We will again introduce the simulation entities Alice and Bob.
This time, however, they each hold a quantum memory for storing and manipulating their qubits.
They are also now initialised with the send and receive ports of the classical channel that they will use to exchange the classical corrections.
In the next section we will see how we can use nodes to simplify such communication connections even further.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Alice</span><span class="p">(</span><span class="n">pydynaa</span><span class="o">.</span><span class="n">Entity</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">teleport_state</span><span class="p">,</span> <span class="n">cchannel_send_port</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">teleport_state</span> <span class="o">=</span> <span class="n">teleport_state</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">cchannel_send_port</span> <span class="o">=</span> <span class="n">cchannel_send_port</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span> <span class="o">=</span> <span class="n">QuantumMemory</span><span class="p">(</span><span class="s2">&quot;AliceMemory&quot;</span><span class="p">,</span> <span class="n">num_positions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_wait</span><span class="p">(</span><span class="n">pydynaa</span><span class="o">.</span><span class="n">EventHandler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle_input_qubit</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="n">entity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin1&quot;</span><span class="p">],</span> <span class="n">event_type</span><span class="o">=</span><span class="n">Port</span><span class="o">.</span><span class="n">evtype_input</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">notify_all_input</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_handle_input_qubit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># Callback function that does teleportation and</span>
<span class="gp">... </span>        <span class="c1"># schedules a corrections ready event</span>
<span class="gp">... </span>        <span class="n">q0</span><span class="p">,</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">create_qubits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">no_state</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">assign_qstate</span><span class="p">([</span><span class="n">q0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">teleport_state</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="n">q0</span><span class="p">],</span> <span class="n">positions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">CNOT</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>        <span class="n">m0</span><span class="p">,</span> <span class="n">m1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">positions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">observable</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">discard</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">cchannel_send_port</span><span class="o">.</span><span class="n">tx_input</span><span class="p">([</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">])</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">()</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">: Alice received entangled qubit, &quot;</span>
<span class="gp">... </span>              <span class="sa">f</span><span class="s2">&quot;measured qubits &amp; sending corrections&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bob</span><span class="p">(</span><span class="n">pydynaa</span><span class="o">.</span><span class="n">Entity</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">depolar_rate</span> <span class="o">=</span> <span class="mf">1e7</span>  <span class="c1"># depolarization rate of waiting qubits [Hz]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cchannel_recv_port</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">noise_model</span> <span class="o">=</span> <span class="n">DepolarNoiseModel</span><span class="p">(</span><span class="n">depolar_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">depolar_rate</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span> <span class="o">=</span> <span class="n">QuantumMemory</span><span class="p">(</span><span class="s2">&quot;BobMemory&quot;</span><span class="p">,</span> <span class="n">num_positions</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">memory_noise_models</span><span class="o">=</span><span class="p">[</span><span class="n">noise_model</span><span class="p">])</span>
<span class="gp">... </span>        <span class="n">cchannel_recv_port</span><span class="o">.</span><span class="n">bind_output_handler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle_corrections</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_handle_corrections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># Callback function that handles messages from both Alice and Charlie</span>
<span class="gp">... </span>        <span class="n">m0</span><span class="p">,</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">items</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">m1</span><span class="p">:</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">m0</span><span class="p">:</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>        <span class="n">qubit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">positions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>        <span class="n">fidelity</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">fidelity</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">ns</span><span class="o">.</span><span class="n">y0</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">()</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">: Bob received entangled qubit and corrections!&quot;</span>
<span class="gp">... </span>              <span class="sa">f</span><span class="s2">&quot; Fidelity = </span><span class="si">{</span><span class="n">fidelity</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We see that Alice will wait for a qubit to arrive on her memory from Charlie, perform the Bell measurement as before, then send the classical corrections via the port she holds to Bob.
For Bob we have this time assumed (for simplicity) that the corrections from Alice will arrive after his qubit from Charlie, which means we can avoid using event expressions as before.
Instead we demonstrate how a message handler callback, <code class="docutils literal notranslate"><span class="pre">_handle_corrections()</span></code>, can be bound using <a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Port.bind_output_handler" title="netsquid.components.component.Port.bind_output_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind_output_handler()</span></code></a> to the port at Bob’s end of the classical channel,
which will be passed any output message that arrives on it.
Similarly for binding any input message one can use <a class="reference internal" href="api_components/netsquid.components.component.html#netsquid.components.component.Port.bind_input_handler" title="netsquid.components.component.Port.bind_input_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind_input_handler()</span></code></a>.</p>
<p>Regarding Charlie, rather than again defining a simulation entity class, we will instead automate his entanglement generation completely using components.
A new component we need to replace Charlie is the quantum source (<a class="reference internal" href="api_components/netsquid.components.qsource.html#netsquid.components.qsource.QSource" title="netsquid.components.qsource.QSource"><code class="xref py py-class docutils literal notranslate"><span class="pre">QSource</span></code></a>), which we will connect to Alice and Bob via quantum channels.
A quantum source is a component that can generate one or more qubits in a specific or randomly sampled quantum state.
In the latter case we can specify what state to assign to the generated qubit(s) using a <em>state sampler</em> object (<code class="xref py py-class docutils literal notranslate"><span class="pre">StateSampler</span></code>):</p>
<p>The statesampler is initialised with a list of states and a list of matching probabilities.
A random state from this list can be sampled with the <a class="reference internal" href="api_qubits/netsquid.qubits.state_sampler.html#netsquid.qubits.state_sampler.StateSampler.sample" title="netsquid.qubits.state_sampler.StateSampler.sample"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sample()</span></code></a> method.
For this example we will always want the entangled bell state <span class="math notranslate nohighlight">\(\vert B_{00}\rangle\)</span>, which is represented by <a class="reference internal" href="api_qubits/netsquid.qubits.ketstates.html#netsquid.qubits.ketstates.b00" title="netsquid.qubits.ketstates.b00"><code class="xref py py-obj docutils literal notranslate"><span class="pre">b00</span></code></a> in NetSquid:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.qubits.state_sampler</span> <span class="kn">import</span> <span class="n">StateSampler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">netsquid.qubits.ketstates</span> <span class="k">as</span> <span class="nn">ks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_sampler</span> <span class="o">=</span> <span class="n">StateSampler</span><span class="p">([</span><span class="n">ks</span><span class="o">.</span><span class="n">b00</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">])</span>
</pre></div>
</div>
<p>Because we want to send the two generated qubits in different directions, one for Alice and one for Bob, we will specify two output ports to the quantum source constructor with the default names <em>qout0</em> and <em>qout1</em>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components.qsource</span> <span class="kn">import</span> <span class="n">QSource</span><span class="p">,</span> <span class="n">SourceStatus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">charlie_source</span> <span class="o">=</span> <span class="n">QSource</span><span class="p">(</span><span class="s2">&quot;Charlie&quot;</span><span class="p">,</span> <span class="n">state_sampler</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">num_ports</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">timing_model</span><span class="o">=</span><span class="n">FixedDelayModel</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">50</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">status</span><span class="o">=</span><span class="n">SourceStatus</span><span class="o">.</span><span class="n">INTERNAL</span><span class="p">)</span>
</pre></div>
</div>
<p>The quantum source can be in one of three modes specified by the <a class="reference internal" href="api_components/netsquid.components.qsource.html#netsquid.components.qsource.SourceStatus" title="netsquid.components.qsource.SourceStatus"><code class="xref py py-class docutils literal notranslate"><span class="pre">SourceStatus</span></code></a> enumerator: OFF (the default), INTERNAL, and EXTERNAL.
In the internal mode the source operates using its internal clock component (<a class="reference internal" href="api_components/netsquid.components.clock.html#netsquid.components.clock.Clock" title="netsquid.components.clock.Clock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clock</span></code></a>), which can be initialised using the <code class="docutils literal notranslate"><span class="pre">frequency</span></code> or <code class="docutils literal notranslate"><span class="pre">timing_model</span></code> parameters.
In the external mode the source waits to be externally triggered by receiving any message on its <em>trigger</em> port.
We can also call <a class="reference internal" href="api_components/netsquid.components.qsource.html#netsquid.components.qsource.QSource.trigger" title="netsquid.components.qsource.QSource.trigger"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trigger()</span></code></a> manually to emulate a trigger message arriving on the port.
In the example above we have chosen to use the internal clock with a delay of 50 ns (frequency of 20 GHz).</p>
<p>To setup the network to generate entanglement for Alice and Bob, we connect the output ports of the quantum source to two one-way quantum channels, which we in turn connect to the inputs on the quantum memories of Alice and Bob:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">setup_network</span><span class="p">(</span><span class="n">alice</span><span class="p">,</span> <span class="n">bob</span><span class="p">,</span> <span class="n">qsource</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mf">4e-3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">qchannel_c2a</span> <span class="o">=</span> <span class="n">QuantumChannel</span><span class="p">(</span><span class="s2">&quot;Charlie-&gt;Alice&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="n">models</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;delay_model&quot;</span><span class="p">:</span> <span class="n">FibreDelayModel</span><span class="p">()})</span>
<span class="gp">... </span>    <span class="n">qchannel_c2b</span> <span class="o">=</span> <span class="n">QuantumChannel</span><span class="p">(</span><span class="s2">&quot;Charlie-&gt;Bob&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="n">models</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;delay_model&quot;</span><span class="p">:</span> <span class="n">FibreDelayModel</span><span class="p">()})</span>
<span class="gp">... </span>    <span class="n">qsource</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;qout0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">qchannel_c2a</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;send&#39;</span><span class="p">])</span>
<span class="gp">... </span>    <span class="n">qsource</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;qout1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">qchannel_c2b</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;send&#39;</span><span class="p">])</span>
<span class="gp">... </span>    <span class="n">alice</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;qin1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">qchannel_c2a</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;recv&#39;</span><span class="p">])</span>
<span class="gp">... </span>    <span class="n">bob</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;qin0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">qchannel_c2b</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;recv&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>We can now create the Alice and Bob entities together with a classical channel between them, and call the network setup:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.components</span> <span class="kn">import</span> <span class="n">ClassicalChannel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cchannel</span> <span class="o">=</span> <span class="n">ClassicalChannel</span><span class="p">(</span><span class="s2">&quot;CChannel&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mf">4e-3</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">models</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;delay_model&quot;</span><span class="p">:</span> <span class="n">FibreDelayModel</span><span class="p">()})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alice</span> <span class="o">=</span> <span class="n">Alice</span><span class="p">(</span><span class="n">teleport_state</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">y0</span><span class="p">,</span> <span class="n">cchannel_send_port</span><span class="o">=</span><span class="n">cchannel</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;send&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bob</span> <span class="o">=</span> <span class="n">Bob</span><span class="p">(</span><span class="n">cchannel_recv_port</span><span class="o">=</span><span class="n">cchannel</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;recv&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setup_network</span><span class="p">(</span><span class="n">alice</span><span class="p">,</span> <span class="n">bob</span><span class="p">,</span> <span class="n">charlie_source</span><span class="p">)</span>
</pre></div>
</div>
<p>Running the simulation for two entanglement cycles gives us a noisy fidelity outcome as before:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">sim_run</span><span class="p">(</span><span class="n">end_time</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="go">10.0: Alice received entangled qubit, measured qubits &amp; sending corrections</span>
<span class="go">30.0: Bob received entangled qubit and corrections! Fidelity = 0.909</span>
<span class="go">60.0: Alice received entangled qubit, measured qubits &amp; sending corrections</span>
<span class="go">80.0: Bob received entangled qubit and corrections! Fidelity = 0.909</span>
</pre></div>
</div>
<p>One important difference from the same example presented in the last section is that the quantum noise has now been handled automatically by the quantum memories.</p>
<section id="what-is-next">
<h3>What is next?<a class="headerlink" href="#what-is-next" title="Link to this heading"></a></h3>
<p>In this tutorial we presented how the game of ping pong and quantum teleportation example from the previous section can be improved using the base components of NetSquid and their ports.
In the next tutorial we will start creating composite components such as nodes and connections to improve and simplify the network setup even more.
It will introduce components with sub-components and how ports can be forwarded between them, allowing for multiple layers of abstraction.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tutorial.pydynaa.html" class="btn btn-neutral float-left" title="Discrete event simulation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tutorial.nodes.html" class="btn btn-neutral float-right" title="Nodes and Connections" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2021, TNO and TUDelft (QuTech).</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: 1.1.7
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
      <dd><a href="/1-1-stable/">1.1.5</a></dd>
      <dd><a href="/1-0-stable/">1.0.7</a></dd>
      <dd><a href="/0-10-stable/">0.10.4</a></dd>
      <dd><a href="/0-9-stable/">0.9.11</a></dd>
      <dd><a href="/0-8-stable/">0.8.7</a></dd>
      <dd><a href="/0-7-stable/">0.7.5</a></dd>
      <dd><a href="/0-6-stable/">0.6.4</a></dd>
      <dd><a href="/0-5-stable/">0.5.2</a></dd>
      <dd><a href="/0-4-stable/">0.4.2</a></dd>
      <dd><a href="/0-3-stable/">0.3.5</a></dd>
      <dd><a href="/latest-release/">latest release</a></dd>
      <dd><a href="/master/">master branch</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".highlight-default .highlight").each(function() {
            if ($(this).find(".gp").length > 0) {
             $(this).prepend("<div class='codebtn btn btn-neutral float-right'><div class='gp'>>>></div><div>");
             $(this).children("pre").contents().filter(function() {return this.nodeType === 3;}).wrap("<span></span>").end();
            }
        });
        $(".highlight-default .highlight .codebtn").click(function() {
            $(this).parent().children("pre").find(".gp").toggleClass("hidden");
            var traceback_elem = $(this).parent().children("pre").find(".gt, .go");
            traceback_elem.toggleClass("hidden");
            traceback_elem.nextUntil(".gp, .go").toggleClass("hidden");

        })
    });
</script>


</body>
</html>