<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Repeater chain &mdash; NetSquid 1.1.7 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=370aedac"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="A simple link layer protocol" href="learn.examples.simple_link.html" />
    <link rel="prev" title="Repeater with purification" href="learn.examples.repeater.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #E3E3E3" >

          
          
          <a href="../index.html" class="icon icon-home">
            NetSquid
              <img src="../_static/squid-150.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.1.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../INSTALL.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RELEASE.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AUTHORS.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LICENSE.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Learn NetSquid</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quick_start.html">NetSquid in 10 minutes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.intro.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.qubits.html">Qubits and quantum computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.pydynaa.html">Discrete event simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.components.html">Modelling of network components</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.nodes.html">Nodes and Connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.quantumprocessor.html">The Quantum Processor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.simulation.html">A full simulation</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../learn.examples.html">Examples</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="learn.examples.teleportation.html">Teleportation</a></li>
<li class="toctree-l2"><a class="reference internal" href="learn.examples.repeater.html">Repeater with purification</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Repeater chain</a></li>
<li class="toctree-l2"><a class="reference internal" href="learn.examples.simple_link.html">A simple link layer protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="learn.examples.magic_simple_link.html">Faster Link layer Protocol using abstraction</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api_reference.html">NetSquid package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.qubits.html">netsquid.qubits</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qformalism.html">netsquid.qubits.qformalism</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qubitapi.html">netsquid.qubits.qubitapi</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.operators.html">netsquid.qubits.operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.cliffords.html">netsquid.qubits.cliffords</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.ketstates.html">netsquid.qubits.ketstates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.state_sampler.html">netsquid.qubits.state_sampler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qubit.html">netsquid.qubits.qubit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qstate.html">netsquid.qubits.qstate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qrepr.html">netsquid.qubits.qrepr</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.kettools.html">netsquid.qubits.kettools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.dmtools.html">netsquid.qubits.dmtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.sparsedmtools.html">netsquid.qubits.sparsedmtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.stabtools.html">netsquid.qubits.stabtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.gslctools.html">netsquid.qubits.gslctools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qreprutil.html">netsquid.qubits.qreprutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.ketutil.html">netsquid.qubits.ketutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.dmutil.html">netsquid.qubits.dmutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.sparseutil.html">netsquid.qubits.sparseutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.gslcutil.html">netsquid.qubits.gslcutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.opmath.html">netsquid.qubits.opmath</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.components.html">netsquid.components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.component.html">netsquid.components.component</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.channel.html">netsquid.components.channel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qchannel.html">netsquid.components.qchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.cchannel.html">netsquid.components.cchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.cqchannel.html">netsquid.components.cqchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qmemory.html">netsquid.components.qmemory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.instructions.html">netsquid.components.instructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qprogram.html">netsquid.components.qprogram</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qprocessor.html">netsquid.components.qprocessor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.clock.html">netsquid.components.clock</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qsource.html">netsquid.components.qsource</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qdetector.html">netsquid.components.qdetector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.switch.html">netsquid.components.switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.ccoding.html">netsquid.components.ccoding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.components.models.html">netsquid.components.models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.model.html">netsquid.components.models.model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.delaymodels.html">netsquid.components.models.delaymodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.errormodels.html">netsquid.components.models.errormodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.qerrormodels.html">netsquid.componentsmodels.qerrormodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.cerrormodels.html">netsquid.components.models.cerrormodels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.nodes.html">netsquid.nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.node.html">netsquid.nodes.node</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.connections.html">netsquid.nodes.connections</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.network.html">netsquid.nodes.network</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.protocols.html">netsquid.protocols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html">netsquid.protocols.protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.nodeprotocols.html">netsquid.protocols.nodeprotocols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html">netsquid.protocols.serviceprotocol</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.util.html">netsquid.util</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simtools.html">netsquid.util.simtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simlog.html">netsquid.util.simlog</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simstats.html">netsquid.util.simstats</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.datacollector.html">netsquid.util.datacollector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.cycache.html">netsquid.util.cycache</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.cymath.html">netsquid.util.cymath</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html">netsquid.util.constrainedmap</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.examples.html">netsquid.examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.teleportation.html">netsquid.examples.teleportation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.entanglenodes.html">netsquid.examples.entanglenodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.purify.html">netsquid.examples.purify</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.repeater.html">netsquid.examples.repeater</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.repeater_chain.html">netsquid.examples.repeater_chain</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.simple_link.html">netsquid.examples.simple_link</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.magic_simple_link.html">netsquid.examples.magic_simple_link</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api_pydynaa.html">pyDynAA package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html">pydynaa.Entity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-event">pydynaa.Event</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventtype">pydynaa.EventType</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventexpression">pydynaa.EventExpression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventhandler">pydynaa.EventHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-expressionhandler">pydynaa.ExpressionHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-simulationengine">pydynaa.SimulationEngine</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">For developers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../INSTALL-SOURCE.html">Installation from source</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CHANGELOG.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #E3E3E3" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">NetSquid</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../learn.examples.html">Examples</a></li>
      <li class="breadcrumb-item active">Repeater chain</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/learn_examples/learn.examples.repeater_chain.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="learn.examples.repeater.html" class="btn btn-neutral float-left" title="Repeater with purification" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="learn.examples.simple_link.html" class="btn btn-neutral float-right" title="A simple link layer protocol" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="repeater-chain">
<h1>Repeater chain<a class="headerlink" href="#repeater-chain" title="Link to this heading">ÔÉÅ</a></h1>
<p>In this example we show how a simple quantum repeater chain network can be setup and simulated in NetSquid.
The module file used in this example can be located as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">netsquid</span> <span class="k">as</span> <span class="nn">ns</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This example module is located at: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
<span class="gp">... </span>      <span class="n">ns</span><span class="o">.</span><span class="n">examples</span><span class="o">.</span><span class="n">repeater_chain</span><span class="o">.</span><span class="vm">__file__</span><span class="p">))</span>
<span class="go">This example module is located at: .../netsquid/examples/repeater_chain.py</span>
</pre></div>
</div>
<p>In the <a class="reference external" href="netsquid.examples.repeater.html">repeater example</a> we simulated a single quantum repeater on a network topology consisting of two nodes
connected via a single repeater node (see for instance <a class="reference external" href="https://arxiv.org/abs/quant-ph/9803056">[Briegel et al.]</a> for more background).
To simulate a repeater chain we will extend this network topology to be a line of <em>N</em> nodes as shown below:</p>
<a class="reference internal image-reference" href="../_images/aafig-5225dd26c7e6031bedbb3069f01c6f6865d36af2.svg"><img alt="../_images/aafig-5225dd26c7e6031bedbb3069f01c6f6865d36af2.svg" height="90.0" src="../_images/aafig-5225dd26c7e6031bedbb3069f01c6f6865d36af2.svg" width="930.0" /></a>
<p>We will refer to the outer nodes as <em>end nodes</em>, and sometimes also as Alice and Bob for convenience,
and the in between nodes as the <em>repeater nodes</em>.
The lines between the nodes represent both an entangling connection and a classical connection,
as introduced in the <a class="reference external" href="netsquid.examples.teleportation.html">teleportation example</a>.
The repeaters will use a so-called <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_teleportation">entanglement swapping scheme</a> to entangle the end nodes,
which consists of the following steps:</p>
<ol class="arabic simple">
<li><p>generating entanglement with both of its neighbours,</p></li>
<li><p>measuring its two locally stored qubits in the Bell basis,</p></li>
<li><p>sending its own measurement outcomes to its right neighbour, and also forwarding on outcomes received from its left neighbour in this way.</p></li>
</ol>
<p>Let us create the repeater chain network.
We need to create the <em>N</em> nodes, each with a quantum processor, and every pair of nodes
in the chain must be linked using an entangling connection and a classical connection.
In each entangling connection an entangled qubit generating source is available.
A schematic illustration of a repeater and its connections is shown below:</p>
<a class="reference internal image-reference" href="../_images/aafig-90baf27884520107d2f730db4e3a0aa141783e2b.svg"><img alt="../_images/aafig-90baf27884520107d2f730db4e3a0aa141783e2b.svg" height="188.0" src="../_images/aafig-90baf27884520107d2f730db4e3a0aa141783e2b.svg" width="874.0" /></a>
<p>We will re-use the Connection subclasses
<a class="reference internal" href="../api_examples/netsquid.examples.teleportation.html#netsquid.examples.teleportation.EntanglingConnection" title="netsquid.examples.teleportation.EntanglingConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">EntanglingConnection</span></code></a> and <a class="reference internal" href="../api_examples/netsquid.examples.teleportation.html#netsquid.examples.teleportation.ClassicalConnection" title="netsquid.examples.teleportation.ClassicalConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClassicalConnection</span></code></a>
created in the <a class="reference external" href="tutorial.simulation.html">teleportation tutorial</a> and
use the following function to create quantum processors for each node:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_qprocessor</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Factory to create a quantum processor for each node in the repeater chain network.</span>

<span class="sd">    Has two memory positions and the physical instructions necessary for teleportation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the quantum processor.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~netsquid.components.qprocessor.QuantumProcessor`</span>
<span class="sd">        A quantum processor to specification.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">noise_rate</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="n">gate_duration</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">gate_noise_model</span> <span class="o">=</span> <span class="n">DephaseNoiseModel</span><span class="p">(</span><span class="n">noise_rate</span><span class="p">)</span>
    <span class="n">mem_noise_model</span> <span class="o">=</span> <span class="n">DepolarNoiseModel</span><span class="p">(</span><span class="n">noise_rate</span><span class="p">)</span>
    <span class="n">physical_instructions</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">PhysicalInstruction</span><span class="p">(</span><span class="n">INSTR_X</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">gate_duration</span><span class="p">,</span>
                            <span class="n">quantum_noise_model</span><span class="o">=</span><span class="n">gate_noise_model</span><span class="p">),</span>
        <span class="n">PhysicalInstruction</span><span class="p">(</span><span class="n">INSTR_Z</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">gate_duration</span><span class="p">,</span>
                            <span class="n">quantum_noise_model</span><span class="o">=</span><span class="n">gate_noise_model</span><span class="p">),</span>
        <span class="n">PhysicalInstruction</span><span class="p">(</span><span class="n">INSTR_MEASURE_BELL</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">gate_duration</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="n">qproc</span> <span class="o">=</span> <span class="n">QuantumProcessor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">num_positions</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fallback_to_nonphysical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">mem_noise_models</span><span class="o">=</span><span class="p">[</span><span class="n">mem_noise_model</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                             <span class="n">phys_instructions</span><span class="o">=</span><span class="n">physical_instructions</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qproc</span>
</pre></div>
</div>
<p>We create a network component and add the nodes and connections to it.
This way we can easily keep track of all our components in the network, which will be useful when collecting data later.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setup_network</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">node_distance</span><span class="p">,</span> <span class="n">source_frequency</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Setup repeater chain network.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_nodes : int</span>
<span class="sd">        Number of nodes in the network, at least 3.</span>
<span class="sd">    node_distance : float</span>
<span class="sd">        Distance between nodes [km].</span>
<span class="sd">    source_frequency : float</span>
<span class="sd">        Frequency at which the sources create entangled qubits [Hz].</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~netsquid.nodes.network.Network`</span>
<span class="sd">        Network component with all nodes and connections as subcomponents.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_nodes</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can&#39;t create repeater chain with </span><span class="si">{</span><span class="n">num_nodes</span><span class="si">}</span><span class="s2"> nodes.&quot;</span><span class="p">)</span>
    <span class="n">network</span> <span class="o">=</span> <span class="n">Network</span><span class="p">(</span><span class="s2">&quot;Repeater_chain_network&quot;</span><span class="p">)</span>
    <span class="c1"># Create nodes with quantum processors</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">):</span>
        <span class="c1"># Prepend leading zeros to the number</span>
        <span class="n">num_zeros</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node_</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">0</span><span class="si">{</span><span class="n">num_zeros</span><span class="si">}</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">qmemory</span><span class="o">=</span><span class="n">create_qprocessor</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;qproc_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)))</span>
    <span class="n">network</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="c1"># Create quantum and classical connections:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">node_right</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Create quantum connection</span>
        <span class="n">qconn</span> <span class="o">=</span> <span class="n">EntanglingConnection</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;qconn_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">node_distance</span><span class="p">,</span>
                                     <span class="n">source_frequency</span><span class="o">=</span><span class="n">source_frequency</span><span class="p">)</span>
        <span class="c1"># Add a noise model which depolarizes the qubits exponentially</span>
        <span class="c1"># depending on the connection length</span>
        <span class="k">for</span> <span class="n">channel_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;qchannel_C2A&#39;</span><span class="p">,</span> <span class="s1">&#39;qchannel_C2B&#39;</span><span class="p">]:</span>
            <span class="n">qconn</span><span class="o">.</span><span class="n">subcomponents</span><span class="p">[</span><span class="n">channel_name</span><span class="p">]</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="s1">&#39;quantum_noise_model&#39;</span><span class="p">]</span> <span class="o">=</span>\
                <span class="n">FibreDepolarizeModel</span><span class="p">()</span>
        <span class="n">port_name</span><span class="p">,</span> <span class="n">port_r_name</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">node_right</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="n">qconn</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;quantum&quot;</span><span class="p">)</span>
        <span class="c1"># Forward qconn directly to quantum memories for right and left inputs:</span>
        <span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span><span class="o">.</span><span class="n">forward_input</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin0&quot;</span><span class="p">])</span>  <span class="c1"># R input</span>
        <span class="n">node_right</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="n">port_r_name</span><span class="p">]</span><span class="o">.</span><span class="n">forward_input</span><span class="p">(</span>
            <span class="n">node_right</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin1&quot;</span><span class="p">])</span>  <span class="c1"># L input</span>
        <span class="c1"># Create classical connection</span>
        <span class="n">cconn</span> <span class="o">=</span> <span class="n">ClassicalConnection</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;cconn_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">node_distance</span><span class="p">)</span>
        <span class="n">port_name</span><span class="p">,</span> <span class="n">port_r_name</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">node_right</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="n">cconn</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;classical&quot;</span><span class="p">,</span>
            <span class="n">port_name_node1</span><span class="o">=</span><span class="s2">&quot;ccon_R&quot;</span><span class="p">,</span> <span class="n">port_name_node2</span><span class="o">=</span><span class="s2">&quot;ccon_L&quot;</span><span class="p">)</span>
        <span class="c1"># Forward cconn to right most node</span>
        <span class="k">if</span> <span class="s2">&quot;ccon_L&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;ccon_L&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">bind_input_handler</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">message</span><span class="p">,</span> <span class="n">_node</span><span class="o">=</span><span class="n">node</span><span class="p">:</span> <span class="n">_node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;ccon_R&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tx_output</span><span class="p">(</span><span class="n">message</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">network</span>
</pre></div>
</div>
<p>We have used a custom noise model in this example, which helps to exaggerate the effectiveness of the repeater chain.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FibreDepolarizeModel</span><span class="p">(</span><span class="n">QuantumErrorModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Custom non-physical error model used to show the effectiveness</span>
<span class="sd">    of repeater chains.</span>

<span class="sd">    The default values are chosen to make a nice figure,</span>
<span class="sd">    and don&#39;t represent any physical system.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p_depol_init : float, optional</span>
<span class="sd">        Probability of depolarization on entering a fibre.</span>
<span class="sd">        Must be between 0 and 1. Default 0.009</span>
<span class="sd">    p_depol_length : float, optional</span>
<span class="sd">        Probability of depolarization per km of fibre.</span>
<span class="sd">        Must be between 0 and 1. Default 0.025</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_depol_init</span><span class="o">=</span><span class="mf">0.009</span><span class="p">,</span> <span class="n">p_depol_length</span><span class="o">=</span><span class="mf">0.025</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;p_depol_init&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_depol_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;p_depol_length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_depol_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">required_properties</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">error_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="n">delta_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Uses the length property to calculate a depolarization probability,</span>
<span class="sd">        and applies it to the qubits.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qubits : tuple of :obj:`~netsquid.qubits.qubit.Qubit`</span>
<span class="sd">            Qubits to apply noise to.</span>
<span class="sd">        delta_time : float, optional</span>
<span class="sd">            Time qubits have spent on a component [ns]. Not used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">qubits</span><span class="p">:</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;p_depol_init&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span>
                <span class="mi">10</span><span class="p">,</span> <span class="o">-</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;p_depol_length&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">depolarize</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="n">prob</span><span class="p">)</span>
</pre></div>
</div>
<p>The next step is to setup the protocols.
To easily manage all the protocols, we add them as subprotocols of one main protocol.
In this way, we can start them at the same time, and the main protocol will stop when all subprotocols have finished.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setup_repeater_protocol</span><span class="p">(</span><span class="n">network</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Setup repeater protocol on repeater chain network.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    network : :class:`~netsquid.nodes.network.Network`</span>
<span class="sd">        Repeater chain network to put protocols on.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~netsquid.protocols.protocol.Protocol`</span>
<span class="sd">        Protocol holding all subprotocols used in the network.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">protocol</span> <span class="o">=</span> <span class="n">LocalProtocol</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="c1"># Add SwapProtocol to all repeater nodes. Note: we use unique names,</span>
    <span class="c1"># since the subprotocols would otherwise overwrite each other in the main protocol.</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">subprotocol</span> <span class="o">=</span> <span class="n">SwapProtocol</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Swap_</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">protocol</span><span class="o">.</span><span class="n">add_subprotocol</span><span class="p">(</span><span class="n">subprotocol</span><span class="p">)</span>
    <span class="c1"># Add CorrectProtocol to Bob</span>
    <span class="n">subprotocol</span> <span class="o">=</span> <span class="n">CorrectProtocol</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
    <span class="n">protocol</span><span class="o">.</span><span class="n">add_subprotocol</span><span class="p">(</span><span class="n">subprotocol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">protocol</span>
</pre></div>
</div>
<p>The definition of the swapping subprotocol that will run on each repeater node:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SwapProtocol</span><span class="p">(</span><span class="n">NodeProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform Swap on a repeater node.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node : :class:`~netsquid.nodes.node.Node` or None, optional</span>
<span class="sd">        Node this protocol runs on.</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of this protocol.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qmem_input_port_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin1&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qmem_input_port_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;qin0&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_program</span> <span class="o">=</span> <span class="n">QuantumProgram</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_program</span><span class="o">.</span><span class="n">get_qubit_indices</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_program</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">INSTR_MEASURE_BELL</span><span class="p">,</span> <span class="p">[</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">],</span> <span class="n">output_key</span><span class="o">=</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qmem_input_port_l</span><span class="p">)</span> <span class="o">&amp;</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qmem_input_port_r</span><span class="p">))</span>
            <span class="c1"># Perform Bell measurement</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">execute_program</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_program</span><span class="p">,</span> <span class="n">qubit_mapping</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">m</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_program</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="s2">&quot;m&quot;</span><span class="p">]</span>
            <span class="c1"># Send result to right node on end</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;ccon_R&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tx_output</span><span class="p">(</span><span class="n">Message</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
</pre></div>
</div>
<p>The definition of the correction subprotocol responsible for applying the classical corrections at Bob:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CorrectProtocol</span><span class="p">(</span><span class="n">NodeProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform corrections for a swap on an end-node.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node : :class:`~netsquid.nodes.node.Node` or None, optional</span>
<span class="sd">        Node this protocol runs on.</span>
<span class="sd">    num_nodes : int</span>
<span class="sd">        Number of nodes in the repeater chain network.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;CorrectProtocol&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">=</span> <span class="n">num_nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x_corr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_corr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_program</span> <span class="o">=</span> <span class="n">SwapCorrectProgram</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;ccon_L&quot;</span><span class="p">])</span>
            <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s2">&quot;ccon_L&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">rx_input</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">items</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">ks</span><span class="o">.</span><span class="n">BellIndex</span><span class="o">.</span><span class="n">B01</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="n">ks</span><span class="o">.</span><span class="n">BellIndex</span><span class="o">.</span><span class="n">B11</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_x_corr</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">ks</span><span class="o">.</span><span class="n">BellIndex</span><span class="o">.</span><span class="n">B10</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="n">ks</span><span class="o">.</span><span class="n">BellIndex</span><span class="o">.</span><span class="n">B11</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_z_corr</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_corr</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_corr</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_program</span><span class="o">.</span><span class="n">set_corrections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x_corr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_corr</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">execute_program</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_program</span><span class="p">,</span> <span class="n">qubit_mapping</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">send_signal</span><span class="p">(</span><span class="n">Signals</span><span class="o">.</span><span class="n">SUCCESS</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_x_corr</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_z_corr</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Note that for the corrections we only need to apply each of the <span class="math notranslate nohighlight">\(X\)</span> or <span class="math notranslate nohighlight">\(Z\)</span> operators maximally once.
This is due to the anti-commutativity and self-inverse of these Pauli matrices, i.e.
<span class="math notranslate nohighlight">\(ZX = -XZ\)</span> and <span class="math notranslate nohighlight">\(XX=ZZ=I\)</span>, which allows us to cancel repeated occurrences up to a global phase (-1).
The program that executes the correction on Bob‚Äôs quantum processor is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SwapCorrectProgram</span><span class="p">(</span><span class="n">QuantumProgram</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Quantum processor program that applies all swap corrections.&quot;&quot;&quot;</span>
    <span class="n">default_num_qubits</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">set_corrections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_corr</span><span class="p">,</span> <span class="n">z_corr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_corr</span> <span class="o">=</span> <span class="n">x_corr</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_corr</span> <span class="o">=</span> <span class="n">z_corr</span> <span class="o">%</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">program</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">q1</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_qubit_indices</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_corr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">INSTR_X</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_corr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">INSTR_Z</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>With our network and protocols ready, we can add a data collector to define when and which data we want to collect.
We can wait for the signal sent by the <em>CorrectProtocol</em> when it finishes, and if it has, compute the fidelity of the
qubits at Alice and Bob with respect to the expected Bell state.
Using our network and main protocol we can easily find Alice and the CorrectionProtocol as subcomponents.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setup_datacollector</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Setup the datacollector to calculate the fidelity</span>
<span class="sd">    when the CorrectionProtocol has finished.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    network : :class:`~netsquid.nodes.network.Network`</span>
<span class="sd">        Repeater chain network to put protocols on.</span>

<span class="sd">    protocol : :class:`~netsquid.protocols.protocol.Protocol`</span>
<span class="sd">        Protocol holding all subprotocols used in the network.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~netsquid.util.datacollector.DataCollector`</span>
<span class="sd">        Datacollector recording fidelity data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure nodes are ordered in the chain:</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>

    <span class="k">def</span> <span class="nf">calc_fidelity</span><span class="p">(</span><span class="n">evexpr</span><span class="p">):</span>
        <span class="n">qubit_a</span><span class="p">,</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">peek</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">qubit_b</span><span class="p">,</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">peek</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">fidelity</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">qubits</span><span class="o">.</span><span class="n">fidelity</span><span class="p">([</span><span class="n">qubit_a</span><span class="p">,</span> <span class="n">qubit_b</span><span class="p">],</span> <span class="n">ks</span><span class="o">.</span><span class="n">b00</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;fidelity&quot;</span><span class="p">:</span> <span class="n">fidelity</span><span class="p">}</span>

    <span class="n">dc</span> <span class="o">=</span> <span class="n">DataCollector</span><span class="p">(</span><span class="n">calc_fidelity</span><span class="p">,</span> <span class="n">include_entity_name</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">dc</span><span class="o">.</span><span class="n">collect_on</span><span class="p">(</span><span class="n">pydynaa</span><span class="o">.</span><span class="n">EventExpression</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">protocol</span><span class="o">.</span><span class="n">subprotocols</span><span class="p">[</span><span class="s1">&#39;CorrectProtocol&#39;</span><span class="p">],</span>
                                          <span class="n">event_type</span><span class="o">=</span><span class="n">Signals</span><span class="o">.</span><span class="n">SUCCESS</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">dc</span>
</pre></div>
</div>
<p>We want to run the experiment for multiple numbers of nodes and distances.
Let us first define a function to run a single simulation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_simulation</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">node_distance</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">num_iters</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run the simulation experiment and return the collected data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_nodes : int, optional</span>
<span class="sd">        Number nodes in the repeater chain network. At least 3. Default 4.</span>
<span class="sd">    node_distance : float, optional</span>
<span class="sd">        Distance between nodes, larger than 0. Default 20 [km].</span>
<span class="sd">    num_iters : int, optional</span>
<span class="sd">        Number of simulation runs. Default 100.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`pandas.DataFrame`</span>
<span class="sd">        Dataframe with recorded fidelity data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ns</span><span class="o">.</span><span class="n">sim_reset</span><span class="p">()</span>
    <span class="n">est_runtime</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">num_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">node_distance</span> <span class="o">*</span> <span class="mf">5e3</span>
    <span class="n">network</span> <span class="o">=</span> <span class="n">setup_network</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">node_distance</span><span class="o">=</span><span class="n">node_distance</span><span class="p">,</span>
                            <span class="n">source_frequency</span><span class="o">=</span><span class="mf">1e9</span> <span class="o">/</span> <span class="n">est_runtime</span><span class="p">)</span>
    <span class="n">protocol</span> <span class="o">=</span> <span class="n">setup_repeater_protocol</span><span class="p">(</span><span class="n">network</span><span class="p">)</span>
    <span class="n">dc</span> <span class="o">=</span> <span class="n">setup_datacollector</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">protocol</span><span class="p">)</span>
    <span class="n">protocol</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">ns</span><span class="o">.</span><span class="n">sim_run</span><span class="p">(</span><span class="n">est_runtime</span> <span class="o">*</span> <span class="n">num_iters</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dc</span><span class="o">.</span><span class="n">dataframe</span>
</pre></div>
</div>
<p>Finally we will run multiple simulations and plot them in a figure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_plot</span><span class="p">(</span><span class="n">num_iters</span><span class="o">=</span><span class="mi">2000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run the simulation for multiple nodes and distances and show them in a figure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    num_iters : int, optional</span>
<span class="sd">        Number of iterations per simulation configuration.</span>
<span class="sd">        At least 1. Default 2000.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">distance</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">50</span><span class="p">]:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">num_node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="n">num_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">run_simulation</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="n">num_node</span><span class="p">,</span>
                                            <span class="n">node_distance</span><span class="o">=</span><span class="n">distance</span> <span class="o">/</span> <span class="n">num_node</span><span class="p">,</span>
                                            <span class="n">num_iters</span><span class="o">=</span><span class="n">num_iters</span><span class="p">)[</span><span class="s1">&#39;fidelity&#39;</span><span class="p">]</span>
        <span class="c1"># For errorbars we use the standard error of the mean (sem)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;sem&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="s1">&#39;fidelity&#39;</span><span class="p">})</span>
        <span class="n">data</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">&#39;fidelity&#39;</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="s1">&#39;sem&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">distance</span><span class="si">}</span><span class="s2"> km&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;number of nodes&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;fidelity&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Repeater chain with different total lengths&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Using the ket vector formalism produces the following figure:</p>
<a class="reference internal image-reference" href="../_images/rep_chain_example_ket.png"><img alt="../_images/rep_chain_example_ket.png" class="align-center" src="../_images/rep_chain_example_ket.png" style="width: 600px;" /></a>
<p>Because the quantum states don‚Äôt have an opportunity to grow very large in our simulation,
it is also possible for this simple example to improve on our results using the density matrix formalism.
Instead of running the simulation for 2000 iterations, it is now sufficient to run it for only a few.
As we see in the figure below, the error-bars now become negligible:</p>
<a class="reference internal image-reference" href="../_images/rep_chain_example_dm.png"><img alt="../_images/rep_chain_example_dm.png" class="align-center" src="../_images/rep_chain_example_dm.png" style="width: 600px;" /></a>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="learn.examples.repeater.html" class="btn btn-neutral float-left" title="Repeater with purification" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="learn.examples.simple_link.html" class="btn btn-neutral float-right" title="A simple link layer protocol" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2021, TNO and TUDelft (QuTech).</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: 1.1.7
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
      <dd><a href="/1-1-stable/">1.1.5</a></dd>
      <dd><a href="/1-0-stable/">1.0.7</a></dd>
      <dd><a href="/0-10-stable/">0.10.4</a></dd>
      <dd><a href="/0-9-stable/">0.9.11</a></dd>
      <dd><a href="/0-8-stable/">0.8.7</a></dd>
      <dd><a href="/0-7-stable/">0.7.5</a></dd>
      <dd><a href="/0-6-stable/">0.6.4</a></dd>
      <dd><a href="/0-5-stable/">0.5.2</a></dd>
      <dd><a href="/0-4-stable/">0.4.2</a></dd>
      <dd><a href="/0-3-stable/">0.3.5</a></dd>
      <dd><a href="/latest-release/">latest release</a></dd>
      <dd><a href="/master/">master branch</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".highlight-default .highlight").each(function() {
            if ($(this).find(".gp").length > 0) {
             $(this).prepend("<div class='codebtn btn btn-neutral float-right'><div class='gp'>>>></div><div>");
             $(this).children("pre").contents().filter(function() {return this.nodeType === 3;}).wrap("<span></span>").end();
            }
        });
        $(".highlight-default .highlight .codebtn").click(function() {
            $(this).parent().children("pre").find(".gp").toggleClass("hidden");
            var traceback_elem = $(this).parent().children("pre").find(".gt, .go");
            traceback_elem.toggleClass("hidden");
            traceback_elem.nextUntil(".gp, .go").toggleClass("hidden");

        })
    });
</script>


</body>
</html>