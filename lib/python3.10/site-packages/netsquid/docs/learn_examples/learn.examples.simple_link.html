<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>A simple link layer protocol &mdash; NetSquid 1.1.7 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=370aedac"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Faster Link layer Protocol using abstraction" href="learn.examples.magic_simple_link.html" />
    <link rel="prev" title="Repeater chain" href="learn.examples.repeater_chain.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #E3E3E3" >

          
          
          <a href="../index.html" class="icon icon-home">
            NetSquid
              <img src="../_static/squid-150.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.1.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../INSTALL.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RELEASE.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AUTHORS.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LICENSE.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Learn NetSquid</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quick_start.html">NetSquid in 10 minutes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.intro.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.qubits.html">Qubits and quantum computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.pydynaa.html">Discrete event simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.components.html">Modelling of network components</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.nodes.html">Nodes and Connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.quantumprocessor.html">The Quantum Processor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.simulation.html">A full simulation</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../learn.examples.html">Examples</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="learn.examples.teleportation.html">Teleportation</a></li>
<li class="toctree-l2"><a class="reference internal" href="learn.examples.repeater.html">Repeater with purification</a></li>
<li class="toctree-l2"><a class="reference internal" href="learn.examples.repeater_chain.html">Repeater chain</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">A simple link layer protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="learn.examples.magic_simple_link.html">Faster Link layer Protocol using abstraction</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api_reference.html">NetSquid package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.qubits.html">netsquid.qubits</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qformalism.html">netsquid.qubits.qformalism</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qubitapi.html">netsquid.qubits.qubitapi</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.operators.html">netsquid.qubits.operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.cliffords.html">netsquid.qubits.cliffords</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.ketstates.html">netsquid.qubits.ketstates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.state_sampler.html">netsquid.qubits.state_sampler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qubit.html">netsquid.qubits.qubit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qstate.html">netsquid.qubits.qstate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qrepr.html">netsquid.qubits.qrepr</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.kettools.html">netsquid.qubits.kettools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.dmtools.html">netsquid.qubits.dmtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.sparsedmtools.html">netsquid.qubits.sparsedmtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.stabtools.html">netsquid.qubits.stabtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.gslctools.html">netsquid.qubits.gslctools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.qreprutil.html">netsquid.qubits.qreprutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.ketutil.html">netsquid.qubits.ketutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.dmutil.html">netsquid.qubits.dmutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.sparseutil.html">netsquid.qubits.sparseutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.gslcutil.html">netsquid.qubits.gslcutil</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_qubits/netsquid.qubits.opmath.html">netsquid.qubits.opmath</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.components.html">netsquid.components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.component.html">netsquid.components.component</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.channel.html">netsquid.components.channel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qchannel.html">netsquid.components.qchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.cchannel.html">netsquid.components.cchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.cqchannel.html">netsquid.components.cqchannel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qmemory.html">netsquid.components.qmemory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.instructions.html">netsquid.components.instructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qprogram.html">netsquid.components.qprogram</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qprocessor.html">netsquid.components.qprocessor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.clock.html">netsquid.components.clock</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qsource.html">netsquid.components.qsource</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.qdetector.html">netsquid.components.qdetector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.switch.html">netsquid.components.switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_components/netsquid.components.ccoding.html">netsquid.components.ccoding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.components.models.html">netsquid.components.models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.model.html">netsquid.components.models.model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.delaymodels.html">netsquid.components.models.delaymodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.errormodels.html">netsquid.components.models.errormodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.qerrormodels.html">netsquid.componentsmodels.qerrormodels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_models/netsquid.components.models.cerrormodels.html">netsquid.components.models.cerrormodels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.nodes.html">netsquid.nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.node.html">netsquid.nodes.node</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.connections.html">netsquid.nodes.connections</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_nodes/netsquid.nodes.network.html">netsquid.nodes.network</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.protocols.html">netsquid.protocols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.protocol.html">netsquid.protocols.protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.nodeprotocols.html">netsquid.protocols.nodeprotocols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_protocols/netsquid.protocols.serviceprotocol.html">netsquid.protocols.serviceprotocol</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.util.html">netsquid.util</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simtools.html">netsquid.util.simtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simlog.html">netsquid.util.simlog</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.simstats.html">netsquid.util.simstats</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.datacollector.html">netsquid.util.datacollector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.cycache.html">netsquid.util.cycache</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.cymath.html">netsquid.util.cymath</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_util/netsquid.util.constrainedmap.html">netsquid.util.constrainedmap</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../netsquid.examples.html">netsquid.examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.teleportation.html">netsquid.examples.teleportation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.entanglenodes.html">netsquid.examples.entanglenodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.purify.html">netsquid.examples.purify</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.repeater.html">netsquid.examples.repeater</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.repeater_chain.html">netsquid.examples.repeater_chain</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.simple_link.html">netsquid.examples.simple_link</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_examples/netsquid.examples.magic_simple_link.html">netsquid.examples.magic_simple_link</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api_pydynaa.html">pyDynAA package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html">pydynaa.Entity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-event">pydynaa.Event</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventtype">pydynaa.EventType</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventexpression">pydynaa.EventExpression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-eventhandler">pydynaa.EventHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-expressionhandler">pydynaa.ExpressionHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pydynaa.html#pydynaa-simulationengine">pydynaa.SimulationEngine</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">For developers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../INSTALL-SOURCE.html">Installation from source</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CHANGELOG.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #E3E3E3" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">NetSquid</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../learn.examples.html">Examples</a></li>
      <li class="breadcrumb-item active">A simple link layer protocol</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/learn_examples/learn.examples.simple_link.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="learn.examples.repeater_chain.html" class="btn btn-neutral float-left" title="Repeater chain" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="learn.examples.magic_simple_link.html" class="btn btn-neutral float-right" title="Faster Link layer Protocol using abstraction" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="a-simple-link-layer-protocol">
<h1>A simple link layer protocol<a class="headerlink" href="#a-simple-link-layer-protocol" title="Link to this heading"></a></h1>
<p>In this example we will look at achieving robust entanglement
generation by defining a simple quantum <em>link layer</em> protocol.
This example is inspired by the quantum link layer proposed by <a class="reference external" href="https://arxiv.org/abs/1903.09778">Dahlberg et al</a>.
In this paper the following quantum network stack is defined in analogy to the classical OSI stack:</p>
<a class="reference internal image-reference" href="../_images/layers_LL.png"><img alt="The five layers of the quantum network stack." class="align-center" src="../_images/layers_LL.png" style="width: 400px;" /></a>
<p>The bottom or <em>physical layer</em> is responsible for executing entanglement generation <em>attempts</em> when requested.
These attempts can succeed or fail, and this information is propagated to the <em>link layer</em>,
which is responsible for generating this entanglement in a robust manner.
The link layer receives requests from the network layer to
create entanglement and will respond with success once this is achieved.</p>
<p>In this example will be explore simplified implementations for the physical and link layer protocols.
Before we dive into the protocols let us describe an example physical network in NetSquid,
which will have the following layout:</p>
<a class="reference internal image-reference" href="../_images/aafig-e136a9d79a1b68165fcb04c47d8657cb7d2036ca.svg"><img alt="../_images/aafig-e136a9d79a1b68165fcb04c47d8657cb7d2036ca.svg" class="align-center" height="113.79999999999998" src="../_images/aafig-e136a9d79a1b68165fcb04c47d8657cb7d2036ca.svg" width="505.79999999999995" /></a>
<p>Alice and Bob will use a <em>single-click scheme</em> to generate <em>heralded entanglement</em> (see paper).
The quantum and classical channels and the detector required to generate
the entanglement are contained within a heralded connection.
We will request the entanglement generator at Alice, who will use the classical connection to
synchronize the requests with Bob.
A node contains a Quantum Processor which is connected to the heralded connection.</p>
<a class="reference internal image-reference" href="../_images/aafig-89271adffc8daabf412851542a5f2a6eab0899c3.svg"><img alt="../_images/aafig-89271adffc8daabf412851542a5f2a6eab0899c3.svg" class="align-center" height="113.79999999999998" src="../_images/aafig-89271adffc8daabf412851542a5f2a6eab0899c3.svg" width="437.19999999999993" /></a>
<p>The network is setup as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_example_network</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the example network.</span>

<span class="sd">    Alice and Bob need a QuantumProcessor to store the qubits they produce.</span>
<span class="sd">    Their qubits are send through a heralded connection,</span>
<span class="sd">    which needs to be connected to Alice and Bob.</span>
<span class="sd">    It is assumed qubits are send to the connection,</span>
<span class="sd">    and it returns classical messages.</span>
<span class="sd">    In this example we won&#39;t use noise on the quantum memories,</span>
<span class="sd">    so instead of defining PhysicalInstructions we</span>
<span class="sd">    fallback to nonphysical ones.</span>
<span class="sd">    In order to synchronize their attempts a classical connection is added.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_qubits : int</span>
<span class="sd">        The number of entangled qubit pairs we expect this network to make. Default 3.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~netsquid.nodes.network.Network`</span>
<span class="sd">        The example network for a simple link.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">network</span> <span class="o">=</span> <span class="n">Network</span><span class="p">(</span><span class="s1">&#39;SimpleLinkNetwork&#39;</span><span class="p">)</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">([</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">])</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># in km</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">node</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">QuantumProcessor</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;qmem_</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                                               <span class="n">num_positions</span><span class="o">=</span><span class="n">num_qubits</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                               <span class="n">fallback_to_nonphysical</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">HeraldedConnection</span><span class="p">(</span><span class="s2">&quot;HeraldedConnection&quot;</span><span class="p">,</span> <span class="n">length_to_a</span><span class="o">=</span><span class="n">distance</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                              <span class="n">length_to_b</span><span class="o">=</span><span class="n">distance</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">time_window</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">network</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">connection</span><span class="o">=</span><span class="n">conn</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;quantum&#39;</span><span class="p">)</span>
    <span class="n">network</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">delay</span><span class="o">=</span><span class="n">distance</span> <span class="o">/</span> <span class="mi">200000</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;classical&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">network</span>
</pre></div>
</div>
<p>Let us now define the needed protocols.
The <em>physical layer</em> and the <em>link layer</em> work together very closely, therefore we will give a
full overview of both protocols first, before diving into their implementation.</p>
<p>The <em>link layer</em> should respond to CREATE requests, which are issued from the <em>network</em> layer.
A CREATE request specifies in our case the number of qubits pairs we want to generate.
For this example we assume the request to generate three qubits just arrived at Alice.
The protocol works as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The link layer receives the request from the network layer.</p></li>
<li><p>The request is synchronized with the other node.</p></li>
<li><p>Every 100 ns the physical layer sends a trigger to the link layer.</p></li>
<li><p>On the trigger from the physical layer the link layer responds with the first queued request.</p></li>
<li><p>The link layers send a response to their physical layer with instructions.</p></li>
<li><p>The physical layer protocols create a qubit-photon pair using their quantum processors
and send the photon to the heralded connection.</p></li>
<li><p>When both photons arrive at the detector of the heralded connection, they are measured.</p></li>
<li><p>The heralded connection informs the physical layer of the measurement outcome.</p></li>
<li><p>The measurement outcome is propagated to the link layer, which can now
decide to send a response to the network layer.</p></li>
<li><p>Repeat step 5-9 until the desired number of pairs is created.</p></li>
</ol>
</div></blockquote>
<p>The physical layer we implement using the <code class="docutils literal notranslate"><span class="pre">MidpointHeraldingProtocol</span></code> (MHP) protocol, whereas
the link layer is implemented using an <code class="docutils literal notranslate"><span class="pre">EGProtocol</span></code>, where EG is an acronym for entanglement generation.
The MHP should trigger the EGP on a fixed timer, and start
the entanglement generation process on a response from the EGP.
This is implemented as shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MidpointHeraldingProtocol</span><span class="p">(</span><span class="n">NodeProtocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Attempt to generate entanglement via a HeraldingConnection.</span>

<span class="sd">    This protocol sends a trigger to an EGProtocol every ``time_step`` nanoseconds.</span>
<span class="sd">    On a response the protocol creates a qubit in memory, entangles it with a photon,</span>
<span class="sd">    and sends this photon to the qout port of the quantum memory.</span>
<span class="sd">    This port is expected to forward the photon to the heralded connection.</span>
<span class="sd">    This connection is expected to return an outcome of the photon measurement,</span>
<span class="sd">    which returns 1 or 2 (each denotes an entangled state) for success.</span>
<span class="sd">    The photon will be generated on position 0, and the qubits on 1 .. N.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node : `~netsquid.nodes.node.Node`</span>
<span class="sd">        The node this protocol runs on.</span>
<span class="sd">    time_step : int</span>
<span class="sd">        The period of the triggers in nanoseconds.</span>
<span class="sd">    q_port_name : str</span>
<span class="sd">        The name of the port connected to the heraled connection.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    trigger_label : str</span>
<span class="sd">        The label of the trigger signal</span>
<span class="sd">    answer_label : str</span>
<span class="sd">        The label of the answer signal</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">q_port_name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span> <span class="o">=</span> <span class="n">time_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;qout&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">forward_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="n">q_port_name</span><span class="p">])</span>
        <span class="c1"># And we will wait for an outcome on the input port</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port_name</span> <span class="o">=</span> <span class="n">q_port_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_port_name</span> <span class="o">=</span> <span class="n">q_port_name</span>
        <span class="c1"># We have to remember if we already send a photon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_label</span> <span class="o">=</span> <span class="s2">&quot;TRIGGER&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">answer_label</span> <span class="o">=</span> <span class="s2">&quot;ANSWER&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trigger_label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">answer_label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_task_label</span> <span class="o">=</span> <span class="s1">&#39;do_task_label&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_task_label</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">EmitProgram</span><span class="p">(</span><span class="n">QuantumProgram</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Program to create a qubit and emit an entangled photon to the &#39;qout&#39; port.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">program</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># Emit from q2 using q1</span>
            <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_qubit_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">INSTR_INIT</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">INSTR_EMIT</span><span class="p">,</span> <span class="p">[</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">])</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sends triggers periodically or starts an entanglement attempt.</span>

<span class="sd">        The triggers are skipped during the entanglement attempt for simplicity.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        :class:`~pydynaa.core.EventExpression`</span>
<span class="sd">            Await a timer signal or a response from the connection.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1">#  Instead of a duration we specify the time explicitly</span>
            <span class="c1">#  to be a mulitple of the time_step.</span>
            <span class="n">time</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">()</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span>
            <span class="n">wait_timer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_timer</span><span class="p">(</span><span class="n">end_time</span><span class="o">=</span><span class="n">time</span><span class="p">)</span>
            <span class="n">wait_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_task_label</span><span class="p">)</span>
            <span class="n">evexpr</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">wait_timer</span> <span class="o">|</span> <span class="n">wait_signal</span>
            <span class="k">if</span> <span class="n">evexpr</span><span class="o">.</span><span class="n">second_term</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="c1"># Start the entanglement attempt</span>
                <span class="n">qpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_signal_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_task_label</span><span class="p">)</span>
                <span class="n">prog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EmitProgram</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">execute_program</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qubit_mapping</span><span class="o">=</span><span class="p">[</span><span class="n">qpos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">q_port_name</span><span class="p">]</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_port_input</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
                <span class="n">message</span> <span class="o">=</span> <span class="n">port</span><span class="o">.</span><span class="n">rx_input</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">message</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;photonoutcome&#39;</span><span class="p">:</span>
                    <span class="n">outcome</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outcome</span> <span class="o">=</span> <span class="s1">&#39;FAIL&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">send_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">answer_label</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="p">(</span><span class="n">outcome</span><span class="p">,</span> <span class="n">qpos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">send_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trigger_label</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">do_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qpos</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Start the task.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qpos : int</span>
<span class="sd">            The number indicating which qubit pair we are making.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_task_label</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="n">qpos</span><span class="p">)</span>
</pre></div>
</div>
<p>The EGP is defined as a <em>service</em>: a protocol that defines the interface the network layer can use more explicitly.
We can split our protocol into two parts: handling input of requests and handling the requests themselves.
We will use the service to handle the input of requests, and the actual
handling of the requests will be implemented by a protocol.
In <a class="reference external" href="learn.examples.magic_simple_link.html">an extention of this example</a> we will reuse
the service but create a new protocol.
Our EGP can’t handle multiple requests at once, so we use a queue to schedule the requests.
The service is implemented as shown below with an abstract request handler:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EGService</span><span class="p">(</span><span class="n">ServiceProtocol</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract interface for an Entanglement Generation Service.</span>

<span class="sd">    Defines the available request and response types, and implements the queue mechanism.</span>
<span class="sd">    Every request will be assigned a unique create_id, which is</span>
<span class="sd">    returned when a request is put to this service.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node : :class:`~netsquid.nodes.node.Node`</span>
<span class="sd">        The node this protocol runs on.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        The name of this protocol. Default EGService.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    req_create : namedtuple</span>
<span class="sd">        A request to create entanglement with a remote node.</span>
<span class="sd">    res_ok : namedtuple</span>
<span class="sd">        A response to indicate a create request has finished.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define the requests and responses as class attributes so</span>
    <span class="c1"># they are identical for every EGProtocol instance</span>
    <span class="n">req_create</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;LinkLayerCreate&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;purpose_id&#39;</span><span class="p">,</span> <span class="s1">&#39;number&#39;</span><span class="p">])</span>
    <span class="n">res_ok</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;LinkLayerOk&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;purpose_id&#39;</span><span class="p">,</span> <span class="s1">&#39;create_id&#39;</span><span class="p">,</span> <span class="s1">&#39;logical_qubit_id&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># Register the request and response</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_request</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">req_create</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_response</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_ok</span><span class="p">)</span>
        <span class="c1"># We will use a queue for requests</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_new_req_signal</span> <span class="o">=</span> <span class="s2">&quot;New request in queue&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new_req_signal</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_id</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">handle_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Schedule the request on the queue.</span>

<span class="sd">        Schedule the request in a queue and</span>
<span class="sd">        signal to :meth:`~netsquid.examples.simple_link.EGProtocol.run`</span>
<span class="sd">        new items have been put into the queue.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        request :</span>
<span class="sd">            The object representing the request.</span>
<span class="sd">        identifier : str</span>
<span class="sd">            The identifier for this request.</span>
<span class="sd">        start_time : float, optional</span>
<span class="sd">            The time at which the request can be executed. Default current simulation time.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Additional arguments which can be set by the service.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The dictionary with additional arguments.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called after</span>
<span class="sd">        :meth:`~netsquid.protocols.serviceprotocol.ServiceProtocol.put` which</span>
<span class="sd">        does the type checking etc.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start_time</span><span class="p">,</span> <span class="p">(</span><span class="n">identifier</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new_req_signal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wait for a new request signal, then run the requests one by one.</span>

<span class="sd">        Assumes request handlers are generators and not functions.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_req_signal</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start_time</span><span class="p">,</span> <span class="p">(</span><span class="n">handler_id</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">():</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_timer</span><span class="p">(</span><span class="n">end_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">)</span>
                <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_handlers</span><span class="p">[</span><span class="n">handler_id</span><span class="p">]</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span>
                <span class="n">gen</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">})</span>
                <span class="k">yield from</span> <span class="n">gen</span>

    <span class="k">def</span> <span class="nf">_get_next_create_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Return a unique create id.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_id</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_id</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">purpose_id</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">create_id</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Implement the entanglement generation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        purpose_id : int</span>
<span class="sd">            Integer representing which purpose this entanglement is for.</span>
<span class="sd">            Used to communicate to the higher layers.</span>
<span class="sd">        number : int</span>
<span class="sd">            Number of qubit pairs to make.</span>
<span class="sd">        create_id : int</span>
<span class="sd">            The unique identifier provided by the service.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Drain for any optional parameters.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>The synchronization and request handling can now be defined in the protocol:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EGProtocol</span><span class="p">(</span><span class="n">EGService</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implement an Entanglement Generation service.</span>

<span class="sd">    Upon a *LinkLayerCreate* request generates pairs of entangled qubits, of which one</span>
<span class="sd">    is locally stored and the other is stored at the remote node.</span>
<span class="sd">    Requests are fulfulled in FIFO order, and upon completion</span>
<span class="sd">    a response signal is sent.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node : :class:`~netsquid.nodes.node.Node`</span>
<span class="sd">        The node this protocol runs on.</span>
<span class="sd">    c_port_name : str</span>
<span class="sd">        The name of the port which is connected to the remote node.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        The name of this protocol. Default EGProtocol.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">c_port_name</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># Require a Physical Layer protocol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mh_name</span> <span class="o">=</span> <span class="s2">&quot;MH_Protocol&quot;</span>
        <span class="c1"># Setup queue synchronization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="n">c_port_name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_port</span><span class="o">.</span><span class="n">bind_input_handler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle_msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_phys_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mh_protocol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a physical layer protocol as a subprotocol.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mh_protocol :</span>
<span class="sd">            The protocol which implements a physical layer.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subprotocol</span><span class="p">(</span><span class="n">mh_protocol</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mh_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Synchronize the request with the other service and schedule it on the queue.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        request :</span>
<span class="sd">            The object representing the request.</span>
<span class="sd">        identifier : str</span>
<span class="sd">            The identifier for this request.</span>
<span class="sd">        start_time : float, optional</span>
<span class="sd">            The time at which the request can be executed. Default current time.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Additional arguments not part of the original request.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The dictionary with additional arguments.</span>
<span class="sd">            For the create request this is the unique create id.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;create_id&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;create_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_create_id</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">travel_time</span> <span class="o">=</span> <span class="mi">10000</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">()</span> <span class="o">+</span> <span class="n">travel_time</span>
            <span class="c1"># Make sure Message don&#39;t combine by specifying a header.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_port</span><span class="o">.</span><span class="n">tx_output</span><span class="p">(</span>
                <span class="n">Message</span><span class="p">([</span><span class="n">request</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="n">request</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">handle_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_handle_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handle incoming messages from the other service.</span>

<span class="sd">        The services use these messages to ensure they start</span>
<span class="sd">        the same request at the same time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        msg : Message</span>
<span class="sd">            A Message from another ServiceProtocol containing request</span>
<span class="sd">            and scheduling data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">request</span><span class="p">,</span> <span class="n">handler_id</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">items</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handle_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">handler_id</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make sure we have an subprotocol before running our program.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mh_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subprotocols</span> <span class="ow">or</span> \
                <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subprotocols</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mh_name</span><span class="p">],</span> <span class="n">Protocol</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;EGProtocol requires a physical layer protocol to be added.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_subprotocols</span><span class="p">()</span>
        <span class="k">yield from</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">purpose_id</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handler for create requests.</span>

<span class="sd">        Create qubits together with a remote node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        purpose_id : int</span>
<span class="sd">            The number used to to tag this request for a specific purpose in a higher layer.</span>
<span class="sd">        number : int</span>
<span class="sd">            The number of qubits to make in this request.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        :class:`~pydynaa.core.EventExpression`</span>
<span class="sd">            The expressions required to execute the create request.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :obj:`~netsquid.examples.simple_link.EGProtocol.res_ok`</span>
<span class="sd">            The response object indicating we successfully made the requested qubits.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">create_id</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;create_id&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_id</span> <span class="o">=</span> <span class="n">create_id</span>
        <span class="n">curpairs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sub_proto</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subprotocols</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mh_name</span><span class="p">]</span>
        <span class="n">wait_trigger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_signal</span><span class="p">(</span><span class="n">sub_proto</span><span class="p">,</span> <span class="n">sub_proto</span><span class="o">.</span><span class="n">trigger_label</span><span class="p">)</span>
        <span class="n">wait_answer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_signal</span><span class="p">(</span><span class="n">sub_proto</span><span class="p">,</span> <span class="n">sub_proto</span><span class="o">.</span><span class="n">answer_label</span><span class="p">)</span>
        <span class="c1"># Start the main loop</span>
        <span class="k">while</span> <span class="n">curpairs</span> <span class="o">&lt;</span> <span class="n">number</span><span class="p">:</span>
            <span class="n">evexpr</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">wait_trigger</span> <span class="o">|</span> <span class="n">wait_answer</span>
            <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">evexpr</span><span class="o">.</span><span class="n">triggered_events</span><span class="p">:</span>
                <span class="n">qpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">curpairs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">qpos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_ok</span><span class="p">(</span><span class="n">purpose_id</span><span class="p">,</span> <span class="n">create_id</span><span class="p">,</span> <span class="n">qpos</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">send_response</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
                    <span class="n">curpairs</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_handle_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">curpairs</span><span class="p">):</span>
        <span class="c1"># Communicate with the physical layer on trigger and answers signals.</span>
        <span class="n">sub_proto</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subprotocols</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mh_name</span><span class="p">]</span>
        <span class="n">label</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">sub_proto</span><span class="o">.</span><span class="n">get_signal_by_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">receiver</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="n">sub_proto</span><span class="o">.</span><span class="n">trigger_label</span><span class="p">:</span>
            <span class="n">sub_proto</span><span class="o">.</span><span class="n">do_task</span><span class="p">(</span><span class="n">qpos</span><span class="o">=</span><span class="n">curpairs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">label</span> <span class="o">==</span> <span class="n">sub_proto</span><span class="o">.</span><span class="n">answer_label</span><span class="p">:</span>
            <span class="n">outcome</span><span class="p">,</span> <span class="n">qpos</span> <span class="o">=</span> <span class="n">value</span>
            <span class="c1"># outcome of 1 is |01&gt;+|10&gt;, 2 is |01&gt;-|10&gt;.</span>
            <span class="c1"># Other outcomes are non-entangled states.</span>
            <span class="k">if</span> <span class="n">outcome</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">outcome</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">qpos</span>
        <span class="k">return</span> <span class="kc">None</span>
</pre></div>
</div>
<p>We have skipped over the heralded connection, so we will address it now.
The connection contains a detector in order to measure the incoming photons.
In this example we have the detector in the middle of the connection.</p>
<a class="reference internal image-reference" href="../_images/aafig-acfb1e06d944ba845256afa3260bb5e5d2e83560.svg"><img alt="../_images/aafig-acfb1e06d944ba845256afa3260bb5e5d2e83560.svg" class="align-center" height="230.0" src="../_images/aafig-acfb1e06d944ba845256afa3260bb5e5d2e83560.svg" width="1266.0" /></a>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HeraldedConnection</span><span class="p">(</span><span class="n">Connection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A connection that takes in two qubits, and returns a message</span>
<span class="sd">    how they were measured at a detector.</span>

<span class="sd">    Either no clicks, a single click or double click, or an error</span>
<span class="sd">    when the qubits didn&#39;t arrive within the time window.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        The name of this connection</span>
<span class="sd">    length_to_a : float</span>
<span class="sd">        The length in km between the detector and side A. We assume a speed of 200000 km/s</span>
<span class="sd">    length_to_b : float</span>
<span class="sd">        The length in km between the detector and side B. We assume a speed of 200000 km/s</span>
<span class="sd">    time_window : float, optional</span>
<span class="sd">        The interval where qubits are still able to be measured correctly.</span>
<span class="sd">        Must be positive. Default is 0.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">length_to_a</span><span class="p">,</span> <span class="n">length_to_b</span><span class="p">,</span> <span class="n">time_window</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">delay_a</span> <span class="o">=</span> <span class="n">length_to_a</span> <span class="o">/</span> <span class="mi">200000</span> <span class="o">*</span> <span class="mf">1e9</span>
        <span class="n">delay_b</span> <span class="o">=</span> <span class="n">length_to_b</span> <span class="o">/</span> <span class="mi">200000</span> <span class="o">*</span> <span class="mf">1e9</span>
        <span class="n">channel_a</span> <span class="o">=</span> <span class="n">ClassicalChannel</span><span class="p">(</span><span class="s2">&quot;ChannelA&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="n">delay_a</span><span class="p">)</span>
        <span class="n">channel_b</span> <span class="o">=</span> <span class="n">ClassicalChannel</span><span class="p">(</span><span class="s2">&quot;ChannelB&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="n">delay_b</span><span class="p">)</span>
        <span class="n">qchannel_a</span> <span class="o">=</span> <span class="n">QuantumChannel</span><span class="p">(</span><span class="s2">&quot;QChannelA&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="n">delay_a</span><span class="p">)</span>
        <span class="n">qchannel_b</span> <span class="o">=</span> <span class="n">QuantumChannel</span><span class="p">(</span><span class="s2">&quot;QChannelB&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="n">delay_b</span><span class="p">)</span>
        <span class="c1"># Add all channels as subcomponents</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">channel_a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">channel_b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">qchannel_a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">qchannel_b</span><span class="p">)</span>
        <span class="c1"># Add midpoint detector</span>
        <span class="n">detector</span> <span class="o">=</span> <span class="n">BSMDetector</span><span class="p">(</span><span class="s2">&quot;Midpoint&quot;</span><span class="p">,</span> <span class="n">system_delay</span><span class="o">=</span><span class="n">time_window</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subcomponent</span><span class="p">(</span><span class="n">detector</span><span class="p">)</span>
        <span class="c1"># Connect the ports</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">forward_input</span><span class="p">(</span><span class="n">qchannel_a</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;send&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">forward_input</span><span class="p">(</span><span class="n">qchannel_b</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;send&#39;</span><span class="p">])</span>
        <span class="n">qchannel_a</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;recv&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">detector</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;qin0&#39;</span><span class="p">])</span>
        <span class="n">qchannel_b</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;recv&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">detector</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;qin1&#39;</span><span class="p">])</span>
        <span class="n">channel_a</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;send&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">detector</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;cout0&#39;</span><span class="p">])</span>
        <span class="n">channel_b</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;send&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">detector</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;cout1&#39;</span><span class="p">])</span>
        <span class="n">channel_a</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;recv&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">forward_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
        <span class="n">channel_b</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;recv&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">forward_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The main part of the heralded connection is the BSMDetector, so in the code shown below we will address it.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BSMDetector</span><span class="p">(</span><span class="n">QuantumDetector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A component that performs Bell basis measurements.</span>

<span class="sd">    Measure two incoming qubits in the Bell basis if they</span>
<span class="sd">    arrive within the specified measurement delay.</span>
<span class="sd">    Only informs the connections that send a qubit of the measurement result.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">system_delay</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">dead_time</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">models</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">output_meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">error_on_fail</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">num_input_ports</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_output_ports</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                         <span class="n">meas_operators</span><span class="o">=</span><span class="n">create_meas_ops</span><span class="p">(),</span>
                         <span class="n">system_delay</span><span class="o">=</span><span class="n">system_delay</span><span class="p">,</span> <span class="n">dead_time</span><span class="o">=</span><span class="n">dead_time</span><span class="p">,</span>
                         <span class="n">models</span><span class="o">=</span><span class="n">models</span><span class="p">,</span> <span class="n">output_meta</span><span class="o">=</span><span class="n">output_meta</span><span class="p">,</span>
                         <span class="n">error_on_fail</span><span class="o">=</span><span class="n">error_on_fail</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="n">properties</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sender_ids</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">preprocess_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Preprocess and capture the qubit metadata</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">preprocess_inputs</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">port_name</span><span class="p">,</span> <span class="n">qubit_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qubits_per_port</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qubit_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sender_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">port_name</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">inform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port_outcomes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inform the MHP of the measurement result.</span>

<span class="sd">        We only send a result to the node that send a qubit.</span>
<span class="sd">        If the result is empty we change the result and header.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        port_outcomes : dict</span>
<span class="sd">            A dictionary with the port names as keys</span>
<span class="sd">            and the post-processed measurement outcomes as values</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">port_name</span><span class="p">,</span> <span class="n">outcomes</span> <span class="ow">in</span> <span class="n">port_outcomes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outcomes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">outcomes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;TIMEOUT&#39;</span><span class="p">]</span>
                <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;error&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;photonoutcome&#39;</span>
            <span class="c1"># Extract the ids from the port names (cout...)</span>
            <span class="k">if</span> <span class="n">port_name</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sender_ids</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">Message</span><span class="p">(</span><span class="n">outcomes</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span><span class="o">.</span><span class="n">tx_output</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clear sender ids after the measurement has finished.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sender_ids</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</pre></div>
</div>
<p>Together these parts allow for robust entanglement generation.
We still need to setup the protocols.
A mockup Network layer will send the request to the link layer at Alice.
By making the EGP a subprotocol of the Network layer it will automatically stop when
the Network layer has no more requests.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NetworkProtocol</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Send requests to an EG service protocol.</span>

<span class="sd">    Will automatically stop the services and their sub-protocols</span>
<span class="sd">    when the requests are finished.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name to identify this protocol.</span>
<span class="sd">    entangle_protocol : :class:`~netsquid.examples.simple_link.EGService`</span>
<span class="sd">        The service that will get the requests from this network.</span>
<span class="sd">    remote_entangle_protocol : :class:`~netsquid.examples.simple_link.EGService`</span>
<span class="sd">       The service that will create the pairs together with the entangle_protocol.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">entangle_protocol</span><span class="p">,</span> <span class="n">remote_entangle_protocol</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subprotocol</span><span class="p">(</span><span class="n">entangle_protocol</span><span class="p">,</span> <span class="s2">&quot;EGP_Alice&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_subprotocol</span><span class="p">(</span><span class="n">remote_entangle_protocol</span><span class="p">,</span> <span class="s2">&quot;EGP_Bob&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Start the protocols and put requests to Alice.&quot;&quot;&quot;</span>
        <span class="n">proto</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subprotocols</span><span class="p">[</span><span class="s1">&#39;EGP_Alice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subprotocols</span><span class="p">[</span><span class="s1">&#39;EGP_Bob&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="c1"># Start with a single request</span>
        <span class="n">req_1</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">req_create</span><span class="p">(</span><span class="n">purpose_id</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">create_id</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">req_1</span><span class="p">)[</span><span class="s1">&#39;create_id&#39;</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Waiting for responses with create_id </span><span class="si">{</span><span class="n">create_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_results</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">req_1</span><span class="p">)</span>
        <span class="n">req_2</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">req_create</span><span class="p">(</span><span class="n">purpose_id</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">create_id</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">req_2</span><span class="p">)[</span><span class="s1">&#39;create_id&#39;</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Waiting for responses with create_id </span><span class="si">{</span><span class="n">create_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">req_3</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">req_create</span><span class="p">(</span><span class="n">purpose_id</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">create_id</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">req_3</span><span class="p">)[</span><span class="s1">&#39;create_id&#39;</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Waiting for responses with create_id </span><span class="si">{</span><span class="n">create_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_results</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">req_2</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_results</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">req_3</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished all network requests&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">show_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Show the qubits which are entangled as a result of the request.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        proto : :class:`~netsquid.examples.simple_link.EGProtocol`</span>
<span class="sd">            The entanglement generation service</span>
<span class="sd">        request : :class:`~netsquid.examples.simple_link.EGService.req_create`</span>
<span class="sd">            The request</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        :class:`~pydynaa.core.EventExpression`</span>
<span class="sd">            The eventexpressions required to wait for the response signals.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ok_signal</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">res_ok</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Qubits between Alice and Bob with purpose_id </span><span class="si">{</span><span class="n">request</span><span class="o">.</span><span class="n">purpose_id</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">await_signal</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">ok_signal</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">get_signal_result</span><span class="p">(</span><span class="n">ok_signal</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">qubits</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">qmemory</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">logical_qubit_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">qstate</span><span class="o">.</span><span class="n">qubits</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">ns</span><span class="o">.</span><span class="n">sim_time</span><span class="p">()</span><span class="si">:</span><span class="s2">8.0f</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">qubits</span><span class="si">}</span><span class="s2"> with create_id </span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">create_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally we put the protocols on the nodes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setup_protocol</span><span class="p">(</span><span class="n">network</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Configure the protocols.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    network : :class:`~netsquid.nodes.network.Network`</span>
<span class="sd">        The network to configure the protocols on. Should consist of two nodes</span>
<span class="sd">        called Alice and Bob.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~netsquid.protocols.protocol.Protocol`</span>
<span class="sd">        A protocol describing the complete simple link setup.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">nodes</span>
    <span class="c1"># Setup Alice</span>
    <span class="n">q_ports</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">get_connected_ports</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;quantum&#39;</span><span class="p">)</span>
    <span class="n">c_ports</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">get_connected_ports</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;classical&#39;</span><span class="p">)</span>
    <span class="n">alice_mhp</span> <span class="o">=</span> <span class="n">MidpointHeraldingProtocol</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;Alice&#39;</span><span class="p">],</span> <span class="mi">500</span><span class="p">,</span> <span class="n">q_ports</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">alice_egp</span> <span class="o">=</span> <span class="n">EGProtocol</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;Alice&#39;</span><span class="p">],</span> <span class="n">c_ports</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">alice_egp</span><span class="o">.</span><span class="n">add_phys_layer</span><span class="p">(</span><span class="n">alice_mhp</span><span class="p">)</span>
    <span class="c1"># Setup Bob</span>
    <span class="n">bob_mhp</span> <span class="o">=</span> <span class="n">MidpointHeraldingProtocol</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;Bob&#39;</span><span class="p">],</span> <span class="mi">470</span><span class="p">,</span> <span class="n">q_ports</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">bob_egp</span> <span class="o">=</span> <span class="n">EGProtocol</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;Bob&#39;</span><span class="p">],</span> <span class="n">c_ports</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">bob_egp</span><span class="o">.</span><span class="n">add_phys_layer</span><span class="p">(</span><span class="n">bob_mhp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">NetworkProtocol</span><span class="p">(</span><span class="s2">&quot;SimpleLinkProtocol&quot;</span><span class="p">,</span> <span class="n">alice_egp</span><span class="p">,</span> <span class="n">bob_egp</span><span class="p">)</span>
</pre></div>
</div>
<p>We can run our simulation by calling the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_simulation</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run the example simulation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ns</span><span class="o">.</span><span class="n">sim_reset</span><span class="p">()</span>
    <span class="n">ns</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  <span class="c1"># Set the seed so we get the same outcome</span>
    <span class="n">ns</span><span class="o">.</span><span class="n">set_qstate_formalism</span><span class="p">(</span><span class="n">QFormalism</span><span class="o">.</span><span class="n">DM</span><span class="p">)</span>
    <span class="n">network</span> <span class="o">=</span> <span class="n">create_example_network</span><span class="p">()</span>
    <span class="n">protocol</span> <span class="o">=</span> <span class="n">setup_protocol</span><span class="p">(</span><span class="n">network</span><span class="p">)</span>
    <span class="n">protocol</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">ns</span><span class="o">.</span><span class="n">sim_run</span><span class="p">()</span>
</pre></div>
</div>
<p>Which will give us the following output:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netsquid.examples.simple_link</span> <span class="kn">import</span> <span class="n">run_simulation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">run_simulation</span><span class="p">()</span>
<span class="go">Waiting for responses with create_id 1</span>
<span class="go">Qubits between Alice and Bob with purpose_id 4:</span>
<span class="go">   2078020: [Qubit(&#39;QS#790-0&#39;), Qubit(&#39;QS#791-0&#39;)] with create_id 1</span>
<span class="go">   7506520: [Qubit(&#39;QS#2874-0&#39;), Qubit(&#39;QS#2875-0&#39;)] with create_id 1</span>
<span class="go">  18363520: [Qubit(&#39;QS#7042-0&#39;), Qubit(&#39;QS#7043-0&#39;)] with create_id 1</span>
<span class="go">Waiting for responses with create_id 2</span>
<span class="go">Waiting for responses with create_id 3</span>
<span class="go">Qubits between Alice and Bob with purpose_id 6:</span>
<span class="go">  20400020: [Qubit(&#39;QS#7820-0&#39;), Qubit(&#39;QS#7822-0&#39;)] with create_id 2</span>
<span class="go">  22437010: [Qubit(&#39;QS#8604-0&#39;), Qubit(&#39;QS#8602-0&#39;)] with create_id 2</span>
<span class="go">Qubits between Alice and Bob with purpose_id 4:</span>
<span class="go">  25828520: [Qubit(&#39;QS#9904-0&#39;), Qubit(&#39;QS#9906-0&#39;)] with create_id 3</span>
<span class="go">Finished all network requests</span>
</pre></div>
</div>
<p>We could give this Protocol much more functionality to better represent the design of the paper.
For example, in the request one could specify a minimum fidelity or maximum generation time.
To reach a minimum fidelity one requires some kind of entanglement distillation.
Changing the bright state population of the qubit-photon pair can change the success probability, and
thus change the generation time.
Using entanglement swapping it is possible to create entanglement between nodes which aren’t directly connected.
This process builds upon the robust entanglement generation scheme shown in this example.</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="learn.examples.repeater_chain.html" class="btn btn-neutral float-left" title="Repeater chain" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="learn.examples.magic_simple_link.html" class="btn btn-neutral float-right" title="Faster Link layer Protocol using abstraction" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2021, TNO and TUDelft (QuTech).</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: 1.1.7
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
      <dd><a href="/1-1-stable/">1.1.5</a></dd>
      <dd><a href="/1-0-stable/">1.0.7</a></dd>
      <dd><a href="/0-10-stable/">0.10.4</a></dd>
      <dd><a href="/0-9-stable/">0.9.11</a></dd>
      <dd><a href="/0-8-stable/">0.8.7</a></dd>
      <dd><a href="/0-7-stable/">0.7.5</a></dd>
      <dd><a href="/0-6-stable/">0.6.4</a></dd>
      <dd><a href="/0-5-stable/">0.5.2</a></dd>
      <dd><a href="/0-4-stable/">0.4.2</a></dd>
      <dd><a href="/0-3-stable/">0.3.5</a></dd>
      <dd><a href="/latest-release/">latest release</a></dd>
      <dd><a href="/master/">master branch</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".highlight-default .highlight").each(function() {
            if ($(this).find(".gp").length > 0) {
             $(this).prepend("<div class='codebtn btn btn-neutral float-right'><div class='gp'>>>></div><div>");
             $(this).children("pre").contents().filter(function() {return this.nodeType === 3;}).wrap("<span></span>").end();
            }
        });
        $(".highlight-default .highlight .codebtn").click(function() {
            $(this).parent().children("pre").find(".gp").toggleClass("hidden");
            var traceback_elem = $(this).parent().children("pre").find(".gt, .go");
            traceback_elem.toggleClass("hidden");
            traceback_elem.nextUntil(".gp, .go").toggleClass("hidden");

        })
    });
</script>


</body>
</html>