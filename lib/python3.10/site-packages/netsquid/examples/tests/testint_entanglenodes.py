# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: testint_entanglenodes.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the EntangleNodes protocol in the entanglenodes module.

"""
import unittest
import netsquid as ns
import pydynaa
from pydynaa import EventType, EventExpression
from netsquid.protocols.protocol import Signals
from netsquid.components.qprocessor import QuantumProcessor
from netsquid.components.qsource import QSourceTriggerError
from netsquid.nodes.node import Node
from netsquid.examples.entanglenodes import EntangleNodes, example_network_setup


class TestEntangleNodes(unittest.TestCase):
    """Unit tests for the EntangleNodes protocol.

    """

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        ns.sim_reset()
        self.prep_delay = 5
        self.qchannel_delay = 100
        self.num_mem_positions = 3
        network = example_network_setup(self.prep_delay, self.qchannel_delay, self.num_mem_positions)
        self.node_A = network.get_node("node_A")
        self.node_B = network.get_node("node_B")
        self.node_C = Node("node_C")
        self.helper = pydynaa.Entity()  # helper entity

    def test_init(self):
        """Test initialization creates valid Entitys with unique private EventTypes."""
        entangleA1 = EntangleNodes(self.node_A, role="source", input_mem_pos=0)
        entangleA2 = EntangleNodes(self.node_A, role="source", input_mem_pos=1)
        self.assertTrue(entangleA2.uid > entangleA1.uid)
        for pairs in [1, 2]:
            self.node_A.reset()
            self.node_B.reset()
            entangleA = EntangleNodes(self.node_A, role="source", input_mem_pos=0, num_pairs=pairs)
            entangleB = EntangleNodes(self.node_B, role="receiver", input_mem_pos=0, num_pairs=pairs)
            self.assertEqual(len(self.node_A.qmemory.unused_positions), self.num_mem_positions - 1)
            self.assertEqual(len(self.node_B.qmemory.unused_positions), self.num_mem_positions - 1)
            entangleA.start()
            entangleB.start()
            self.assertEqual(len(self.node_A.qmemory.unused_positions), self.num_mem_positions - pairs)
            self.assertEqual(len(self.node_B.qmemory.unused_positions), self.num_mem_positions - pairs)
            entangleA.stop()
            entangleB.stop()
            self.assertEqual(len(self.node_A.qmemory.unused_positions), self.num_mem_positions - 1)
            self.assertEqual(len(self.node_B.qmemory.unused_positions), self.num_mem_positions - 1)
        with self.assertRaises(RuntimeError):
            self.node_A.reset()
            self.node_B.reset()
            EntangleNodes(self.node_A, role="source", input_mem_pos=0, num_pairs=self.num_mem_positions + 1).start()

    def test_connected(self):
        """Test connection of components."""
        entangleA = EntangleNodes(self.node_A, role="source")
        entangleB = EntangleNodes(self.node_B, role="receiver")
        self.assertTrue(entangleA.is_connected)
        self.assertTrue(entangleB.is_connected)
        with self.assertRaises(ValueError):
            entangleA = EntangleNodes(self.node_C, role="receiver")
        self.node_C.add_subcomponent(QuantumProcessor("QuantumMemoryCTest", 1))
        entangleC = EntangleNodes(self.node_C, role="receiver", num_pairs=2)
        self.assertFalse(entangleC.is_connected)
        entangleC = EntangleNodes(self.node_C, role="receiver", num_pairs=1)
        self.assertTrue(entangleC.is_connected)

    def test_reset(self):
        """Test reset."""
        entangleA = EntangleNodes(self.node_A, role="source")
        entangleB = EntangleNodes(self.node_B, role="receiver")
        entangleA.start()
        entangleB.start()
        with self.assertRaises(QSourceTriggerError):
            # Resetting doesn't reset components
            entangleA.reset()
        self.node_A.reset()
        entangleA.reset()

    def test_entangle(self):
        """Test entangling of nodes."""
        start_event = EventType("START ENTANGLE", "Starting entangling protocol")
        start_expression = EventExpression(event_type=start_event)
        entangleA = EntangleNodes(self.node_A, role="source", start_expression=start_expression, input_mem_pos=0,
                                  num_pairs=3)
        entangleB = EntangleNodes(self.node_B, role="receiver", start_expression=start_expression, input_mem_pos=1,
                                  num_pairs=3)
        port_b = self.node_B.get_conn_port(self.node_A.ID, label="quantum")
        port_b.forward_input(self.node_B.qmemory.ports["qin1"])
        entangleA.start()
        entangleB.start()
        ns.sim_run()
        self.assertEqual(entangleA.get_signal_result(Signals.SUCCESS), None)
        self.assertEqual(entangleB.get_signal_result(Signals.SUCCESS), None)
        self.helper._schedule_now(start_event)
        for time, success_A, success_B in [
            (0, None, None),
            (self.prep_delay + 1, 2, None),  # input A is swapped to position 2
            (2 * self.prep_delay + 1, 1, None),  # input A is swapped to position 1
            (3 * self.prep_delay + 1, 0, None),  # input A not swapped
            (self.prep_delay + self.qchannel_delay + 1, 0, 2),  # input B is swapped to position 2
            (2 * self.prep_delay + self.qchannel_delay + 1, 0, 0),  # input B is swapped to position 0
            (3 * self.prep_delay + self.qchannel_delay + 1, 0, 1),  # input B not swapped
        ]:
            ns.sim_run(time)
            self.assertEqual(entangleA.get_signal_result(Signals.SUCCESS), success_A)
            self.assertEqual(entangleB.get_signal_result(Signals.SUCCESS), success_B)


if __name__ == "__main__":
    # import logging
    # from netsquid import logger
    # logger.setLevel(logging.DEBUG)
    unittest.main()
