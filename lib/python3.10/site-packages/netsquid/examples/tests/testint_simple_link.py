# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: testint_simple_link.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"""Integration tests for the simple link module.

"""
import unittest

import netsquid as ns
from netsquid.components.qprocessor import QuantumProcessor
from netsquid.components.component import Message
from netsquid.examples.simple_link import MidpointHeraldingProtocol, BSMDetector, HeraldedConnection, \
    EGProtocol
from netsquid.nodes import Node
from netsquid.protocols.protocol import Protocol
from netsquid.qubits import qubitapi
from netsquid.qubits.qubit import Qubit


class TestMakePairsProtocol(unittest.TestCase):
    """Test the MakePairsProtocol.

    """

    def setUp(self):
        ns.sim_reset()
        memory = QuantumProcessor("TestMem", num_positions=4, fallback_to_nonphysical=True)
        self.node = Node("TestNode", port_names=['conn'], qmemory=memory)
        self.node.ports['conn'].bind_output_handler(self.output_helper)
        self.message = []

    def output_helper(self, msg):
        self.message.append(msg)

    def test_emit(self):
        """Test the emit program called via do_task.

        """
        timestep = 100
        protocol = MidpointHeraldingProtocol(self.node, timestep, 'conn')
        protocol.start()
        protocol.do_task(0)
        ns.sim_run(duration=1)
        self.assertEqual(1, len(self.message))
        self.assertEqual(1, len(self.message[0].items))
        self.assertIsInstance(self.message[0].items[0], Qubit)
        # Send an answer to finish the attempt
        self.node.ports['conn'].tx_input(Message(''))
        ns.sim_run(duration=1)
        # Test repeatability
        protocol.do_task(1)
        ns.sim_run(duration=1)
        self.assertEqual(2, len(self.message))


class TestQDetector(unittest.TestCase):
    """Test the BSMDetector.

    """

    def setUp(self):
        ns.sim_reset()
        self.message = []
        self.port_in_a = 'qin0'
        self.port_in_b = 'qin1'
        self.detector = BSMDetector("testDetector")
        self.detector.ports['cout0'].bind_output_handler(self.output_helper)
        self.detector.ports['cout1'].bind_output_handler(self.output_helper)

    def output_helper(self, msg):
        self.message.append(msg)

    def test_measure(self):
        """Test the measurements are performed and discard the qubits.

        """
        q1, q2 = qubitapi.create_qubits(2)
        self.detector.ports[self.port_in_a].tx_input(Message([q1]))
        self.detector.ports[self.port_in_b].tx_input(Message([q2]))
        ns.sim_run()
        self.assertIsNone(q1.qstate)
        self.assertIsNone(q2.qstate)
        self.assertEqual(2, len(self.message))
        for msg in self.message:
            self.assertIsInstance(msg, Message)
            self.assertIsInstance(msg.items[0], int)

    def test_time_window(self):
        """Test the measurement works inside the time window.

        """
        q1, q2 = qubitapi.create_qubits(2)
        self.set_time_window(10)
        self.detector.ports[self.port_in_a].tx_input(Message([q1]))
        ns.sim_run(9)
        self.detector.ports[self.port_in_b].tx_input(Message([q2]))
        ns.sim_run()
        self.assertIsNone(q1.qstate)
        self.assertIsNone(q2.qstate)
        self.assertEqual(2, len(self.message))
        for msg in self.message:
            self.assertIsInstance(msg, Message)
            self.assertIsInstance(msg.items[0], int)

    def set_time_window(self, value):
        self.detector.properties['system_delay'] = value

    def test_outside_time_window(self):
        """Test the measurements don't work outside the time window.

        """
        q1, q2 = qubitapi.create_qubits(2)
        self.detector.time_window = 10
        self.detector.ports[self.port_in_a].tx_input(Message([q1]))
        ns.sim_run(20)
        self.detector.ports[self.port_in_b].tx_input(Message([q2]))
        ns.sim_run()
        self.assertIsNone(q1.qstate)
        self.assertIsNone(q2.qstate)
        self.assertEqual(2, len(self.message))
        for msg in self.message:
            self.assertIsInstance(msg, Message)
            self.assertEqual(msg.items[0], "TIMEOUT")


class TestHeraldedConnection(TestQDetector):
    """Test the HeraldedConnection.

    """

    def setUp(self):
        """Overwrite the variables used in the TestQDetector."""
        ns.sim_reset()
        self.message = []
        self.port_in_a = 'A'
        self.port_in_b = 'B'
        self.detector = HeraldedConnection("HeraldedConnection", 0, 0, 0)
        self.detector.ports['A'].bind_output_handler(self.output_helper)
        self.detector.ports['B'].bind_output_handler(self.output_helper)

    def set_time_window(self, value):
        self.detector.subcomponents['Midpoint'].properties['system_delay'] = value

    def test_time_window(self):
        """Test the time window works in the heraldedconnection.

        """
        super().test_time_window()

    def test_outside_time_window(self):
        """Test the measurements don't work outside the timing window.

        """
        super().test_outside_time_window()


class DummyMHP(Protocol):
    """Dummy protocol used for replacing the MHP protocol.

    """

    def __init__(self):
        super().__init__()
        self.test_task_qpos = None
        self.trigger_label = 'TRIGGER'
        self.add_signal(self.trigger_label)
        self.answer_label = 'ANSWER'
        self.add_signal(self.answer_label)

    def do_task(self, qpos):
        self.test_task_qpos = qpos


class TestEGService(unittest.TestCase):
    """Tests for the EGProtocol.

    """

    def setUp(self):
        ns.sim_reset()
        self.node = Node('Testnode', port_names=['h_conn'])
        self.proto = EGProtocol(self.node, 'h_conn')
        self.dummy_proto = DummyMHP()
        self.proto.add_phys_layer(self.dummy_proto)
        self.proto.start()
        self.node.ports['h_conn'].bind_output_handler(self.output_helper)
        self.message = []

    def output_helper(self, msg):
        self.message.append(msg)

    def test_create(self):
        """Test the put method works"""
        num_qubits = 3
        self.proto.put(EGProtocol.req_create(0, num_qubits))
        ns.sim_run(10001)
        self.assertEqual(1, len(self.message))
        self.assertEqual(num_qubits, self.message[0].items[0].number)
        self.assertIsNone(self.dummy_proto.test_task_qpos)
        for i in range(num_qubits):
            self.dummy_proto.send_signal(self.dummy_proto.trigger_label)
            ns.sim_run()
            self.assertEqual(i, self.dummy_proto.test_task_qpos)
            self.dummy_proto.send_signal(self.dummy_proto.answer_label, result=(1, i + 1))
            ns.sim_run()


if __name__ == "__main__":
    unittest.main()
