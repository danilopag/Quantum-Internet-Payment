# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: testint_repeater_chain.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import unittest
from netsquid.examples.repeater_chain import run_simulation, setup_network, setup_repeater_protocol
import netsquid as ns
from netsquid.qubits import qformalism as qform


class TestRepeaterChain(unittest.TestCase):

    def setUp(self):
        ns.sim_reset()
        ns.set_random_state(seed=42)

    def test_num_iters(self):
        for num_iter in [1, 5, 10, 100]:
            self.assertEqual(num_iter, len(run_simulation(num_iters=num_iter)['fidelity']))

    def test_num_nodes(self):
        for num_nodes in [-1, 0, 1, 2]:
            with self.assertRaises(ValueError):
                run_simulation(num_nodes=num_nodes)

    def test_setup_network(self):
        for num_nodes in [3, 5, 20]:
            network = setup_network(num_nodes=num_nodes, node_distance=1, source_frequency=1)
            self.assertEqual(num_nodes + 2 * (num_nodes - 1), len(network.subcomponents))

    def test_setup_protocols(self):
        for num_nodes in [3, 5, 20]:
            network = setup_network(num_nodes=num_nodes, node_distance=1, source_frequency=1)
            protocol = setup_repeater_protocol(network)
            self.assertEqual(num_nodes - 1, len(protocol.subprotocols))

    def test_simulation(self):
        qform.set_qstate_formalism(qform.QFormalism.DM)
        for num_nodes, exp_fidelity in [(3, 0.9240), (5, 0.9083), (20, 0.7654)]:
            fidelities = run_simulation(num_nodes, node_distance=10 / num_nodes, num_iters=20)["fidelity"]
            self.assertAlmostEqual(exp_fidelity, fidelities.mean(), places=4)
        for num_nodes, exp_fidelity in [(3, 0.6487), (5, 0.6946), (20, 0.6956)]:
            fidelities = run_simulation(num_nodes, node_distance=30 / num_nodes, num_iters=20)["fidelity"]
            self.assertAlmostEqual(exp_fidelity, fidelities.mean(), places=4)


if __name__ == "__main__":
    # import logging
    # ns.logger.setLevel(logging.DEBUG)
    # ns.get_loggers()["netsquid.protocols.protocol"].setLevel(logging.DEBUG)
    # ns.get_loggers()["netsquid.components.component"].setLevel(logging.DEBUG)
    unittest.main(verbosity=2)
