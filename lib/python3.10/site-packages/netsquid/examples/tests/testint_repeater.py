# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: testint_repeater.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Integration tests for the repeater protocol module.

"""
import unittest
import pydynaa as pd
import netsquid as ns
from netsquid.util import simtools
from netsquid.qubits import ketstates as ks
from netsquid.qubits import qubitapi as qapi
from netsquid.qubits import qformalism as qform
from netsquid.nodes.node import Node
from netsquid.components import Channel
from netsquid.components import QuantumProcessor
from netsquid.protocols import Signals, NodeProtocol
from netsquid.examples.repeater import Repeater, example_network_setup, example_sim_setup


class DummyProtocol(NodeProtocol):
    def __init__(self, node, start_event, signal_result):
        super().__init__(node)
        self.start_event = start_event
        self.signal_result = signal_result

    def run(self):
        yield pd.EventExpression(event_type=self.start_event)
        return self.signal_result


class TestRepeater(unittest.TestCase):
    """Unit tests for the Repeater protocol.

    """

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        ns.sim_reset()
        self.god = pd.Entity()  # helper entity
        self.cc_delay_RB = 100
        cchannel_RB = Channel("cchannel_RB", delay=self.cc_delay_RB)
        self.node_A = Node("A")
        self.node_B = Node("B")
        self.node_R = Node("R")
        self.node_A.add_subcomponent(QuantumProcessor("QuantumProcessorA",
                                                      fallback_to_nonphysical=True))
        self.node_B.add_subcomponent(QuantumProcessor("QuantumProcessorB",
                                                      fallback_to_nonphysical=True))
        self.node_R.add_subcomponent(QuantumProcessor("QuantumProcessorR", 2,
                                                      fallback_to_nonphysical=True))
        self.node_R.connect_to(self.node_B, cchannel_RB)
        self.evtype_start_A = pd.EventType("START_A", "start node_A")
        self.evtype_start_B = pd.EventType("START_B", "start node_B")
        self.evtype_start_Ra = pd.EventType("START_RA", "start node_Ra")
        self.evtype_start_Rb = pd.EventType("START_RB", "start node_Rb")
        self.protocol_A = DummyProtocol(self.node_A, self.evtype_start_A, 0)
        self.protocol_A.start()
        self.protocol_B = DummyProtocol(self.node_B, self.evtype_start_B, 0)
        self.protocol_B.start()
        self.protocol_Ra = DummyProtocol(self.node_R, self.evtype_start_Ra, 0)
        self.protocol_Ra.start()
        self.protocol_Rb = DummyProtocol(self.node_R, self.evtype_start_Rb, 1)
        self.protocol_Rb.start()

    def tearDown(self):
        self.protocol_A.stop()
        self.protocol_B.stop()
        self.protocol_Ra.stop()
        self.protocol_Rb.stop()

    def test_connected(self):
        """Test connection of components."""
        repeater_B = Repeater(self.node_B, self.node_B.get_conn_port(self.node_R.ID), role="corrector")
        repeater_B.start_expression = repeater_B.await_signal(self.protocol_B)
        repeater_R = Repeater(self.node_R, self.node_R.get_conn_port(self.node_B.ID), role="repeater")
        repeater_R.start_expression = (repeater_R.await_signal(self.protocol_Ra) &
                                       repeater_R.await_signal(self.protocol_Rb))
        self.assertTrue(repeater_R.is_connected)
        self.assertTrue(repeater_B.is_connected)
        repeater_R = Repeater(Node("D"), self.node_B.get_conn_port(self.node_R.ID), role="corrector")
        repeater_R.start_expression = (repeater_R.await_signal(self.protocol_Ra) &
                                       repeater_R.await_signal(self.protocol_Rb))
        self.assertFalse(repeater_R.is_connected)

    def test_repeater_teleport(self):
        """Test repeater teleports correctly."""
        repeater_B = Repeater(self.node_B, self.node_B.get_conn_port(self.node_R.ID), role="corrector")
        repeater_B.start_expression = repeater_B.await_signal(self.protocol_B)
        repeater_R = Repeater(self.node_R, self.node_R.get_conn_port(self.node_B.ID), role="repeater")
        repeater_R.start_expression = (repeater_R.await_signal(self.protocol_Ra) &
                                       repeater_R.await_signal(self.protocol_Rb))
        repeater_B.start()
        repeater_R.start()
        # Create b01 states
        # qapi.set_qstate_formalism(qapi.STABILIZER_FORMALISM)
        qA1, qA2 = qapi.create_qubits(2, "A", no_state=True)
        qB1, qB2 = qapi.create_qubits(2, "B", no_state=True)
        qapi.assign_qstate([qA1, qA2], ks.b01)
        qapi.assign_qstate([qB1, qB2], ks.b01)
        self.node_A.qmemory.put([qA1], ready_evtype=self.evtype_start_A)
        self.node_B.qmemory.put([qB1], ready_evtype=self.evtype_start_B)
        self.node_R.qmemory.put([qA2], positions=[0], ready_evtype=self.evtype_start_Ra)
        self.node_R.qmemory.put([qB2], positions=[1], ready_evtype=self.evtype_start_Rb)
        qA = None
        qB = None

        def get_A(event):
            nonlocal qA
            qA, = self.node_A.qmemory.pop([0])

        def get_B(event):
            nonlocal qB
            qB, = self.node_B.qmemory.pop([0])

        ns.sim_run()
        get_A(None)
        get_B(None)
        # Check have correct qubits and fidelity.result
        self.assertTrue(qA != qB)
        self.assertTrue(qA._qstate == qB._qstate)
        self.assertAlmostEqual(qapi.fidelity([qA, qB], ks.b00), 1.)
        # Check time delayed equal to fixed delay of classical channel
        self.assertAlmostEqual(ns.sim_time(), self.cc_delay_RB)
        self.assertTrue(repeater_R.is_running)

    def test_repeater_delayed_B(self):
        """Test that repeater protocol can handle a delayed qubit on node B."""
        repeater_B = Repeater(self.node_B, self.node_B.get_conn_port(self.node_R.ID), role="corrector")
        repeater_B.start_expression = repeater_B.await_signal(self.protocol_B)
        repeater_R = Repeater(self.node_R, self.node_R.get_conn_port(self.node_B.ID), role="repeater")
        repeater_R.start_expression = (repeater_R.await_signal(self.protocol_Ra) &
                                       repeater_R.await_signal(self.protocol_Rb))
        repeater_B.start()
        repeater_R.start()
        # Create b01 states
        qA1, qA2 = qapi.create_qubits(2, "A", no_state=True)
        qB1, qB2 = qapi.create_qubits(2, "B", no_state=True)
        qapi.assign_qstate([qA1, qA2], ks.b01)
        qapi.assign_qstate([qB1, qB2], ks.b01)
        self.node_A.qmemory.put([qA1], ready_evtype=self.evtype_start_A)
        self.node_R.qmemory.put([qA2], positions=[0], ready_evtype=self.evtype_start_Ra)
        self.node_R.qmemory.put([qB2], positions=[1], ready_evtype=self.evtype_start_Rb)
        qB = None

        def put_B(event):
            self.node_B.qmemory.put([qB1], ready_evtype=self.evtype_start_B)

        def get_B(event):
            nonlocal qB
            qB, = self.node_B.qmemory.pop([0])

        delay_B = 500
        self._EVT_PUT_B = pd.EventType("PUT_B", "Put Qubit on node B store")
        self.god._wait_once(pd.EventHandler(put_B), event_type=self._EVT_PUT_B)
        self.god._wait_once(pd.EventHandler(get_B), entity=repeater_B, event_type=Signals.SUCCESS.value)
        self.god._schedule_after(delay_B, self._EVT_PUT_B)
        ns.sim_run()
        self.assertAlmostEqual(qapi.fidelity(qB.qstate.qubits, ks.b00), 1.)
        # Check time delayed equal to delay in putting qubit B on node B
        self.assertAlmostEqual(ns.sim_time(), delay_B)


class TestRepeaterExpt(unittest.TestCase):
    """Integration tests for the RepeaterExpt protocol.

    """

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        ns.sim_reset()

    def tearDown(self):
        ns.set_qstate_formalism(qform.QFormalism.KET)

    def test_run_filterrepeaterexp(self):
        """Test running of filtering RepeaterExpt with sample settings."""
        # NOTE we test with statistical sampling, so tests can statistically fail.
        network = example_network_setup()
        # Fix the random seed to reduce this risk
        for formalism in [qform.QFormalism.KET, qform.QFormalism.DM]:
            ns.set_qstate_formalism(formalism)
            simtools.set_random_state(seed=0)
            network.reset()
            rexp, dc = example_sim_setup(
                network.subcomponents["node_A"], network.subcomponents["node_B"],
                network.subcomponents["node_R"], purify="filter", num_runs=2000)
            rexp.start()
            ns.sim_run()
            # print(ns.sim_run()
            df = dc.dataframe
            self.assertFalse(df.empty)
            self.assertLessEqual(abs(df["F2"].mean() - 0.42), 0.05)
            self.assertLessEqual(abs(df["pairs_A"].mean() - 3.9), 0.25)
            self.assertLessEqual(abs(df["pairs_B"].mean() - 3.9), 0.25)
            self.assertLessEqual(abs(df["time"].mean() - 1180e3), 150e3)

    def test_run_distilrepeaterexp(self):
        """Test running of DistilRepeaterExpt with sample settings."""
        # NOTE we test with statistical sampling, so tests can statistically fail.
        network = example_network_setup()
        # Fix the random seed to reduce this risk
        for formalism in [qform.QFormalism.KET, qform.QFormalism.DM, qform.QFormalism.STAB]:
            ns.set_qstate_formalism(formalism)
            simtools.set_random_state(seed=0)
            network.reset()
            rexp, dc = example_sim_setup(
                network.get_node("node_A"), network.get_node("node_B"),
                network.get_node("node_R"), purify="distil", num_runs=2000)
            rexp.start()
            ns.sim_run()
            df = dc.dataframe
            self.assertFalse(df.empty)
            self.assertLessEqual(abs(df["F2"].mean() - 0.44), 0.05)
            self.assertLessEqual(abs(df["pairs_A"].mean() - 2.6), 0.25)
            self.assertLessEqual(abs(df["pairs_B"].mean() - 2.6), 0.25)
            self.assertLessEqual(abs(df["time"].mean() - 625e3), 100e3)


if __name__ == "__main__":
    # import logging
    # ns.logger.setLevel(logging.DEBUG)
    # ns.get_loggers()["netsquid.protocols.protocol"].setLevel(logging.DEBUG)
    # ns.get_loggers()["netsquid.components.component"].setLevel(logging.DEBUG)
    unittest.main(verbosity=2)
