# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: testint_purify.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Integration tests for the filter protocol module.

"""
import unittest
import tracemalloc
import numpy as np
import netsquid as ns
import pydynaa as pd
from netsquid.util.simtools import sim_reset, sim_run, set_random_state, sim_time
from netsquid.util.simlog import check_memory_usage
from netsquid.nodes.node import Node
from netsquid.qubits import operators as ops
from netsquid.qubits import ketstates as ks
from netsquid.qubits import qubitapi as qapi
from netsquid.qubits import qformalism as qform
from netsquid.nodes.connections import DirectConnection
from netsquid.components.channel import Channel
from netsquid.components.qprocessor import QuantumProcessor
from netsquid.protocols import Signals, NodeProtocol
from netsquid.examples.purify import Filter, Distil, example_sim_setup, example_network_setup


class DummyProtocol(NodeProtocol):
    def __init__(self, node, signal_result):
        super().__init__(node)
        self.return_value = signal_result

    def run(self):
        while True:
            yield self.await_port_input(self.node.qmemory.ports["qin"])
            self.send_signal(Signals.SUCCESS, self.return_value)


class TestFilter(unittest.TestCase):
    """Unit tests for the Filter protocol.

    """

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        sim_reset()
        self.god = pd.Entity()  # helper entity
        self.cc_delay_AB = 100
        self.cc_delay_BA = 100
        cchannel_AB = Channel("cchannel_AB", delay=self.cc_delay_AB)
        cchannel_BA = Channel("cchannel_BA", delay=self.cc_delay_BA)
        cconn_AB = DirectConnection("cconnAB", cchannel_AB, cchannel_BA)
        self.node_A = Node("A")
        self.node_B = Node("B")
        self.node_C = Node("C")
        self.node_A.add_subcomponent(QuantumProcessor("QuantumMemoryATest", fallback_to_nonphysical=True))
        self.node_B.add_subcomponent(QuantumProcessor("QuantumMemoryBTest", fallback_to_nonphysical=True))
        self.node_A.connect_to(self.node_B, cconn_AB)
        self.dummy_protocol_A = DummyProtocol(self.node_A, 0)
        self.dummy_protocol_B = DummyProtocol(self.node_B, 0)
        self.dummy_protocol_A.start()
        self.dummy_protocol_B.start()

    def tearDown(self):
        self.dummy_protocol_A.stop()
        self.dummy_protocol_B.stop()

    def test_connected(self):
        """Test connection of components."""
        filterA = Filter(self.node_A, self.node_A.get_conn_port(self.node_B.ID))
        filterA.start_expression = filterA.await_signal(self.dummy_protocol_A, Signals.SUCCESS)
        filterB = Filter(self.node_B, self.node_B.get_conn_port(self.node_A.ID))
        filterB.start_expression = filterB.await_signal(self.dummy_protocol_B, Signals.SUCCESS)
        self.assertTrue(filterA.is_connected)
        self.assertTrue(filterB.is_connected)
        self.assertFalse(Filter(self.node_A, self.node_A.get_conn_port(self.node_B.ID), None).is_connected)

    def test_filter_success(self):
        """Test successful run of filter protocol."""
        filterA = Filter(self.node_A, self.node_A.get_conn_port(self.node_B.ID), epsilon=1)
        filterA.start_expression = filterA.await_signal(self.dummy_protocol_A, Signals.SUCCESS)
        filterB = Filter(self.node_B, self.node_B.get_conn_port(self.node_A.ID), epsilon=1)
        filterB.start_expression = filterB.await_signal(self.dummy_protocol_B, Signals.SUCCESS)
        filterA.start()
        filterB.start()
        # Create qubits in |00> state
        qA, qB = qapi.create_qubits(2)
        qA_ready = None
        qB_ready = None

        def retrieve_qubit(event):
            nonlocal qA_ready, qB_ready
            # event = evexpr.triggered_events[0]
            if event.source == filterA:
                [qA_ready] = event.source.node.qmemory.pop([0])
            elif event.source == filterB:
                [qB_ready] = event.source.node.qmemory.pop([0])

        self.god._wait(pd.EventHandler(retrieve_qubit), event_type=Signals.SUCCESS.value)
        sim_run()
        self.assertTrue(filterA.is_running)
        self.assertTrue(filterB.is_running)
        self.assertNotEqual(qA_ready, qA)
        self.assertNotEqual(qB_ready, qB)
        sim_run()
        self.assertEqual(filterA.get_signal_result(Signals.SUCCESS), None)
        self.assertEqual(filterB.get_signal_result(Signals.SUCCESS), None)
        self.assertEqual(qA_ready, None)
        self.assertEqual(qB_ready, None)
        self.node_A.qmemory.put([qA])
        self.node_B.qmemory.put([qB])
        sim_run()
        self.assertEqual(filterA.get_signal_result(Signals.SUCCESS), 0)
        self.assertEqual(filterB.get_signal_result(Signals.SUCCESS), 0)
        self.assertEqual(qA_ready, qA)
        self.assertEqual(qB_ready, qB)

    def test_filter_fail(self):
        """Test failed run of filter protocol."""
        filterA = Filter(self.node_A, self.node_A.get_conn_port(self.node_B.ID), epsilon=0)
        filterA.start_expression = filterA.await_signal(self.dummy_protocol_A, Signals.SUCCESS)
        filterB = Filter(self.node_B, self.node_B.get_conn_port(self.node_A.ID), epsilon=0)
        filterB.start_expression = filterB.await_signal(self.dummy_protocol_B, Signals.SUCCESS)
        filterA.start()
        filterB.start()
        # Create qubits in |00> state
        qA, qB = qapi.create_qubits(2)
        self.node_A.qmemory.put([qA])
        self.node_B.qmemory.put([qB])
        nodeA_failed = False
        nodeB_failed = False

        def check_failed(event):
            nonlocal nodeA_failed, nodeB_failed
            if event.source == filterA:
                nodeA_failed = True
            if event.source == filterB:
                nodeB_failed = True

        self.god._wait(pd.EventHandler(check_failed), event_type=Signals.FAIL.value)
        sim_run()
        self.assertTrue(nodeA_failed)
        self.assertTrue(nodeB_failed)
        self.assertTrue(filterA.is_running)
        self.assertTrue(filterB.is_running)

    def test_filter_restart_on_replace(self):
        """Test that filter nodes restart when Qubit on QuantumMemory replaced."""
        filterA = Filter(self.node_A, self.node_A.get_conn_port(self.node_B.ID), epsilon=0)
        filterA.start_expression = filterA.await_signal(self.dummy_protocol_A, Signals.SUCCESS)
        filterB = Filter(self.node_B, self.node_B.get_conn_port(self.node_A.ID), epsilon=0)
        filterB.start_expression = filterB.await_signal(self.dummy_protocol_B, Signals.SUCCESS)
        filterA.start()
        filterB.start()
        # Create 3 qubits in |110> state
        qA, qB1, qB2 = qapi.create_qubits(3)
        qapi.operate(qA, ops.X)
        qapi.operate(qB1, ops.X)
        # Put only qB1 on filter, together with qA filter will succeed
        qmem_pos_B = 0
        self.node_B.qmemory.put([qB1], positions=[qmem_pos_B])
        nodeB_failed = False
        PUT_NEW_QUBIT = pd.EventType("PUT_NEW_QUBIT", "Put new qubit on the store")

        def check_failed(event):
            nonlocal nodeB_failed
            nodeB_failed = True

        def put_new_qubit(event):
            self.node_A.qmemory.put([qA])
            self.node_B.qmemory.put([qB2], positions=[qmem_pos_B])

        self.god._wait_once(pd.EventHandler(put_new_qubit), event_type=PUT_NEW_QUBIT)
        self.god._wait_once(pd.EventHandler(check_failed), event_type=Signals.FAIL.value)
        self.god._schedule_after(50, event_type=PUT_NEW_QUBIT)
        sim_run()
        # if qB2 successfully replaced qB1 then filter will fail, if not filter should pass
        self.assertTrue(filterA.is_running)
        self.assertTrue(filterB.is_running)
        self.assertTrue(nodeB_failed)


class TestDistil(unittest.TestCase):
    """Unit tests for the Distil protocol.

    """

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        sim_reset()
        self.god = pd.Entity()  # helper entity
        self.cc_delay_AB = 100
        self.cc_delay_BA = 100
        cchannel_AB = Channel("cchannel_AB", delay=self.cc_delay_AB)
        cchannel_BA = Channel("cchannel_BA", delay=self.cc_delay_BA)
        cconn_AB = DirectConnection("cconnAB", cchannel_AB, cchannel_BA)
        self.node_A = Node("A")
        self.node_B = Node("B")
        self.node_C = Node("C")
        self.node_A.add_subcomponent(QuantumProcessor("QMemA", 2, fallback_to_nonphysical=True))
        self.node_B.add_subcomponent(QuantumProcessor("QMemB", 2, fallback_to_nonphysical=True))
        self.node_A.connect_to(self.node_B, cconn_AB)
        self.EVT_STORE = pd.EventType("STORE", "Qubit ready to be stored.")
        self.dummy_protocol_A = DummyProtocol(self.node_A, 0)
        self.dummy_protocol_B = DummyProtocol(self.node_B, 0)
        self.dummy_protocol_A.start()
        self.dummy_protocol_B.start()

    def tearDown(self):
        self.dummy_protocol_A.stop()
        self.dummy_protocol_B.stop()

    def test_connected(self):
        """Test connection of components."""
        distilA = Distil(self.node_A, self.node_A.get_conn_port(self.node_B.ID), "A")
        distilA.start_expression = distilA.await_signal(self.dummy_protocol_A, Signals.SUCCESS)
        distilB = Distil(self.node_B, self.node_B.get_conn_port(self.node_A.ID), "B")
        distilB.start_expression = distilB.await_signal(self.dummy_protocol_B, Signals.SUCCESS)
        self.assertTrue(distilA.is_connected)
        self.assertTrue(distilB.is_connected)
        self.assertFalse(Distil(self.node_A, self.node_A.get_conn_port(self.node_B.ID), "A", None).is_connected)

    def _create_bell_state(self, bell_state):
        q1, q2 = qapi.create_qubits(2, no_state=True)
        qapi.assign_qstate([q1, q2], bell_state)
        return q1, q2

    def _delayed_store(self, node, delay, qubit, start_protocol):
        def do_store(event):
            position = node.qmemory.unused_positions[0]
            node.qmemory.put([qubit], positions=[position])
            start_protocol.return_value = position

        event = self.god._schedule_after(delay, event_type=self.EVT_STORE)
        self.god._wait_once(pd.EventHandler(do_store), event=event)

    def test_distil_success(self):
        """Test successful run of distil protocol."""
        distilA = Distil(self.node_A, self.node_A.get_conn_port(self.node_B.ID), "A")
        distilA.start_expression = distilA.await_signal(self.dummy_protocol_A, Signals.SUCCESS)
        distilB = Distil(self.node_B, self.node_B.get_conn_port(self.node_A.ID), "B")
        distilB.start_expression = distilB.await_signal(self.dummy_protocol_B, Signals.SUCCESS)
        distilA.start()
        distilB.start()
        # Create two entangled states and distribute to nodes (without delay)
        qA1, qB1 = self._create_bell_state(ks.b00)
        qA2, qB2 = self._create_bell_state(ks.b00)
        # qA2, qB2 = qapi.create_qubits(2)
        self._delayed_store(self.node_A, 0, qA1, self.dummy_protocol_A)
        self._delayed_store(self.node_A, 5, qA2, self.dummy_protocol_A)
        self._delayed_store(self.node_B, 0, qB1, self.dummy_protocol_B)
        self._delayed_store(self.node_B, 5, qB2, self.dummy_protocol_B)
        qA_ready = None
        qB_ready = None

        def retrieve_qubit(event):
            nonlocal qA_ready, qB_ready
            if event.source == distilA:
                [qA_ready] = event.source.node.qmemory.pop([0])
            elif event.source == distilB:
                [qB_ready] = event.source.node.qmemory.pop([0])

        self.god._wait(pd.EventHandler(retrieve_qubit), event_type=Signals.SUCCESS.value)
        sim_run()
        self.assertIsNotNone(qA_ready)
        self.assertIsNotNone(qB_ready)
        self.assertTrue(sim_time(), 5)
        # self.assertFalse(distil.is_running)
        self.assertTrue(distilA.is_running)  # now keeps running
        self.assertTrue(distilB.is_running)  # now keeps running
        self.assertTrue(np.isclose(qapi.fidelity([qA_ready, qB_ready], ks.b00, squared=True), 1.0))

    def test_distil_fail(self):
        """Test failure loops of distil protocol."""
        distilA = Distil(self.node_A, self.node_A.get_conn_port(self.node_B.ID), "A")
        distilA.start_expression = distilA.await_signal(self.dummy_protocol_A, Signals.SUCCESS)
        distilB = Distil(self.node_B, self.node_B.get_conn_port(self.node_A.ID), "B")
        distilB.start_expression = distilB.await_signal(self.dummy_protocol_B, Signals.SUCCESS)
        distilA.start()
        distilB.start()
        # Create two entangled states and distribute to nodes (without delay)
        nodeA_failed = 0
        nodeB_failed = 0
        num_fail_runs = 5

        def load_new_qubits():
            self.dummy_protocol_A.return_value = 0
            self.dummy_protocol_B.return_value = 0
            qA1, qB1 = qapi.create_qubits(2)
            qA2, qB2 = qapi.create_qubits(2)
            # Rotate states to ensure 100% failure of distillation
            qapi.operate(qA1, ops.create_rotation_op(3 * np.pi / 2, (1, 0, 0)))
            qapi.operate(qB1, ops.create_rotation_op(3 * np.pi / 2, (1, 0, 0), conjugate=True))
            qapi.operate(qA2, ops.create_rotation_op(3 * np.pi / 2, (1, 0, 0)))
            qapi.operate(qB2, ops.create_rotation_op(np.pi / 2, (1, 0, 0), conjugate=True))
            # qA2, qB2 = qapi.create_qubits(2)
            self._delayed_store(self.node_A, 0, qA1, self.dummy_protocol_A)
            self._delayed_store(self.node_A, 1, qA2, self.dummy_protocol_A)
            self._delayed_store(self.node_B, 0, qB1, self.dummy_protocol_B)
            self._delayed_store(self.node_B, 1, qB2, self.dummy_protocol_B)

        def check_failed(event):
            nonlocal nodeA_failed, nodeB_failed
            if event.source == distilA:
                nodeA_failed += 1
                if nodeA_failed < num_fail_runs:
                    load_new_qubits()
            elif event.source == distilB:
                nodeB_failed += 1

        self.god._wait(pd.EventHandler(check_failed), event_type=Signals.FAIL.value)
        load_new_qubits()
        sim_run()
        self.assertTrue(distilA.is_running)
        self.assertTrue(distilB.is_running)
        self.assertEqual(nodeA_failed, num_fail_runs)
        self.assertEqual(nodeB_failed, num_fail_runs)
        self.assertEqual(sim_time(), 5 * (self.cc_delay_AB + 1))


class TestFilteringExample(unittest.TestCase):
    """Integration tests for the FilteringExample protocol.

    """

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        ns.sim_reset()

    def tearDown(self):
        qform.set_qstate_formalism(qform.QFormalism.KET)

    def test_run_filtexp(self):
        """Test running of FiltExpt with sample settings."""
        # Setup data collector
        # NOTE we test with statistical sampling, so tests can statistically fail.
        network = example_network_setup()
        # Fix the random seed to reduce this risk
        for formalism in [qform.QFormalism.DM, qform.QFormalism.KET]:
            qform.set_qstate_formalism(formalism)
            ns.sim_reset()
            set_random_state(seed=0)
            network.reset()
            filtexp, dc = example_sim_setup(network.subcomponents["node_A"], network.subcomponents["node_B"],
                                            num_runs=4000)
            with check_memory_usage(
                    2000000,  # up from 200000 to allow test to pass (see Issue ...)
                    filters=[tracemalloc.Filter(False, "*examples/purify*")]):
                filtexp.start()
                ns.sim_run()
            df = dc.dataframe
            self.assertLessEqual(abs(df["F2"].mean() - 0.75), 0.05)
            self.assertLessEqual(abs(df["pairs"].mean() - 3.9), 0.25)
            self.assertLessEqual(abs(df["time"].mean() - 820e3), 150e3)
            self.assertFalse(filtexp.is_running)


if __name__ == "__main__":
    # import logging
    # ns.logger.setLevel(logging.DEBUG)
    unittest.main()
