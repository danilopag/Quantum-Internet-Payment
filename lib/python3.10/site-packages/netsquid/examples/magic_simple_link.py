# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: magic_simple_link.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
r"""
When creating complicated simulations the runtime may become extremely long.
In certain cases this problem can be solved by approximating certain parts of the simulation.
Attempting entanglement creation is such a process, in this example
we will extend the `simple_link example <learn.examples.simple_link.html>`_
and replace a part of the simulation with a quicker implementation.
Instead of modelling the complete underlying behaviour, we make an abstraction and think of these details
as part of a black box.
It is sufficient to only model the output of this black box, granted we follow the same distribution.
By doing so we break the locality constraints we would normally like to enforce.
Breaking these constraints can be considered 'cheating',
but as this is a simulation detail it is usually referred to as 'magic'.

In this example we take the ``EGService`` as a whole, however we implement a new handler function.
In order to make this handler function cheat locality we have to give the service a reference to the
other service.
Instead of communicating with the other service and generating attempts,
we can skip all attempts and put the state we are after into the memories
on both nodes after the expected simulation time using some timers.
Of course, these timers should follow the same distribution as they would have in the original service, but for
this example we take a static delay.

.. literalinclude:: ../../netsquid/examples/magic_simple_link.py
    :pyobject: MagicEGProtocol

Setting up our protocols is almost identical, however there is
no need to communicate anymore, therefore the protocol doesn't need to know which port to use.

.. literalinclude:: ../../netsquid/examples/magic_simple_link.py
    :pyobject: setup_protocol

Running the protocols in the same manner we did in the simple link example,

.. literalinclude:: ../../netsquid/examples/magic_simple_link.py
    :pyobject: run_simulation

will give us the following output:

>>> from netsquid.examples.magic_simple_link import run_simulation
>>> run_simulation()
Waiting for responses with create_id 1
Qubits between Alice and Bob with purpose_id 4:
   1010000: [Qubit('QS#0-0'), Qubit('QS#0-1')] with create_id 1
   2010000: [Qubit('QS#1-0'), Qubit('QS#1-1')] with create_id 1
   3010000: [Qubit('QS#2-0'), Qubit('QS#2-1')] with create_id 1
Waiting for responses with create_id 2
Waiting for responses with create_id 3
Qubits between Alice and Bob with purpose_id 6:
   4020000: [Qubit('QS#3-0'), Qubit('QS#3-1')] with create_id 2
   5020000: [Qubit('QS#4-0'), Qubit('QS#4-1')] with create_id 2
Qubits between Alice and Bob with purpose_id 4:
   6020000: [Qubit('QS#5-0'), Qubit('QS#5-1')] with create_id 3
Finished all network requests

In the output we see the main difference is the number of qubits that have been generated in the simulation
is vastly smaller.
Instead of the almost 10000 qubits we only needed 12.
Would we have gotten the correct distribution for the delays the simulation wouldn't behave differently,
yet this version can be computed a lot faster.

"""

import netsquid as ns
from netsquid.qubits.qformalism import QFormalism
from netsquid.examples.simple_link import EGService, NetworkProtocol, create_example_network
from netsquid.qubits import StateSampler


class MagicEGProtocol(EGService):
    """Extends the EGService by magically creating the qubits.

    Skips communicating with the other service and 'magically' puts qubits
    into the node's memory. The service sends a response signal once the protocol is finished.

    Parameters
    ----------
    node : :class:`~netsquid.nodes.node.Node`
        The node this protocol runs on.
    name : str, optional
        The name of this protocol. Default 'MagicEGProtocol'.

    Attributes
    ----------
    req_create : namedtuple
        A request to create entanglement with a remote node.
    res_ok : namedtuple
        A response to indicate a create request has finished.

    """

    def __init__(self, node, name="MagicEGProtocol"):
        super().__init__(node, name=name)
        # Sample our expected states weighted by their probabilities
        self._sampler = StateSampler([ns.b01, ns.b11], [0.5, 0.5])
        self._other_service = None

    def add_other_service(self, service):
        self._other_service = service

    def handle_request(self, request, identifier, start_time=None, **kwargs):
        """Schedule the request.

        Schedule the request in a queue and
        signal to :meth:`~netsquid.examples.simple_link.EGProtocol.run`
        new items have been put into the queue.

        Parameters
        ----------
        request :
            The object representing the request.
        identifier : str
            The identifier for this request.
        start_time : float, optional
            The time after which the request can be executed.
        kwargs : dict
            Additional arguments not part of the original request.

        Returns
        -------
        dict
            The dictionary with additional arguments.
            For the create request this is the unique entanglement id.

        """
        if start_time is None:
            # By default we wait until we expect the message to have arrived
            travel_time = 10000
            start_time = ns.sim_time() + travel_time
        if kwargs.get('create_id') is None:
            kwargs['create_id'] = self._get_next_create_id()
        self.queue.append((start_time, (identifier, request, kwargs)))
        # Send ourselves a signal we got a new request
        self.send_signal(self._new_req_signal)
        return kwargs

    def create(self, purpose_id, number, create_id, **kwargs):
        """Magic handler of create requests.

        Parameters
        ----------
        purpose_id : int
            The number used to tag this request for a specific purpose in a higher layer.
        number : int
            The number of qubits to make in this request.
        create_id : int
            The unique number associated with this request.

        Yields
        ------
        :class:`~pydynaa.core.EventExpression`
            The expressions required to execute the create request.

        """
        for curpairs in range(number):
            # We wait a bit, this should be sampled from a distribution.
            yield self.await_timer(1000000)
            # We reserve position 0 for the communication qubit
            qpos = curpairs + 1
            qubits = ns.qubits.create_qubits(2)
            qstate, _, _ = self._sampler.sample()
            ns.qubits.assign_qstate(qubits, qstate)
            self.node.qmemory.put(qubits[0], positions=[qpos])
            # Here we cheat by putting the qubits into the memory manually
            self._other_service.node.qmemory.put(qubits[1], positions=[qpos])
            response = self.res_ok(purpose_id, create_id, qpos)
            self.send_response(response)
            # Cheat again to make sure the response is also send via Bob
            self._other_service.send_response(response)


def setup_protocol(network):
    """Configure the protocols.

    Parameters
    ----------
    network : :class:`~netsquid.nodes.network.Network`
        The network to configure the protocols on. Should consist of two nodes
        called Alice and Bob.

    Returns
    -------
    :class:`~netsquid.protocols.protocol.Protocol`
        A protocol describing the complete simple link setup.

    """
    nodes = network.nodes
    alice_egp = MagicEGProtocol(nodes['Alice'])
    bob_egp = MagicEGProtocol(nodes['Bob'])
    # The services need a reference to each other in order to cheat
    alice_egp.add_other_service(bob_egp)
    bob_egp.add_other_service(alice_egp)
    return NetworkProtocol("SimpleLinkProtocol", alice_egp, bob_egp)


def run_simulation():
    """Run the example simulation.

    """
    ns.sim_reset()
    ns.set_random_state(42)  # Set the seed so we get the same outcome
    ns.set_qstate_formalism(QFormalism.DM)
    network = create_example_network()
    protocol = setup_protocol(network)
    protocol.start()
    ns.sim_run()


if __name__ == "__main__":
    run_simulation()
