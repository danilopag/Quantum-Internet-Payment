# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_sparseutil.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the sparseutil module.

"""
import unittest
import numpy as np
from scipy import sparse
from netsquid.qubits.ketutil import ket2sparsedm
from netsquid.qubits.ketstates import s0, s1, h0, h1
from netsquid.qubits.ketstates import s00, s01, s10, s11
from netsquid.qubits.ketstates import h00, h10
from netsquid.qubits.ketstates import b00, b01, b11
from netsquid.qubits.sparseutil import sparse_kron_identity_left, sparse_kron_identity_right, sparse_kron_identity_middle
from netsquid.qubits import sparseutil as su
from netsquid.qubits.sparseutil import sparse_allclose


class TestSparseUtil(unittest.TestCase):
    """Unit tests for the sparseutil module.

    """

    def test_sparse_kron_identity_extend(self):
        """Test sparse_kron_identity_{left,right} functions."""
        for a in range(2, 8):
            for b in range(2, 8):
                for N in range(2, 8):
                    # Test three different matrix types
                    dense_matrix = np.asarray(np.random.rand(a, b), dtype=complex)
                    sparse_matrix = np.copy(dense_matrix)
                    sparse_matrix[sparse_matrix < 0.33] = 0
                    zero_matrix = np.zeros((a, b), dtype=complex)
                    for matrix in [dense_matrix, sparse_matrix, zero_matrix]:
                        sp_in = sparse.csr_matrix(matrix)
                        # Test kron left
                        sp_kronleft = sparse_kron_identity_left(sp_in, N)
                        self.assertEqual(sp_kronleft.shape, (sp_in.shape[0] * N, sp_in.shape[1] * N))
                        self.assertEqual(sp_kronleft.nnz, sp_in.nnz * N)
                        self.assertTrue(isinstance(sp_kronleft, sparse.csr.csr_matrix))
                        dense_out = np.kron(np.eye(N), matrix)
                        self.assertTrue(np.allclose(sp_kronleft.toarray(), dense_out))
                        # Test kron right
                        sp_kronright = sparse_kron_identity_right(sp_in, N)
                        self.assertEqual(sp_kronright.shape, (sp_in.shape[0] * N, sp_in.shape[1] * N))
                        self.assertEqual(sp_kronright.nnz, sp_in.nnz * N)
                        self.assertTrue(isinstance(sp_kronright, sparse.csr.csr_matrix))
                        dense_out = np.kron(matrix, np.eye(N))
                        self.assertTrue(np.allclose(sp_kronright.toarray(), dense_out))

    def test_sparse_kron_identity_middle(self):
        """Test sparse_kron_identity_middle function."""
        # Should never be called for n > 2, but should still be tested
        for n in range(2, 4):
            a = 2 ** n
            for N in range(2, 6):
                for ins_index in range(0, n - 1):
                    # Test three different matrix types
                    dense_matrix = np.array(np.random.rand(a, a), dtype=complex)
                    sparse_matrix = np.copy(dense_matrix)
                    sparse_matrix[sparse_matrix < 0.33] = 0
                    zero_matrix = np.zeros((a, a), dtype=complex)
                    for matrix in [dense_matrix, sparse_matrix, zero_matrix]:
                        sp_kronmid = sparse_kron_identity_middle(matrix, ins_index, N)
                        self.assertTrue(isinstance(sp_kronmid, sparse.csr.csr_matrix))
                        # Construct dense comparison
                        dense_id = np.eye(N)
                        dim = matrix.shape[0]
                        stepsize = dim // (2 ** (ins_index + 1))
                        rows = []
                        row = []
                        for i in range(0, dim, stepsize):
                            row = []
                            for j in range(0, dim, stepsize):
                                row.append(np.kron(dense_id, matrix[i:i + stepsize, j:j + stepsize]))
                            rows.append(row)
                        dense_out = np.block(rows)
                        self.assertTrue(np.allclose(sp_kronmid.toarray(), dense_out))

    def test_reorder_sparse_dm(self):
        """Test reorder_sparse_dm function."""
        # Asymmetric matrix should raise error
        rho_assym = sparse.csr_matrix((2, 3))
        with self.assertRaises(ValueError):
            su.reorder_sparse_dm(rho_assym, [1, 0])
        # 3 qubit state
        st012 = np.kron(s01, h1)  # |01->
        rho = ket2sparsedm(st012)
        self.assertTrue(sparse_allclose(su.reorder_sparse_dm(rho, [0, 1, 2]),
                                        rho))  # null case
        st021 = np.kron(s0, np.kron(h1, s1))  # |0-1>
        self.assertTrue(sparse_allclose(su.reorder_sparse_dm(rho, [0, 2, 1]),
                                        ket2sparsedm(st021)))
        self.assertTrue(sparse_allclose(rho, ket2sparsedm(st012)))  # check same rho
        st210 = np.kron(np.kron(h1, s1), s0)  # |-10>
        self.assertTrue(sparse_allclose(su.reorder_sparse_dm(rho, [2, 1, 0]),
                                        ket2sparsedm(st210)))
        self.assertTrue(sparse_allclose(rho, ket2sparsedm(st012)))  # check same rho
        # 2 qubit state complex state
        st01 = np.array([[0.5], [-0.5j], [0.5], [0.5j]], dtype=complex)
        rho = ket2sparsedm(st01)
        self.assertTrue(sparse_allclose(su.reorder_sparse_dm(rho, [0, 1]),
                                        rho))  # null case
        st10 = np.array([[0.5], [0.5], [-0.5j], [0.5j]], dtype=complex)
        self.assertTrue(sparse_allclose(su.reorder_sparse_dm(rho, [1, 0]),
                                        ket2sparsedm(st10)))
        # 4 qubit mixed state
        st1_0123 = np.kron(s01, h10)  # |01-+>
        st2_0123 = np.kron(h00, s10)  # |++10>
        rho = 0.5 * (ket2sparsedm(st1_0123) + ket2sparsedm(st2_0123))
        self.assertTrue(sparse_allclose(su.reorder_sparse_dm(rho, [0, 1, 2, 3]),
                                        rho))  # null case

        st1_3012 = np.kron(h0, np.kron(s0, np.kron(s1, h1)))
        st2_3012 = np.kron(s0, np.kron(h00, s1))
        self.assertTrue(sparse_allclose(su.reorder_sparse_dm(rho, [3, 0, 1, 2]),
                                        0.5 * (ket2sparsedm(st1_3012) + ket2sparsedm(st2_3012))))

        st1_0213 = np.kron(s0, np.kron(h1, np.kron(s1, h0)))
        st2_0213 = np.kron(h0, np.kron(s1, np.kron(h0, s0)))
        self.assertTrue(sparse_allclose(su.reorder_sparse_dm(rho, [0, 2, 1, 3]),
                                        0.5 * (ket2sparsedm(st1_0213) + ket2sparsedm(st2_0213))))
        self.assertTrue(sparse_allclose(rho, 0.5 * (ket2sparsedm(st1_0123) + ket2sparsedm(st2_0123))))    # check same rho
        st1_2130 = np.kron(np.kron(h1, s1), np.kron(h0, s0))
        st2_2130 = np.kron(np.kron(s1, h0), np.kron(s0, h0))
        self.assertTrue(sparse_allclose(su.reorder_sparse_dm(rho, [2, 1, 3, 0]),
                                        0.5 * (ket2sparsedm(st1_2130) + ket2sparsedm(st2_2130))))

    def test_sparse_partialtrace(self):
        """Test matrix reordering."""
        # *** Trace out qubits from entangled bipartite state
        rho_b00 = ket2sparsedm(b00)
        rho_half_eye = sparse.csr_matrix(0.5 * np.eye(2))
        for i in range(2):
            self.assertTrue(sparse_allclose(su.sparse_partialtrace(rho_b00, [i]), rho_half_eye))
        rho_fully_traced = su.sparse_partialtrace(rho_b00, [0, 1])
        self.assertTrue(rho_fully_traced.shape[0], 1)
        rho_1 = sparse.csr_matrix(([1], ([0], [0])), shape=(1, 1))
        self.assertTrue(sparse_allclose(rho_fully_traced, rho_1))
        # *** Trace out qubits from GHZ tripartite state
        ghz3 = (np.kron(s00, s0) + np.kron(s11, s1)) / np.sqrt(2)
        rho_ghz3 = ket2sparsedm(ghz3)
        for i in range(3):
            self.assertTrue(sparse_allclose(su.sparse_partialtrace(rho_ghz3, [i]), 0.5 * (ket2sparsedm(s00) + ket2sparsedm(s11))))
            inds = set([0, 1, 2])
            inds.remove(i)
            self.assertTrue(sparse_allclose(su.sparse_partialtrace(rho_ghz3, list(inds)), rho_half_eye))
        rho_ghz3_fully_traced = su.sparse_partialtrace(rho_ghz3, [0, 1, 2])
        self.assertTrue(sparse_allclose(rho_ghz3_fully_traced, rho_1))
        # *** Trace out qubits from arbitrary large mixed state
        st1 = np.kron(s00, h10)
        st2 = np.kron(h10, b11)
        st3 = np.kron(b01, s10)
        rho = (ket2sparsedm(st1) + ket2sparsedm(st2) + ket2sparsedm(st3)) / 3
        # trace out two non-adjacent qubits:
        rho_test = sparse.csr_matrix(np.array([[5/12, 1/6, -1/12, 0],
                                               [1/6, 1/4, 0, -1/12],
                                               [-1/12, 0, 1/4, 0],
                                               [0, -1/12, 0, 1/12]], dtype=complex))
        self.assertTrue(sparse_allclose(su.sparse_partialtrace(rho, [1, 2]), rho_test))
        rho_test = sparse.csr_matrix(np.array([[5/12, 1/12, -1/12, -1/12],
                                               [1/12, 1/4, 1/12, -1/12],
                                               [-1/12, 1/12, 1/4, 1/12],
                                               [-1/12, -1/12, 1/12, 1/12]], dtype=complex))
        self.assertTrue(sparse_allclose(su.sparse_partialtrace(rho, [2, 3]), rho_test))
        # trace out two adjacent qubits:
        rho_test = sparse.csr_matrix(np.array([[1/4, -1/6, -1/12, 0],
                                               [-1/6, 5/12, 0, -1/12],
                                               [-1/12, 0, 1/12, 0],
                                               [0, -1/12, 0, 1/4]], dtype=complex))
        self.assertTrue(sparse_allclose(su.sparse_partialtrace(rho, [1, 3]), rho_test))
        rho_test = sparse.csr_matrix(np.array([[1/4, -1/6, 1/12, 0],
                                               [-1/6, 5/12, 0, 1/12],
                                               [1/12, 0, 1/12, 0],
                                               [0, 1/12, 0, 1/4]], dtype=complex))
        self.assertTrue(sparse_allclose(su.sparse_partialtrace(rho, [0, 3]), rho_test))
        # trace out three qubits:
        rho_test = sparse.csr_matrix(np.array([[1/3, -1/6], [-1/6, 2/3]], dtype=complex))
        self.assertTrue(sparse_allclose(su.sparse_partialtrace(rho, [0, 1, 3]), rho_test))
        # Check exception on bad qubit indices
        with self.assertRaises(ValueError):
            su.sparse_partialtrace(rho, [-1, 3])
        with self.assertRaises(ValueError):
            su.sparse_partialtrace(rho, [5, 0])

    def test_sparse_dm_fidelity(self):
        """Test fidelity of sparse density matrices."""
        rho = ket2sparsedm(b00)
        for sigma, F in [(ket2sparsedm(b00), 1), (ket2sparsedm(s00), 1 / np.sqrt(2)), (ket2sparsedm(b11), 0.)]:
            self.assertAlmostEqual(su.sparse_dm_fidelity(rho, sigma), F)
            self.assertAlmostEqual(su.sparse_dm_fidelity(rho, sigma, squared=True), F ** 2)
            # Check if the fidelity is computed properly with the sparse_dm_check.
            self.assertAlmostEqual(su.sparse_dm_fidelity(rho, sigma, sparse_dm_check=True), F)
            self.assertAlmostEqual(su.sparse_dm_fidelity(rho, sigma, squared=True, sparse_dm_check=True), F ** 2)
        # Check if the fidelity is determined properly for non-pure states.
        rho_target = sparse.csr_matrix(np.array([[0.5, 1j], [1j, 0.5]]))
        rho_reference = sparse.csr_matrix(np.array([[0.5, -1j], [-1j, 0.5]]))
        self.assertAlmostEqual(su.sparse_dm_fidelity(rho_target, rho_reference, squared=True), 5.)

    def test_is_valid_sparse_dm(self):
        """Test checking of valid sparse density matrices."""
        # Check some valid sparse DMs
        for ket in [s0, s00, b00, b11, np.kron(h10, b01)]:
            rho = ket2sparsedm(ket)
            self.assertTrue(su.is_valid_sparse_dm(rho))
        # Check some invalid DMs
        for rho in [np.array([[-1, 0], [0, 0]]), np.array([[0.5, 0], [0, 0]]), np.array([[0.5, 0], [0.5, 1j]])]:
            rho = sparse.csr_matrix(rho)
            self.assertFalse(su.is_valid_sparse_dm(rho))
        # Check for sparse DM with a trace close to 1
        rho = np.array([[0.02200320 + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j],
                        [0. + 0.j, 0.43056081 + 0.j, -0.39368698 + 0.j, 0. + 0.j],
                        [0. + 0.j, -0.39368698 + 0.j, 0.43056081 + 0.j, 0. + 0.j],
                        [0. + 0.j, 0. + 0.j, 0. + 0.j, 0.11687618 + 0.j]])
        rho = sparse.csr_matrix(rho)
        trace = su.sparse_trace(rho)
        self.assertNotEqual(trace, 1.)
        self.assertAlmostEqual(trace, 1.000001)
        self.assertTrue(su.is_valid_sparse_dm(rho))

    def test_is_pure_sparse_dm(self):
        """Test checking of pure sparse density matrices."""
        for ket in [s0, s00, b00, b11, np.kron(h10, b01)]:
            rho = ket2sparsedm(ket)
            self.assertTrue(su.is_pure_sparse_dm(rho))
        rho_target = sparse.csr_matrix(np.array([[0.5, 1j], [1j, 0.5]]))
        rho_reference = sparse.csr_matrix(np.array([[0.5, -1j], [-1j, 0.5]]))
        self.assertFalse(su.is_pure_sparse_dm(rho_target))
        self.assertFalse(su.is_pure_sparse_dm(rho_reference))


if __name__ == "__main__":
    unittest.main()
