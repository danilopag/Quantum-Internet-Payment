# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_stabtools.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for stabtools module.

"""
import unittest
from unittest.mock import Mock, MagicMock
import numpy as np
from netsquid.qubits import qubitapi as qapi
from netsquid.qubits.stabtools import StabRepr, ConversionError
from netsquid.qubits import stabtools
from netsquid.qubits.operators import Z, I, X, H, Y, CNOT
import netsquid as ns
from netsquid.util.simlog import disable_warn_deprecated
from netsquid.qubits import ketstates as ks
from netsquid.qubits.kettools import KetRepr
from netsquid.qubits.ketutil import ket2dm, dagger
from netsquid.qubits.qubit import Qubit
from netsquid.qubits.tests.test_qrepr import TestQRepr
from netsquid.qubits.tests.test_qstate import TestDepQState


class TestStabRepr(TestQRepr, unittest.TestCase):

    def create_qrepr(self, **kwargs) -> StabRepr:
        return StabRepr(**kwargs)

    def test_destab_generation(self):
        """Test generating a destabilizer matrix works."""
        stab_repr = self.create_qrepr(num_qubits=2)
        self.assertTrue(np.allclose(stab_repr.destab_matrix, np.array([[1, 0, 0, 0], [0, 1, 0, 0]])))
        stab_repr = self.create_qrepr(check_matrix=[[1, 0]], phases=[1])
        self.assertTrue(np.allclose(stab_repr.destab_matrix, np.array([[0, 1]])))

    def test_destab_methods(self):
        """Test methods modifying the state keep the destabilizers valid."""
        stab_repr = self.create_qrepr(num_qubits=4)
        self.assertTrue(stab_repr.is_valid)
        stab_repr.operate([0], H)
        self.assertTrue(stab_repr.is_valid)
        stab_repr.operate([1], H)
        self.assertTrue(stab_repr.is_valid)
        stab_repr.operate([1, 3], CNOT)
        self.assertTrue(stab_repr.is_valid)
        stab_repr.multiply_rows(0, 3)
        self.assertTrue(stab_repr.is_valid)
        stab_repr.row_reduce()
        self.assertTrue(stab_repr.is_valid)
        stab_repr = stab_repr.discard(2)
        self.assertTrue(stab_repr.is_valid)

    def test_assign_qrepr(self):
        repr1 = self.create_qrepr(check_matrix=[[0, 1]], phases=[1])
        self.assertTrue(repr1.is_valid)
        self.assertEqual(1, repr1.num_qubits)
        repr2 = self.create_qrepr(check_matrix=[[0, 0, 1, 0], [0, 0, 0, 1]], phases=[1, 1])
        self.assertTrue(repr2.is_valid)
        self.assertEqual(2, repr2.num_qubits)
        with self.assertRaises(ValueError):
            self.create_qrepr(check_matrix=[[0, 1]], phases=[1, 1])
        with self.assertRaises(ValueError):
            self.create_qrepr(check_matrix=[[0, 0, 1, 0], [0, 0, 0, 1]], phases=[1])

    @classmethod
    def setUpClass(cls):
        # Some base stabilizer states
        # 1-qubit standard (Z) basis states
        cls.chmat_zX = np.asarray([[0, 1]], dtype=np.uint8)
        cls.phase_z0 = [+1]  # |0>
        cls.phase_z1 = [-1]  # |1>
        # 1-qubit Hadamard (X) basis states
        cls.chmat_xX = np.asarray([[1, 0]], dtype=np.uint8)
        cls.phase_x0 = [+1]  # |+>
        cls.phase_x1 = [-1]  # |->
        # 1-qubit (Y) basis states
        cls.chmat_yX = np.asarray([[1, 1]], dtype=np.uint8)
        cls.phase_y0 = [1]  # [+1j]  # (|0> + i|1>)/sqrt(2)
        cls.phase_y1 = [-1]  # [-1j]  # (|0> - i|1>)/sqrt(2)
        # 2-qubit standard basis states
        cls.chmat_sXX = np.asarray([[0, 0, 1, 0], [0, 0, 0, 1]], dtype=np.uint8)
        cls.phase_00 = [+1, +1]
        cls.phase_01 = [+1, -1]
        cls.phase_10 = [-1, +1]
        cls.phase_11 = [-1, -1]
        # 2-qubit hadamard basis states
        cls.chmat_hXX = np.asarray([[1, 0, 0, 0], [0, 1, 0, 0]], dtype=np.uint8)
        # 2-qubit Y basis states
        cls.chmat_yXX = np.asarray([[1, 0, 1, 0], [0, 1, 0, 1]], dtype=np.uint8)
        # 2-qubit Bell states
        cls.chmat_bXX = np.asarray([[1, 1, 0, 0], [0, 0, 1, 1]], dtype=np.uint8)
        # 4-qubit standard basis states (incomplete)
        cls.chmat_sXXXX = np.asarray(
            [[0, 0, 0, 0, 1, 0, 0, 0],
             [0, 0, 0, 0, 0, 1, 0, 0],
             [0, 0, 0, 0, 0, 0, 1, 0],
             [0, 0, 0, 0, 0, 0, 0, 1]], dtype=np.uint8)
        cls.phase_s0000 = [+1, +1, +1, +1]
        cls.phase_s0001 = [+1, +1, +1, -1]
        cls.phase_s0010 = [+1, +1, -1, +1]
        cls.phase_s0011 = [+1, +1, -1, -1]
        cls.phase_s0100 = [+1, -1, +1, +1]
        cls.phase_s1000 = [-1, +1, +1, +1]
        cls.phase_s1100 = [-1, -1, +1, +1]
        cls.phase_s0001 = [+1, +1, +1, -1]
        cls.phase_s1000 = [-1, +1, +1, +1]
        cls.phase_s1001 = [-1, +1, +1, -1]
        cls.phase_s0001 = [+1, +1, +1, -1]
        cls.phase_s0100 = [+1, -1, +1, +1]
        cls.phase_s0101 = [+1, -1, +1, -1]

    def assertEqualGenerator(self, representation, check_matrix, phases):
        self.assertTrue(np.allclose(representation.check_matrix, check_matrix))
        self.assertTrue(np.allclose(representation.phases, phases))

    def test_StabState_init(self):
        """Test StabState initialization."""
        # check holder creation
        ss = StabRepr(self.chmat_bXX, self.phase_01)
        self.assertTrue(ss.is_valid)
        self.assertEqualGenerator(ss, self.chmat_bXX, self.phase_01)
        self.assertEqualGenerator(ss, self.chmat_bXX, self.phase_01)
        self.assertEqual(ss, StabRepr(self.chmat_bXX, self.phase_01))
        self.assertEqual(ss.num_qubits, 2)
        # Should no longer be possible to replace stabilizer attributes
        with self.assertRaises(AttributeError):
            ss.check_matrix = self.chmat_bXX
        with self.assertRaises(AttributeError):
            ss.phases = self.phase_11
        ss = StabRepr(self.chmat_bXX, self.phase_11)
        self.assertTrue(ss.is_valid)
        self.assertTrue(np.allclose(ss.phases, self.phase_11))

    def test_StabState_compare(self):
        """Test StabState comparison."""
        # {ZXII, XZII, IIYI, IIIZ}
        chmat = np.array(
            [[0, 1, 0, 0, 1, 0, 0, 0],
             [1, 0, 0, 0, 0, 1, 0, 0],
             [0, 0, 1, 0, 0, 0, 1, 0],
             [0, 0, 0, 0, 0, 0, 0, 1]], dtype=np.uint8)
        phases = [1, -1, -1, -1]
        qrepr1 = self.create_qrepr(check_matrix=chmat, phases=phases)
        self.assertTrue(qrepr1.is_valid)
        # check swap 1<->2
        chmat = np.array(
            [[1, 0, 0, 0, 0, 1, 0, 0],
             [0, 1, 0, 0, 1, 0, 0, 0],
             [0, 0, 1, 0, 0, 0, 1, 0],
             [0, 0, 0, 0, 0, 0, 0, 1]], dtype=np.uint8)
        phases = [-1, 1, -1, -1]
        qrepr2 = self.create_qrepr(check_matrix=chmat, phases=phases)
        self.assertTrue(qrepr2.is_valid)
        self.assertEqual(qrepr1, qrepr2)
        # check mult 3->4, 2->3
        chmat = np.array(
            [[1, 0, 0, 0, 0, 1, 0, 0],
             [0, 1, 0, 0, 1, 0, 0, 0],
             [0, 1, 1, 0, 1, 0, 1, 0],
             [0, 0, 1, 0, 0, 0, 1, 1]], dtype=np.uint8)
        phases = [-1, 1, -1, 1]
        qrepr3 = self.create_qrepr(check_matrix=chmat, phases=phases)
        self.assertTrue(qrepr3.is_valid)
        self.assertEqual(qrepr3, qrepr1)
        self.assertEqual(qrepr3, qrepr2)

    def test_row_multiplication(self):
        """Test stabilizer row multiplication"""
        # {XIZI, ZXXI, -IZZI, -IIIZ}
        stabilizer = stabtools.StabRepr(np.array(
            [[1, 0, 0, 0, 0, 0, 1, 0],
             [0, 1, 1, 0, 1, 0, 0, 0],
             [0, 0, 0, 0, 0, 1, 1, 0],
             [0, 0, 0, 0, 0, 0, 0, 1]], dtype=np.uint8), [1, 1, -1, -1])
        self.assertTrue(stabilizer.is_valid)
        stabilizer.multiply_rows(0, 1)  # mult_index, target_index
        g2 = stabilizer.generator_to_matrix(1)
        # g2 = stabtools._generator_to_full_matrix(stabilizer.check_matrix[1], stabilizer.phases[1])
        self.assertTrue(np.allclose(g2, _tensor_product([Y.arr, X.arr, Y.arr, I.arr])))
        stabilizer.multiply_rows(1, 3)  # mult_index, target_index
        g4 = stabilizer.generator_to_matrix(3)
        # g4 = stabtools._generator_to_full_matrix(stabilizer.check_matrix[3], stabilizer.phases[3])
        self.assertTrue(np.allclose(g4, -1 * _tensor_product([Y.arr, X.arr, Y.arr, Z.arr])))

    def test_op_qubit(self):
        """Single qubit operator tests explicitly with stabilizers."""
        # Basic op tests
        # More involved op tests (copied from kettools)
        chmat_bXXsX = np.array([[1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 1]], dtype=np.uint8)
        phase_s01s0 = self.phase_01 + self.phase_z0
        qrepr12 = self.create_qrepr(check_matrix=self.chmat_bXX, phases=self.phase_01)
        qrepr3 = self.create_qrepr(check_matrix=self.chmat_zX, phases=self.phase_z0)
        qrepr123 = qrepr12 ^ qrepr3
        self.assertTrue(qrepr123.is_valid)
        self.assertEqualGenerator(qrepr123, chmat_bXXsX, phase_s01s0)
        qrepr12x3 = qrepr123.operate(1, X)
        self.assertTrue(qrepr12x3.is_valid)
        phase_s00s0 = self.phase_00 + self.phase_z0
        self.assertEqualGenerator(qrepr12x3, chmat_bXXsX, phase_s00s0)
        qrepr1z2x3 = qrepr12x3.operate(0, Z)
        self.assertTrue(qrepr1z2x3.is_valid)
        phase_s10s0 = self.phase_10 + self.phase_z0
        self.assertEqualGenerator(qrepr1z2x3, chmat_bXXsX, phase_s10s0)
        qrepr1z2x3h = qrepr1z2x3.operate(2, H)
        self.assertTrue(qrepr1z2x3h.is_valid)
        chmat_bXXxX = np.array([[1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0]], dtype=np.uint8)
        self.assertEqualGenerator(qrepr1z2x3h, chmat_bXXxX, self.phase_10 + self.phase_x0)

    def test_measure(self):
        super().test_measure()
        # Regression test for bug in random measurement implementation
        qrepr = StabRepr([[1, 0, 0, 0], [0, 0, 0, 1]], [-1, -1])
        qrepr.multiply_rows(0, 1)
        self.assertTrue(qrepr.is_valid)
        _, m, p = qrepr.measure(0, modify=True)
        self.assertTrue(qrepr.is_valid)
        self.assertEqual(p, 0.5)
        self.assertEqual(1., qrepr.fidelity(KetRepr(ks.s1), [1]))

    def test_to_basis_state(self):
        """Test the state is put into the standard basis and the circuit is correct."""
        qrepr = self.create_qrepr(num_qubits=4)
        qrepr.operate([0], ns.H, modify=True)
        for i in range(1, 4):
            qrepr.operate([0, i], ns.CNOT, modify=True)
        qrepr.operate([3], ns.Z, modify=True)
        self.assertTrue(qrepr.is_valid)
        qrepr_copy = qrepr.__deepcopy__()
        gates = qrepr.to_basis_state(normalize_phases=True)
        self.assertEqual(qrepr, qrepr_copy)
        qrepr = self.create_qrepr(num_qubits=4)
        for op, idx in gates[::-1]:
            qrepr.operate(idx, op.inv, modify=True)
        self.assertTrue(qrepr.is_valid)
        self.assertEqual(qrepr, qrepr_copy)
        # Regression test for this array
        mat = np.array([
            [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1],
            [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]])
        phs = np.ones(mat.shape[0])
        stab_repr = stabtools.StabRepr(mat, phs)
        qrepr = self.create_qrepr(num_qubits=7)
        try:
            gates = stab_repr.to_basis_state(normalize_phases=True)
            for op, idx in gates[::-1]:
                qrepr.operate(idx, op.inv, modify=True)
            self.assertEqual(stab_repr, qrepr)
        except AssertionError:
            self.fail("The normalization circuit failed the assertions unexpectedly.")

    def test_stab_fidelity(self):
        """Test the fidelity calculations"""
        qrepr = self.create_qrepr(num_qubits=1)
        s0 = KetRepr(ks.s0)
        s1 = KetRepr(ks.s1)
        h0 = KetRepr(ks.h0)
        h1 = KetRepr(ks.h1)
        y0 = KetRepr(ks.y0)
        y1 = KetRepr(ks.y1)
        s00 = KetRepr(ks.s00)
        b00 = KetRepr(ks.b00)
        self.assertEqual(1, qrepr.fidelity(s0))
        self.assertEqual(0, qrepr.fidelity(s1))
        self.assertEqual(1 / 2, qrepr.fidelity(h0, squared=True))
        qrepr = self.create_qrepr(num_qubits=2)
        self.assertEqual(1, qrepr.fidelity(s00))
        self.assertEqual(1, qrepr.fidelity(s0, [0]))
        self.assertEqual(0, qrepr.fidelity(s1, [1]))
        qrepr.operate([0], ns.H, modify=True)
        qrepr.operate(None, ns.CNOT, modify=True)
        self.assertEqual(1 / 2, qrepr.fidelity(s0, [0], squared=True))
        self.assertEqual(1 / 2, qrepr.fidelity(s0, [1], squared=True))
        self.assertEqual(1 / 2, qrepr.fidelity(s1, [0], squared=True))
        self.assertEqual(1 / 2, qrepr.fidelity(s1, [1], squared=True))
        self.assertEqual(1 / 2, qrepr.fidelity(s00, squared=True))
        self.assertEqual(1, qrepr.fidelity(b00))
        self.assertEqual(1, qrepr.fidelity(b00, [1, 0]))
        self.assertTrue(qrepr.is_valid)
        # Regression test
        qrepr = self.create_qrepr(check_matrix=[
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
            [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
        ], phases=[1, 1, 1, -1, -1, -1])
        self.assertTrue(qrepr.is_valid)
        self.assertEqual(1, qrepr.fidelity(h0, [0]))
        self.assertEqual(1, qrepr.fidelity(s0, [1]))
        self.assertEqual(1, qrepr.fidelity(y0, [2]))
        self.assertEqual(1, qrepr.fidelity(h1, [3]))
        self.assertEqual(1, qrepr.fidelity(s1, [4]))
        self.assertEqual(1, qrepr.fidelity(y1, [5]))

    def test_measure_drop_qubit(self):
        """Test dropping qubits from a quantum state when measuring"""
        # Test the row_index is calculated correctly
        mat = np.array([
            [1, 0, 0, 0],
            [1, 0, 0, 1]
        ])
        phs = [1, 1]
        s0 = KetRepr(ks.s0)
        h0 = KetRepr(ks.h0)
        for qid, state in [(1, s0), (0, h0)]:
            qrepr = self.create_qrepr(check_matrix=mat, phases=phs)
            self.assertEqual(2, qrepr.num_qubits)
            self.assertTrue(qrepr.is_valid)
            self.assertEqual(1, qrepr.fidelity(h0, [0]))
            self.assertEqual(1, qrepr.fidelity(s0, [1]))
            qrepr.measure_discard(1-qid)
            self.assertTrue(qrepr.is_valid)
            self.assertEqual(1, qrepr.fidelity(state, [qid]))


def _tensor_product(op_list):
    # Take tensor product of list of operators
    result = op_list[0]
    for op in op_list[1:]:
        result = np.kron(result, op)
    return result


class TestStabState(TestDepQState, unittest.TestCase):
    """Unit tests for the deprecated StabState module.

    The TestQState baseclass defines extra test methods.

    """

    @disable_warn_deprecated
    def create_qstate(self, qubits, check_matrix=None, phases=None):
        if check_matrix is not None and phases is not None:
            stabstate = stabtools.Stabilizer(check_matrix, phases)
        else:
            stabstate = None
        stabtools.StabState(qubits, stabstate)

    def test_CS_operation(self):
        """Test CS operation fails because it is not a Clifford."""
        with self.assertRaises(ValueError):
            super().test_CS_operation()

    def test_measure_gen_projective(self):
        """Test projective measurements fail because gmeasure is not defined."""
        with self.assertRaises(AttributeError):
            super().test_measure_gen_projective()

    def test_measure_gen_filter(self):
        """Test filter measurements fail because gmeasure is not defined."""
        with self.assertRaises(AttributeError):
            super().test_measure_gen_filter()

    def test_gmeasure_qubits(self):
        """Test gmeasure is not defined."""
        with self.assertRaises(AttributeError):
            super().test_gmeasure_qubits()

    @disable_warn_deprecated
    def assertEqualGenerators(self, qubit, check_matrix, phases):
        qubits = ns.qubits.create_qubits(num_qubits=check_matrix.shape[0])
        other_qstate = stabtools.StabState(
            qubits=qubits, stabilizer=stabtools.Stabilizer(check_matrix, phases))
        # Check both stab states valid (just to be sure!)
        self.assertTrue(qubit.qstate.stabilizer.is_valid)
        self.assertTrue(other_qstate.stabilizer.is_valid)
        # Check equal
        equal = qubit.qstate.compare(other_qstate)
        if not equal:
            print("Unequal result in assertEqualGenerators")
            print("  check matrices:\n{}\n{}".format(qubit.qstate.stabilizer.check_matrix, check_matrix))
            print("  phases:\n{}\n{}".format(qubit.qstate.stabilizer.phases, phases))
        self.assertTrue(equal)

    def setUp(self):
        # Some base stabilizer states
        # 1-qubit standard (Z) basis states
        self.chmat_zX = np.asarray([[0, 1]], dtype=np.uint8)
        self.phase_z0 = [+1]  # |0>
        self.phase_z1 = [-1]  # |1>
        # 1-qubit Hadamard (X) basis states
        self.chmat_xX = np.asarray([[1, 0]], dtype=np.uint8)
        self.phase_x0 = [+1]  # |+>
        self.phase_x1 = [-1]  # |->
        # 1-qubit (Y) basis states
        self.chmat_yX = np.asarray([[1, 1]], dtype=np.uint8)
        self.phase_y0 = [1]  # [+1j]  # (|0> + i|1>)/sqrt(2)
        self.phase_y1 = [-1]  # [-1j]  # (|0> - i|1>)/sqrt(2)
        # 2-qubit standard basis states
        self.chmat_sXX = np.asarray([[0, 0, 1, 0], [0, 0, 0, 1]], dtype=np.uint8)
        self.phase_00 = [+1, +1]
        self.phase_01 = [+1, -1]
        self.phase_10 = [-1, +1]
        self.phase_11 = [-1, -1]
        # 2-qubit hadamard basis states
        self.chmat_hXX = np.asarray([[1, 0, 0, 0], [0, 1, 0, 0]], dtype=np.uint8)
        # 2-qubit Y basis states
        self.chmat_yXX = np.asarray([[1, 0, 1, 0], [0, 1, 0, 1]], dtype=np.uint8)
        # 2-qubit Bell states
        self.chmat_bXX = np.asarray([[1, 1, 0, 0], [0, 0, 1, 1]], dtype=np.uint8)
        # 4-qubit standard basis states (incomplete)
        self.chmat_sXXXX = np.asarray(
            [[0, 0, 0, 0, 1, 0, 0, 0],
             [0, 0, 0, 0, 0, 1, 0, 0],
             [0, 0, 0, 0, 0, 0, 1, 0],
             [0, 0, 0, 0, 0, 0, 0, 1]], dtype=np.uint8)
        self.phase_s0000 = [+1, +1, +1, +1]
        self.phase_s0001 = [+1, +1, +1, -1]
        self.phase_s0010 = [+1, +1, -1, +1]
        self.phase_s0011 = [+1, +1, -1, -1]
        self.phase_s0100 = [+1, -1, +1, +1]
        self.phase_s1000 = [-1, +1, +1, +1]
        self.phase_s1100 = [-1, -1, +1, +1]
        self.phase_s0001 = [+1, +1, +1, -1]
        self.phase_s1000 = [-1, +1, +1, +1]
        self.phase_s1001 = [-1, +1, +1, -1]
        self.phase_s0001 = [+1, +1, +1, -1]
        self.phase_s0100 = [+1, -1, +1, +1]
        self.phase_s0101 = [+1, -1, +1, -1]

    @disable_warn_deprecated
    def test_StabState_init(self):
        """Test StabState initialization."""
        # check holder creation
        h1 = Qubit("H1")
        self.assertEqual(h1.name, "H1")
        self.assertEqual(h1.qstate, None)
        with self.assertRaises(RuntimeError):
            h1._index
        # check StabState creation
        with self.assertRaises(ValueError):
            stabtools.StabState([h1, h1], stabtools.Stabilizer(self.chmat_bXX, self.phase_01))
        with self.assertRaises(ValueError):
            stabtools.StabState([h1], stabtools.Stabilizer(self.chmat_bXX, self.phase_01))
        h2 = Qubit("H2")
        ss = stabtools.StabState([h1, h2], stabtools.Stabilizer(self.chmat_bXX, self.phase_01))
        self.assertEqualGenerators(h1, self.chmat_bXX, self.phase_01)
        self.assertEqualGenerators(h2, self.chmat_bXX, self.phase_01)
        self.assertTrue(h1.qstate.compare(h2.qstate))
        self.assertEqual(h1._index, 0)
        self.assertEqual(h2._index, 1)
        self.assertEqual(ss.num_qubits, 2)
        # Should no longer be possible to replace stabilizer attributes
        with self.assertRaises(AttributeError):
            ss.stabilizer.check_matrix = self.chmat_bXX
        with self.assertRaises(AttributeError):
            ss.stabilizer.phases = self.phase_11
        ss.stabilizer = stabtools.Stabilizer(self.chmat_bXX, self.phase_11)
        self.assertTrue(np.allclose(ss.stabilizer.phases, self.phase_11))
        with self.assertRaises(ValueError):
            ss.stabilizer = stabtools.Stabilizer(np.asarray([[1, 0]]), [1])

    @disable_warn_deprecated
    def test_StabState_compare(self):
        """Test StabState comparison."""
        # {ZXII, XZII, IIYI, IIIZ}
        chmat = np.array(
            [[0, 1, 0, 0, 1, 0, 0, 0],
             [1, 0, 0, 0, 0, 1, 0, 0],
             [0, 0, 1, 0, 0, 0, 1, 0],
             [0, 0, 0, 0, 0, 0, 0, 1]], dtype=np.uint8)
        phases = [1, -1, -1, -1]
        q1, __, __, __ = self.create_qubits("Q", 4, chmat, phases)
        # check swap 1<->2
        chmat = np.array(
            [[1, 0, 0, 0, 0, 1, 0, 0],
             [0, 1, 0, 0, 1, 0, 0, 0],
             [0, 0, 1, 0, 0, 0, 1, 0],
             [0, 0, 0, 0, 0, 0, 0, 1]], dtype=np.uint8)
        phases = [-1, 1, -1, -1]
        qubits = ns.qubits.create_qubits(num_qubits=chmat.shape[0])
        self.assertTrue(q1.qstate.compare(stabtools.StabState(qubits, stabtools.Stabilizer(chmat, phases))))
        # check mult 3->4, 2->3
        chmat = np.array(
            [[1, 0, 0, 0, 0, 1, 0, 0],
             [0, 1, 0, 0, 1, 0, 0, 0],
             [0, 1, 1, 0, 1, 0, 1, 0],
             [0, 0, 1, 0, 0, 0, 1, 1]], dtype=np.uint8)
        phases = [-1, 1, -1, 1]
        qubits = ns.qubits.create_qubits(num_qubits=chmat.shape[0])
        self.assertTrue(q1.qstate.compare(stabtools.StabState(qubits, stabtools.Stabilizer(chmat, phases))))

    def test_row_multiplication(self):
        """Test stabilizer row multiplication"""
        # {XZIY, XIZI, ZXXI, -IIIY}
        stabilizer = stabtools.Stabilizer(np.array(
            [[1, 0, 0, 1, 0, 1, 0, 1],
             [1, 0, 0, 0, 0, 0, 1, 0],
             [0, 1, 1, 0, 1, 0, 0, 0],
             [0, 0, 0, 1, 0, 0, 0, 1]], dtype=np.uint8), [1, 1, 1, -1])
        self.assertTrue(stabilizer.is_valid)
        stabilizer.multiply_rows(0, 1)  # mult_index, target_index
        g2 = stabilizer.generator_to_matrix(1)
        # g2 = stabtools._generator_to_full_matrix(stabilizer.check_matrix[1], stabilizer.phases[1])
        self.assertTrue(np.allclose(g2, _tensor_product([I.arr, Z.arr, Z.arr, Y.arr])))
        stabilizer.multiply_rows(1, 3)  # mult_index, target_index
        g4 = stabilizer.generator_to_matrix(3)
        # g4 = stabtools._generator_to_full_matrix(stabilizer.check_matrix[3], stabilizer.phases[3])
        self.assertTrue(np.allclose(g4, -1 * _tensor_product([I.arr, Z.arr, Z.arr, I.arr])))

    def test_op_qubit(self):
        """Single qubit operator tests explicitly with stabilizers."""
        # Basic op tests
        # More involved op tests (copied from kettools)
        chmat_bXXsX = np.array([[1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 1]], dtype=np.uint8)
        phase_s01s0 = self.phase_01 + self.phase_z0
        q1, q2 = self.create_qubits("A", 2, self.chmat_bXX, self.phase_01)
        q3, = self.create_qubits("B", 1, self.chmat_zX, self.phase_z0)
        q1.combine(q3)
        qs = q1.qstate
        self.assertEqualGenerators(q1, chmat_bXXsX, phase_s01s0)
        # breakpoint()
        qs.operate_qubits([q2], X)
        phase_s00s0 = self.phase_00 + self.phase_z0
        self.assertEqualGenerators(q2, chmat_bXXsX, phase_s00s0)
        qs.operate_qubits([q1], Z)
        phase_s10s0 = self.phase_10 + self.phase_z0
        self.assertEqualGenerators(q2, chmat_bXXsX, phase_s10s0)
        qs.operate_qubits([q3], H)
        chmat_bXXxX = np.array([[1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0]], dtype=np.uint8)
        self.assertEqualGenerators(q3, chmat_bXXxX, self.phase_10 + self.phase_x0)

    def test_to_basis_state(self):
        """Test the state is put into the standard basis and the circuit is correct."""
        qubits = self.create_qubits("A", 4)
        qapi.operate(qubits[0], ns.H)
        for qubit in qubits[1:]:
            qapi.operate([qubits[0], qubit], ns.CNOT)
        qapi.operate(qubits[3], ns.Z)
        qubits[0].qstate.stabilizer.row_reduce()
        mat = qubits[0].qstate.stabilizer.check_matrix.copy()
        phs = qubits[0].qstate.stabilizer.phases.copy()
        gates = qubits[0].qstate.stabilizer.to_basis_state()
        for op, idx in gates[::-1]:
            qapi.operate([qubits[x] for x in idx], op.inv)
        stab = qubits[0].qstate.stabilizer
        stab.row_reduce()
        self.assertTrue(np.allclose(stab.check_matrix, mat))
        self.assertTrue(np.allclose(stab.phases, phs))
        # Regression test for this array
        mat = np.array([
            [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1],
            [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]])
        phs = np.ones(mat.shape[0])
        stab = stabtools.Stabilizer(mat, phs)
        qubits = self.create_qubits('B', 7)
        try:
            gates = stab.to_basis_state(normalize_phases=True)
            for op, idx in gates[::-1]:
                qapi.operate([qubits[x] for x in idx], op.inv)
            stabilizer = qubits[0].qstate.stabilizer
            stabilizer.row_reduce()
            self.assertTrue(np.allclose(stabilizer.check_matrix, mat))
            self.assertTrue(np.allclose(stabilizer.phases, phs))
        except AssertionError:
            self.fail("The normalization circuit failed the assertions unexpectedly.")

    @disable_warn_deprecated
    def test_fidelity(self):
        """Test the fidelity calculations"""
        q1, = self.create_qubits("A", 1)
        self.assertEqual(1, q1.qstate.fidelity(ks.s0))
        self.assertEqual(0, q1.qstate.fidelity(ks.s1))
        self.assertEqual(1 / 2, q1.qstate.fidelity(ks.h0, squared=True))
        qubits = self.create_qubits("B", 2)
        qs = qubits[0].qstate
        self.assertEqual(1, qs.fidelity(ks.s00))
        self.assertEqual(1, qs.fidelity(ks.s0, qubits[:1]))
        self.assertEqual(0, qs.fidelity(ks.s1, qubits[1:]))
        qapi.operate(qubits[0], ns.H)
        qapi.operate(qubits, ns.CNOT)
        self.assertEqual(1 / 2, qs.fidelity(ks.s0, qubits[:1], squared=True))
        self.assertEqual(1 / 2, qs.fidelity(ks.s0, qubits[1:], squared=True))
        self.assertEqual(1 / 2, qs.fidelity(ks.s1, qubits[:1], squared=True))
        self.assertEqual(1 / 2, qs.fidelity(ks.s1, qubits[1:], squared=True))
        self.assertEqual(1 / 2, qs.fidelity(ks.s00, squared=True))
        self.assertEqual(1, qs.fidelity(ks.b00))
        self.assertEqual(1, qs.fidelity(ket2dm(ks.b00)))

    def test_ket_property(self):
        """Test ket state property"""
        test_states = [
            (1, self.chmat_zX, self.phase_z0, ks.s0),
            (1, self.chmat_yX, self.phase_y1, ks.y1),
            (2, self.chmat_bXX, self.phase_00, ks.b00),
            (2, self.chmat_bXX, self.phase_01, ks.b01),
            (2, self.chmat_sXX, self.phase_00, ks.s00),
            (4, self.chmat_sXXXX, self.phase_s1100, np.kron(ks.s11, ks.s00)),
        ]
        for num_qubits, chmat, phases, ket_state in test_states:
            q1 = self.create_qubits("A", num_qubits, chmat, phases)[0]
            self.assertTrue(np.allclose(q1.qstate.ket, ket_state))

    def test_predictive_measure_qubit(self):
        """Predictive test for projective measurement of a qubit"""
        # Mock up random number generator to give predictable results
        rng = Mock(np.random.RandomState)
        for obs in [X, Y]:
            q1, q2 = self.create_qubits("Q", 2)
            rng.randint = MagicMock(return_value=0)
            m, __ = q1.qstate.measure_qubit(q1, observable=obs, rng=rng)
            self.assertEqual(m, 0)
            rng.randint = MagicMock(return_value=1)
            m, __ = q2.qstate.measure_qubit(q2, observable=obs, rng=rng)
            self.assertEqual(m, 1)
            e0, e1 = obs.eigenkets
            self.assertTrue(np.allclose(q2.qstate.dm, np.kron(e0, e1) @ dagger(np.kron(e0, e1))))

    def test_ket2stabilizer(self):
        """Test ket2stabilizer function."""
        # Test some of the supported ketstates
        stab = stabtools.ket2stabilizer(ks.s0)
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.array_equal(stab.check_matrix, self.chmat_zX))
        self.assertTrue(np.array_equal(stab.phases, self.phase_z0))
        stab = stabtools.ket2stabilizer(ks.h1)
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.array_equal(stab.check_matrix, self.chmat_xX))
        self.assertTrue(np.array_equal(stab.phases, self.phase_x1))
        stab = stabtools.ket2stabilizer(ks.s01)
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.array_equal(stab.check_matrix, self.chmat_sXX))
        self.assertTrue(np.array_equal(stab.phases, self.phase_01))
        stab = stabtools.ket2stabilizer(ks.h11)
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.array_equal(stab.check_matrix, self.chmat_hXX))
        self.assertTrue(np.array_equal(stab.phases, self.phase_11))
        stab = stabtools.ket2stabilizer(ks.y01)
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.array_equal(stab.check_matrix, self.chmat_yXX))
        self.assertTrue(np.array_equal(stab.phases, self.phase_01))
        stab = stabtools.ket2stabilizer(ks.b00)
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.array_equal(stab.check_matrix, self.chmat_bXX))
        self.assertTrue(np.array_equal(stab.phases, self.phase_00))
        stab = stabtools.ket2stabilizer(ks.b01)
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.array_equal(stab.check_matrix, self.chmat_bXX))
        self.assertTrue(np.array_equal(stab.phases, self.phase_01))
        # Test support ket with different global phase
        stab = stabtools.ket2stabilizer(ks.s0 * 1j)
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.array_equal(stab.check_matrix, self.chmat_zX))
        self.assertTrue(np.array_equal(stab.phases, self.phase_z0))
        stab = stabtools.ket2stabilizer(ks.b01 * -1)
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.array_equal(stab.check_matrix, self.chmat_bXX))
        self.assertTrue(np.array_equal(stab.phases, self.phase_01))
        # Test unsupported kets raise error
        with self.assertRaises(ConversionError):
            stabtools.ket2stabilizer(np.array([[1], [1], [1], [0]], dtype=complex))
        with self.assertRaises(ConversionError):
            stabtools.ket2stabilizer(np.array([[1], [1j], [1j], [0]], dtype=complex))
        with self.assertRaises(ConversionError):
            stabtools.ket2stabilizer(np.array([[1 / np.sqrt(2)], [1 / np.sqrt(3)], [0], [0]], dtype=complex))
        with self.assertRaises(ConversionError):
            stabtools.ket2stabilizer(np.array([[1], [-1], [-1j], [-1], [+1], [1j], [-1j], [1j]], dtype=complex) / np.sqrt(8))
        stab = stabtools.ket2stabilizer(np.kron(ks.b01, ks.s0))
        self.assertTrue(stab.is_valid)
        mat = np.array([[1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 1]])
        self.assertTrue(np.array_equal(stab.check_matrix, mat))
        self.assertTrue(np.array_equal(stab.phases, np.array([1, -1, 1])))
        stab = stabtools.ket2stabilizer(np.kron(ks.b00, ks.s1))
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.array_equal(stab.check_matrix, mat))
        self.assertTrue(np.array_equal(stab.phases, np.array([1, 1, -1])))
        stab = stabtools.ket2stabilizer(np.kron(ks.h00, ks.s00))
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.allclose(stab.ket(), np.kron(ks.h00, ks.s00)))
        ket = np.array([[1], [-1], [-1], [-1]], dtype=complex) / 2
        stab = stabtools.ket2stabilizer(ket)
        self.assertTrue(stab.is_valid)
        ket = np.array([[1], [-1j], [-1j], [-1], [-1], [1j], [-1j], [-1]], dtype=complex) / np.sqrt(8)
        stab = stabtools.ket2stabilizer(ket)
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.allclose(stab.ket(), ket))
        ket = np.array([[1, -1j, 1j, -1, 1j, -1, 1, -1j]]) / np.sqrt(8)
        stab = stabtools.ket2stabilizer(ket)
        self.assertTrue(stab.is_valid)
        check_matrix = np.array([
            [1, 0, 0, 1, 1, 1],
            [0, 1, 0, 1, 1, 1],
            [0, 0, 1, 1, 1, 1]]
        )
        stab = stabtools.ket2stabilizer(ket)
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.array_equal(stab.check_matrix, check_matrix))
        self.assertTrue(np.array_equal(stab.phases, np.array([1, 1, -1])))
        ket = np.array([[1], [-1j], [1j], [-1], [0], [0], [0], [0]], dtype=complex) / np.sqrt(4)
        ket.reshape(8, 1)
        check_matrix = np.array([
            [0, 1, 0, 0, 1, 1],
            [0, 0, 1, 0, 1, 1],
            [0, 0, 0, 1, 0, 0]]
        )
        stab = stabtools.ket2stabilizer(ket)
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.array_equal(stab.check_matrix, check_matrix))
        self.assertTrue(np.array_equal(stab.phases, np.array([1, -1, 1])))
        ket = np.array([[1, 1, -1, -1, 0, 0, 0, 0]], dtype=complex) / np.sqrt(4)
        ket.reshape(8, 1)
        check_matrix = np.array([
            [0, 1, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0]]
        )
        stab = stabtools.ket2stabilizer(ket)
        self.assertTrue(stab.is_valid)
        self.assertTrue(np.array_equal(stab.check_matrix, check_matrix))
        self.assertTrue(np.array_equal(stab.phases, np.array([-1, 1, 1])))


if __name__ == "__main__":
    unittest.main(verbosity=2)
