# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_state_sampler.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for state sampler module.

"""
import unittest
import numpy as np

from netsquid.qubits import qubitapi as qapi
from netsquid.qubits import ketstates as ks
from netsquid.qubits import cliffords
from netsquid.qubits.ketutil import ket2dm
from netsquid.qubits.gslctools import GSLCRepr
from netsquid.qubits.kettools import KetRepr
from netsquid.qubits.dmtools import DenseDMRepr
from netsquid.qubits.qformalism import QFormalism, set_qstate_formalism
from netsquid.qubits.stabtools import StabRepr
from netsquid.qubits.state_sampler import StateSampler
# Number of iterations used in the probabilistic tests
from netsquid.qubits.qrepr import QRepr
from netsquid.qubits.qformalism import convert_qrepr


class TestStateSampler(unittest.TestCase):
    """Unit tests for StateSampler class.

    """

    def setUp(self):
        set_qstate_formalism(QFormalism.KET)

    def tearDown(self):
        set_qstate_formalism(QFormalism.KET)

    def test_initialize(self):
        """Test initialization of State Sampler."""
        qrepr_s0 = KetRepr(ks.s0)
        s_child = StateSampler([qrepr_s0])
        s_parent = StateSampler(s_child)
        for attrib in ["states", "probabilities", "labels"]:
            self.assertEqual(len(getattr(s_parent, attrib)), 1)
        self.assertIs(s_child.states[0], qrepr_s0)
        self.assertEqual(s_child.probabilities[0], 1)
        self.assertIs(s_child.labels[0], None)
        self.assertIs(s_parent.states[0], qrepr_s0)
        self.assertEqual(s_parent.probabilities[0], 1)
        self.assertIs(s_parent.labels[0], None)
        self.assertEqual(s_parent.probability_of_none, 0)
        with self.assertRaises(TypeError):
            StateSampler(probabilities=1)
        with self.assertRaises(TypeError):
            StateSampler(labels=1)
        with self.assertRaises(TypeError):
            StateSampler(probabilities=[1])
        with self.assertRaises(TypeError):
            StateSampler(labels=[1])
        # Test incorrect construction
        with self.assertRaises(TypeError):
            StateSampler()
        with self.assertRaises(ValueError):
            StateSampler(None)
        with self.assertRaises(ValueError):
            StateSampler([])
        with self.assertRaises(TypeError):
            StateSampler(False)
        with self.assertRaises(TypeError):
            StateSampler((1, 2))

    def _is_qs_repr(self, value):
        # check if value is a valid
        if value is None:
            return
        self.assertTrue(isinstance(value, QRepr))

    def test_attributes(self):
        """Test attributes of State Sampler."""
        qubits = qapi.create_qubits(2, no_state=True)
        qapi.assign_qstate(qubits, qrepr=KetRepr(ks.b00))
        qrepr = qubits[0].qstate.qrepr
        s = StateSampler(qrepr)
        for attrib in ["states", "probabilities", "labels"]:
            self.assertEqual(len(getattr(s, attrib)), 1)
        self._is_qs_repr(s.states[0])
        self.assertEqual(s.probabilities[0], 1)
        self.assertIs(s.labels[0], None)
        self.assertEqual(s.probability_of_none, 0)

    def test_init_numpy_array_faulty(self):
        """Test initialisation with faulty arrays."""
        # Rank 3 array
        array = np.array([[[1]]])
        with self.assertRaises(ValueError):
            StateSampler(array)
        # Dimension 3 (no qubit)
        array = np.array([[1], [1], [1]])
        with self.assertRaises(ValueError):
            StateSampler(array)
        # Neither dm or ket
        array = np.array([[1, 2], [1, 2], [1, 2], [1, 2]])
        with self.assertRaises(ValueError):
            StateSampler(array)

    def test_init_1_qubit(self):
        """Test initialization and merging of 1 qubit states."""
        ketrepr = KetRepr(ks.s0)
        reprs = {}
        for formalism in QFormalism:
            reprs[formalism] = convert_qrepr(ketrepr, formalism)
        for formalism in QFormalism:
            state = reprs[formalism]
            s = StateSampler([state, state], [0.5, 0.5])
            self._is_qs_repr(s.states[0])
            self.assertEqual(s.probabilities[0], 1)
            self.assertIs(s.labels[0], None)
            self.assertEqual(s.probability_of_none, 0)

    def test_init_2_qubit(self):
        """Test initialization and merging of 2 qubit states."""
        ketrepr = KetRepr(ks.s00)
        reprs = {}
        for formalism in QFormalism:
            reprs[formalism] = convert_qrepr(ketrepr, formalism)
        for formalism in QFormalism:
            state = reprs[formalism]
            s = StateSampler([state, state], [0.5, 0.5])
            self._is_qs_repr(s.states[0])
            self.assertEqual(s.probabilities[0], 1)
            self.assertIs(s.labels[0], None)
            self.assertEqual(s.probability_of_none, 0)

    def test_init_list_mixed_no_prob(self):
        """Test initialisation without explicit probabilities."""
        # Mixed state (no probabilities)
        ket1 = KetRepr([[1], [0]])
        ket2 = KetRepr([[0], [1]])
        s = StateSampler([ket1, ket2])
        for state, prob, label in zip(s.states, s.probabilities, s.labels):
            self._is_qs_repr(state)
            self.assertEqual(prob, 1 / 2)
            self.assertIs(label, None)

    def test_init_list_mixed_unequal_prob(self):
        """Test initialisation with unequal probabilities."""
        # Mixed state (un-equal probabilities)
        ket1 = KetRepr([[1], [0]])
        ket2 = KetRepr([[0], [1]])
        s = StateSampler([ket1, ket2], probabilities=[1 / 4, 3 / 4])
        for state, prob, label in zip(s.states, s.probabilities, s.labels):
            self._is_qs_repr(state)
            self.assertIs(label, None)
        self.assertEqual(s.probabilities, [1 / 4, 3 / 4])

    def test_init_list_faulty_tot_prob(self):
        """Test initialisation with faulty probabilities."""
        # Mixed state (faulty probabilities > 1)
        ket1 = KetRepr([[1], [0]])
        ket2 = KetRepr([[0], [1]])
        with self.assertRaises(ValueError):
            StateSampler([ket1, ket2], probabilities=[3 / 4, 3 / 4])
        with self.assertRaises(ValueError):
            StateSampler([ket1, ket2], probabilities=([1 / 3] * 3))

    def test_init_list_same_labels(self):
        """Test initialisation with same labels."""
        # Mixed state (same labels)
        ket1 = KetRepr([[1], [0]])
        ket2 = KetRepr([[0], [1]])
        s = StateSampler([ket1, ket2], labels='test')
        for state, prob, label in zip(s.states, s.probabilities, s.labels):
            self.assertIsInstance(state, KetRepr)
            self.assertEqual(prob, 1 / 2)
            self.assertIs(label, 'test')

    def test_init_list_different_labels(self):
        """Test initialisation with different labels."""
        # Mixed state (different labels)
        ket1 = KetRepr([[1], [0]])
        ket2 = KetRepr([[0], [1]])
        labels = [0, 1]
        s = StateSampler([ket1, ket2], labels=labels)
        for state, prob, label in zip(s.states, s.probabilities, s.labels):
            self.assertIsInstance(state, KetRepr)
            self.assertEqual(prob, 1 / 2)
        self.assertEqual(s.labels, labels)

    def test_init_list_faulty_labels(self):
        """Test initialisation with faulty labels."""
        # Mixed state (faulty labels)
        ket1 = KetRepr([[1], [0]])
        ket2 = KetRepr([[0], [1]])
        labels = [0, 1, 3]
        with self.assertRaises(ValueError):
            StateSampler([ket1, ket2], labels=labels)

    def test_sample(self):
        """Test sampling statistics."""
        state1 = DenseDMRepr(np.array([[0, 0, 0, 0], [0, 1, +1, 0], [0, 1, +1, 0], [0, 0, 0, 0]]) / 2)
        state2 = DenseDMRepr(np.array([[0, 0, 0, 0], [0, 1, -1, 0], [0, 1, -1, 0], [0, 0, 0, 0]]) / 2)
        states = [None, state1, state2]
        probabilities = [0.7, 0.2, 0.1]
        labels = [0, 1, 2]
        state_sampler = StateSampler(states, probabilities, labels)
        # Full sample
        counter = [0] * 3
        num = 1000
        for _ in range(num):
            state, prob, label = state_sampler.sample()
            counter[label] += 1
            self.assertEqual(probabilities[label], prob)
            if state is None:
                self.assertIs(states[label], None)
            else:
                self.assertEqual(state, states[label])
        for i, count in enumerate(counter):
            self.assertAlmostEqual(count / num, probabilities[i], delta=0.05)  # ~3 sigma

    def test_sample_exclude_none(self):
        """Test sampling statistics with excluding None states."""
        state1 = DenseDMRepr(np.array([[0, 0, 0, 0], [0, 1, +1, 0], [0, 1, +1, 0], [0, 0, 0, 0]]) / 2)
        state2 = DenseDMRepr(np.array([[0, 0, 0, 0], [0, 1, -1, 0], [0, 1, -1, 0], [0, 0, 0, 0]]) / 2)
        states = [None, state1, state2]
        probabilities = [0.7, 0.2, 0.1]
        labels = [0, 1, 2]
        state_sampler = StateSampler(states, probabilities, labels)
        # Only sample non-None
        counter = [0] * 3
        num = 1000
        tot_prob = sum(probabilities[1:])
        new_probabilities = [0.] + [p / tot_prob for p in probabilities[1:]]
        for _ in range(num):
            state, prob, label = state_sampler.sample(exclude_none=True)
            counter[label] += 1
            self.assertEqual(probabilities[label], prob)
            if state is None:
                self.assertIs(states[label], None)
            else:
                self.assertEqual(state, states[label])
        for i, count in enumerate(counter):
            self.assertAlmostEqual(count / num, new_probabilities[i], delta=0.05)  # ~3 sigma

    def test_sample_advanced(self):
        """Test advanced sampling statistics."""
        ket0 = KetRepr([[1], [0]])
        ket1 = KetRepr([[0], [1]])
        s0 = StateSampler([None, ket0], [0.8, 0.2])
        s1 = StateSampler([None, ket1], [0.7, 0.3])
        s = StateSampler([s0, s1], [(1 - 0.4), 0.4], [0, 1])
        leaves = s.get_leaves()
        p_none = sum([p for s, p, __ in leaves if s is None])
        self.assertAlmostEqual(p_none, s.probability_of_none)
        self.assertAlmostEqual(0.8 * 0.6 + 0.7 * 0.4, p_none)
        # Note that ket0 and ket1 actually have the same probability
        num = 1000
        counter = [0] * 2
        for _ in range(num):
            state, _, (label,) = s.sample(exclude_none=True)
            if state is not None:
                counter[label] += 1
        self.assertAlmostEqual(counter[0] / num, counter[1] / num, delta=0.1)  # ~3 sigma
        self.assertAlmostEqual(0.4 * 0.3, (1 - p_none) * counter[0] / num, delta=0.1)  # ~3 sigma

    def test_sample_single(self):
        """Test single sampling."""
        ket = KetRepr([[1], [0]])
        s = StateSampler(ket)
        for _ in range(10):
            state, prob, label = s.sample()
            self.assertEqual(state, ket)
            self.assertEqual(prob, 1)
            self.assertIs(label, None)

    def test_sample_single_exclude_none(self):
        """Test single sampling excluding None."""
        ket = KetRepr([[1], [0]])
        s = StateSampler(ket)
        for _ in range(10):
            state, prob, label = s.sample(exclude_none=True)
            self.assertEqual(state, ket)
            self.assertEqual(prob, 1)
            self.assertIs(label, None)

    def test_get_leaves_one_level(self):
        """Test get_leaves at one level."""
        ket1 = KetRepr([[1], [0]])
        ket2 = KetRepr([[0], [1]])
        states = [None, ket1, ket2]
        labels = [None, 1, 2]
        s = StateSampler(states, labels=labels)
        leaves = s.get_leaves()
        absolute_labels = [l.label for l in leaves]
        self.assertIn(None, absolute_labels)
        self.assertIn(labels[1], absolute_labels)
        self.assertIn(labels[2], absolute_labels)

    def test_get_leaves_multiple_levels(self):
        """Test get_leaves at multiple levels."""
        ket1 = KetRepr([[1], [0]])
        ket2 = KetRepr([[0], [1]])
        s1 = StateSampler([ket2, ket1], labels=1)
        s2 = StateSampler([ket1, ket2], labels=[3, None])
        s = StateSampler([None, s1, s2, s2], labels=[None, None, 2, None])
        leaves = s.get_leaves()
        absolute_labels = [l.label for l in leaves]
        expected = [None, 1, 1, (2, 3), (2,), 3, None]
        self.assertCountEqual(absolute_labels, expected)

    def test_convert_states(self):
        """Test conversion of states to match a given formalism"""
        formalisms = [QFormalism.KET, QFormalism.DM, QFormalism.STAB, QFormalism.GSLC, QFormalism.SPARSEDM]
        reprs = {
            QFormalism.KET: KetRepr(ks.s0),
            QFormalism.DM: convert_qrepr(KetRepr(ks.s1), QFormalism.DM),
            QFormalism.STAB: convert_qrepr(KetRepr(ks.h0), QFormalism.STAB),
            QFormalism.GSLC: convert_qrepr(KetRepr(ks.h1), QFormalism.GSLC),
            QFormalism.SPARSEDM: convert_qrepr(KetRepr(ks.y0), QFormalism.SPARSEDM)
        }
        states = [reprs[f] for f in formalisms]
        ss = StateSampler(states, labels=[None] + list(range(len(formalisms) - 1)))
        self.assertEqual(len(ss.get_leaves()), len(formalisms))
        # NOTE, ketleaves order since leaves get ordered. Also, some states that are equal get reduced
        # FIXME why is this test so order dependent
        # ketleaves = [ks.s1, ks.y0, ks.h0, ks.h1, ks.s0]  # old order
        ketleaves = [ks.s1, ks.h0, ks.h1, ks.y0, ks.s0]
        for formalism in formalisms:
            ss.convert_states(formalism)
            self.assertEqual(5, len(ss.get_leaves()))
            for sampleleaf, stateleaf in zip(ss.get_leaves(), [convert_qrepr(KetRepr(k), formalism) for k in ketleaves]):
                self.assertEqual(sampleleaf.qrepr, stateleaf)

    def test_reduce_states(self):
        """Test reducing states with same label"""
        h0dm = convert_qrepr(KetRepr(ks.h0), QFormalism.DM)
        h1dm = convert_qrepr(KetRepr(ks.h1), QFormalism.DM)
        st1 = KetRepr(ks.s0)
        st2 = convert_qrepr(st1, QFormalism.DM)
        st3 = convert_qrepr(h0dm, QFormalism.STAB)
        st4 = StateSampler([h0dm, st3], labels=["3", "4"])
        st5 = KetRepr(ks.s1)
        st6 = convert_qrepr(st5, QFormalism.DM)
        st7 = GSLCRepr(local_cliffords=[cliffords.CLIFF_K])
        st8 = StateSampler([h1dm, st7], labels=["3", "4"])
        ss1 = StateSampler([st2, st2, st6])
        ss1.reduce_states()
        self.assertEqual(len(ss1.get_leaves()), 1)
        expected_dm = 2/3 * ket2dm(ks.s0) + 1/3 * ket2dm(ks.s1)
        self.assertEqual(ss1.get_leaves()[0].qrepr, DenseDMRepr(expected_dm))

        states = [st3, st7, None, None, st1, st2, st2, st1, st6, st5,
                  st1, st2, st5, st6, st4, st8, st4, None, None, st3]
        labels = ["0", "0", "1", "0", "0", "0", "0", "0", "0", "0",
                  "1", "1", "1", "1", "1", "1", "0", "0", "1", "1"]
        ss = StateSampler(states, labels=labels)
        ss.reduce_states()
        leaves = ss.get_leaves()
        self.assertEqual(len(leaves), 16)
        self.assertEqual(len(ss._labels), 16)
        self.assertEqual(len(ss._probabilities), 16)
        self.assertEqual(len(ss._qs_reprs), 16)
        for leaf in leaves:
            if leaf.label == ("0", "3"):
                self.assertAlmostEqual(1 / 20 / 2, leaf.probability)
                self.assertIs(leaf.qrepr, h0dm)
            elif leaf.label == ("0", "4"):
                self.assertAlmostEqual(1 / 20 / 2, leaf.probability)
                self.assertIs(leaf.qrepr, st3)
            elif leaf.label == ("1", "3"):
                self.assertAlmostEqual(1 / 20, leaf.probability)
                self.assertEqual(leaf.qrepr, DenseDMRepr(np.eye(2) / 2))
            elif leaf.label == ("1", "4"):
                self.assertAlmostEqual(1 / 40, leaf.probability)
                self.assertTrue(leaf.qrepr is st7 or leaf.qrepr is st3)
            elif leaf.label == "0":
                if leaf.qrepr is st1:
                    self.assertAlmostEqual(leaf.probability, 2 / 20)
                elif leaf.qrepr is None:
                    self.assertAlmostEqual(leaf.probability, 2 / 20)
                elif leaf.qrepr == DenseDMRepr(2 / 3 * st2.dm + 1 / 3 * st6.dm):
                    self.assertAlmostEqual(leaf.probability, 3 / 20)
                elif leaf.qrepr is st5:
                    self.assertAlmostEqual(leaf.probability, 1 / 20)
                elif leaf.qrepr is st3:
                    self.assertAlmostEqual(leaf.probability, 1 / 20)
                elif leaf.qrepr is st7:
                    self.assertAlmostEqual(leaf.probability, 1 / 20)
                else:
                    assert False, "Unexpected state {}".format(leaf.qrepr)
            elif leaf.label == "1":
                if leaf.qrepr is None:
                    self.assertAlmostEqual(leaf.probability, 2 / 20)
                elif leaf.qrepr == DenseDMRepr(np.eye(2) / 2):
                    self.assertAlmostEqual(leaf.probability, 2 / 20)
                elif leaf.qrepr is st1:
                    self.assertAlmostEqual(leaf.probability, 1 / 20)
                elif leaf.qrepr is st5:
                    self.assertAlmostEqual(leaf.probability, 1 / 20)
                elif leaf.qrepr is st3:
                    self.assertAlmostEqual(leaf.probability, 1 / 20)
                elif leaf.qrepr is st7:
                    self.assertAlmostEqual(leaf.probability, 1 / 20)
                else:
                    assert False, "Unexpected state {}".format(leaf.qrepr)
            else:
                assert False, "Unexpected label {}".format(leaf.label)

    def test_reduce_GSLC(self):
        """Test reducing of GSLC states"""
        state1 = GSLCRepr(num_qubits=2, local_cliffords=[cliffords.CLIFF_H, cliffords.CLIFF_I], edges=[[1], [0]])
        state2 = GSLCRepr(num_qubits=2, local_cliffords=[cliffords.CLIFF_I, cliffords.CLIFF_H], edges=[[1], [0]])
        state3 = KetRepr(np.array([[1], [0], [0], [1]], dtype=complex) / np.sqrt(2))
        ss = StateSampler([state1, state2, state3], probabilities=[0.2, 0.3, 0.5])
        self.assertEqual(len(ss.get_leaves()), 2)
        self.assertTrue(np.allclose([leaf.probability for leaf in ss.get_leaves()], [0.5, 0.5]))
        ss.convert_states(QFormalism.GSLC)
        self.assertEqual(len(ss.get_leaves()), 1)
        self.assertTrue(np.allclose([leaf.probability for leaf in ss.get_leaves()], [1.]))

    def test_convert_from_dm(self):
        """Tests to see if ss correctly expands dm into multiple leaves"""
        dm = 0.25 * ket2dm(ks.h0) + 0.75 * ket2dm(ks.h1)
        ss = StateSampler([DenseDMRepr(dm)], labels="dm")
        self.assertEqual(len(ss.get_leaves()), 1)
        ss.convert_states(QFormalism.DM)
        self.assertEqual(len(ss.get_leaves()), 1)
        ss.convert_states(QFormalism.KET)
        leaves = ss.get_leaves()
        self.assertEqual(len(leaves), 2)
        self.assertTrue(np.allclose([leaf.probability for leaf in leaves], [0.25, 0.75]))
        self.assertTrue(leaves[0].qrepr == KetRepr(ks.h0))
        self.assertTrue(leaves[1].qrepr == KetRepr(ks.h1))
        ss1 = StateSampler([DenseDMRepr(dm)], labels="dm")
        ss2 = StateSampler([KetRepr(ks.s0), ss1], probabilities=[0.30, 0.70])
        leaves = ss2.get_leaves()
        self.assertEqual(len(leaves), 2)
        self.assertTrue(np.allclose([leaf.probability for leaf in leaves], [0.30, 0.70]))
        ss2.convert_states(QFormalism.KET)
        leaves = ss2.get_leaves()
        self.assertEqual(len(leaves), 3)
        self.assertTrue(np.allclose([leaf.probability for leaf in leaves], [0.30, 0.25 * 0.70, 0.75 * 0.70]))
        self.assertTrue(leaves[0].qrepr == KetRepr(ks.s0))
        self.assertTrue(leaves[1].qrepr == KetRepr(ks.h0))
        self.assertTrue(leaves[2].qrepr == KetRepr(ks.h1))

    def test_convert_and_reduce_states(self):
        """Test to see if ss is correctly reduced after conversion"""
        h0dm = DenseDMRepr(ket2dm(ks.h0))
        h1dm = DenseDMRepr(ket2dm(ks.h1))
        st1 = KetRepr(ks.s0)
        st2 = convert_qrepr(st1, QFormalism.DM)
        st3 = StabRepr(np.asarray([[1, 0]], dtype=np.uint8), phases=[1])
        st4 = StateSampler([h0dm, st3], labels=["3", "4"])
        st5 = KetRepr(ks.s1)
        st6 = convert_qrepr(st5, QFormalism.DM)
        st7 = GSLCRepr(local_cliffords=[cliffords.CLIFF_K])
        st8 = StateSampler([h1dm, st7], labels=["3", "4"])
        ss1 = StateSampler([st2, st2, st6])
        ss1.reduce_states()
        self.assertEqual(len(ss1.get_leaves()), 1)
        self.assertEqual(ss1.get_leaves()[0].qrepr, DenseDMRepr(2/3*st2.dm + 1/3*st6.dm))

        states = [st3, st7, None, None, st1, st2, st2, st1, st6, st5,
                  st1, st2, st5, st6, st4, st8, st4, None, None, st3]
        labels = ["0", "0", "1", "0", "0", "0", "0", "0", "0", "0",
                  "1", "1", "1", "1", "1", "1", "0", "0", "1", "1"]
        ss = StateSampler(states, labels=labels)
        ss.convert_states(QFormalism.DM)
        ss.reduce_states()
        leaves = ss.get_leaves()
        self.assertEqual(len(leaves), 8)
        self.assertEqual(len(ss._labels), 8)
        self.assertEqual(len(ss._probabilities), 8)
        self.assertEqual(len(ss._qs_reprs), 8)
        for leaf in leaves:
            if leaf.label == ("0", "3"):
                self.assertAlmostEqual(1 / 20 / 2, leaf.probability)
                self.assertIs(leaf.qrepr, h0dm)
            elif leaf.label == ("0", "4"):
                self.assertAlmostEqual(1 / 20 / 2, leaf.probability)
                self.assertEqual(leaf.qrepr, h0dm)
            elif leaf.label == ("1", "3"):
                self.assertAlmostEqual(1 / 20, leaf.probability)
                self.assertEqual(leaf.qrepr, DenseDMRepr(np.eye(2) / 2))
            elif leaf.label == ("1", "4"):
                self.assertAlmostEqual(1 / 20, leaf.probability)
                res = convert_qrepr(st3, QFormalism.DM).dm + convert_qrepr(st7, QFormalism.DM).dm
                self.assertEqual(leaf.qrepr, DenseDMRepr(res / 2))
            elif leaf.label == "0":
                if leaf.qrepr is None:
                    self.assertAlmostEqual(leaf.probability, 2 / 20)
                elif leaf.probability == 8 / 20:
                    res = (4 * st2.dm + convert_qrepr(st3, QFormalism.DM).dm + convert_qrepr(st7, QFormalism.DM).dm + 2 * st6.dm)
                    self.assertEqual(leaf.qrepr, DenseDMRepr(res / 8))
                else:
                    assert False, "Unexpected state {} with probability {}".format(leaf.qrepr, leaf.probability)
            elif leaf.label == "1":
                if leaf.qrepr is None:
                    self.assertAlmostEqual(leaf.probability, 2 / 20)
                elif leaf.probability == 5 / 20:
                    res = (2 * st2.dm + convert_qrepr(st3, QFormalism.DM).dm + 2 * st6.dm)
                    self.assertEqual(leaf.qrepr, DenseDMRepr(res / 5))
                else:
                    assert False, "Unexpected state {} with probability {}".format(leaf.qrepr, leaf.probability)

            else:
                assert False, "Unexpected label {}".format(leaf.label)

    def test_combine_equal_states(self):
        """Test combining states with equal label and state"""
        st1 = KetRepr(ks.s0)
        st2 = convert_qrepr(st1, QFormalism.DM)
        st3 = StabRepr(np.asarray([[1, 1]], dtype=np.uint8), phases=[1])
        st_stab = StabRepr(np.asarray([[1, 0]], dtype=np.uint8), phases=[-1])
        st_h0 = KetRepr(ks.h0)
        st4 = StateSampler([st_h0, st_stab], labels="3")
        states = [st1, st2, st2, st1, st1, st2, st2, st1, st3, st3, st3, st4, st4, st4, None, None, None, None]
        labels = ["0", "0", "0", "0", "1", "1", "2", "2", None, "6", None, "4", None, "4", None, "10", "10", None]
        ss = StateSampler(states, labels=labels)
        leaves = ss.get_leaves()
        self.assertEqual(len(ss._labels), 14)
        self.assertEqual(len(ss._probabilities), 14)
        self.assertAlmostEqual(sum(ss._probabilities), 1)
        self.assertEqual(len(ss._qs_reprs), 14)
        self.assertEqual(len(leaves), 14)
        for leaf in leaves:
            if leaf.label == "3":
                self.assertEqual(1 / 36, leaf.probability)
                self.assertTrue(leaf.qrepr is st_h0 or leaf.qrepr is st_stab)
            elif leaf.label == ("4", "3"):
                self.assertEqual(1 / 18, leaf.probability)
                self.assertTrue(leaf.qrepr is st_h0 or leaf.qrepr is st_stab)
            elif leaf.label == "0":
                self.assertEqual(leaf.probability, 2 / 18)
                self.assertTrue(leaf.qrepr is st2 or leaf.qrepr is st1)
            elif leaf.label == "1":
                self.assertEqual(leaf.probability, 1 / 18)
                self.assertTrue(leaf.qrepr is st2 or leaf.qrepr is st1)
            elif leaf.label == "2":
                self.assertEqual(leaf.probability, 1 / 18)
                self.assertTrue(leaf.qrepr is st2 or leaf.qrepr is st1)
            elif leaf.label is None:
                self.assertEqual(leaf.probability, 2 / 18)
                self.assertTrue(leaf.qrepr is st3 or leaf.qrepr is None)
            elif leaf.label == "6":
                self.assertEqual(leaf.probability, 1 / 18)
                self.assertTrue(leaf.qrepr is st3)
            elif leaf.label == "10":
                self.assertEqual(leaf.probability, 2 / 18)
                self.assertTrue(leaf.qrepr is None)
            else:
                assert False, "Unexpected label {}".format(leaf.label)


if __name__ == '__main__':
    unittest.main()
