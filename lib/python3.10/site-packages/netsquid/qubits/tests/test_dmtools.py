# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_dmtools.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for dmtools module.

"""
import unittest
import abc
from unittest.mock import Mock, MagicMock
import numpy as np

from netsquid.qubits.dmtools import DenseDMRepr

from netsquid.qubits import dmtools
from netsquid.qubits.operators import Operator, I, X, Y, Z, H, S, CNOT
from netsquid.qubits.ketutil import dagger, ket2dm
from netsquid.qubits.ketstates import s0, s1, b01
from netsquid.qubits.qubit import Qubit
from netsquid.qubits.tests.test_qrepr import TestQRepr
from netsquid.qubits.tests.test_qstate import TestDepQState
from netsquid.qubits import qubitapi as qapi


class TestDMRepr(TestQRepr, metaclass=abc.ABCMeta):
    """Test the DMRepr class.

    """
    def test_assign_qrepr(self):
        repr1 = self.create_qrepr(dm=[[1, 0], [0, 0]])
        self.assertTrue(repr1.is_valid)
        self.assertEqual(1, repr1.num_qubits)
        repr2 = self.create_qrepr(dm=[[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]])
        self.assertTrue(repr2.is_valid)
        self.assertEqual(2, repr2.num_qubits)

    def _assertEqualDM2Ket(self, representation, ket):
        raise NotImplementedError

    def test_init(self):
        """Test DMRepr initialization"""
        super(TestDMRepr, self).test_init()
        dmrepr = self.create_qrepr(dm=ket2dm(b01))
        self._assertEqualDM2Ket(dmrepr, b01)
        self.assertEqual(2, dmrepr.num_qubits)
        dmrepr2 = self.create_qrepr(dm=ket2dm(b01))
        self.assertEqual(dmrepr, dmrepr2)

    def test_multi_operate(self):
        """Test multi quantum operations with arbitrary weights"""
        # Test a measurement with Z observable
        dmrepr = self.create_qrepr(num_qubits=1)
        dmrepr.multi_operate([0], operators=list(Z.projectors), modify=True)
        self._assertEqualDM2Ket(dmrepr, s0)
        # Test a measurement with Y observable
        dmrepr = self.create_qrepr(num_qubits=1)
        dmrepr = dmrepr.multi_operate([0], operators=list(Y.projectors), weights=(1, 1))
        self._assertEqualDM2Ket(dmrepr, np.eye(2)/2)
        # Test complete depolarization of single arbitary qubit
        # (also a valid stochastic operation)
        ket = (0.4j * s0 - (0.8 + 0.2j) * s1)
        ket /= np.sqrt(dagger(ket) @ ket)
        dmrepr = self.create_qrepr(dm=ket2dm(ket))
        dmrepr.multi_operate([0], [I, X, Y, Z], weights=(1/4, 1/4, 1/4, 1/4), modify=True)
        self._assertEqualDM2Ket(dmrepr, np.eye(2)/2)
        # Test amplitude damping with articifial weights
        gamma = 0.3
        dmrepr = self.create_qrepr(dm=ket2dm(s1))
        E0 = Operator("E0", [[1, 0], [0, np.sqrt(1 - gamma)]]) * 0.5
        E1 = Operator("E1", [[0, np.sqrt(gamma)], [0, 0]]) * (1/3)
        dmrepr = dmrepr.multi_operate([0], [E0, E1], weights=(4, 9))
        self._assertEqualDM2Ket(dmrepr, np.array([[gamma, 0], [0, 1 - gamma]]))

    def test_predictive_measure_qubit(self):
        """Predictive test for projective measurement of a qubit"""
        # Mock up random number generator to give predictable results
        rng = Mock(np.random.RandomState)
        for obs in [X, Y]:
            dmrepr = self.create_qrepr(num_qubits=2)
            rng.random_sample = MagicMock(return_value=0)
            dmrepr, m, __ = dmrepr.measure(0, observable=obs, rng=rng, modify=True)
            self.assertEqual(m, 0)
            rng.random_sample = MagicMock(return_value=1)
            dmrepr, m, __ = dmrepr.measure(1, observable=obs, rng=rng)
            self.assertEqual(m, 1)
            e0, e1 = obs.eigenkets
            self._assertEqualDM2Ket(dmrepr, np.kron(e0, e1) @ dagger(np.kron(e0, e1)))

    def test_large_states(self):
        """Test dm representation can handle large states."""
        # Create largish qubit quantum state
        n = 8  # ~ requires 8 mb of RAM per DM state
        dmrepr = self.create_qrepr(num_qubits=n)
        self.assertEqual(dmrepr.num_qubits, n)
        self.assertEqual(dmrepr.reduced_dm().shape, (2**n, 2**n))
        # Test operate
        for i in range(n):
            dmrepr.operate([i], H, modify=True)
        self._assertEqualDM2Ket(dmrepr, np.ones((2**n, 2**n)) / 2 ** n)
        dmrepr = dmrepr.operate([0], X * H)
        dmrepr = dmrepr.operate([n // 2], H)
        dmrepr = dmrepr.operate([0, n // 2], CNOT)
        dmrepr = dmrepr.operate([1], S)
        # Test measure with drop
        dmrepr, m1, __ = dmrepr.measure(0)
        self.assertEqual(m1, 1)
        dmrepr, m2, __ = dmrepr.measure(n // 2)
        dmrepr.discard(n // 2)
        self.assertEqual(m2, 1)
        dmrepr, m1, __ = dmrepr.measure(1, observable=Y)
        self.assertEqual(m1, 0)

    def test_arithmetic(self):
        """Test arithmetic works for dm representation."""
        repr1 = self.create_qrepr(num_qubits=1)
        repr2 = self.create_qrepr(num_qubits=1)
        self.assertEqual(repr1, repr2)
        repr3 = (repr1 + repr2) / 2
        self.assertEqual(repr3, repr1)
        repr4 = repr2 * (1/2) + repr1 * (1/2)
        self.assertEqual(repr4, repr1)
        repr5 = 2 * repr2 - repr1
        self.assertEqual(repr5, repr1)
        dm = np.array([[1, 0], [0, 0]])
        self.assertEqual(2*dm - repr1, repr1)
        self.assertEqual(dm/2 + repr1/2, repr1)
        with self.assertRaises(TypeError):
            repr1 * 'a'
        with self.assertRaises(TypeError):
            repr1 + 'a'
        with self.assertRaises(TypeError):
            repr1 - 'a'


class TestDenseDMRepr(TestDMRepr, unittest.TestCase):
    """Test the DenseDMRepr class.

    """

    def create_qrepr(self, **kwargs) -> DenseDMRepr:
        return DenseDMRepr(**kwargs)

    def _assertEqualDM2Ket(self, representation, ket):
        if ket.shape[1] == 1:
            ket = ket2dm(ket)
        self.assertTrue(np.allclose(representation.dm, ket))


class TestDMState(TestDepQState, unittest.TestCase):
    """Unit tests for deprecated DMState class.

    The TestQState baseclass defines extra test methods.

    """
    # DEPRECATED
    def _assertEqualDM2Ket(self, dm, ket):
        self.assertTrue(np.allclose(dm, ket2dm(ket)))

    def create_qstate(self, qubits, dm=None):
        dmtools.DMState(qubits, dm=dm)

    @property
    def is_stabilizer(self):
        return False

    def test_DMState_init(self):
        """Test DMState initialization"""
        # check qubit creation
        h1 = Qubit("H1")
        self.assertEqual(h1.name, "H1")
        self.assertEqual(h1.qstate, None)
        with self.assertRaises(RuntimeError):
            h1._index
        # check DMState creation
        with self.assertRaises(ValueError):
            dmtools.DMState([h1, h1], ket2dm(b01))
        with self.assertRaises(ValueError):
            dmtools.DMState([h1], ket2dm(b01))
        h2 = Qubit("H2")
        qs = dmtools.DMState([h1, h2], ket2dm(b01))
        self._assertEqualDM2Ket(qs.dm, b01)
        h1.qstate.compare(qs)
        h2.qstate.compare(qs)
        self.assertEqual(h1._index, 0)
        self.assertEqual(h2._index, 1)
        self.assertEqual(qs.num_qubits, 2)
        with self.assertRaises(ValueError):
            qs.dm = ket2dm(s0)

    def test_multi_operate(self):
        """Test multi quantum operations with arbitrary weights"""
        # Test a measurement with Z observable
        q1, = self.create_qubits("Q", 1)
        qs = q1.qstate
        qs.multi_operate_qubits([q1], operators=list(Z.projectors))
        self.assertTrue(np.allclose(qs.dm, np.array([[1, 0], [0, 0]])))
        # Test a measurement with Y observable
        q1, = self.create_qubits("Q", 1)
        qs = q1.qstate
        qs.multi_operate_qubits([q1], operators=list(Y.projectors), weights=(1, 1))
        self.assertTrue(np.allclose(qs.dm, np.eye(2)/2))
        # Test complete depolarization of single arbitary qubit
        # (also a valid stochastic operation)
        ket = (0.4j * s0 - (0.8 + 0.2j) * s1)
        ket /= np.sqrt(dagger(ket) @ ket)
        q1, = self.create_qubits("Q", 1, dm=(ket2dm(ket)))
        qs = q1.qstate
        qs.multi_operate_qubits([q1], [I, X, Y, Z], weights=(1/4, 1/4, 1/4, 1/4))
        self.assertTrue(np.allclose(qs.dm, np.eye(2)/2))
        # Test amplitude damping with articifial weights
        gamma = 0.3
        q1, = self.create_qubits("Q", 1, dm=(ket2dm(s1)))
        qs = q1.qstate
        E0 = Operator("E0", [[1, 0], [0, np.sqrt(1 - gamma)]]) * 0.5
        E1 = Operator("E1", [[0, np.sqrt(gamma)], [0, 0]]) * (1/3)
        qs.multi_operate_qubits([q1], [E0, E1], weights=(4, 9))
        self.assertTrue(np.allclose(qs.dm, np.array([[gamma, 0], [0, 1 - gamma]])))

    def test_predictive_measure_qubit(self):
        """Predictive test for projective measurement of a qubit"""
        # Mock up random number generator to give predictable results
        rng = Mock(np.random.RandomState)
        for obs in [X, Y]:
            q1, q2 = self.create_qubits("Q", 2)
            rng.random_sample = MagicMock(return_value=0)
            m, __ = q1.qstate.measure_qubit(q1, observable=obs, rng=rng)
            self.assertEqual(m, 0)
            rng.random_sample = MagicMock(return_value=1)
            m, __ = q2.qstate.measure_qubit(q2, observable=obs, rng=rng)
            self.assertEqual(m, 1)
            e0, e1 = obs.eigenkets
            self.assertTrue(np.allclose(q2.qstate.dm, np.kron(e0, e1) @ dagger(np.kron(e0, e1))))

    def test_amplitude_dampen_ensemble(self):
        """Test amplitude damping"""
        gamma = 0.1
        # For p=1, starionary state is |0>
        q1, = self.create_qubits("Q", 1)
        q1.qstate.amplitude_dampen(q1, gamma=gamma, prob=1)  # -> stationary
        self.assertTrue(np.allclose(q1.qstate.dm, ket2dm(s0)))
        qapi.operate(q1, X)
        q1.qstate.amplitude_dampen(q1, gamma=gamma, prob=1)  # -> dampened
        self.assertTrue(np.allclose(q1.qstate.dm, gamma * ket2dm(s0) + (1 - gamma) * ket2dm(s1)))
        # For p=0.5, |0> no longer stationary state
        q1, = self.create_qubits("Q", 1)
        q1.qstate.amplitude_dampen(q1, gamma=gamma, prob=0.5)
        self.assertTrue(np.allclose(q1.qstate.dm,
                                    (1 - 0.5 * gamma) * ket2dm(s0) + (0.5 * gamma) * ket2dm(s1)))
        # For p=0.5, stationary state is 0.5*(|0><0| + |1><1|)
        q1, = self.create_qubits("Q", 1)
        qapi.operate(q1, H)
        q1.qstate.multi_operate_qubits([q1], operators=list(Z.projectors))  # -> 0.5*(|0><0| + |1><1|)
        q1.qstate.amplitude_dampen(q1, gamma=gamma, prob=0.5)
        self.assertTrue(np.allclose(q1.qstate.dm, 0.5 * np.eye(2)))  # -> stationary
        for g, p in [(0.5, -0.1), (0.5, 1.1), (-0.1, 0.5), (1.1, 0.5)]:
            q1, = self.create_qubits("Q", 1)
            with self.assertRaises(ValueError):
                q1.qstate.amplitude_dampen(q1, gamma=g, prob=p)

    def test_large_states(self):
        """Test dm formalism can handle large states."""
        # Create largish qubit quantum state
        n = 8  # ~ requires 8 mb of RAM per DM state
        qubits = self.create_qubits("Q", n)
        qstate = qubits[0].qstate
        self.assertEqual(qstate.num_qubits, n)
        self.assertEqual(qstate.dm.shape, (2**n, 2**n))
        # Test operate
        for i, qubit in enumerate(qubits):
            qstate.operate_qubits([qubit], H)
        self.assertTrue(np.allclose(qstate.dm, np.ones((2**n, 2**n)) / 2 ** n))
        qstate.operate_qubits([qubits[0]], X * H)
        qstate.operate_qubits([qubits[n // 2]], H)
        qstate.operate_qubits([qubits[0], qubits[n // 2]], CNOT)
        qstate.operate_qubits([qubits[1]], S)
        # Test measure with drop
        m1, __ = qstate.measure_qubit(qubits[0])
        self.assertEqual(m1, 1)
        m2, __ = qstate.measure_qubit(qubits[n // 2], drop_qubit=True)
        self.assertEqual(m2, 1)
        m1, __ = qstate.measure_qubit(qubits[1], observable=Y)
        self.assertEqual(m1, 0)

    # def generate_random_dm(self):
    #    return qutip.random_objects.rand_dm(4).data.todense()

    # def test_depolarize_bell_diagonal(self):
    #    rho = self.generate_random_dm()
    #    rho_bell = dmtools.depolarize_bell_diagonal(rho)
    #    # check fidelity unchanged
    #    self._assertEqualFidelity(rho, rho_bell)
    #    # TODO check for diagonal in Bell basis

    # def test_depolarize_werner(self):
    #    rho = self.generate_random_dm()
    #    rho_werner = dmtools.depolarize_werner(rho)
    #    # check valid Werner state:
    #    rho_b00 = rho_werner[0][3] * 2 * ket2dm(b00)
    #    rho_other = rho_werner[1][1] * np.eye(4)
    #    rho_test = rho_b00 + rho_other
    #    self.assertTrue(np.allclose(rho_test, rho_werner))
    #    # check fidelity unchanged
    #    self._assertEqualFidelity(rho, rho_werner)


if __name__ == "__main__":
    unittest.main(verbosity=2)
