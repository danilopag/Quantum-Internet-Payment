# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_ketutil.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the ketutil module.

"""
import unittest
import numpy as np
from netsquid.qubits import ketstates as ks
from netsquid.qubits import ketutil as ku
from netsquid.util.cymath import correct_global_phase


class TestKetutil(unittest.TestCase):
    """Unit tests for the ketutil module.

    """

    def _check_dm2kets(self, dm, kets, probs):
        res_kets, res_probs = ku.dm2kets(dm)
        self.assertEqual(len(res_kets), len(kets))
        self.assertEqual(len(res_probs), len(probs))
        res_kets = [correct_global_phase(ket) for ket in res_kets]
        for ket, prob in zip(kets, probs):
            found = False
            for res_ket, res_prob in zip(res_kets, res_probs):
                if np.allclose(res_ket, ket):
                    found = True
                    self.assertAlmostEqual(prob, res_prob)
                    break
            self.assertTrue(found)

    def _check_sampled_ket(self, dm, ket, prob, tol=0.1, N=1000):
        # Do a statistical check
        count = 0
        for __ in range(N):
            count += np.allclose(ket, correct_global_phase(ku.sample_ket_from_dm(dm)))
        res_prob = count / N
        self.assertTrue(abs(res_prob - prob) < tol)

    def test_dm2kets(self):
        """Test dm2kets function."""
        dm = np.array(0.25 * np.eye(4), dtype=complex)
        self._check_dm2kets(dm, [ks.s00, ks.s01, ks.s10, ks.s11], [0.25] * 4)
        dm = np.array(np.diag([0, 0.4, 0, 0.6]), dtype=complex)
        self._check_dm2kets(dm, [ks.s01, ks.s11], [0.4, 0.6])
        dm = 0.2 * ku.outerprod(ks.b01) + 0.8 * ku.outerprod(ks.b00)
        self._check_dm2kets(dm, [ks.b01, ks.b00], [0.2, 0.8])

    def test_sample_ket_from_dm(self):
        """Test sample_ket_from_dm function."""
        dm = np.array(np.diag([0, 1.0, 0, 0., 0., 0., 0., 0.]), dtype=complex)
        self._check_sampled_ket(dm, np.kron(ks.s00, ks.s1), 1)
        dm = 0.2 * ku.outerprod(ks.b01) + 0.5 * ku.outerprod(ks.b00) + 0.3 * ku.outerprod(ks.b11)
        self._check_sampled_ket(dm, ks.b00, 0.5)
        dm = np.array(np.diag([0, 0.5, 0.1, 0.05, 0., 0.2, 0.15, 0.]), dtype=complex)
        self._check_sampled_ket(dm, np.kron(ks.s11, ks.s0), 0.15)

    def test_reorder(self):
        """Test the reordering of a ket state"""
        state = np.kron(ks.s01, ks.s00)
        new_state = ku.reorder_ket(state, [0, 1, 2, 3])
        self.assertTrue(np.allclose(state, new_state))
        new_state = ku.reorder_ket(state, [1, 0, 2, 3])
        self.assertTrue(np.allclose(new_state, np.kron(ks.s10, ks.s00)))
        new_state = ku.reorder_ket(state, [2, 0, 1, 3])
        self.assertTrue(np.allclose(new_state, np.kron(ks.s00, ks.s10)))
        new_state = ku.reorder_ket(ks.s10, [1, 0])
        self.assertTrue(np.allclose(new_state, ks.s01))
        with self.assertRaises(ValueError):
            ku.reorder_ket(state, [0])
        with self.assertRaises(ValueError):
            ku.reorder_ket(state, [1, 2, 3])

    # def test_reshape_for_trace(self):
    #    """Test the reshape of the ket state, which when taken the outer product of, is the reduced_dm"""
    #    state = np.kron(ks.s01, ks.s00)
    #    reshape_for_trace = ku._reshape_for_trace(state, [0, 1])
    #    self.assertTrue(np.allclose(ku.outerprod(reshape_for_trace), ku.ket2dm(ks.s01)))
    #    reshape_for_trace = ku._reshape_for_trace(state, [2, 3])
    #    self.assertTrue(np.allclose(ku.outerprod(reshape_for_trace), ku.ket2dm(ks.s00)))
    #    reshape_for_trace = ku._reshape_for_trace(state, [1, 3])
    #    self.assertTrue(np.allclose(ku.outerprod(reshape_for_trace), ku.ket2dm(ks.s10)))

    def test_ket_fidelity(self):
        """Reset the ket fidelity function."""
        state = np.kron(ks.s01, ks.s00)
        self.assertAlmostEqual(ku.ket_fidelity(state, state), 1)
        with self.assertRaises(ValueError):
            ku.ket_fidelity(ks.s0, state)
        self.assertAlmostEqual(ku.ket_fidelity(state, ks.s01, [0, 1]), 1)
        self.assertAlmostEqual(ku.ket_fidelity(state, ks.s00, [2, 3]), 1)
        self.assertAlmostEqual(ku.ket_fidelity(state, ks.s10, [1, 3]), 1)
        self.assertAlmostEqual(ku.ket_fidelity(ks.h0, ks.s0, squared=False), np.sqrt(0.5))
        self.assertAlmostEqual(ku.ket_fidelity(ks.h0, ks.s0, squared=True), 0.5)

    def test_partial_trace(self):
        """Test the partial trace"""
        state = np.kron(ks.s01, ks.s00)
        self.assertTrue(np.allclose(ku.partialtrace(state, [2, 3]), ku.ket2dm(ks.s01)))
        self.assertTrue(np.allclose(ku.partialtrace(state, [0, 1]), ku.ket2dm(ks.s00)))

    def test_reduced_dm(self):
        """Test the reduce method"""
        state = np.kron(ks.s01, ks.s00)
        self.assertTrue(np.allclose(ku.reduced_dm(state, [0, 1]), ku.ket2dm(ks.s01)))
        self.assertTrue(np.allclose(ku.reduced_dm(state, [1, 0]), ku.ket2dm(ks.s10)))
        self.assertTrue(np.allclose(ku.reduced_dm(state, [1, 3]), ku.ket2dm(ks.s10)))
