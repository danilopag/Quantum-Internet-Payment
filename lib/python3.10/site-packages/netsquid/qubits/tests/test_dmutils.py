# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_dmutils.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the dmutil module.

"""
import unittest
import numpy as np
from netsquid.qubits.ketutil import ket2dm
from netsquid.qubits.ketstates import s0, s1, h0, h1
from netsquid.qubits.ketstates import s00, s01, s10, s11
from netsquid.qubits.ketstates import h00, h10
from netsquid.qubits.ketstates import b00, b01, b11
from netsquid.qubits import dmutil as dmu


class TestOperator(unittest.TestCase):
    """Unit tests for the operators module.

    """

    def test_reorder_matrix(self):
        """Test matrix reordering."""
        # 3 qubit state
        st012 = np.kron(s01, h1)  # |01->
        rho = ket2dm(st012)
        self.assertTrue(np.allclose(dmu.reorder_dm(rho, [0, 1, 2]),
                                    rho))  # null case
        st021 = np.kron(s0, np.kron(h1, s1))  # |0-1>
        self.assertTrue(np.allclose(dmu.reorder_dm(rho, [0, 2, 1]),
                                    ket2dm(st021)))
        self.assertTrue(np.allclose(rho, ket2dm(st012)))  # check same rho
        st210 = np.kron(np.kron(h1, s1), s0)  # |-10>
        self.assertTrue(np.allclose(dmu.reorder_dm(rho, [2, 1, 0]),
                                    ket2dm(st210)))
        self.assertTrue(np.allclose(rho, ket2dm(st012)))  # check same rho
        # 2 qubit state complex state
        st01 = np.array([[0.5], [-0.5j], [0.5], [0.5j]], dtype=complex)
        rho = ket2dm(st01)
        self.assertTrue(np.allclose(dmu.reorder_dm(rho, [0, 1]),
                                    rho))  # null case
        st10 = np.array([[0.5], [0.5], [-0.5j], [0.5j]], dtype=complex)
        self.assertTrue(np.allclose(dmu.reorder_dm(rho, [1, 0]),
                                    ket2dm(st10)))
        # 4 qubit mixed state
        st1_0123 = np.kron(s01, h10)  # |01-+>
        st2_0123 = np.kron(h00, s10)  # |++10>
        rho = 0.5 * (ket2dm(st1_0123) + ket2dm(st2_0123))
        self.assertTrue(np.allclose(dmu.reorder_dm(rho, [0, 1, 2, 3]),
                                    rho))  # null case

        st1_3012 = np.kron(h0, np.kron(s0, np.kron(s1, h1)))
        st2_3012 = np.kron(s0, np.kron(h00, s1))
        self.assertTrue(np.allclose(dmu.reorder_dm(rho, [3, 0, 1, 2]),
                                    0.5 * (ket2dm(st1_3012) + ket2dm(st2_3012))))

        st1_0213 = np.kron(s0, np.kron(h1, np.kron(s1, h0)))
        st2_0213 = np.kron(h0, np.kron(s1, np.kron(h0, s0)))
        self.assertTrue(np.allclose(dmu.reorder_dm(rho, [0, 2, 1, 3]),
                                    0.5 * (ket2dm(st1_0213) + ket2dm(st2_0213))))
        self.assertTrue(np.allclose(rho, 0.5 * (ket2dm(st1_0123) + ket2dm(st2_0123))))    # check same rho
        st1_2130 = np.kron(np.kron(h1, s1), np.kron(h0, s0))
        st2_2130 = np.kron(np.kron(s1, h0), np.kron(s0, h0))
        self.assertTrue(np.allclose(dmu.reorder_dm(rho, [2, 1, 3, 0]),
                                    0.5 * (ket2dm(st1_2130) + ket2dm(st2_2130))))

    def test_partialtrace(self):
        """Test matrix reordering."""
        # *** Trace out qubits from entangled bipartite state
        rho_b00 = ket2dm(b00)
        for i in range(2):
            self.assertTrue(np.allclose(dmu.partialtrace(rho_b00, [i]), 0.5 * np.eye(2)))
        self.assertTrue(np.allclose(dmu.partialtrace(rho_b00, [0, 1]), 1))
        # *** Trace out qubits from GHZ tripartite state
        ghz3 = (np.kron(s00, s0) + np.kron(s11, s1)) / np.sqrt(2)
        rho_ghz3 = ket2dm(ghz3)
        for i in range(3):
            self.assertTrue(np.allclose(dmu.partialtrace(rho_ghz3, [i]), 0.5 * (ket2dm(s00) + ket2dm(s11))))
            inds = set([0, 1, 2])
            inds.remove(i)
            self.assertTrue(np.allclose(dmu.partialtrace(rho_ghz3, list(inds)), 0.5 * np.eye(2)))
        self.assertTrue(np.allclose(dmu.partialtrace(rho_ghz3, [0, 1, 2]), 1))
        # *** Trace out qubits from arbitrary large mixed state
        st1 = np.kron(s00, h10)
        st2 = np.kron(h10, b11)
        st3 = np.kron(b01, s10)
        rho = (ket2dm(st1) + ket2dm(st2) + ket2dm(st3)) / 3
        # trace out two non-adjacent qubits:
        self.assertTrue(np.allclose(dmu.partialtrace(rho, [1, 2]),
                                    np.array([[5/12, 1/6, -1/12, 0],
                                              [1/6, 1/4, 0, -1/12],
                                              [-1/12, 0, 1/4, 0],
                                              [0, -1/12, 0, 1/12]], dtype=complex)))
        self.assertTrue(np.allclose(dmu.partialtrace(rho, [2, 3]),
                                    np.array([[5/12, 1/12, -1/12, -1/12],
                                              [1/12, 1/4, 1/12, -1/12],
                                              [-1/12, 1/12, 1/4, 1/12],
                                              [-1/12, -1/12, 1/12, 1/12]], dtype=complex)))
        # trace out two adjacent qubits:
        self.assertTrue(np.allclose(dmu.partialtrace(rho, [1, 3]),
                                    np.array([[1/4, -1/6, -1/12, 0],
                                              [-1/6, 5/12, 0, -1/12],
                                              [-1/12, 0, 1/12, 0],
                                              [0, -1/12, 0, 1/4]], dtype=complex)))
        self.assertTrue(np.allclose(dmu.partialtrace(rho, [0, 3]),
                                    np.array([[1/4, -1/6, 1/12, 0],
                                              [-1/6, 5/12, 0, 1/12],
                                              [1/12, 0, 1/12, 0],
                                              [0, 1/12, 0, 1/4]], dtype=complex)))
        # trace out three qubits:
        self.assertTrue(np.allclose(dmu.partialtrace(rho, [0, 1, 3]),
                                    np.array([[1/3, -1/6], [-1/6, 2/3]], dtype=complex)))
        # Check exception on bad qubit indices
        with self.assertRaises(ValueError):
            dmu.partialtrace(rho, [-1, 3])
        with self.assertRaises(ValueError):
            dmu.partialtrace(rho, [5, 0])

    def test_is_valid_dm(self):
        """Test checking of valid density matrices."""
        # Check some valid DMs
        for ket in [s0, s00, b00, b11, np.kron(h10, b01)]:
            rho = ket2dm(ket)
            self.assertTrue(dmu.is_valid_dm(rho))
        # Check some invalid DMs
        for rho in [s00, np.array("-1 0; 0 0"), np.array("0.5 0; 0 0"), np.array("0.5 0; 0.5 1j")]:
            self.assertFalse(dmu.is_valid_dm(rho))
        # Check for DM with a trace close to 1
        rho = np.array([[0.02200320 + 0.j, 0. + 0.j, 0. + 0.j, 0. + 0.j],
                        [0. + 0.j, 0.43056081 + 0.j, -0.39368698 + 0.j, 0. + 0.j],
                        [0. + 0.j, -0.39368698 + 0.j, 0.43056081 + 0.j, 0. + 0.j],
                        [0. + 0.j, 0. + 0.j, 0. + 0.j, 0.11687618 + 0.j]])
        self.assertNotEqual(np.trace(rho), 1.)
        self.assertAlmostEqual(np.trace(rho), 1.000001)
        self.assertTrue(dmu.is_valid_dm(rho))

    def test_dm_fidelity(self):
        """Test fidelity of density matrices."""
        rho = ket2dm(b00)
        for sigma, F in [(ket2dm(b00), 1), (ket2dm(s00), 1 / np.sqrt(2)), (ket2dm(b11), 0.)]:
            self.assertAlmostEqual(dmu.dm_fidelity(rho, sigma), F)
            self.assertAlmostEqual(dmu.dm_fidelity(rho, sigma, squared=True), F ** 2)


if __name__ == "__main__":
    unittest.main()
