# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_qstate.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Definition of the TestQState abstract base class for general unit
testing of QState formalisms. This base class should be inherited
by all the test classes of each formalism.

"""
import unittest
from unittest.mock import Mock, MagicMock, patch
import abc
import numpy as np
from netsquid.qubits.dmtools import DenseDMRepr
from netsquid.qubits.ketutil import ket2dm
from netsquid.qubits.qstate import QState
from netsquid.qubits.qrepr import QRepr
from netsquid.qubits.kettools import KetRepr
from netsquid.qubits.stabtools import StabRepr
# DEPRECATED
from netsquid.util.simlog import disable_warn_deprecated
from netsquid.qubits.ketstates import s0, b00, b01, b10, b11, s1, s00, s11, h0, h1, s10, s01, h00, h01, h10, h11, y0, y1
from netsquid.qubits.operators import X, H, Y, S, I, Z, CZ, CNOT, SWAP, Operator, CS
from netsquid.qubits import cliffords
from netsquid.qubits.ketutil import outerprod, dagger
from netsquid.qubits.qubit import Qubit
from netsquid.qubits import GSLCRepr
from netsquid.qubits import qubitapi as qapi


class TestQState(unittest.TestCase):

    def test_init(self):
        """Test initialisation of QState."""
        qubits = [Qubit(f"TestQubit-#{i}") for i in range(3)]
        for formalism in [KetRepr, DenseDMRepr, StabRepr, GSLCRepr]:
            qstate = QState(qubits, formalism(num_qubits=len(qubits)))
            self.assertEqual(3, qstate.num_qubits)
            self.assertIsInstance(qstate.qrepr, QRepr)
            self.assertEqual(3, qstate.qrepr.num_qubits)

    def test_drop_qubit(self):
        """Test dropping of a qubit from a QState."""
        qubits = [Qubit(f"TestQubit-#{i}") for i in range(3)]
        qstate = QState(qubits, KetRepr(num_qubits=len(qubits)))
        for qubit in qubits:
            self.assertIs(qubit.qstate, qstate)
        qstate.drop_qubit(qubits[2])
        self.assertEqual(2, qstate.num_qubits)
        self.assertEqual(2, qstate.qrepr.num_qubits)
        self.assertIsNone(qubits[2].qstate)
        qstate.drop_qubit(qubits[0])
        self.assertEqual(1, qstate.num_qubits)
        self.assertEqual(1, qstate.qrepr.num_qubits)
        self.assertIsNone(qubits[0].qstate)
        # Dropping the last qubit of a qstate doesn't modify the qstate
        qstate.drop_qubit(qubits[1])
        self.assertEqual(0, qstate.num_qubits)
        self.assertEqual(0, qstate.qrepr.num_qubits)
        self.assertIsNone(qubits[1].qstate)

    def test_auto_drop_qubit(self):
        """Test that qubits are automatically dropped when they leave scope."""
        qubits = [Qubit(f"TestQubit-#{i}") for i in range(3)]
        qstate = QState(qubits, KetRepr(num_qubits=len(qubits)))
        for qubit in qubits:
            self.assertIs(qubit.qstate, qstate)
        qstate.drop_qubit(qubits[2])
        self.assertEqual(2, qstate.num_qubits)
        self.assertEqual(2, qstate.qrepr.num_qubits)
        self.assertIsNone(qubits[2].qstate)
        qstate.drop_qubit(qubits[0])
        self.assertEqual(1, qstate.num_qubits)
        self.assertEqual(1, qstate.qrepr.num_qubits)
        self.assertIsNone(qubits[0].qstate)
        # Dropping the last qubit of a qstate doesn't modify the qstate
        qstate.drop_qubit(qubits[1])
        self.assertEqual(0, qstate.num_qubits)
        self.assertEqual(0, qstate.qrepr.num_qubits)
        self.assertIsNone(qubits[1].qstate)

    def test_combine_qstates(self):
        """Test combining of QStates."""
        qubits1 = [Qubit(f"TestQubit-#1-{i}") for i in range(3)]
        qstate1 = QState(qubits1, KetRepr(num_qubits=len(qubits1)))
        qubits2 = [Qubit(f"TestQubit-#2-{i}") for i in range(2)]
        qstate2 = QState(qubits2, KetRepr(num_qubits=len(qubits2)))
        self.assertEqual(3, qstate1.num_qubits)
        self.assertEqual(2, qstate2.num_qubits)
        self.assertEqual(3, qstate1.qrepr.num_qubits)
        self.assertEqual(2, qstate2.qrepr.num_qubits)
        qstate1.combine_qstate(qstate2)
        self.assertEqual(5, qstate1.num_qubits)
        self.assertEqual(5, qstate1.qrepr.num_qubits)
        # The final qubit stays in the qstate
        self.assertEqual(0, qstate2.num_qubits)
        # The qrepr is also left with a final qubit
        # TODO: This should also be zero, or maybe qrepr is None?
        self.assertEqual(2, qstate2.qrepr.num_qubits)

    def test_get_qubit_index(self):
        """Test index lookup of qubit in QState."""
        qubits1 = [Qubit(f"TestQubit-#1-{i}") for i in range(3)]
        qstate1 = QState(qubits1, KetRepr(num_qubits=len(qubits1)))
        for i, qubit in enumerate(qubits1):
            self.assertEqual(i, qstate1.indices_of([qubit])[0])
        self.assertIsNone(qstate1.indices_of(['qubit'])[0])
        self.assertIsNone(qstate1.indices_of([Qubit('testqubit')])[0])
        self.assertEqual([0, 1, 2], qstate1.indices_of(qubits1))


class TestDepQState(metaclass=abc.ABCMeta):
    """Abstract base class for a test class of a ``QState`` formalism.

    Defines test methods that check basic functionality of a QState
    instance.

    """
    # DEPRECATED
    @abc.abstractmethod
    def create_qstate(self, qubits, *args, **kwargs):
        """Create a quantum state, defaulting to |0...0>.

        This method should be overridden by each quantum state test case.

        Parameters
        ----------
        qubits : list of :obj:`~netsquid.qubits.qubit.Qubit`
            List of qubits to create quantum state for.

        """
        # Should be implemented by child test class
        pass

    def create_qubits(self, system_name, num_qubits, *args, **kwargs):
        """Create qubits in |0...0> quantum state.

        Parameters
        ----------
        system_name : str
            System name for qubits
        num_qubits : int
            Number of qubits to create.

        Returns
        -------
        list of :obj:`~netsquid.qubits.qubit.Qubit`
            Created qubits.

        """
        qubits = []
        for i in range(num_qubits):
            qubits.append(Qubit("{}{}".format(system_name, i)))
        self.create_qstate(qubits, *args, **kwargs)
        return qubits

    @disable_warn_deprecated
    def test_create_qubits(self):
        """Test creation of qubits in |0...0> state."""
        q1, q2 = self.create_qubits("Q", 2)
        self.assertEqual(q1.name, "Q0")
        self.assertEqual(q2.name, "Q1")
        self.assertTrue(q1.qstate == q2.qstate)
        self.assertTrue(q1.qstate.compare(q2.qstate))
        self.assertTrue(np.allclose(q1.qstate.dm, ket2dm(s00)))
        q1, = self.create_qubits("A", 1)
        q2, = self.create_qubits("B", 1)
        self.assertEqual(q1.name, "A0")
        self.assertEqual(q2.name, "B0")
        self.assertTrue(q1.qstate.compare(q2.qstate))
        self.assertNotEqual(q1.qstate, q2.qstate)
        self.assertIsNot(q1.qstate, q2.qstate)
        self.assertTrue(np.allclose(q1.qstate.dm, ket2dm(s0)))

    @disable_warn_deprecated
    def test_operate_qubit(self):
        """Test single qubit operations."""
        # Test some single qubit operations:
        q1, = self.create_qubits("Q", 1)
        qs = q1.qstate
        qs.operate_qubits([q1], X)  # -> Z-
        self.assertTrue(np.allclose(qs.dm, ket2dm(s1)))
        qs.operate_qubits([q1], X)  # -> Z+
        self.assertTrue(np.allclose(qs.dm, ket2dm(s0)))
        q1.qstate.operate_qubits([q1], H)  # -> X+
        self.assertTrue(np.allclose(qs.dm, ket2dm(h0)))
        q1.qstate.operate_qubits([q1], S)  # -> Y+
        self.assertTrue(np.allclose(qs.dm, ket2dm(y0)))
        q1.qstate.operate_qubits([q1], H)  # -> Y-
        self.assertTrue(np.allclose(qs.dm, ket2dm(y1)))
        q1.qstate.operate_qubits([q1], S)  # -> X+
        self.assertTrue(np.allclose(qs.dm, ket2dm(h0)))
        q1.qstate.operate_qubits([q1], H)  # -> Z+
        self.assertTrue(np.allclose(qs.dm, ket2dm(s0)))
        # Test single qubit operations on larger ket state
        q1, q2, q3, q4 = self.create_qubits("Q", 4)
        qs = q1.qstate
        qs.operate_qubits([q4], X)
        qs.operate_qubits([q2], H)
        ket = np.kron(np.kron(s0, h0), s01)
        self.assertTrue(np.allclose(qs.dm, ket2dm(ket)))

    @disable_warn_deprecated
    def create_qubits_in_basis(self, system_name, ketstring):
        """Create qubits in the standard or hadamard bases.

        Qubits are prepared as in state: {|0>, |1>, |+>, |->}^num_qubits.

        Parameters
        ----------
        system_name : str
            Name of the qubit system
        ketstring : str
            String represent of desired ket vector e.g. "010+" -> |010+>.

        Returns
        -------
        list of :obj:`~netsquid.qubits.qubit.Qubit`
            Created qubits.

        Raises
        ------
        ValueError
            If an length of ``ketstring`` not equal to ``num_qubits``.

        Notes
        -----
            Creates qubits in default |0...0> state then does bit flipping.

        """
        qubits = self.create_qubits(system_name, len(ketstring))
        qs = qubits[0].qstate
        for i, qstr in enumerate(ketstring):
            if qstr == "1" or qstr == "-":
                qs.operate_qubits([qubits[i]], X)
            if qstr == "+" or qstr == "-":
                qs.operate_qubits([qubits[i]], H)
        return qubits

    def test_create_qubits_in_basis(self):
        """Test creation of qubits in standard basis via bit flipping"""
        for ketstring, ket in [
            ("0", s0), ("1", s1),
            ("+", h0), ("-", h1),
            ("00", s00), ("01", s01), ("10", s10), ("11", s11),
            ("++", h00), ("+-", h01), ("-+", h10), ("--", h11),
            ("011", np.kron(s01, s1)), ("1011", np.kron(s10, s11)),
            ("-+1", np.kron(h10, s1)), ("10--", np.kron(s10, h11)),
        ]:
            q1 = self.create_qubits_in_basis("Q", ketstring)[0]
            self.assertTrue(np.allclose(q1.qstate.dm, ket2dm(ket)))

    @disable_warn_deprecated
    def test_CNOT_operation(self):
        """Test correct CNOT operation."""
        for input_ketstring, output_ket, control_index, target_index in [
            ("0000", np.kron(s00, s00), 0, 1),
            ("0100", np.kron(s01, s00), 0, 1),
            ("1000", np.kron(s11, s00), 0, 1),
            ("1100", np.kron(s10, s00), 0, 1),
            ("0000", np.kron(s00, s00), 3, 2),
            ("0001", np.kron(s00, s11), 3, 2),
            ("0010", np.kron(s00, s10), 3, 2),
            ("0011", np.kron(s00, s01), 3, 2),
            ("0000", np.kron(s00, s00), 0, 3),
            ("0001", np.kron(s00, s01), 0, 3),
            ("1000", np.kron(s10, s01), 0, 3),
            ("1001", np.kron(s10, s00), 0, 3),
            ("0000", np.kron(s00, s00), 3, 1),
            ("0001", np.kron(s01, s01), 3, 1),
            ("0100", np.kron(s01, s00), 3, 1),
            ("0101", np.kron(s00, s01), 3, 1),
        ]:
            qubits = self.create_qubits_in_basis("Q", input_ketstring)
            qs = qubits[0].qstate
            qs.operate_qubits([qubits[control_index], qubits[target_index]], CNOT)
            self.assertTrue(np.allclose(qs.dm, ket2dm(output_ket)))

    @disable_warn_deprecated
    def create_qubits_bell_state(self, system_name, bell_index=0):
        """Create qubits in the specified Bell state.

        Parameters
        ----------
        system_name : str
            Name of the qubits
        bell_index : {0, 1, 2, 3}, optional
            Index of the target Bell state:

            ========== =================================
            bell_index Bell state
            ========== =================================
                0      ``|b00> = (|00> + |11>)/sqrt(2)``
                1      ``|b01> = (|01> + |10>)/sqrt(2)``
                2      ``|b10> = (|00> - |11>)/sqrt(2)``
                3      ``|b11> = (|01> - |10>)/sqrt(2)``
            ========== =================================

        Returns
        -------
        list of :obj:`~netsquid.qubits.qubit.Qubit`
            Created Bell state qubits.

        Raises
        ------
        IndexError
            If an invalid `bell_index` is given.

        """
        q1, q2 = self.create_qubits(system_name, 2)
        qs = q1.qstate
        qs.operate_qubits([q1], H)
        qs.operate_qubits([q1, q2], CNOT)
        if bell_index % 2:
            # transform for |b01> or |b11>
            qs.operate_qubits([q2], X)
        if bell_index > 1:
            # transform for |b10> or |b11>
            qs.operate_qubits([q1], Z)
        return q1, q2

    def test_create_qubits_bell_state(self):
        """Test creation of qubits in Bell states"""
        for bell_index, bell_ket in [(0, b00), (1, b01), (2, b10), (3, b11)]:
            q1, q2 = self.create_qubits_bell_state("Q", bell_index=bell_index)
            self.assertTrue(np.allclose(q1.qstate.dm, ket2dm(bell_ket)))

    @disable_warn_deprecated
    def test_CZ_operation(self):
        """Test correct controlled Z operation."""
        q1, q2 = self.create_qubits("CZ", 2)
        qapi.operate(q1, H)
        qapi.operate(q2, H)
        qapi.operate([q1, q2], CZ)
        self.assertTrue(np.allclose(q1.qstate.dm, ket2dm((s00 + s01 + s10 - s11) / 2)))

        for bell_index, output_ket, control_index, target_index in [
            (0, b10, 0, 1),
            (1, b01, 0, 1),
            (2, b00, 0, 1),
            (3, b11, 0, 1),
        ]:
            qubits = self.create_qubits_bell_state("Q", bell_index=bell_index)
            qs = qubits[0].qstate
            qs.operate_qubits([qubits[control_index], qubits[target_index]], CZ)
            self.assertTrue(np.allclose(qs.dm, ket2dm(output_ket)))
        for input_ketstring, output_ket, control_index, target_index in [
            ("0-", np.kron(s0, h1), 0, 1),
            ("0+", np.kron(s0, h0), 0, 1),
            ("1-", np.kron(s1, h0), 0, 1),
            ("1+", np.kron(s1, h1), 0, 1),
            ("-0", np.kron(h1, s0), 1, 0),
            ("+0", np.kron(h0, s0), 1, 0),
            ("-1", np.kron(h0, s1), 1, 0),
            ("+1", np.kron(h1, s1), 1, 0),
        ]:
            qubits = self.create_qubits_in_basis("Q", input_ketstring)
            qs = qubits[0].qstate
            qs.operate_qubits([qubits[control_index], qubits[target_index]], CZ)
            self.assertTrue(np.allclose(qs.dm, ket2dm(output_ket)))

    @disable_warn_deprecated
    def test_swap_operation(self):
        """Test correct SWAP operation"""
        for bell_index, output_ket, control_index, target_index in [
            (0, b00, 0, 1),
            (1, b01, 0, 1),
            (2, b10, 0, 1),
            (3, b11, 0, 1),
        ]:
            qubits = self.create_qubits_bell_state("Q", bell_index=bell_index)
            qs = qubits[0].qstate
            qs.operate_qubits([qubits[control_index], qubits[target_index]], SWAP)
            self.assertTrue(np.allclose(qs.dm, ket2dm(output_ket)))
        b00_op = (I ^ I) * CNOT * (H ^ I)
        b01_op = (I ^ X) * CNOT * (H ^ I)
        b10_op = (Z ^ I) * CNOT * (H ^ I)
        b11_op = (Z ^ X) * CNOT * (H ^ I)
        for num_qubits, input_operator, output_ket, control_index, target_index in [
            (2, b00_op, b00, 0, 1),
            (2, b01_op, b01, 0, 1),
            (2, b10_op, b10, 0, 1),
            (2, b11_op, b11, 0, 1),
            (2, I ^ H, np.kron(h0, s0), 0, 1),
            (2, I ^ H * X, np.kron(h1, s0), 0, 1),
            (2, X ^ H, np.kron(h0, s1), 0, 1),
            (2, X ^ H * X, np.kron(h1, s1), 0, 1),
            (2, H ^ I, np.kron(s0, h0), 1, 0),
            (2, H ^ X, np.kron(s1, h0), 1, 0),
            (2, H * X ^ I, np.kron(s0, h1), 1, 0),
            (2, H * X ^ X, np.kron(s1, h1), 1, 0),
            (3, I ^ b00_op, np.kron(b00, s0), 0, 2),
            (3, X ^ b00_op, np.kron(b00, s1), 0, 2),
            (3, H ^ b00_op, np.kron(b00, h0), 0, 2),
            (3, (H * X) ^ b00_op, np.kron(b00, h1), 0, 2),
            (3, I ^ b01_op, np.kron(b01, s0), 0, 2),
            (3, X ^ b01_op, np.kron(b01, s1), 0, 2),
            (3, H ^ b01_op, np.kron(b01, h0), 0, 2),
            (3, (H * X) ^ b01_op, np.kron(b01, h1), 0, 2),
            (3, I ^ b10_op, np.kron(b10, s0), 0, 2),
            (3, X ^ b10_op, np.kron(b10, s1), 0, 2),
            (3, H ^ b10_op, np.kron(b10, h0), 0, 2),
            (3, (H * X) ^ b10_op, np.kron(b10, h1), 0, 2),
            (3, I ^ b11_op, np.kron(b11, s0), 0, 2),
            (3, X ^ b11_op, np.kron(b11, s1), 0, 2),
            (3, H ^ b11_op, np.kron(b11, h0), 0, 2),
            (3, (H * X) ^ b11_op, np.kron(b11, h1), 0, 2),
        ]:
            qubits = self.create_qubits("Q", num_qubits)
            qs = qubits[0].qstate
            qs.operate_qubits(qubits, input_operator)
            qs.operate_qubits([qubits[control_index], qubits[target_index]], SWAP)
            self.assertTrue(np.allclose(qs.dm, ket2dm(output_ket)))

    @disable_warn_deprecated
    def test_combine_qstates(self):
        """Test combining of quantum states"""
        a1, a2 = self.create_qubits_bell_state("A", bell_index=1)
        b1, b2 = self.create_qubits_bell_state("B", bell_index=0)
        qs1 = a1.qstate
        qs2 = b1.qstate
        a1.qstate.combine_qstate(b1.qstate)
        self.assertEqual(qs1.num_qubits, 4)
        self.assertEqual(len(qs1.qubits), 4)
        self.assertEqual(len(qs2.qubits), 0)
        self.assertEqual(len({a1._index, a2._index, b1._index, b2._index}), 4)
        self.assertTrue(a1.qstate.compare(b2.qstate))
        self.assertTrue(a1.qstate == b2.qstate)
        a1.qstate.combine_qstate(b1.qstate)  # try combining again
        self.assertTrue(a1.qstate == b2.qstate)
        c1, c2 = self.create_qubits_bell_state("C", bell_index=3)
        # with self.assertRaises(ValueError):
        #    c1.qstate.combine_qstate(c2.qstate)  # can't combine ourself
        d1, _ = self.create_qubits_in_basis("C", "00")
        with self.assertRaises(RuntimeError):
            c1.qstate.combine_qstate(d1.qstate)  # qubits can't have same name
        # regression test for append right
        # e1, = self.create_qubits_in_basis("Z", "0")
        # e2, = self.create_qubits_in_basis("H", "+")
        # e_ref = self.create_qubits_in_basis("ZH", "0+")
        # e1.qstate.combine_qstate(e2.qstate)
        # self.assertTrue(e1.qstate == e2.qstate)
        # for name, pos in e1.qstate.indices.items():
        #    self.assertEqual(name, e1.qstate.qubits[pos].name)
        # self.assertEqual(["Z0", "H0"], [qubit.name for qubit in e1.qstate.qubits])
        # self.assertTrue(np.allclose(e1.qstate.dm, e_ref[0].qstate.dm))
        # self.assertEqual([e1, e2], e1.qstate.qubits)
        # self.assertEqual({"Z0": 0, "H0": 1}, e1.qstate.indices)
        # self.assertTrue(np.allclose(qapi.reduced_dm([e1, e2]), qapi.reduced_dm(e_ref)))
        # regression test for append left
        # e3, = self.create_qubits_in_basis("H", "+")
        # e4, = self.create_qubits_in_basis("Z", "0")
        # e_ref = self.create_qubits_in_basis("ZH", "+0")
        # e3.qstate.combine_qstate(e4.qstate)
        # self.assertTrue(e3.qstate == e4.qstate)
        # for name, pos in e3.qstate.indices.items():
        #    self.assertEqual(name, e3.qstate.qubits[pos].name)
        # self.assertEqual(["H0", "Z0"], [qubit.name for qubit in e3.qstate.qubits])
        # self.assertTrue(np.allclose(e3.qstate.dm, e_ref[0].qstate.dm))
        # self.assertEqual([e3, e4], e3.qstate.qubits)
        # self.assertEqual({"Z0": 0, "H0": 1}, e1.qstate.indices)
        # self.assertTrue(np.allclose(qapi.reduced_dm([e3, e4]), qapi.reduced_dm(e_ref)))

    @patch('netsquid.qubits.qstate.logger.warning')
    @disable_warn_deprecated
    def test_reuse_qubits_for_new_qstate(self, mock_warning):
        """Test re-use of qubits for a new QState."""
        # Create qubits in shared state
        a1, a2 = self.create_qubits_in_basis("A", "11")
        a1.qstate.combine_qstate(a2.qstate)  # Ensure combined
        self.assertEqual(a1.qstate, a2.qstate)
        self.assertTrue(np.allclose(a1.qstate.dm, ket2dm(s11)))
        b1, = self.create_qubits_in_basis("B", "+")
        self.assertTrue(np.allclose(b1.qstate.dm, ket2dm(h0)))
        b1qs = b1.qstate
        c1 = Qubit("c1")
        self.assertEqual(c1.qstate, None)
        # Create new qstate for (a1, b1, c1)
        self.create_qstate([a1, b1, c1])
        # Check new state
        # self.assertEqual(mock_warning.call_count, 1)
        self.assertEqual(a1.qstate, b1.qstate)
        self.assertEqual(a1.qstate, c1.qstate)
        self.assertEqual(a1.qstate.num_qubits, 3)
        ket = np.kron(s00, s0)
        self.assertTrue(np.allclose(a1.qstate.dm, ket2dm(ket)))
        # Check old states
        self.assertNotEqual(a1.qstate, a2.qstate)
        self.assertEqual(a2.qstate.num_qubits, 1)
        self.assertTrue(np.allclose(a2.qstate.dm, ket2dm(s1)))
        self.assertNotEqual(b1.qstate, b1qs)
        # self.assertEqual(b1qs.num_qubits, 0)
        # self.assertTrue(np.allclose(b1qs.dm, ket2dm(h0)))

    @disable_warn_deprecated
    def test_measure_qubit(self):
        """Test projective measurement of a qubit"""
        # Measure single qubit
        q1, = self.create_qubits("Q", 1)
        qs = q1.qstate
        m, p = qs.measure_qubit(q1, observable=Z)
        self.assertEqual(m, 0)
        self.assertAlmostEqual(p, 1.)
        self.assertTrue(np.allclose(qs.dm, ket2dm(s0)))
        m, p = qs.measure_qubit(q1, observable=Y)
        self.assertAlmostEqual(p, 0.5)
        subket = y0 if m == 0 else y1
        self.assertTrue(np.allclose(qs.dm, ket2dm(subket)))
        # Measure qubit in entangled state
        q1, q2 = self.create_qubits_bell_state("Q", bell_index=1)
        qs = q1.qstate
        m, p = qs.measure_qubit(q1, observable=Z)
        self.assertAlmostEqual(p, 0.5)
        subket = s01 if m == 0 else s10
        self.assertTrue(np.allclose(qs.dm, ket2dm(subket)))
        # repeat measurement:
        m2, p2 = qs.measure_qubit(q1, observable=Z)
        self.assertEqual(m, m2)
        self.assertAlmostEqual(p2, 1.)
        self.assertTrue(np.allclose(qs.dm, ket2dm(subket)))
        __, p3 = qs.measure_qubit(q2, observable=X)
        self.assertAlmostEqual(p3, 0.5)

    @disable_warn_deprecated
    def test_measure_drop_qubit(self):
        """Test dropping qubits from a quantum state when measuring"""
        q1, q2 = self.create_qubits_bell_state("Q", bell_index=0)
        qs = q1.qstate
        # drop first qubit with Y observable measurement
        # note b00 = (|0_Y 1_Y> + |1_Y 0_Y>)/sqrt(2)
        m, p = qs.measure_qubit(q1, observable=Y, drop_qubit=True)
        self.assertAlmostEqual(p, 0.5)
        self.assertEqual(qs.num_qubits, 1)
        self.assertTrue(q2.qstate == qs)
        self.assertEqual(q2.qstate, qs)
        self.assertEqual(q2._index, 0)
        self.assertEqual(qs.qubits[0].name, "Q1")
        self.assertNotIn(q1, qs.qubits)
        q2ket = y1 if m == 0 else y0
        self.assertTrue(np.allclose(qs.dm, ket2dm(q2ket)))
        # Check q1 is assigned a new QState
        self.assertTrue(q1.qstate != qs)
        q1ket = y0 if m == 0 else y1
        self.assertTrue(np.allclose(q1.qstate.dm, ket2dm(q1ket)))
        # try to drop last qubit with X observable measurement
        # Last qubit does not need to be "dropped" from state
        m, p = qs.measure_qubit(q2, observable=X, drop_qubit=True)
        self.assertAlmostEqual(p, 0.5)
        self.assertEqual(q2.qstate, qs)
        self.assertIs(q2.qstate, qs)
        self.assertEqual(qs.num_qubits, 1)
        q2ket = h0 if m == 0 else h1
        self.assertTrue(np.allclose(qs.dm, ket2dm(q2ket)))
        # Repeat, but now don't assign a new qstate
        q1, q2 = self.create_qubits_bell_state("Q", bell_index=0)
        qs = q1.qstate
        m, p = qs.measure_qubit(q1, drop_qubit=True, new_qstate=False)
        self.assertEqual(q2.qstate, qs)
        q2ket = s0 if m == 0 else s1
        self.assertTrue(np.allclose(qs.dm, ket2dm(q2ket)))
        self.assertEqual(q1.qstate, None)

    @disable_warn_deprecated
    def test_drop_qubit(self):
        """Test dropping qubits from a quantum state"""
        q1, q2, q3, q4 = self.create_qubits_in_basis("Q", "1-+0")
        qs = q1.qstate
        qs.drop_qubit(q2)
        self.assertEqual(qs.num_qubits, 3)
        self.assertEqual(q2.qstate, None)
        self.assertNotEqual(q1.qstate, None)
        self.assertEqual(q1.qstate, qs)
        self.assertEqual(q3.qstate, qs)
        self.assertEqual(q4.qstate, qs)
        qs.drop_qubit(q3)
        self.assertEqual(q3.qstate, None)
        self.assertEqual(qs.num_qubits, 2)
        self.assertTrue(np.allclose(qs.dm, ket2dm(s10)))
        q1, = self.create_qubits_in_basis("Q", "1")
        qs = q1.qstate
        qs.drop_qubit(q1)
        self.assertEqual(q1.qstate, None)

    @disable_warn_deprecated
    def test_stoch_operate(self):
        """Test stochastic operations"""
        q1, = self.create_qubits("Q", 1)
        qs = q1.qstate
        with self.assertRaises(ValueError):
            qs.stoch_operate_qubits([q1], [X, Y], p_weights=[1, 1])
        with self.assertRaises(ValueError):
            qs.stoch_operate_qubits([q1], [X, Y], p_weights=[1, 1, 1])
        qs.stoch_operate_qubits([q1], [X], p_weights=(1,))
        self.assertTrue(np.allclose(q1.qstate.dm, ket2dm(s1)))
        qs.stoch_operate_qubits([q1], [I, H, I, I, H, I], p_weights=[0, 0.5, 0, 0, 0.5, 0])
        self.assertTrue(np.allclose(q1.qstate.dm, ket2dm(h1)))

    @disable_warn_deprecated
    def test_fidelity(self):
        """Test fidelity of quantum state"""
        q1, q2 = self.create_qubits_bell_state("Q", bell_index=0)
        self.assertAlmostEqual(q1.qstate.fidelity(b00), 1)
        self.assertAlmostEqual(q1.qstate.fidelity(s00), 1 / np.sqrt(2))
        self.assertAlmostEqual(q1.qstate.fidelity(s00, squared=True), 0.5)
        self.assertAlmostEqual(q1.qstate.fidelity(b11), 0)
        # Test indexing a qubit works correctly
        q1, q2, q3, q4, q5, q6 = self.create_qubits_in_basis('Q', '+0+1--')
        qapi.operate([q1], S)
        qapi.operate([q6], S)
        self.assertAlmostEqual(q1.qstate.fidelity(y0, [q1]), 1)
        self.assertAlmostEqual(q1.qstate.fidelity(s0, [q2]), 1)
        self.assertAlmostEqual(q1.qstate.fidelity(h0, [q3]), 1)
        self.assertAlmostEqual(q1.qstate.fidelity(s1, [q4]), 1)
        self.assertAlmostEqual(q1.qstate.fidelity(h1, [q5]), 1)
        self.assertAlmostEqual(q1.qstate.fidelity(y1, [q6]), 1)

    @disable_warn_deprecated
    def test_rotation_operators(self):
        """Test Clifford rotation operations"""
        # only test pi/2 rotations (Clifford gates)
        theta = np.pi / 2.
        # Test bilateral rotations using 1-qubit operators
        Rx = np.cos(theta / 2) * I - (1j * np.sin(theta / 2)) * X
        Ry = np.cos(theta / 2) * I - (1j * np.sin(theta / 2)) * Y
        Rz = np.cos(theta / 2) * I - (1j * np.sin(theta / 2)) * Z
        Rx.clifford = cliffords.CLIFF_KY
        Ry.clifford = cliffords.CLIFF_HZ
        Rz.clifford = cliffords.CLIFF_S
        q1, q2 = self.create_qubits_in_basis("Q", "10")
        qs = q1.qstate
        qs.operate_qubits([q1], Rx)
        qs.operate_qubits([q2], Rx)
        psi = np.kron(y0, y1)
        self.assertTrue(np.allclose(q1.qstate.dm, ket2dm(psi)))
        qs.operate_qubits([q1], Ry * Rx)
        qs.operate_qubits([q2], Rz * Rx)
        psi = np.kron(h0, s1)
        self.assertTrue(np.allclose(q1.qstate.dm, ket2dm(psi)))
        qs.operate_qubits([q1], Rz)
        qs.operate_qubits([q2], Ry)
        psi = np.kron(y0, h1)
        self.assertTrue(np.allclose(q1.qstate.dm, ket2dm(psi)))
        # Test bilateral rotation as a 2-qubit operator
        q3, q4 = self.create_qubits_in_basis("Q", "10")
        qs = q3.qstate
        BXX = Rx ^ Rx
        qs.operate_qubits([q3, q4], BXX)
        psi = np.kron(y0, y1)
        self.assertTrue(np.allclose(q3.qstate.dm, ket2dm(psi)))
        BYZ = Ry ^ Rz
        qs.operate_qubits([q3, q4], BXX)
        qs.operate_qubits([q3, q4], BYZ)
        psi = np.kron(h0, s1)
        self.assertTrue(np.allclose(q3.qstate.dm, ket2dm(psi)))
        qs.operate_qubits([q4, q3], BYZ)
        psi = np.kron(y0, h1)
        self.assertTrue(np.allclose(q3.qstate.dm, ket2dm(psi)))

    @disable_warn_deprecated
    def test_operate_multiqubits(self):
        """Test operations on arbitrary number of qubits."""
        qubits = self.create_qubits("Q", 6)
        for qubit2 in qubits[1:]:
            qubits[0].combine(qubit2)
        q2 = qubits[1]
        qapi.operate(q2, H)
        q4 = qubits[3]
        q5 = qubits[4]
        # Apply 3-qubit operator on distant and unordered qubits
        q2.qstate.operate_qubits([q5, q2, q4], X ^ Z ^ X)
        ket = np.kron(np.kron(s0, h1), np.kron(s01, s10))
        self.assertTrue(np.allclose(qubits[0].qstate.dm, ket2dm(ket)))

    @disable_warn_deprecated
    def test_reduced_dm(self):
        """Test finding of reduced density matrix."""
        qubits = self.create_qubits_in_basis("Q", "0+-1")
        for q in qubits[1:]:
            qubits[0].combine(q)
        qs = qubits[0].qstate
        # Test null case
        dm = qs.reduced_dm(qubits)
        self.assertTrue(np.allclose(qs.dm, dm))
        # Test pure re-ordering
        dm = qs.reduced_dm([*qubits[1:3], qubits[0], qubits[3]])
        self.assertTrue(np.allclose(dm, (
            np.kron(ket2dm(h0), np.kron(ket2dm(h1), np.kron(ket2dm(s0), ket2dm(s1)))))))
        # Test pure reduction
        dm = qs.reduced_dm([qubits[0], qubits[3]])
        self.assertTrue(np.allclose(dm, np.kron(ket2dm(s0), ket2dm(s1))))
        # Test re-ordered reduction
        dm = qs.reduced_dm([qubits[3], qubits[1]])
        self.assertTrue(np.allclose(dm, np.kron(ket2dm(s1), ket2dm(h0))))
        # Test single qubits
        dm = qs.reduced_dm(qubits[0:1])
        self.assertTrue(np.allclose(dm, ket2dm(s0)))
        dm = qs.reduced_dm(qubits[2:3])
        self.assertTrue(np.allclose(dm, ket2dm(h1)))
        # Test entangled qubits
        q1, q2 = self.create_qubits_bell_state("Q", bell_index=0)
        qs = q1.qstate
        dm1 = qs.reduced_dm([q1])
        dm2 = qs.reduced_dm([q2])
        self.assertTrue(np.allclose(dm1, 0.5 * np.eye(2)))
        self.assertTrue(np.allclose(dm2, 0.5 * np.eye(2)))
        self.assertTrue(np.allclose(qs.dm, ket2dm(b00)))

    @disable_warn_deprecated
    def test_CS_operation(self):
        """Test correct controlled PHASE operation."""
        for bell_index, output_ket, control_index, target_index in [
            (0, (s00 + 1j * s11) / np.sqrt(2), 0, 1),
            (1, b01, 0, 1),
            (2, (s00 - 1j * s11) / np.sqrt(2), 0, 1),
            (3, b11, 0, 1),
        ]:
            qubits = self.create_qubits_bell_state("Q", bell_index=bell_index)
            qs = qubits[0].qstate
            qs.operate_qubits([qubits[control_index], qubits[target_index]], CS)
            self.assertTrue(np.allclose(qs.dm, ket2dm(output_ket)))

    @disable_warn_deprecated
    def test_gmeasure_qubits(self):
        """Test the general measurement using a beamsplitter operator set"""
        n0 = Operator("n0", np.array([[0, 0, 0, 0], [0, 0.5, 0.5, 0],
                                      [0, 0.5, 0.5, 0], [0, 0, 0, 1 / np.sqrt(2)]]))
        n1 = Operator("n0", np.array([[0, 0, 0, 0], [0, 0.5, -0.5, 0],
                                      [0, -0.5, 0.5, 0], [0, 0, 0, 1 / np.sqrt(2)]]))
        n2 = Operator("n2", np.array([[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]))
        rng = Mock(np.random.RandomState)
        rand_nums = (0, 0.3, 1)  # Mocked random results
        # expected results per mocked random result:
        exp_outcomes = (0, 1, 2)
        exp_states = (b01, b11, s00)
        exp_probs = (0.25, 0.25, 0.5)
        for r, exp_o, exp_s, exp_p in zip(rand_nums, exp_outcomes, exp_states, exp_probs):
            q1, q2 = self.create_qubits("Q", 2)
            q1.qstate.operate_qubits([q1], H)
            rng.random_sample = MagicMock(return_value=r)
            outcome, p = q1.qstate.gmeasure_qubits([q1, q2], [n0, n1, n2], rng=rng)
            self.assertTrue(outcome == exp_o)
            self.assertTrue(np.allclose(q1.qstate.dm, ket2dm(exp_s)))
            self.assertAlmostEqual(p, exp_p)

    @disable_warn_deprecated
    def test_measure_gen_projective(self):
        """Test general measurement with projective operators"""
        h1, h2 = self.create_qubits_bell_state("A", bell_index=1)
        qs = h1.qstate
        P0, P1 = Z.projectors
        self.assertTrue(P0.is_projective)
        self.assertTrue(P1.is_projective)
        m_res, p = qs.gmeasure_qubits([h1], [P0, P1])
        self.assertAlmostEqual(p, 0.5)
        if m_res == 0:
            self.assertTrue(np.allclose(qs.dm, ket2dm(s01)))  # measured 0
        else:
            self.assertTrue(np.allclose(qs.dm, ket2dm(s10)))  # measured 1
        # repeat measurement:
        m_res2, p2 = qs.gmeasure_qubits([h1], [P0, P1])
        self.assertEqual(m_res, m_res2)
        self.assertEqual(p2, 1.)
        # drop measured qubit and measure other qubit
        qs.measure_qubit(h1, Z, drop_qubit=True)
        m_res3, p3 = qs.gmeasure_qubits([h2], [P0, P1])
        self.assertTrue(m_res3 != m_res)
        if m_res3 == 0:
            self.assertTrue(np.allclose(qs.dm, ket2dm(s0)))  # measured 0
        else:
            self.assertTrue(np.allclose(qs.dm, ket2dm(s1)))  # measured 1

    @disable_warn_deprecated
    def test_measure_gen_filter(self):
        """Test a general filter measurement"""
        q1, q2 = self.create_qubits_in_basis("A", "10")
        qs = q1.qstate
        epsilon = 0.3
        M0 = Operator("M0", np.sqrt(epsilon) * outerprod(s0) + outerprod(s1))
        M1 = Operator("M1", np.sqrt(1 - epsilon) * outerprod(s0))
        self.assertFalse(M0.is_projective)
        self.assertFalse(M1.is_projective)
        self.assertTrue(np.allclose(dagger(M0.arr) @ M0.arr + dagger(M1.arr) @ M1.arr, np.eye(2)))
        m, p = qs.gmeasure_qubits([q1], [M0, M1])
        self.assertAlmostEqual(p, 1)
        self.assertEqual(m, 0)
