# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_kettools.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for kettools module.

"""
import unittest
from unittest.mock import Mock, MagicMock
import numpy as np
from netsquid.qubits import qformalism as qform
from netsquid.util import simtools
from netsquid.qubits import ketutil as ku, kettools, qubitapi
from netsquid.qubits import ketstates as ks
from netsquid.qubits.operators import Operator, I, X, Y, Z, H, S, CNOT
from netsquid.qubits.ketutil import dagger
from netsquid.qubits.qubit import Qubit
from netsquid.qubits.tests.test_qrepr import TestQRepr
from netsquid.qubits.kettools import KetRepr
from netsquid.qubits.tests.test_qstate import TestDepQState
from netsquid.util.simlog import disable_warn_deprecated


class TestKetRepr(TestQRepr, unittest.TestCase):

    def create_qrepr(self, **kwargs) -> KetRepr:
        return KetRepr(**kwargs)

    def test_assign_qrepr(self):
        repr1 = self.create_qrepr(ket=[1, 0])
        self.assertEqual(1, repr1.num_qubits)
        self.assertTrue(repr1.is_valid)
        repr1 = self.create_qrepr(ket=[1, 0, 0, 0])
        self.assertEqual(2, repr1.num_qubits)
        self.assertTrue(repr1.is_valid)

    def test_init(self):
        for i in range(1, 4):
            ket = self.create_qrepr(num_qubits=i)
            self.assertEqual(i, ket.num_qubits)
        ket = KetRepr([1, 0])
        self.assertEqual(1, ket.num_qubits)
        ket = KetRepr([1, 0, 0, 0])
        self.assertEqual(2, ket.num_qubits)
        with self.assertRaises(TypeError):
            KetRepr()

    def test_measure(self):
        simtools.set_random_state(seed=42)
        ket = self.create_qrepr(num_qubits=2)
        ket, m, p = ket.measure(0, Z)
        self.assertEqual(0, m)
        self.assertEqual(1.0, p)
        ket, m, p = ket.measure(1, X)
        self.assertEqual(1, m)
        self.assertAlmostEqual(0.5, p, places=9)

    def test_large_states(self):
        """Test ket formalism can handle large ket states."""
        # Create large qubit quantum state
        # NOTE a dense ket vector should still fit into RAM
        n = 15  # ~ requires 4 mb of RAM per ket state
        ketrepr = self.create_qrepr(num_qubits=n)
        self.assertEqual(ketrepr.num_qubits, n)
        self.assertEqual(ketrepr.ket.shape, (2 ** n, 1))
        # Test operate
        for i in range(n):
            ketrepr.operate([i], H, modify=True)
        self.assertTrue(np.allclose(ketrepr.ket, np.ones((2 ** n, 1)) / np.sqrt(2) ** n))
        ketrepr = ketrepr.operate([0], X * H)
        ketrepr = ketrepr.operate([n // 2], H)
        ketrepr = ketrepr.operate([0, n // 2], CNOT)
        ketrepr = ketrepr.operate([1], S)
        # Test measure with drop
        ketrepr, m1, __ = ketrepr.measure(0)
        self.assertEqual(m1, 1)
        ketrepr, m2, __ = ketrepr.measure(n // 2)
        self.assertEqual(m2, 1)
        ketrepr, m1, __ = ketrepr.measure(1, observable=Y)
        self.assertEqual(m1, 0)

    def test_reduced_ket(self):
        """Test the reduce method works as expected for some states
        """
        qform.set_qstate_formalism(qform.QFormalism.KET)
        ketrepr = self.create_qrepr(num_qubits=4)
        for i in range(4):
            ketstate = ketrepr.reduced_dm([i])
            self.assertTrue(ketstate.shape == (2, 2))
            self.assertTrue(np.allclose(ketstate, ku.ket2dm(ks.s0)))
        ketrepr = ketrepr.operate([0], operator=X)
        # Test different order of input
        ketstate = ketrepr.reduced_dm([0, 1, 3])
        self.assertTrue(ketstate.shape == (8, 8))
        self.assertTrue(np.allclose(ketstate, ku.ket2dm(np.kron(ks.s1, np.kron(ks.s0, ks.s0)))))
        ketstate = ketrepr.reduced_dm([1, 0, 2])
        self.assertTrue(ketstate.shape == (8, 8))
        self.assertTrue(np.allclose(ketstate, ku.ket2dm(np.kron(ks.s0, np.kron(ks.s1, ks.s0)))))
        # Test negative values
        ketrepr = KetRepr(ket=1 / np.sqrt(2) * ks.s00 - 1 / np.sqrt(2) * ks.s01)
        ketstate = ketrepr.reduced_dm([0])
        self.assertTrue(np.allclose(ketstate, ku.ket2dm(ks.s0)))
        ketstate = ketrepr.reduced_dm([1])
        self.assertTrue(np.allclose(ketstate, ku.ket2dm(1 / np.sqrt(2) * ks.s0 - 1 / np.sqrt(2) * ks.s1)))
        # Test complex values
        ketrepr = KetRepr(1 / np.sqrt(2) * ks.s00 + 1j / np.sqrt(2) * ks.s10)
        ketstate = ketrepr.reduced_dm([1])
        self.assertTrue(np.allclose(ketstate, ku.ket2dm(ks.s0)))
        ketstate = ketrepr.reduced_dm([0])
        self.assertTrue(np.allclose(ketstate, ku.ket2dm(1 / np.sqrt(2) * ks.s0 + 1j / np.sqrt(2) * ks.s1)))

    def test_multi_operate(self):
        """Test multi quantum operations with arbitrary weights"""
        N = 1000
        qrepr = KetRepr(num_qubits=1)
        qrepr = qrepr.multi_operate([0], operators=list(Z.projectors))
        self.assertTrue(np.allclose(qrepr.reduced_dm(), np.array([[1, 0], [0, 0]])))
        # Test a measurement with Y observable
        dm = np.zeros((2, 2), dtype=complex)
        for __ in range(N):
            qrepr = KetRepr(num_qubits=1)
            qrepr.multi_operate([0], operators=list(Y.projectors), weights=(1, 1), modify=True)
            dm += qrepr.reduced_dm()
        self.assertTrue(np.allclose(dm / N, np.eye(2) / 2, atol=5e-2))
        # Test complete depolarization of single arbitary qubit
        # (also a valid stochastic operation)
        dm = np.zeros((2, 2), dtype=complex)
        ket = (0.4j * ks.s0 - (0.8 + 0.2j) * ks.s1)
        ket /= np.sqrt(dagger(ket) @ ket)
        for __ in range(N):
            qrepr = KetRepr(ket=ket)
            qrepr.multi_operate([0], [I, X, Y, Z], weights=(1 / 4, 1 / 4, 1 / 4, 1 / 4), modify=True)
            dm += qrepr.reduced_dm()
        self.assertTrue(np.allclose(dm / N, np.eye(2) / 2, atol=5e-2))
        # Test amplitude damping with articifial weights
        dm = np.zeros((2, 2), dtype=complex)
        gamma = 0.3
        for __ in range(N):
            qrepr = KetRepr(ket=ks.s1)
            E0 = Operator("E0", [[1, 0], [0, np.sqrt(1 - gamma)]]) * 0.5
            E1 = Operator("E1", [[0, np.sqrt(gamma)], [0, 0]]) * (1 / 3)
            qrepr.multi_operate([0], [E0, E1], weights=(4, 9), modify=True)
            dm += qrepr.reduced_dm()
        self.assertTrue(np.allclose(dm / N, np.array([[gamma, 0], [0, 1 - gamma]]), atol=5e-2))

    def test_predictive_measure_qubit(self):
        """Predictive test for projective measurement of a qubit"""
        # Mock up random number generator to give predictable results
        rng = Mock(np.random.RandomState)
        for obs in [X, Y]:
            ketrepr = KetRepr(num_qubits=2)
            rng.random_sample = MagicMock(return_value=0)
            ketrepr, m, __ = ketrepr.measure(0, observable=obs, rng=rng)
            self.assertEqual(m, 0)
            rng.random_sample = MagicMock(return_value=1)
            ketrepr, m, __ = ketrepr.measure(1, observable=obs, rng=rng)
            self.assertEqual(m, 1)
            e0, e1 = obs.eigenkets
            self.assertTrue(np.allclose(ketrepr.ket, np.kron(e0, e1)))

    def test_arithmetic(self):
        repr1 = self.create_qrepr(num_qubits=1)
        repr2 = self.create_qrepr(num_qubits=1)
        self.assertEqual(repr1, repr2)
        repr3 = (repr1 + repr2) / 2
        self.assertEqual(repr3, repr1)
        repr4 = repr2 * (1/2) + repr1 * (1/2)
        self.assertEqual(repr4, repr1)
        repr5 = 2 * repr2 - repr1
        self.assertEqual(repr5, repr1)
        ket = np.array([[1], [0]])
        self.assertEqual(2*ket - repr1, repr1)
        self.assertEqual(ket/2 + repr1/2, repr1)
        with self.assertRaises(TypeError):
            repr1 * 'a'
        with self.assertRaises(TypeError):
            repr1 + 'a'
        with self.assertRaises(TypeError):
            repr1 - 'a'


class TestKetState(TestDepQState, unittest.TestCase):
    """Unit tests for the deprecated KetState class.

    The TestQState baseclass defines extra test methods.

    """

    def _assertEqualKet(self, ket1, ket2):
        self.assertTrue(np.allclose(ket1, ket2))

    @disable_warn_deprecated
    def create_qstate(self, qubits, ket=None):
        kettools.KetState(qubits, ket=ket)

    @property
    def is_stabilizer(self):
        return False

    def test_KetState_init(self):
        """Test KetState initialization"""
        # check qubit creation
        h1 = Qubit("H1")
        self.assertEqual(h1.name, "H1")
        self.assertEqual(h1.qstate, None)
        with self.assertRaises(RuntimeError):
            h1._index
        # check KetState creation
        with self.assertRaises(ValueError):
            kettools.KetState([h1, h1], ks.b01)
        with self.assertRaises(ValueError):
            kettools.KetState([h1], ks.b01)
        h2 = Qubit("H2")
        qs = kettools.KetState([h1, h2], ks.b01)
        self._assertEqualKet(qs.ket, ks.b01)
        h1.qstate.compare(qs)
        h2.qstate.compare(qs)
        self.assertEqual(h1._index, 0)
        self.assertEqual(h2._index, 1)
        self.assertEqual(qs.num_qubits, 2)
        with self.assertRaises(ValueError):
            qs.ket = ks.s0

    def test_predictive_measure_qubit(self):
        """Predictive test for projective measurement of a qubit"""
        # Mock up random number generator to give predictable results
        rng = Mock(np.random.RandomState)
        for obs in [X, Y]:
            q1, q2 = self.create_qubits("Q", 2)
            rng.random_sample = MagicMock(return_value=0)
            m, __ = q1.qstate.measure_qubit(q1, observable=obs, rng=rng)
            self.assertEqual(m, 0)
            rng.random_sample = MagicMock(return_value=1)
            m, __ = q2.qstate.measure_qubit(q2, observable=obs, rng=rng)
            self.assertEqual(m, 1)
            e0, e1 = obs.eigenkets
            self.assertTrue(np.allclose(q2.qstate.ket, np.kron(e0, e1)))

    def test_multi_operate(self):
        """Test multi quantum operations with arbitrary weights"""
        N = 1000
        # Test a measurement with Z observable
        q1, = self.create_qubits("Q", 1)
        qs = q1.qstate
        qs.multi_operate_qubits([q1], operators=list(Z.projectors))
        self.assertTrue(np.allclose(qs.dm, np.array([[1, 0], [0, 0]])))
        # Test a measurement with Y observable
        dm = np.zeros((2, 2), dtype=complex)
        for __ in range(N):
            q1, = self.create_qubits("Q", 1)
            qs = q1.qstate
            qs.multi_operate_qubits([q1], operators=list(Y.projectors), weights=(1, 1))
            dm += qs.dm
        self.assertTrue(np.allclose(dm / N, np.eye(2) / 2, atol=5e-2))
        # Test complete depolarization of single arbitary qubit
        # (also a valid stochastic operation)
        dm = np.zeros((2, 2), dtype=complex)
        ket = (0.4j * ks.s0 - (0.8 + 0.2j) * ks.s1)
        ket /= np.sqrt(dagger(ket) @ ket)
        for __ in range(N):
            q1, = self.create_qubits("Q", 1, ket=ket)
            qs = q1.qstate
            qs.multi_operate_qubits([q1], [I, X, Y, Z], weights=(1 / 4, 1 / 4, 1 / 4, 1 / 4))
            dm += qs.dm
        self.assertTrue(np.allclose(dm / N, np.eye(2) / 2, atol=5e-2))
        # Test amplitude damping with articifial weights
        dm = np.zeros((2, 2), dtype=complex)
        gamma = 0.3
        for __ in range(N):
            q1, = self.create_qubits("Q", 1, ket=ks.s1)
            qs = q1.qstate
            E0 = Operator("E0", [[1, 0], [0, np.sqrt(1 - gamma)]]) * 0.5
            E1 = Operator("E1", [[0, np.sqrt(gamma)], [0, 0]]) * (1 / 3)
            qs.multi_operate_qubits([q1], [E0, E1], weights=(4, 9))
            dm += qs.dm
        self.assertTrue(np.allclose(dm / N, np.array([[gamma, 0], [0, 1 - gamma]]), atol=5e-2))

    @disable_warn_deprecated
    def test_amplitude_dampen(self):
        """Test amplitude damping"""
        simtools.get_random_state().seed(seed=0)
        N = 200
        fidelity_sums = [0.] * 4
        for __ in range(N):
            gamma = 0.1
            # For p=1, starionary state is |0>
            q1, = self.create_qubits("Q", 1)
            q1.qstate.amplitude_dampen(q1, gamma=gamma, prob=1.)
            fidelity_sums[0] += q1.qstate.fidelity(ks.s0, squared=True)
            q1.qstate.operate_qubits([q1], X)  # -> |1>
            # For p=1, |1> should be dampened
            q1.qstate.amplitude_dampen(q1, gamma=gamma, prob=1.)
            fidelity_sums[1] += q1.qstate.fidelity(ks.s0, squared=True)
            # For p=0.5, stationary state is 0.5*(|0><0| + |1><1|)
            q1, = self.create_qubits("Q", 1)
            q1.qstate.stoch_operate_qubits([q1], [I, X])  # 0.5(|0><0| + |1><1|)
            q1.qstate.amplitude_dampen(q1, gamma=gamma, prob=0.5)
            fidelity_sums[2] += q1.qstate.fidelity(ks.s0, squared=True)
            # For p=0.5, |0> should dampen
            q1, = self.create_qubits("Q", 1)
            q1.qstate.amplitude_dampen(q1, gamma=gamma, prob=0.5)
            fidelity_sums[3] += q1.qstate.fidelity(ks.s0, squared=True)
        self.assertTrue(np.isclose(fidelity_sums[0] / N, 1., atol=0.05))
        self.assertTrue(np.isclose(fidelity_sums[1] / N, gamma, atol=0.05))
        self.assertTrue(np.isclose(fidelity_sums[2] / N, 0.5, atol=0.05))
        self.assertTrue(np.isclose(fidelity_sums[3] / N, (1 - 0.5 * gamma), atol=0.05))
        for g, p in [(0.5, -0.1), (0.5, 1.1), (-0.1, 0.5), (1.1, 0.5)]:
            q1, = self.create_qubits("Q", 1)
            with self.assertRaises(ValueError):
                q1.qstate.amplitude_dampen(q1, gamma=g, prob=p)

    @disable_warn_deprecated
    def test_reduced_ket(self):
        """Test the reduce method works as expected for some states
        """
        qform.set_qstate_formalism(qform.QFormalism.KET)
        qubits = self.create_qubits("Q", 4)
        qubitapi.combine_qubits(qubits)
        for i in range(4):
            ketstate = qubits[0].qstate.reduced_dm([qubits[i]])
            self.assertTrue(ketstate.shape == (2, 2))
            self.assertTrue(np.allclose(ketstate, ku.ket2dm(ks.s0)))
        qubitapi.operate([qubits[0]], operator=X)
        # Test different order of input
        ketstate = qubits[0].qstate.reduced_dm([qubits[0], qubits[1], qubits[2]])
        self.assertTrue(ketstate.shape == (8, 8))
        self.assertTrue(np.allclose(ketstate, ku.ket2dm(np.kron(ks.s1, np.kron(ks.s0, ks.s0)))))
        ketstate = qubits[0].qstate.reduced_dm([qubits[1], qubits[0], qubits[2]])
        self.assertTrue(ketstate.shape == (8, 8))
        self.assertTrue(np.allclose(ketstate, ku.ket2dm(np.kron(ks.s0, np.kron(ks.s1, ks.s0)))))
        # Test negative values
        qubits = self.create_qubits("M", 2)
        qubitapi.assign_qstate(qubits, 1 / np.sqrt(2) * ks.s00 - 1 / np.sqrt(2) * ks.s01)
        ketstate = qubits[0].qstate.reduced_dm([qubits[0]])
        self.assertTrue(np.allclose(ketstate, ku.ket2dm(ks.s0)))
        ketstate = qubits[0].qstate.reduced_dm([qubits[1]])
        self.assertTrue(np.allclose(ketstate, ku.ket2dm(1 / np.sqrt(2) * ks.s0 - 1 / np.sqrt(2) * ks.s1)))
        # Test complex values
        qubitapi.assign_qstate(qubits, 1 / np.sqrt(2) * ks.s00 + 1j / np.sqrt(2) * ks.s10)
        ketstate = qubits[0].qstate.reduced_dm([qubits[1]])
        self.assertTrue(np.allclose(ketstate, ku.ket2dm(ks.s0)))
        ketstate = qubits[0].qstate.reduced_dm([qubits[0]])
        self.assertTrue(np.allclose(ketstate, ku.ket2dm(1 / np.sqrt(2) * ks.s0 + 1j / np.sqrt(2) * ks.s1)))

    def test_large_states(self):
        """Test ket formalism can handle large ket states."""
        # Create large qubit quantum state
        # NOTE a dense ket vector should still fit into RAM
        n = 15  # ~ requires 4 mb of RAM per ket state
        qubits = self.create_qubits("Q", n)
        qstate = qubits[0].qstate
        self.assertEqual(qstate.num_qubits, n)
        self.assertEqual(qstate.ket.shape, (2 ** n, 1))
        # Test operate
        for i, qubit in enumerate(qubits):
            qstate.operate_qubits([qubit], H)
        self.assertTrue(np.allclose(qstate.ket, np.ones((2 ** n, 1)) / np.sqrt(2) ** n))
        qstate.operate_qubits([qubits[0]], X * H)
        qstate.operate_qubits([qubits[n // 2]], H)
        qstate.operate_qubits([qubits[0], qubits[n // 2]], CNOT)
        qstate.operate_qubits([qubits[1]], S)
        # Test measure with drop
        m1, __ = qstate.measure_qubit(qubits[0])
        self.assertEqual(m1, 1)
        m2, __ = qstate.measure_qubit(qubits[n // 2], drop_qubit=True)
        self.assertEqual(m2, 1)
        m1, __ = qstate.measure_qubit(qubits[1], observable=Y)
        self.assertEqual(m1, 0)


if __name__ == "__main__":
    unittest.main(verbosity=2)
