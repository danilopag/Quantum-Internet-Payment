# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_qformalism.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the qformalism module.

"""
import unittest
import numpy as np
from netsquid.qubits.gslcutil import stab2gslc
from scipy import sparse
from netsquid.util.simlog import disable_warn_deprecated
from netsquid.qubits.qstate import QState
from netsquid.qubits.qrepr import convert_to, register_conversion
from netsquid.qubits import qformalism as qform
from netsquid.qubits.qubit import Qubit
from netsquid.qubits.ketutil import ket2dm
from netsquid.qubits.ketstates import s00, s11, b00
from netsquid.qubits.stabtools import StabRepr, ket2stabilizer
from netsquid.qubits.kettools import KetRepr
from netsquid.qubits.dmtools import DenseDMRepr
from netsquid.qubits.state_sampler import StateSampler


class TestQFormalism(unittest.TestCase):
    """Unit tests for the qformalism module.

    """

    def setUp(self):
        ketrepr = KetRepr(s00)
        self.reprs = {}
        for formalism in qform.QFormalism:
            self.reprs[formalism] = convert_to(ketrepr, formalism)

    def test_set_qstate_formalism(self):
        """Test setting the quantum state formalism"""
        for formalism in qform.QFormalism:
            qform.set_qstate_formalism(formalism)
            self.assertEqual(qform.get_qstate_formalism(), formalism)
        with self.assertRaises(TypeError):
            qform.set_qstate_formalism("foo")

    def test_convert_qstate(self):
        """Test conversion of qubit's quantum state formalism."""
        qform.set_qstate_formalism(qform.QFormalism.STAB)
        q1 = Qubit("A")
        q2 = Qubit("B")
        QState([q1, q2], StabRepr([[1, 1, 0, 0], [0, 0, 1, 1]], [1, 1]))
        qform.convert_qstate(q1, formalism=qform.QFormalism.KET)
        self.assertEqual(type(q1.qstate.qrepr), qform.QFormalism.KET)
        self.assertEqual(type(q2.qstate.qrepr), qform.QFormalism.KET)
        self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), ket2dm(b00)))
        dm = DenseDMRepr((ket2dm(s00) + ket2dm(s11)) * 0.5)
        q1 = Qubit("A")
        q2 = Qubit("B")
        qstate = QState([q1, q2])
        for fcurr in qform.QFormalism:
            qform.set_qstate_formalism(fcurr)
            for fstart in qform.QFormalism:
                qstate.qrepr = qform.convert_qrepr(dm, fstart)
                self.assertEqual(type(q2.qstate.qrepr), fstart)
                qform.convert_qstate(q2)
                self.assertEqual(q1.qstate, q2.qstate)
                self.assertEqual(type(q2.qstate.qrepr), fcurr)
                if fcurr in qform.QFormalism.ensemble_formalisms and fstart in qform.QFormalism.ensemble_formalisms:
                    self.assertEqual(qstate.qrepr, qform.convert_qrepr(dm, formalism=fcurr))
                else:
                    dms00 = ket2dm(s00)
                    dms11 = ket2dm(s11)
                    self.assertTrue(np.allclose(qstate.qrepr.reduced_dm(), dms00) or
                                    np.allclose(qstate.qrepr.reduced_dm(), dms11))

    @disable_warn_deprecated
    def test_get_formalism_of_qstate(self):
        # Function is deprecated
        for formalism in qform.QFormalism:
            self.assertEqual(type(self.reprs[formalism]), formalism)
        with self.assertRaises(TypeError):
            qform.get_formalism_of_qstate([0, 0, 1])
        with self.assertRaises(TypeError):
            qform.get_formalism_of_qstate([0])
        with self.assertRaises(TypeError):
            qform.get_formalism_of_qstate(1)
        with self.assertRaises(TypeError):
            qform.get_formalism_of_qstate(True)

    @disable_warn_deprecated
    def test_convert_qsrepr(self):
        # Function is deprecated
        reprs = {}
        reprs[qform.QFormalism.KET] = s00
        reprs[qform.QFormalism.DM] = ket2dm(s00)
        reprs[qform.QFormalism.SPARSEDM] = sparse.csr_matrix(reprs[qform.QFormalism.DM])
        reprs[qform.QFormalism.STAB] = ket2stabilizer(reprs[qform.QFormalism.KET])
        reprs[qform.QFormalism.GSLC] = stab2gslc(reprs[qform.QFormalism.STAB])
        for form_a in qform.QFormalism:
            state_a = reprs[form_a]
            for form_b in qform.QFormalism:
                state_b = reprs[form_b]
                state = qform.convert_qsrepr(state_a, 2, form_b)
                self.assertEqual(qform.get_formalism_of_qstate(state), form_b)
                if isinstance(state, sparse.csr_matrix):
                    self.assertTrue(np.allclose(state_b.toarray(), state.toarray()))
                elif isinstance(state, np.ndarray):
                    self.assertTrue(np.allclose(state_b, state))
                else:
                    self.assertEqual(state_b, state)

    def test_new_formalism(self):
        class TestFormalism(KetRepr):
            def __deepcopy__(self, memodict={}):
                return TestFormalism(self.ket)

        register_conversion(KetRepr, TestFormalism, lambda x: TestFormalism(x.ket))
        qform.set_qstate_formalism(TestFormalism)
        self.assertIs(TestFormalism, qform.get_qstate_formalism())
        formalisms = qform.QFormalism
        with self.assertRaises(ValueError):
            formalisms['KET'] = TestFormalism
        with self.assertRaises(ValueError):
            formalisms['__iter__'] = TestFormalism
        with self.assertRaises(TypeError):
            formalisms['TEST'] = 5
        formalisms['TEST'] = TestFormalism
        self.assertTrue(hasattr(formalisms, 'TEST'))
        self.assertIs(getattr(formalisms, 'TEST'), TestFormalism)
        self.assertIs(formalisms.TEST, TestFormalism)
        statesampler = StateSampler([s00], formalism=qform.QFormalism.TEST)
        qrepr, prob, labels = statesampler.sample()
        self.assertIsInstance(qrepr, TestFormalism)
        del formalisms['TEST']
        self.assertFalse(hasattr(formalisms, 'TEST'))


if __name__ == "__main__":
    unittest.main(verbosity=2)
