# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_operators.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the operators module.

"""
import unittest
import numpy as np
from scipy import sparse
from netsquid.qubits.ketutil import dagger, ket2dm
from netsquid.qubits.ketstates import s0, s1, h0, h1, y0, y1
from netsquid.qubits.ketstates import s00, s01, s10
from netsquid.qubits.ketstates import b00, b01, b10, b11
from netsquid.qubits.ketstates import bell_states, BellIndex
from netsquid.qubits import operators as ops
from netsquid.qubits import opmath
from netsquid.qubits import sparseutil
from netsquid.qubits import qubitapi as qapi


class SparseOperator(ops.Operator):
    def __init__(self, matrix, description="", cacheable=True, can_convert=False):
        # Conversion from sparse to dense is generally not OK
        name = "?"
        if isinstance(matrix, ops.Operator):
            name = matrix.name
            matrix = matrix.csr
        elif isinstance(matrix, np.ndarray) or isinstance(matrix, list):
            matrix = sparse.csr_matrix(matrix)
        self.can_convert = can_convert
        super().__init__(name, matrix, description, cacheable)

    @property
    def arr(self):
        if self.can_convert:
            return super().arr
        else:
            assert False


class DenseOperator(ops.Operator):
    def __init__(self, matrix, description="", cacheable=True, can_convert=True):
        # Conversion to sparse from dense is generally OK
        name = "?"
        if isinstance(matrix, ops.Operator):
            name = matrix.name
            matrix = matrix.arr
        elif isinstance(matrix, sparse.csr_matrix):
            matrix = matrix.todense()
        self.can_convert = can_convert
        super().__init__(name, matrix, description, cacheable)

    @property
    def csr(self):
        if self.can_convert:
            return super().csr
        else:
            assert False


class TestOperator(unittest.TestCase):
    """Unit tests for the operators module.

    """

    def test_Operator_init(self):
        """Test initialization of an Operator"""
        op1 = ops.Operator("TestOp", np.eye(2), "Test descr")
        self.assertEqual(op1.name, "TestOp")
        self.assertEqual(op1.description, "Test descr")
        self.assertTrue(np.allclose(op1.arr, np.eye(2)))
        # Init with an existing operator
        op2 = ops.Operator("TestOp", np.zeros(2))
        op3 = ops.Operator("TestOp3", op2)
        self.assertNotEqual(op2.name, op3.name)
        self.assertTrue(np.allclose(op2.arr, op3.arr))

    def test_Operator_padding_caching(self):
        """Test Operator caching for matrix padding"""
        # Test caching for padding
        cache_id = "padded_matrix"
        cnot_array = np.array([[1, 0, 0, 0], [0, 1, 0, 0],
                               [0, 0, 0, 1], [0, 0, 1, 0]])
        TestCNOT = ops.Operator("TestCNOT", cnot_array)
        self.assertEqual(len(TestCNOT.get_cache(cache_id)), 0)
        opmath.padded_matrix(TestCNOT, [2, 0], 3)
        self.assertEqual(len(TestCNOT.get_cache(cache_id)), 1)
        opmath.padded_matrix(TestCNOT, [2, 0], 3)
        self.assertEqual(len(TestCNOT.get_cache(cache_id)), 1)
        opmath.padded_matrix(TestCNOT, [2, 1], 3)
        self.assertEqual(len(TestCNOT.get_cache(cache_id)), 2)
        # disable caching for call
        opmath.padded_matrix(TestCNOT, [1, 0], 3, cache=False)
        self.assertEqual(len(TestCNOT.get_cache(cache_id)), 2)
        # disable caching for operator
        TestCNOT = ops.Operator("TestCNOT", cnot_array, cacheable=False)
        self.assertEqual(len(TestCNOT.get_cache(cache_id)), 0)
        opmath.padded_matrix(TestCNOT, [2, 0], 3)
        self.assertEqual(len(TestCNOT.get_cache(cache_id)), 0)
        # Test sparse storage for large matrices
        TestCNOT = ops.Operator("TestCNOT", cnot_array)
        num_qubits = opmath.sparse_padding_threshold - 1  # below threshold
        padded_matrix = opmath.padded_matrix(TestCNOT, [2, 0], num_qubits)

        self.assertNotIsInstance(padded_matrix, sparse.csr.csr_matrix)
        self.assertNotIsInstance(TestCNOT.get_cache(cache_id)[num_qubits, (2, 0)], sparse.csr.csr_matrix)
        num_qubits = opmath.sparse_padding_threshold  # above threshold
        padded_matrix = opmath.padded_matrix(TestCNOT, [2, 0], num_qubits)
        self.assertIsInstance(padded_matrix, sparse.csr.csr_matrix)
        self.assertIsInstance(TestCNOT.get_cache(cache_id)[num_qubits, (2, 0)], sparse.csr.csr_matrix)

    def test_Operator_padded_matrix(self):
        """Test Operator matrix padding for arbitrary operators"""
        # Define some large ket vectors
        s000000 = np.kron(np.kron(s00, s00), s00)
        s000100 = np.kron(np.kron(s00, s01), s00)
        s010010 = np.kron(np.kron(s01, s00), s10)
        s010101 = np.kron(np.kron(s01, s01), s01)
        s01011001 = np.kron(np.kron(s01, s01), np.kron(s10, s01))
        # Apply 1-qubit operator
        for OperatorClass in [SparseOperator, DenseOperator]:
            mat = opmath.padded_matrix(OperatorClass(ops.X), [3], 6)
            self.assertTrue(np.allclose(mat * s000000, s000100))
            # Apply 2-qubit adjacent but-flipped operator
            mat = opmath.padded_matrix(OperatorClass(ops.X) ^ ops.I, [3, 2], 6)
            self.assertTrue(np.allclose(mat * s000000, s000100))
            mat = opmath.padded_matrix(OperatorClass(ops.X) ^ OperatorClass(ops.I), [3, 2], 6)
            self.assertTrue(np.allclose(mat * s000000, s000100))
            # Apply 2-qubit separated operator
            mat = opmath.padded_matrix(OperatorClass(ops.X) ^ ops.X, [1, 4], 6)
            self.assertTrue(np.allclose(mat * s000000, s010010))
            mat = opmath.padded_matrix(OperatorClass(ops.X) ^ OperatorClass(ops.X), [1, 4], 6)
            self.assertTrue(np.allclose(mat * s000000, s010010))
            # Apply 3-qubit separated operator
            mat = opmath.padded_matrix(ops.X ^ ops.X ^ OperatorClass(ops.X), [1, 3, 5], 6)
            self.assertTrue(np.allclose(mat * s000000, s010101))
            # Apply 5-qubit separated and flipped operator
            mat = opmath.padded_matrix((ops.X ^ ops.I ^ OperatorClass(ops.Z) ^ ops.X ^ ops.X), [7, 0, 3, 4, 1], 8)
            self.assertTrue(np.allclose(mat * np.kron(s000100, s00), -s01011001))

    def test_Operator_projectors(self):
        """Test Operator projectors property"""
        for OperatorClass in [SparseOperator, DenseOperator]:
            P0, P1 = OperatorClass(ops.Z, can_convert=True).projectors
            self.assertTrue(np.allclose(P0.arr, ket2dm(s0)))
            P0, P1 = OperatorClass(ops.X, can_convert=True).projectors
            self.assertTrue(np.allclose(P0.arr, ket2dm(h0)))
            self.assertTrue(np.allclose(P1.arr, ket2dm(h1)))
            P0, P1 = OperatorClass(ops.Y, can_convert=True).projectors
            self.assertTrue(np.allclose(P0.arr, ket2dm(y0)))
            self.assertTrue(np.allclose(P1.arr, ket2dm(y1)))
            with self.assertRaises(RuntimeError):
                nonH = OperatorClass(ops.Operator("nonH", np.array([[1, 1], [0, 1]])))
                nonH.projectors
            P0, P1 = OperatorClass(ops.H, can_convert=True).projectors
            m0, m1 = OperatorClass(ops.H, can_convert=True).eigenvals
            self.assertTrue(np.allclose(m0 * P0.arr + m1 * P1.arr, ops.H.arr))
            P0, P1 = OperatorClass(ops.H, can_convert=True).projectors
            self.assertEqual(P0.use_sparse, OperatorClass == SparseOperator)
            self.assertEqual(P1.use_sparse, OperatorClass == SparseOperator)
            for operator in [ops.Z ^ ops.Z, ops.X ^ ops.X, ops.H ^ ops.Y, ops.Z ^ ops.I]:
                P0, P1 = OperatorClass(operator, can_convert=True).projectors
                self.assertTrue(np.allclose(P0.arr - P1.arr, operator.arr))

    def test_Operator_eigenkets(self):
        """Test Operator eigenkets property"""
        for OperatorClass in [SparseOperator, DenseOperator]:
            v0, v1 = OperatorClass(ops.Z, can_convert=True).eigenkets
            self.assertTrue(np.allclose(v0, s0))
            self.assertTrue(np.allclose(v1, s1))
            v0, v1 = OperatorClass(ops.X, can_convert=True).eigenkets
            self.assertTrue(np.allclose(v0, h0))
            self.assertTrue(np.allclose(v1, h1))
            v0, v1 = OperatorClass(ops.Y, can_convert=True).eigenkets
            self.assertTrue(np.allclose(v0, y0))
            self.assertTrue(np.allclose(v1, y1))

    def test_correct_global_phase(self):
        """Test that eigenket states are given correct global phase"""
        self.assertTrue(np.allclose(ops.correct_global_phase(np.array([[-1j], [0]])), s0))
        self.assertTrue(np.allclose(ops.correct_global_phase(np.array([[0], [-1]])), s1))
        self.assertTrue(np.allclose(ops.correct_global_phase(np.array([[1j], [1]]) / np.sqrt(2)), y1))
        self.assertTrue(np.allclose(ops.correct_global_phase(np.array([[-1j], [1]]) / np.sqrt(2)), y0))

    def test_Operator_eigenvals(self):
        """Test Operator eigenvals"""
        for OperatorClass in [SparseOperator, DenseOperator]:
            for op in [ops.Z, ops.X, ops.Y]:
                m0, m1 = OperatorClass(op, can_convert=True).eigenvals
                self.assertAlmostEqual(m0, +1)
                self.assertAlmostEqual(m1, -1)
            nonH = OperatorClass(ops.Operator("nonH",
                                              np.kron(ops.H.arr, ops.X.arr + s0 * dagger(s1))), can_convert=True)
            self.assertFalse(nonH.is_hermitian)
            self.assertTrue(np.allclose(nonH.eigenvals, np.array([1, 1, -1, -1]) * np.sqrt(2)))
            nonH = OperatorClass(ops.Operator("nonH",
                                              np.kron(ops.H.arr, ops.X.csr + s0 * dagger(s1))), can_convert=True)
            self.assertFalse(nonH.is_hermitian)
            self.assertTrue(np.allclose(nonH.eigenvals, np.array([1, 1, -1, -1]) * np.sqrt(2)))

    def test_Operator_unitary(self):
        """Test if Operator is unitary"""
        for OperatorClass in [SparseOperator, DenseOperator]:
            for op in [ops.Z, ops.X, ops.Y, ops.H]:
                self.assertTrue(OperatorClass(op).is_unitary)
            for op in (ops.Z.projectors + ops.X.projectors +
                       ops.Y.projectors + ops.H.projectors):
                self.assertFalse(OperatorClass(op).is_unitary)

    def test_Operator_hermitian(self):
        """Test if Operator is hermitian"""
        for OperatorClass in [SparseOperator, DenseOperator]:
            for op in [ops.Z, ops.X, ops.Y, ops.H]:
                self.assertTrue(OperatorClass(op).is_hermitian)
            for op in [ops.Operator("nonH", np.array([[1, 1], [0, 1]])),
                       ops.Operator("nonH2", s0 * dagger(s1) + ops.Y.arr)]:
                self.assertFalse(OperatorClass(op).is_hermitian)

    def test_Operator_equality(self):
        """Test equality operation of Operator."""
        for OperatorClass1 in [SparseOperator, DenseOperator]:
            for OperatorClass2 in [SparseOperator, DenseOperator]:
                self.assertTrue(OperatorClass1(ops.X) == OperatorClass2(ops.X))
                self.assertFalse(OperatorClass1(ops.X) == OperatorClass2(ops.Y))
                self.assertTrue(OperatorClass1(ops.X) != OperatorClass2(ops.Y))
                newY = OperatorClass1(ops.Operator("newY", np.array([[0, -1j], [1j, 0]], dtype=complex)))
                self.assertFalse(OperatorClass2(ops.Y) is newY)
                self.assertTrue(OperatorClass2(ops.Y) == newY)

    def test_Operator_arithmetic(self):
        """Test Operator arithmetic methods"""
        # addition
        for OperatorClass1 in [SparseOperator, DenseOperator]:
            for OperatorClass2 in [SparseOperator, DenseOperator]:
                A = OperatorClass1(ops.X) + OperatorClass2(ops.Z)
                self.assertEqual(A.name, "(X+Z)")
                self.assertTrue(np.allclose(A.arr, ops.X.arr + ops.Z.arr))
                self.assertTrue(sparseutil.sparse_allclose(A.csr, ops.X.csr + ops.Z.csr))
                # NOTE reverse not possible as np array does the __add__
                A = OperatorClass1(A) + OperatorClass2(np.eye(2, dtype=complex))
                self.assertEqual(A.name, "((X+Z)+?)")
                self.assertTrue(np.allclose(A.arr, ops.X.arr + ops.Z.arr + np.eye(2)))
                self.assertTrue(sparseutil.sparse_allclose(A.csr, ops.X.csr + ops.Z.csr + sparse.eye(2)))
                # subtraction
                A = OperatorClass1(ops.Z) - OperatorClass2(ops.X)
                self.assertEqual(A.name, "(Z-X)")
                self.assertTrue(np.allclose(A.arr, ops.Z.arr - ops.X.arr))
                self.assertTrue(sparseutil.sparse_allclose(A.csr, ops.Z.csr - ops.X.csr))
                # NOTE reverse not possible as np array does the __sub__
                B = OperatorClass1(A) - OperatorClass2(np.eye(2, dtype=complex))
                self.assertEqual(B.name, "((Z-X)-?)")
                self.assertTrue(np.allclose(B.arr, ops.Z.arr - ops.X.arr - np.eye(2)))
                self.assertTrue(sparseutil.sparse_allclose(B.csr, ops.Z.csr - ops.X.csr - sparse.eye(2)))
                # multiplication
                B = OperatorClass1(ops.Y) * OperatorClass2(A)
                self.assertEqual(B.name, "(Y*(Z-X))")
                self.assertTrue(np.allclose(B.arr, ops.Y.arr @ (ops.Z.arr - ops.X.arr)))
                self.assertTrue(sparseutil.sparse_allclose(B.csr, ops.Y.csr @ (ops.Z.csr - ops.X.csr)))
                C = 5 * OperatorClass1(B) * 1j * OperatorClass2(np.array([[0, 2], [1, 0]]))
                self.assertEqual(C.name, "((((5.00)*(Y*(Z-X)))*(0.00+1.00j))*?)")
                self.assertTrue(np.allclose(C.arr, (B.arr * 5j) @ np.array([[0, 2], [1, 0]])))
                self.assertTrue(
                    sparseutil.sparse_allclose(C.csr, (B.csr * 5j) @ sparse.csr_matrix(np.array([[0, 2], [1, 0]]))))
                # division
                D = B / np.sqrt(2)
                self.assertEqual(D.name, "((Y*(Z-X))/(1.41))")
                self.assertTrue(np.allclose(D.arr, B.arr / np.sqrt(2)))
                self.assertTrue(sparseutil.sparse_allclose(D.csr, B.csr / np.sqrt(2)))
                # tensor product
                E = OperatorClass1(ops.X) ^ OperatorClass2(ops.Z)
                self.assertEqual(E.name, "(X^Z)")
                self.assertTrue(np.allclose(E.arr, np.kron(ops.X.arr, ops.Z.arr)))
                self.assertTrue(sparseutil.sparse_allclose(E.csr, sparse.kron(ops.X.csr, ops.Z.csr)))
                # NOTE reverse not possible as np array does an __xor__
                E = OperatorClass1(ops.X) ^ OperatorClass2(np.eye(2, dtype=complex))
                self.assertEqual(E.name, "(X^?)")
                self.assertTrue(np.allclose(E.arr, np.kron(ops.X.arr, np.eye(2))))
                self.assertTrue(sparseutil.sparse_allclose(E.csr, sparse.kron(ops.X.csr, sparse.eye(2))))

    def test_controlled_op(self):
        """Test creation of controlled gates."""
        for OperatorClass in [SparseOperator, DenseOperator]:
            # Test the classics
            TestCX = OperatorClass(ops.X).ctrl
            TestCZ = OperatorClass(ops.Z).ctrl
            TestCS = OperatorClass(ops.S).ctrl
            self.assertTrue(np.allclose(TestCX.arr, np.array([[1, 0, 0, 0], [0, 1, 0, 0],
                                                              [0, 0, 0, 1], [0, 0, 1, 0]])))
            self.assertEqual(TestCX.name, "CX")
            self.assertTrue(np.allclose(TestCZ.arr, np.array([[1, 0, 0, 0], [0, 1, 0, 0],
                                                              [0, 0, 1, 0], [0, 0, 0, -1]])))
            self.assertEqual(TestCZ.name, "CZ")
            self.assertTrue(np.allclose(TestCS.arr, np.array([[1, 0, 0, 0], [0, 1, 0, 0],
                                                              [0, 0, 1, 0], [0, 0, 0, 1j]], dtype=complex)))
            self.assertEqual(TestCS.name, "CS")
            # # Test creation from a matrix
            TestCM = ops.Operator("M", np.array([[1, 2], [3, 4]])).ctrl
            self.assertTrue(np.allclose(TestCM.arr, np.array([[1, 0, 0, 0], [0, 1, 0, 0],
                                                              [0, 0, 1, 2], [0, 0, 3, 4]])))
            # Test control over 2-qubit gate
            TestCXX = OperatorClass(ops.X ^ ops.X).ctrl
            self.assertEqual(TestCXX.name, "C(X^X)")
            self.assertTrue(np.allclose(TestCXX.arr, np.array([
                [1, 0, 0, 0, 0, 0, 0, 0],
                [0, 1, 0, 0, 0, 0, 0, 0],
                [0, 0, 1, 0, 0, 0, 0, 0],
                [0, 0, 0, 1, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 1],
                [0, 0, 0, 0, 0, 0, 1, 0],
                [0, 0, 0, 0, 0, 1, 0, 0],
                [0, 0, 0, 0, 1, 0, 0, 0]])))

    def test_inverse_op(self):
        """Test creation of inverse operator."""
        for OperatorClass in [SparseOperator, DenseOperator]:
            # Test operator with an inverse
            opr90 = OperatorClass(ops.Ry90)
            Ry90Inv = opr90.inv
            self.assertFalse(np.allclose(ops.Ry90.arr @ ops.Ry90.arr, np.eye(2)))
            self.assertTrue(np.allclose(Ry90Inv.arr, np.transpose(np.conj(ops.Ry90.arr))))
            self.assertTrue(np.allclose(Ry90Inv.arr @ ops.Ry90.arr, np.eye(2)))
            self.assertFalse(Ry90Inv is opr90)
            self.assertTrue(Ry90Inv.inv is opr90)
            self.assertEqual(Ry90Inv.name, "{}^{{-1}}".format(ops.Ry90.name))
            # Test self-inverse operator
            opcnot = OperatorClass(ops.CNOT)
            CNOTInv = opcnot.inv
            self.assertTrue(CNOTInv is opcnot)
            self.assertEqual(CNOTInv.name, ops.CNOT.name)

    def test_complex_conjugate_op(self):
        """Test creation of complex conjugate operator."""
        # Test operator with an complex conjugate
        for OperatorClass in [SparseOperator, DenseOperator]:
            opsy = OperatorClass(ops.Y)
            YConj = opsy.conj
            self.assertTrue(np.allclose(YConj.arr, np.conj(ops.Y.arr)))
            self.assertFalse(YConj is opsy)
            self.assertTrue(YConj.conj is opsy)
            self.assertEqual(YConj.name, "{}*".format(ops.Y.name))
            # Test self-conjugate operator
            opcnot = OperatorClass(ops.CNOT)
            CNOTConj = opcnot.conj
            self.assertTrue(CNOTConj is opcnot)
            self.assertEqual(CNOTConj.name, ops.CNOT.name)

    def test_create_rotation_op(self):
        """Test creation of rotation operators."""
        # test naming
        Rx = ops.create_rotation_op(np.pi / 2, (1, 0, 0))
        Ry = ops.create_rotation_op(np.pi, (0, 1, 0))
        Rz = ops.create_rotation_op(np.pi / 4, (0, 0, 1))
        R = ops.create_rotation_op(-np.pi / 4, (1, 1, 0))
        self.assertEqual(Rx.name, "R_x[1.57]")
        self.assertEqual(Ry.name, "R_y[3.14]")
        self.assertEqual(Rz.name, "R_z[0.79]")
        self.assertEqual(R.name, "R_(0.71,0.71,0.00)[-0.79]")
        # test some rotation matrices
        self.assertTrue(np.allclose(Rx.arr @ s0, y1))
        self.assertTrue(np.allclose(Ry.arr @ s0, s1))
        self.assertTrue(np.allclose(Ry.arr @ h0, -1 * h1))
        self.assertTrue(np.allclose(Ry.arr @ Ry.arr @ h0, - h0))
        self.assertTrue(np.allclose(Ry.arr @ Ry.arr @ h0, - h0))
        # Check relations
        RH = ops.create_rotation_op(np.pi, (1, 0, 1))
        norm = np.exp(-1j * np.angle(RH.arr[0, 0]))
        self.assertTrue(np.allclose(RH.arr * norm, ops.H.arr))
        self.assertTrue(np.allclose(Rz.arr * Rz.arr[1, 1], ops.T.arr))
        # Test conjugation
        self.assertTrue(not np.allclose(R.arr, np.conj(R.arr)))
        RC = ops.create_rotation_op(-np.pi / 4, (1, 1, 0), conjugate=True)
        self.assertTrue(np.allclose(np.conj(R.arr), RC.arr))
        self.assertEqual(RC.name, "R_(0.71,0.71,0.00)[-0.79]*")

    def test_bilateral_rotations(self):
        """Test bilateral rotations."""
        # NOTE this test case originally tested functionality that has now been moved/replaced
        # Check bilateral rotations on Bell basis
        Bx = ops.create_rotation_op(np.pi / 2, (1, 0, 0)) ^ ops.create_rotation_op(np.pi / 2, (1, 0, 0), conjugate=True)
        By = ops.create_rotation_op(np.pi / 2, (0, 1, 0)) ^ ops.create_rotation_op(np.pi / 2, (0, 1, 0), conjugate=True)
        Bz = ops.create_rotation_op(np.pi / 2, (0, 0, 1)) ^ ops.create_rotation_op(np.pi / 2, (0, 0, 1), conjugate=True)
        rho_b00 = ket2dm(b00)
        rho_b01 = ket2dm(b01)
        rho_b10 = ket2dm(b10)
        rho_b11 = ket2dm(b11)
        # Check Bx
        self.assertTrue(np.allclose(Bx.arr @ rho_b00 @ dagger(Bx.arr), rho_b00))
        self.assertTrue(np.allclose(Bx.arr @ rho_b01 @ dagger(Bx.arr), rho_b01))
        self.assertTrue(np.allclose(Bx.arr @ rho_b11 @ dagger(Bx.arr), rho_b10))
        self.assertTrue(np.allclose(Bx.arr @ rho_b10 @ dagger(Bx.arr), rho_b11))
        # Check Bz
        self.assertTrue(np.allclose(Bz.arr @ rho_b00 @ dagger(Bz.arr), rho_b00))
        self.assertTrue(np.allclose(Bz.arr @ rho_b10 @ dagger(Bz.arr), rho_b10))
        self.assertTrue(np.allclose(Bz.arr @ rho_b01 @ dagger(Bz.arr), rho_b11))
        self.assertTrue(np.allclose(Bz.arr @ rho_b11 @ dagger(Bz.arr), rho_b01))
        # Check By
        self.assertTrue(np.allclose(By.arr @ rho_b00 @ dagger(By.arr), rho_b00))
        self.assertTrue(np.allclose(By.arr @ rho_b11 @ dagger(By.arr), rho_b11))
        self.assertTrue(np.allclose(By.arr @ rho_b01 @ dagger(By.arr), rho_b10))
        self.assertTrue(np.allclose(By.arr @ rho_b10 @ dagger(By.arr), rho_b01))

    def test_K_op(self):
        """Test the K operator"""
        self.assertTrue(np.allclose((ops.K * ops.Y * ops.K).arr, ops.Z.arr))
        self.assertTrue(np.allclose((ops.K * ops.Z * ops.K).arr, ops.Y.arr))
        self.assertTrue(np.allclose((ops.K * ops.X * ops.K).arr, -ops.X.arr))

    def test_bell_projectors(self):
        """Test the bell projectors."""
        qubits = qapi.create_qubits(2)
        qapi.operate(qubits[0], ops.H)
        qapi.operate(qubits, ops.CNOT)
        m, p = qapi.gmeasure(qubits, ops.BELL_PROJECTORS)
        self.assertEqual(BellIndex.B00, m)
        self.assertAlmostEqual(p, 1.0)
        self.assertAlmostEqual(qapi.fidelity(qubits, bell_states[m]), 1.0)
        qapi.operate(qubits[0], ops.Z)
        m, p = qapi.gmeasure(qubits, ops.BELL_PROJECTORS)
        self.assertAlmostEqual(p, 1.0)
        self.assertEqual(BellIndex.B10, m)
        self.assertAlmostEqual(qapi.fidelity(qubits, bell_states[m]), 1.0)
        qapi.operate(qubits[0], ops.X)
        m, p = qapi.gmeasure(qubits, ops.BELL_PROJECTORS)
        self.assertAlmostEqual(p, 1.0)
        self.assertEqual(BellIndex.B11, m)
        self.assertAlmostEqual(qapi.fidelity(qubits, bell_states[m]), 1.0)
        qapi.operate(qubits[0], ops.Z)
        m, p = qapi.gmeasure(qubits, ops.BELL_PROJECTORS)
        self.assertAlmostEqual(p, 1.0)
        self.assertEqual(BellIndex.B01, m)
        self.assertAlmostEqual(qapi.fidelity(qubits, bell_states[m]), 1.0)


if __name__ == "__main__":
    unittest.main()
