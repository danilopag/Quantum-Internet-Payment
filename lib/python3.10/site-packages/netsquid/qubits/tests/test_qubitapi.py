# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_qubitapi.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the qubitapi module.

"""
import unittest
import numpy as np
from netsquid.qubits.qrepr import convert_to
from netsquid.qubits import qubitapi as qapi
from netsquid.qubits.kettools import KetRepr
from netsquid.qubits.qformalism import QFormalism, get_qstate_formalism, set_qstate_formalism
from netsquid.qubits.operators import I, X, Y, Z, H, S, CNOT, Operator, BELL_PROJECTORS, T
from netsquid.qubits.ketstates import b00, b10, s0, s1, s11, s01, h0, s00, h1, y0
from netsquid.qubits.ketutil import ket2dm
from netsquid.qubits.stabtools import StabRepr
from netsquid.util import simtools


class TestQubitAPI(unittest.TestCase):
    """Unit tests for the qubitapi module.

    """

    def test_set_qstate_formalism(self):
        """Test setting the quantum state formalism"""
        for formalism in QFormalism:
            set_qstate_formalism(formalism)
            self.assertEqual(get_qstate_formalism(), formalism)
        with self.assertRaises(TypeError):
            set_qstate_formalism("foo")

    def test_create_qubits(self):
        """Test creation of multiple qubits"""
        for formalism in QFormalism:
            set_qstate_formalism(formalism)
            num_qubits = 3
            system_name = "TestName"
            qubits = qapi.create_qubits(num_qubits=num_qubits, system_name=system_name)
            self.assertEqual(len(qubits), num_qubits)
            for i in range(num_qubits):
                self.assertEqual(qubits[i].name, "{}{}".format(system_name, i))
                self.assertFalse(qubits[i].qstate is None)
                self.assertEqual(qubits[i].qstate.num_qubits, 1)
                self.assertTrue(np.allclose(qubits[i].qstate.qrepr.reduced_dm(), ket2dm(s0)))
            # Test default system name
            counter = 5
            qapi._system_name_counter = counter
            qubits = qapi.create_qubits(num_qubits)
            self.assertEqual(len(qubits), num_qubits)
            for i in range(num_qubits):
                self.assertEqual(qubits[i].name, "QS#{}-{}".format(counter, i))
                self.assertEqual(qapi._system_name_counter, counter + 1)
            # Test stateless qubit creation
            qubits = qapi.create_qubits(num_qubits, no_state=True)
            self.assertEqual(len(qubits), num_qubits)
            for i in range(num_qubits):
                self.assertTrue(qubits[i].name > "")
                self.assertTrue(qubits[i].qstate is None)

    def test_combine_qubits(self):
        """Test combination of multiple qubits"""
        for formalism in QFormalism:
            set_qstate_formalism(formalism)
            q1, = qapi.create_qubits(1, "A")
            q2, = qapi.create_qubits(1, "B")
            q3, q4 = qapi.create_qubits(2, "C")
            qapi.combine_qubits([q1, q2, q3, q4])
            self.assertEqual(q1.qstate, q2.qstate)
            self.assertEqual(q1.qstate, q3.qstate)
            self.assertEqual(q1.qstate, q4.qstate)
            self.assertIs(q1.qstate, q2.qstate)
            self.assertIs(q1.qstate, q3.qstate)
            self.assertIs(q1.qstate, q4.qstate)
            self.assertEqual(q1.qstate.num_qubits, 4)
            # Check we have expected |0000> state as result
            ket = np.zeros((16, 1))
            ket[0, 0] = 1
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), ket2dm(ket)))
            with self.assertRaises(ValueError):
                qapi.combine_qubits([q1, q2, None, q4])
        # Test conversion of qubits with different formalisms to set formalism
        for formalism in QFormalism:
            set_qstate_formalism(QFormalism.KET)
            q1, = qapi.create_qubits(1)
            qapi.operate([q1], X)
            set_qstate_formalism(QFormalism.STAB)
            q2, q3 = self._create_bell_state()
            set_qstate_formalism(QFormalism.DM)
            q4, = qapi.create_qubits(1)
            qapi.operate([q4], H)
            qubits = [q1, q2, q3, q4]
            for test_form in QFormalism:
                set_qstate_formalism(test_form)
                qubit = qapi.create_qubits(1)[0]
                qubits.append(qubit)
            set_qstate_formalism(formalism)
            qapi.combine_qubits(qubits)
            for q in qubits:
                self.assertEqual(q.qstate, qubits[0].qstate)
                self.assertEqual(type(q.qstate.qrepr), formalism)
            self.assertTrue(np.allclose(
                qapi.reduced_dm(qubits[:4]), ket2dm(np.kron(s1, np.kron(b00, h0)))))
        # Test combining of homogeneous qstate while a different formalism is set
        set_qstate_formalism(QFormalism.STAB)
        q1, = qapi.create_qubits(1)
        q2, q3 = self._create_bell_state()
        qubits = [q1, q2, q3]
        set_qstate_formalism(QFormalism.KET)
        qapi.combine_qubits(qubits)
        for q in qubits:
            self.assertEqual(q.qstate, qubits[0].qstate)
            self.assertEqual(type(q.qstate.qrepr), QFormalism.STAB)
        self.assertTrue(np.allclose(qapi.reduced_dm(qubits), ket2dm(np.kron(s0, b00))))

    def test_discard_qubit(self):
        """Test discarding a qubit"""
        for formalism in QFormalism.purestate_formalisms:
            set_qstate_formalism(formalism)
            q1, q2 = self._create_bell_state()
            qapi.discard(q2)
            self.assertEqual(q2.qstate, None)
            self.assertNotEqual(q1.qstate, None)
            # Should have resulted in q2 being measured
            qrepr = q1.qstate.qrepr
            dms0 = ket2dm(s0)
            dms1 = ket2dm(s1)

            self.assertTrue(np.allclose(qrepr.reduced_dm(), dms0) or np.allclose(qrepr.reduced_dm(), dms1))
        for formalism in QFormalism.ensemble_formalisms:
            set_qstate_formalism(formalism)
            q1, q2 = self._create_bell_state()
            qapi.discard(q2)
            self.assertEqual(q2.qstate, None)
            self.assertNotEqual(q1.qstate, None)
            # Should have resulted in mixed state (i.e. q2 traced out)
            qrepr = q1.qstate.qrepr
            self.assertTrue(np.allclose(qrepr.reduced_dm(), np.eye(2) * 0.5))

    def test_measure(self):
        """Test measuring qubits"""
        for formalism in QFormalism:
            set_qstate_formalism(formalism)
            q1, q2 = self._create_bell_state()
            m, p = qapi.measure(q1, discard=False, keep_combined=True)
            self.assertIn(m, [0, 1])
            self.assertAlmostEqual(p, 0.5)
            self.assertEqual(q1.qstate, q2.qstate)
            qapi.measure(q1, discard=True, keep_combined=False)
            self.assertNotEqual(q1.qstate, q2.qstate)
            self.assertIsNone(q1.qstate)
            with self.assertRaises(ValueError):
                qapi.measure(q1)

    def test_teleportation(self):
        """Test a teleportation protocol."""
        q1, q2, q3 = qapi.create_qubits(3)
        qapi.operate(q1, H)
        qapi.operate(q1, S)
        qapi.operate(q2, H)
        qapi.operate([q2, q3], CNOT)
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), ket2dm(y0)))
        dm = np.array([[1/2, 0, 0, 1/2],
                       [0, 0, 0, 0],
                       [0, 0, 0, 0],
                       [1/2, 0, 0, 1/2]])
        self.assertTrue(np.allclose(qapi.reduced_dm([q2, q3]), dm))
        qapi.operate([q1, q2], CNOT)
        qapi.operate(q1, H)
        self.assertEqual(3, q3.qstate.num_qubits)
        self.assertEqual(3, q3.qstate.qrepr.num_qubits)
        m0, _ = qapi.measure(q1)
        self.assertEqual(2, q3.qstate.num_qubits)
        self.assertEqual(2, q3.qstate.qrepr.num_qubits)
        dm = ket2dm(s0 if m0 == 0 else s1)
        self.assertTrue(np.allclose(qapi.reduced_dm(q1), dm))
        m1, _ = qapi.measure(q2)
        self.assertEqual(1, q3.qstate.num_qubits)
        self.assertEqual(1, q3.qstate.qrepr.num_qubits)
        dm = ket2dm(s0 if m1 == 0 else s1)
        self.assertTrue(np.allclose(qapi.reduced_dm(q2), dm))
        state = y0
        if m1 == 1:
            state = Z.arr @ state
        if m0 == 1:
            state = X.arr @ state
        dm = ket2dm(state)
        self.assertTrue(np.allclose(qapi.reduced_dm(q3), dm))

    def test_gmeasure(self):
        """Test gmeasuring qubits"""
        for formalism in QFormalism.universal_formalisms:
            set_qstate_formalism(formalism)
            q1, q2 = self._create_bell_state()
            m, p = qapi.gmeasure([q1, q2], BELL_PROJECTORS, check_operators=True)
            self.assertEqual(0, m)
            self.assertAlmostEqual(1, p)
            m, p = qapi.gmeasure([q1, q2], (Z ^ Z).projectors, check_operators=True)  # Parity measurement
            self.assertAlmostEqual(1, p)
            self.assertEqual(0, m)
            m, p = qapi.gmeasure([q1, q2], Z ^ Z, check_operators=True)  # Parity measurement
            self.assertAlmostEqual(1, p)
            self.assertEqual(0, m)
            with self.assertRaises(ValueError):
                qapi.gmeasure([q1, q2], T ^ T, check_operators=True)
            with self.assertRaises(ValueError):
                qapi.gmeasure([q1, q2], [T, S], check_operators=True)

    def test_assign_qstate(self):
        """Test assigning qstates to qubits."""
        reprs = {}
        ketrepr = KetRepr(s00)
        for formalism in QFormalism:
            if formalism is QFormalism.KET:
                reprs[formalism] = ketrepr
            else:
                reprs[formalism] = convert_to(ketrepr, formalism)
        for from_formalism in QFormalism:
            qs_repr = reprs[from_formalism]
            for to_formalism in QFormalism:
                q1, q2 = qapi.create_qubits(2, no_state=True)
                with self.assertRaises(ValueError):
                    # Wrong number of qubits for state
                    qapi.assign_qstate(qubits=[q1], qrepr=qs_repr, formalism=to_formalism)
                qapi.assign_qstate(qubits=[q1, q2], qrepr=qs_repr, formalism=to_formalism)
                self.assertEqual(type(q1.qstate.qrepr), to_formalism)
                self.assertEqual(q1.qstate, q2.qstate)
                self.assertEqual(q1.qstate.qrepr, reprs[to_formalism])
        # Check qubit discarded out of existing state
        for formalism in QFormalism.ensemble_formalisms:
            set_qstate_formalism(formalism)
            q1, q2 = self._create_bell_state()
            qapi.assign_qstate(qubits=[q1], qrepr=StabRepr(np.array([[0, 1]]), [-1]))
            self.assertEqual(type(q1.qstate.qrepr), formalism)
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), ket2dm(s1)))
            # Test q1 dropped from shared state with q2
            self.assertNotEqual(q2.qstate, q1.qstate)
            self.assertEqual(q2.qstate.num_qubits, 1)
        # Test assigning None states.
        q1, q2 = qapi.create_qubits(2)
        self.assertIsNotNone(q1.qstate)
        self.assertIsNotNone(q2.qstate)
        qapi.assign_qstate([q1, q2], None)
        self.assertIsNone(q1.qstate)
        self.assertIsNone(q2.qstate)

    def test_stochastic_operate(self):
        """Test stochastic operate"""
        for formalism in QFormalism.ensemble_formalisms:
            # Test depolarization
            set_qstate_formalism(formalism)
            q1, = qapi.create_qubits(1)
            qapi.stochastic_operate(q1, [I, X, Y, Z])
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), 0.5 * np.eye(2)))
        for formalism in QFormalism:
            set_qstate_formalism(formalism)
            q1, q2 = qapi.create_qubits(2)
            qapi.stochastic_operate([q1, q2], [I ^ I, X ^ X], p_weights=(0, 1))
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), ket2dm(s11)))
            q1, = qapi.create_qubits(1)
            qapi.stochastic_operate([q1], [X, I], p_weights=(0, 1))
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), ket2dm(s0)))
            q1, = qapi.create_qubits(1)
            qapi.stochastic_operate([q1], [I, X], p_weights=(0, 1))
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), ket2dm(s1)))

    def test_multi_operate(self):
        """Test multi operate"""
        gamma = 0.1
        prob = 0.5
        a = np.sqrt(gamma)
        b = np.sqrt(1 - gamma)
        E0 = Operator("E0_AD", [[1, 0], [0, b]])
        E1 = Operator("E1_AD", [[0, a], [0, 0]])
        E2 = Operator("E2_AD", [[b, 0], [0, 1]])
        E3 = Operator("E3_AD", [[0, 0], [a, 0]])
        target_dm = np.asarray([[0.95, 0], [0, 0.05]])
        # Test DM formalism
        set_qstate_formalism(QFormalism.DM)
        q1, = qapi.create_qubits(num_qubits=1)
        qapi.multi_operate(q1, [E0, E1, E2, E3],
                           weights=(prob, prob, 1 - prob, 1 - prob))
        self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), target_dm))
        # Test KET formalism
        set_qstate_formalism(QFormalism.KET)
        dm = np.zeros((2, 2), dtype=complex)
        N = 1000
        for __ in range(N):
            q1, = qapi.create_qubits(num_qubits=1)
            qapi.multi_operate(q1, [E0, E1, E2, E3],
                               weights=(prob, prob, 1 - prob, 1 - prob))
            dm += q1.qstate.qrepr.reduced_dm()
        dm /= N
        self.assertTrue(np.allclose(dm, target_dm, atol=5e-2))
        # Test STAB formalism
        set_qstate_formalism(QFormalism.STAB)
        q1, = qapi.create_qubits(num_qubits=1)
        with self.assertRaises(NotImplementedError):
            qapi.multi_operate(q1, [X, Y, Z])

    def _create_bell_state(self):
        q1, q2 = qapi.create_qubits(2)
        qapi.operate(q1, H)
        qapi.operate([q1, q2], CNOT)
        return q1, q2

    def test_fidelity(self):
        """Test fidelity function"""
        for formalism in QFormalism:
            q0, = qapi.create_qubits(1)
            self.assertAlmostEqual(qapi.fidelity([q0], s0, squared=True), 1)
            self.assertAlmostEqual(qapi.fidelity([q0], s1, squared=True), 0)
            self.assertAlmostEqual(qapi.fidelity([q0], h0, squared=True), 0.5)
            self.assertAlmostEqual(qapi.fidelity([q0], h1, squared=True), 0.5)
            self.assertAlmostEqual(qapi.fidelity([q0], np.array([[1, 0], [0, 0]]), squared=True), 1)
            self.assertAlmostEqual(qapi.fidelity([q0], np.array([[1], [0]]), squared=True), 1)
            self.assertAlmostEqual(qapi.fidelity([q0], np.array([1, 0]), squared=True), 1)
            self.assertAlmostEqual(qapi.fidelity([q0], h1, squared=False), np.sqrt(0.5))
            set_qstate_formalism(formalism)
            # Create qubits in |00> then transform to (|00> + |11>)/sqrt(2) and check fidelity
            # with this expected state.
            q1, q2 = self._create_bell_state()
            self.assertAlmostEqual(qapi.fidelity([q1, q2], b00, squared=True), 1)
            self.assertAlmostEqual(qapi.fidelity([q1, q2], ket2dm(b00), squared=True), 1)
            # Test fidelity on reduced states
            set_qstate_formalism(formalism)
            q1, q2 = self._create_bell_state()
            self.assertAlmostEqual(qapi.fidelity([q1], s0, squared=True), 0.5)
            self.assertAlmostEqual(qapi.fidelity([q1], s1, squared=True), 0.5)
            self.assertAlmostEqual(qapi.fidelity([q1], h0, squared=True), 0.5)
            self.assertAlmostEqual(qapi.fidelity([q1], h1, squared=True), 0.5)
            self.assertAlmostEqual(qapi.fidelity([q1], np.array([[1, 0], [0, 0]]), squared=True), 0.5)
            self.assertAlmostEqual(qapi.fidelity([q1], np.array([[1], [0]]), squared=True), 0.5)
            self.assertAlmostEqual(qapi.fidelity([q1], np.array([1, 0]), squared=True), 0.5)
            self.assertAlmostEqual(qapi.fidelity([q1], s0, squared=False), np.sqrt(0.5))
            self.assertAlmostEqual(qapi.fidelity([q1], ket2dm(s0), squared=True), 0.5)
            self.assertAlmostEqual(qapi.fidelity([q1], ket2dm(s0), squared=False), np.sqrt(0.5))
            q1, q2, q3, q4 = qapi.create_qubits(4)
            qapi.operate(q3, X)
            qapi.operate(q4, H)
            qapi.combine_qubits([q1, q2, q3, q4])
            self.assertAlmostEqual(qapi.fidelity([q2, q3], s01, squared=True), 1)
            self.assertAlmostEqual(qapi.fidelity([q2, q3], ket2dm(s01), squared=True), 1)
            q1, q2, q3 = qapi.create_qubits(3)
            q4, = qapi.create_qubits(1)
            self.assertAlmostEqual(qapi.fidelity([q3, q4], s00, squared=True), 1)

    def test_exp_value(self):
        """Test expectation value function."""
        for formalism in QFormalism:
            set_qstate_formalism(formalism)
            q1, q2, q3 = qapi.create_qubits(3)
            qapi.operate(q2, X)
            qapi.operate(q3, H)
            self.assertAlmostEqual(qapi.exp_value(q1, Z), 1)
            self.assertAlmostEqual(qapi.exp_value(q2, Z), -1)
            self.assertAlmostEqual(qapi.exp_value(q1, X), 0)
            self.assertAlmostEqual(qapi.exp_value(q3, X), 1)
            self.assertAlmostEqual(qapi.exp_value([q2, q3], Z ^ X), -1)
            # Test Bell State
            q1, q2 = self._create_bell_state()
            self.assertAlmostEqual(qapi.exp_value(q1, Z), 0)
            self.assertAlmostEqual(qapi.exp_value(q1, X), 0)
            self.assertAlmostEqual(qapi.exp_value([q1, q2], X ^ Z), 0)

    def test_pauli_noise_purestates(self):
        """Test pauli noise application for pure state formalisms"""
        for formalism in QFormalism.purestate_formalisms:
            set_qstate_formalism(formalism)
            simtools.set_random_state(seed=0)
            N = 200
            for p, target_F2 in [(1, 0.25), (0.5, 0.625)]:
                fidelity_sum = 0
                for __ in range(N):
                    q1, q2 = self._create_bell_state()
                    qapi.apply_pauli_noise(q2, (1. - 0.75 * p, 0.25 * p, 0.25 * p, 0.25 * p))
                    fidelity_sum += qapi.fidelity([q1, q2], b00, squared=True)
                self.assertTrue(np.isclose(fidelity_sum / N, target_F2, atol=0.075))
            for p in [-0.1, 1.1]:
                q1, = qapi.create_qubits(1)
                with self.assertRaises(ValueError):
                    qapi.apply_pauli_noise(q1, (1. - p, p, 0, 0))

    def test_pauli_noise_ensemble(self):
        """Test pauli noise application for ensemble formalisms"""
        for formalism in QFormalism.ensemble_formalisms:
            set_qstate_formalism(formalism)
            # Test complete depolarization on q1
            q1, q2 = self._create_bell_state()
            qapi.apply_pauli_noise(q2, (1 / 4, 1 / 4, 1 / 4, 1 / 4))
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), 0.25 * np.eye(4)))
            # Test same result if act on q2
            q1, q2 = self._create_bell_state()
            qapi.apply_pauli_noise(q1, (1 / 4, 1 / 4, 1 / 4, 1 / 4))
            self.assertTrue(np.allclose(q2.qstate.qrepr.reduced_dm(), 0.25 * np.eye(4)))
            # Test partial depolarization
            q1, q2 = self._create_bell_state()
            qapi.apply_pauli_noise(q2, (0.625, 0.125, 0.125, 0.125))
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), 0.125 * np.eye(4) + 0.5 * ket2dm(b00)))
            # Test weighted depolarization
            q1, q2 = self._create_bell_state()
            qapi.apply_pauli_noise(q2, (0.625, 0.1875, 0.0625, 0.125))
            # qapi.depolarize(q2, 0.5, p_weights=[3/6, 1/6, 2/6])
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(),
                                        np.array([[0.375, 0, 0, 0.25], [0, 0.125, 0.0625, 0],
                                                  [0, 0.0625, 0.125, 0], [0.25, 0, 0, 0.375]])))
            for p in [-0.1, 1.1]:
                q1, = qapi.create_qubits(1)
                with self.assertRaises(ValueError):
                    qapi.apply_pauli_noise(q1, (1. - p, p, 0, 0))

    def test_amplitude_dampen(self):
        """Test amplitude damping"""
        simtools.get_random_state().seed(seed=0)
        num_runs = 200
        fidelity_sums = [0.] * 4
        for __ in range(num_runs):
            gamma = 0.1
            # For p=1, starionary state is |0>
            q1, = qapi.create_qubits(1)
            qapi.amplitude_dampen(q1, gamma=gamma, prob=1.)
            fidelity_sums[0] += qapi.fidelity(q1, s0, squared=True)
            qapi.operate(q1, X)
            # For p=1, |1> should be dampened
            qapi.amplitude_dampen(q1, gamma=gamma, prob=1.)
            fidelity_sums[1] += qapi.fidelity(q1, s0, squared=True)
            # For p=0.5, stationary state is 0.5*(|0><0| + |1><1|)
            q1, = qapi.create_qubits(1)
            qapi.stochastic_operate(q1, [I, X])
            qapi.amplitude_dampen(q1, gamma=gamma, prob=0.5)
            fidelity_sums[2] += qapi.fidelity(q1, s0, squared=True)
            # For p=0.5, |0> should dampen
            q1, = qapi.create_qubits(1)
            qapi.amplitude_dampen(q1, gamma=gamma, prob=0.5)
            fidelity_sums[3] += qapi.fidelity(q1, s0, squared=True)
        self.assertTrue(np.isclose(fidelity_sums[0] / num_runs, 1., atol=0.05))
        self.assertTrue(np.isclose(fidelity_sums[1] / num_runs, gamma, atol=0.05))
        self.assertTrue(np.isclose(fidelity_sums[2] / num_runs, 0.5, atol=0.05))
        self.assertTrue(np.isclose(fidelity_sums[3] / num_runs, (1 - 0.5 * gamma), atol=0.05))
        for g, p in [(0.5, -0.1), (0.5, 1.1), (-0.1, 0.5), (1.1, 0.5)]:
            q1, = qapi.create_qubits(1)
            with self.assertRaises(ValueError):
                qapi.amplitude_dampen(q1, gamma=g, prob=p)

    def test_depolarize_ensemble(self):
        """Test depolarize function for ensemble formalisms"""
        for formalism in QFormalism.ensemble_formalisms:
            set_qstate_formalism(formalism)
            q1, q2 = self._create_bell_state()
            qapi.depolarize(q2, prob=0.0)
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), ket2dm(b00)))
            q1, q2 = self._create_bell_state()
            qapi.depolarize(q2, prob=0.5)
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), 0.125 * np.eye(4) + 0.5 * ket2dm(b00)))
            q1, q2 = self._create_bell_state()
            qapi.depolarize(q2, prob=1)
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), 0.25 * np.eye(4)))
            for p in [-0.1, 1.1]:
                q1, = qapi.create_qubits(1)
                with self.assertRaises(ValueError):
                    qapi.depolarize(q1, prob=p)

    def test_dephase_ensemble(self):
        """Test depolarize function for ensemble formalisms"""
        for formalism in QFormalism.ensemble_formalisms:
            set_qstate_formalism(formalism)
            q1, q2 = self._create_bell_state()
            qapi.dephase(q2, prob=0.)
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), ket2dm(b00)))
            q1, q2 = self._create_bell_state()
            qapi.dephase(q2, prob=0.5)
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), 0.5 * ket2dm(b00) + 0.5 * ket2dm(b10)))
            q1, q2 = self._create_bell_state()
            qapi.dephase(q2, prob=1)
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), ket2dm(b10)))
            for p in [-0.1, 1.1]:
                q1, = qapi.create_qubits(1)
                with self.assertRaises(ValueError):
                    qapi.dephase(q1, prob=p)

    def test_delay_depolarize_purestates(self):
        """Test delay depolarize function for pure state formalisms"""
        for formalism in QFormalism.purestate_formalisms:
            set_qstate_formalism(formalism)
            simtools.set_random_state(seed=0)
            N = 200
            fidelity_sum1 = 0
            fidelity_sum2 = 0
            for __ in range(N):
                q1, q2 = self._create_bell_state()
                qapi.delay_depolarize(q2, 0.1, 10e9)
                fidelity_sum1 += qapi.fidelity([q1, q2], b00, squared=True)
                q3, q4 = self._create_bell_state()
                qapi.delay_depolarize(q4, 0.1, 4e9)
                qapi.delay_depolarize(q4, 0.1, 6e9)
                fidelity_sum2 += qapi.fidelity([q3, q4], b00, squared=True)
            self.assertTrue(np.isclose(fidelity_sum1 / N, 0.526, atol=0.075))
            # Test additivity
            self.assertTrue(np.isclose(fidelity_sum1 / N, fidelity_sum2 / N, atol=0.075))

    def test_delay_depolarize_ensemble(self):
        """Test delay depolarize function for ensemble formalisms"""
        for formalism in QFormalism.ensemble_formalisms:
            set_qstate_formalism(formalism)
            q1, q2 = self._create_bell_state()
            qapi.delay_depolarize(q2, 0.1, 10e9)
            # Test additivity
            q3, q4 = self._create_bell_state()
            qapi.delay_depolarize(q4, 0.1, 4e9)
            qapi.delay_depolarize(q4, 0.1, 6e9)
            self.assertTrue(np.allclose(q1.qstate.qrepr.reduced_dm(), q3.qstate.qrepr.reduced_dm()))

    def test_apply_dda_noise_purestates(self):
        """Test application of DDA noise on pure state formalisms"""
        for formalism in QFormalism.universal_formalisms:
            set_qstate_formalism(formalism)
            simtools.set_random_state(seed=0)
            num_iterations = 100
            # NOTE ampl damping is slow, so limit parameter space
            for depol, deph, ampl in [
                # (1/4, 2/3, 1/3),
                (3 / 4, 2 / 3, 2 / 5),
                # (2/3, 3/5, 1/2),
                (1 / 2, 1 / 3, 5 / 6),
            ]:
                prob1, prob2, prob3, prob4 = 0, 0, 0, 0
                for __ in range(num_iterations):
                    q1, q2, q3, q4 = qapi.create_qubits(4)
                    qapi.operate(q2, H)
                    qapi.operate(q3, H)
                    qapi.operate(q4, X)
                    qapi.apply_dda_noise(q1, depol=depol, deph=deph)
                    qapi.apply_dda_noise(q2, depol=depol, deph=deph)
                    qapi.apply_dda_noise(q3, depol=depol, deph=deph, ampl=ampl)
                    qapi.apply_dda_noise(q4, depol=depol, deph=deph, ampl=ampl)
                    # NOTE recording m results instead of probabilities: ?
                    prob1 += not qapi.measure(q1, Z)[0]
                    prob2 += not qapi.measure(q2, Z)[0]
                    prob3 += not qapi.measure(q3, X)[0]
                    prob4 += not qapi.measure(q4, Z)[0]
                self.assertTrue(np.isclose(prob1 / num_iterations, 1 - depol / 2, atol=0.075))
                self.assertTrue(np.isclose(prob2 / num_iterations, 1 / 2, atol=0.120))
                self.assertTrue(
                    np.isclose(prob3 / num_iterations, (1 + (1 - (2 * deph * (1 - depol) + depol)) * np.sqrt(1 - ampl)) / 2,
                               atol=0.12))
                self.assertTrue(np.isclose(prob4 / num_iterations, (2 * ampl + depol * (1 - ampl)) / 2, atol=0.1))


if __name__ == "__main__":
    unittest.main(verbosity=2)
