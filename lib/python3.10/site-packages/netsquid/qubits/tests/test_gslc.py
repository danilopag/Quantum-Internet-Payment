# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_gslc.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import unittest
import numpy as np
from netsquid.qubits.stabtools import StabRepr

import netsquid as ns
from netsquid.util.simlog import disable_warn_deprecated
from netsquid.qubits import qubitapi as qapi
from netsquid.qubits.gslctools import GSLCRepr
from netsquid.qubits.gslcutil import gslc2stab
from netsquid.qubits import cliffords
from netsquid.qubits import qformalism as qform
import random
from netsquid.qubits.kettools import KetRepr
from netsquid.qubits.qrepr import convert_to

from netsquid.qubits.gslctools import GSLCState
from netsquid.qubits.tests.test_qrepr import TestQRepr
from netsquid.qubits.tests.test_qstate import TestDepQState


def _normalize_ket(ket):
    factor = 1
    for i in ket:
        if not np.isclose(i, 0):
            factor = i
            break
    return ket / factor


@disable_warn_deprecated
def _is_same_state(qubits1, qubits2):
    # DEPRECATED
    ket1 = _normalize_ket(qubits1[0].qstate.ket)
    ket2 = _normalize_ket(qubits2[0].qstate.ket)
    return np.allclose(ket1 - ket2, 0)


def _build_ket(init_edges, init_cliffords):
    form = ns.get_qstate_formalism()
    qform.set_qstate_formalism(qform.QFormalism.KET)
    qubits = qapi.create_qubits(len(init_cliffords))
    qubits = qapi.combine_qubits(qubits)  # uses re-ordered list
    for q_ket in qubits:
        qapi.operate(q_ket, ns.H)
    for i, edges in enumerate(init_edges):
        for j in edges:
            if i < j:
                qapi.operate([qubits[i], qubits[j]], ns.CZ)
    for i, cliff in enumerate(init_cliffords):
        op = ns.Operator(cliff.name, cliff.arr)
        qapi.operate(qubits[i], op)
    qform.set_qstate_formalism(form)
    return qubits


def _build_ket_repr(init_edges, init_cliffords):
    num_qubits = len(init_cliffords)
    ket = KetRepr(num_qubits=num_qubits)
    for q_index in range(num_qubits):
        ket.operate([q_index], ns.H, modify=True)
    for i, edges in enumerate(init_edges):
        for j in edges:
            if i < j:
                ket.operate([i, j], ns.CZ, modify=True)
    for i, cliff in enumerate(init_cliffords):
        op = ns.Operator(cliff.name, cliff.arr)
        ket.operate([i], op, modify=True)
    return ket


class CustomRNG:

    def __init__(self, seed):
        random.seed(seed)

    def random_sample(self):
        return random.random()


class TestGSLCRepr(TestQRepr, unittest.TestCase):

    def create_qrepr(self, **kwargs) -> GSLCRepr:
        return GSLCRepr(**kwargs)

    def test_assign_qrepr(self):
        repr1 = self.create_qrepr(local_cliffords=[cliffords.CLIFF_H])
        self.assertTrue(repr1.is_valid)
        self.assertEqual(1, repr1.num_qubits)
        repr2 = self.create_qrepr(local_cliffords=[cliffords.CLIFF_H, cliffords.CLIFF_H])
        self.assertTrue(repr2.is_valid)
        self.assertEqual(2, repr2.num_qubits)
        with self.assertRaises(ValueError):
            self.create_qrepr(local_cliffords=[cliffords.CLIFF_H, cliffords.CLIFF_H], edges=[{1}])
        with self.assertRaises(ValueError):
            self.create_qrepr(local_cliffords=[cliffords.CLIFF_H], edges=[{1}, {0}])

    def test_random_edge_cases_cliffords(self):
        """Test if some gslc correspond to the correct state after applying an two qubit operator"""
        # The cases here are edge cases that failed during development. Listed here as tests
        edge_cases = [
            ([0, 1], ns.CNOT, [[], []], [cliffords.CLIFF_I, cliffords.CLIFF_H]),
            ([2, 1], ns.CZ, [[1], [0], []], [cliffords.CLIFF_I, cliffords.CLIFF_I, cliffords.CLIFF_H]),
            ([1, 2], ns.CZ, [[1], [0], []], [cliffords.CLIFF_I, cliffords.CLIFF_I, cliffords.CLIFF_H]),
            ([2, 1], ns.CZ, [[1, 2], [0], [0]], [cliffords.CLIFF_KY, cliffords.CLIFF_HX, cliffords.CLIFF_H]),
            ([2, 0], ns.CZ, [[1, 2], [0, 2], [0, 1]], [cliffords.CLIFF_X, cliffords.CLIFF_KH, cliffords.CLIFF_KY]),
            ([2, 1], ns.CNOT, [[1], [0], []], [cliffords.CLIFF_I, cliffords.CLIFF_I, cliffords.CLIFF_H]),
            ([1, 2], ns.CNOT, [[1], [0], []], [cliffords.CLIFF_I, cliffords.CLIFF_I, cliffords.CLIFF_H]),
            ([2, 1], ns.CNOT, [[1, 2], [0], [0]], [cliffords.CLIFF_KY, cliffords.CLIFF_HX, cliffords.CLIFF_H]),
            ([2, 0], ns.CNOT, [[1, 2], [0, 2], [0, 1]], [cliffords.CLIFF_X, cliffords.CLIFF_KH, cliffords.CLIFF_KY]),
        ]
        for q_indices, operation, init_edges, init_cliffords in edge_cases:
            ket = _build_ket_repr(init_edges, init_cliffords)
            repr_gslc = self.create_qrepr(local_cliffords=init_cliffords, edges=init_edges)
            self.assertEqual(convert_to(ket, GSLCRepr), repr_gslc)
            ket.operate(q_indices, operation)
            repr_gslc.operate(q_indices, operation)
            self.assertTrue(convert_to(ket, GSLCRepr), repr_gslc)

    def test_random_edge_cases_measurements(self):
        """Test if some gslc correspond to the correct state before and after measurement"""
        # The cases here are edge cases that failed during development. Listed here as tests
        edge_cases = [
            [1, ns.Z, [[1], [0, 2], [1]], [cliffords.CLIFF_I, cliffords.CLIFF_H, cliffords.CLIFF_I], 74882745],
            [1, ns.Y, [[2, 1], [0], [0]], [cliffords.CLIFF_I, cliffords.CLIFF_KHX, cliffords.CLIFF_KHZ], 141426907],
            [0, ns.Z, [[1], [0]], [cliffords.CLIFF_SY, cliffords.CLIFF_Z], 370338054],
            [0, ns.X, [[1], [0]], [cliffords.CLIFF_Y, cliffords.CLIFF_Z], 1465931193],
            [0, ns.Y, [[]], [cliffords.CLIFF_I], 2],
            [0, ns.Y, [[]], [cliffords.CLIFF_I], 4],
            [0, ns.Y, [[1], [0]], [cliffords.CLIFF_I, cliffords.CLIFF_I], 4],
            [0, ns.Y, [[1], [0]], [cliffords.CLIFF_H, cliffords.CLIFF_H], 1442877925],
            [0, ns.Y, [[1], [0]], [cliffords.CLIFF_I, cliffords.CLIFF_KY], 1442877925],
            [0, ns.Z, [[]], [cliffords.CLIFF_H], 0],
            [0, ns.Z, [[]], [cliffords.CLIFF_I], 0],
            [0, ns.Z, [[]], [cliffords.CLIFF_HKX], 0],
            [0, ns.Y, [[]], [cliffords.CLIFF_I], 2],
            [0, ns.Y, [[]], [cliffords.CLIFF_I], 4],
            [0, ns.Y, [[], []], [cliffords.CLIFF_I, cliffords.CLIFF_I], 2],
            [0, ns.Y, [[], []], [cliffords.CLIFF_I, cliffords.CLIFF_I], 4],
            [0, ns.Y, [[]], [cliffords.CLIFF_H], 2],
            [0, ns.Y, [[]], [cliffords.CLIFF_H], 2],
            [0, ns.Y, [[], []], [cliffords.CLIFF_H, cliffords.CLIFF_H], 1692412510],
            [1, ns.X, [[], []], [cliffords.CLIFF_H, cliffords.CLIFF_HY], 2042842779],
            [0, ns.X, [[], []], [cliffords.CLIFF_HY, cliffords.CLIFF_H], 1525965839],
            [1, ns.Y, [[], [2], [1]], [cliffords.CLIFF_KHY, cliffords.CLIFF_KH, cliffords.CLIFF_I], 862048137],
            [1, ns.X, [[2], [2], [1, 0]], [cliffords.CLIFF_SZ, cliffords.CLIFF_I, cliffords.CLIFF_I], 1770426639],
            [0, ns.Z, [[1, 2], [0], [0]], [cliffords.CLIFF_I, cliffords.CLIFF_I, cliffords.CLIFF_I], 4],
            [0, ns.Z, [[1, 2], [0], [0]], [cliffords.CLIFF_I, cliffords.CLIFF_I, cliffords.CLIFF_I], 2],
            [0, ns.Z, [[1], [0], []], [cliffords.CLIFF_Z, cliffords.CLIFF_H, cliffords.CLIFF_H], 532723995]
        ]
        for q_meas, observable, init_edges, init_cliffords, seed in edge_cases:
            ket = _build_ket_repr(init_edges, init_cliffords)
            gslc = GSLCRepr(local_cliffords=init_cliffords, edges=init_edges)
            self.assertEqual(convert_to(ket, GSLCRepr), gslc)
            ket, meas_ket, prob_ket = ket.measure(q_meas, observable, rng=CustomRNG(seed))
            gslc, meas_gslc, prob_gslc = gslc.measure(q_meas, observable, rng=CustomRNG(seed))
            self.assertAlmostEqual(meas_ket, meas_gslc)
            self.assertAlmostEqual(prob_ket, prob_gslc)
            self.assertEqual(convert_to(ket, GSLCRepr), gslc)

    def test_stab_conversions(self):
        """Test for converting from some stabilizers"""
        # The cases here are edge cases that failed during development. Listed here as tests
        tests = [
            ([ns.H, ns.H], [[], []], [1], ns.X),
            ([ns.H * ns.Y, ns.Y], [[], []], [1], ns.H * ns.Y),
            ([ns.H * ns.Y, ns.S], [[], []], [1], ns.K),
            ([ns.I, ns.H, ns.I, ns.I], [[3], [2], [1, 3], [0, 2]], [3], ns.H * ns.K * ns.Z),
            ([ns.K, ns.H, ns.I], [[1], [0], []], [0, 2], ns.CZ),
            ([ns.S, ns.H, ns.S * ns.Z], [[2], [], [0]], [0], ns.K * ns.H * ns.Y),
            ([ns.I, ns.S * ns.Z, ns.I], [[1, 2], [0], [0]], [1], ns.K * ns.H * ns.Z),
            ([ns.Y, ns.I], [[], []], [1, 0], ns.CZ),
            ([ns.S, ns.S], [[], []], [0], ns.K * ns.H * ns.Y),
            ([ns.Z, ns.Z, ns.Y, ns.H * ns.Z], [[1, 3], [0], [], [0]], [1],
             ns.H * ns.K * ns.Y),
        ]
        for cliffs, edges, ind, op in tests:
            num_qubits = len(cliffs)
            stab = StabRepr(num_qubits=num_qubits)
            for q in range(num_qubits):
                stab.operate([q], ns.H)
            for i, edge in enumerate(edges):
                for j in edge:
                    if i < j:
                        stab.operate([i, j], ns.CZ)
            for i, cliff_op in enumerate(cliffs):
                stab.operate([i], cliff_op)

            # TODO: This has now become an identity test.
            gslc = convert_to(stab, GSLCRepr)
            self.assertEqual(convert_to(stab, GSLCRepr), gslc)
            stab.operate(ind, op)
            self.assertTrue(stab.is_valid)
            gslc = convert_to(stab, GSLCRepr)
            self.assertTrue(convert_to(stab, GSLCRepr), gslc)

    def test_single_equal(self):
        """Test comparing gslc states for single qubits"""
        # 6 lists of 4 cliffords,
        # each list corresponding to one of the 6 possible single qubit states
        # and with what clifford they can be represented with
        # The cases here are edge cases that failed during development. Listed here as tests
        equals = [[cliffords.CLIFF_I, cliffords.CLIFF_X, cliffords.CLIFF_KY, cliffords.CLIFF_KZ],
                  [cliffords.CLIFF_Y, cliffords.CLIFF_Z, cliffords.CLIFF_K, cliffords.CLIFF_KX],
                  [cliffords.CLIFF_S, cliffords.CLIFF_SX, cliffords.CLIFF_KH, cliffords.CLIFF_KHX],
                  [cliffords.CLIFF_SY, cliffords.CLIFF_SZ, cliffords.CLIFF_KHY, cliffords.CLIFF_KHZ],
                  [cliffords.CLIFF_H, cliffords.CLIFF_HX, cliffords.CLIFF_HKY, cliffords.CLIFF_HKZ],
                  [cliffords.CLIFF_HY, cliffords.CLIFF_HZ, cliffords.CLIFF_HK, cliffords.CLIFF_HKX]]
        for equal in equals:
            for i in range(4):
                for j in range(4):
                    assert GSLCRepr(local_cliffords=[equal[i]]) == GSLCRepr(local_cliffords=[equal[j]])
        for eq1 in equals:
            for eq2 in equals:
                if eq1 != eq2:
                    for i in range(4):
                        for j in range(4):
                            assert GSLCRepr(local_cliffords=[eq1[i]]) != GSLCRepr(local_cliffords=[eq2[j]])

    def test_mult_equal(self):
        """Test comparing gslc states with multiple qubits"""
        # The cases here are edge cases that failed during development. Listed here as tests
        I = cliffords.CLIFF_I
        H = cliffords.CLIFF_H
        X = cliffords.CLIFF_X
        Y = cliffords.CLIFF_Y
        Z = cliffords.CLIFF_Z
        ga = GSLCRepr(local_cliffords=[H, I, H], edges=[[1], [0, 2], [1]])
        ga2 = GSLCRepr(local_cliffords=[H, I, H], edges=[[1], [0, 2], [1]])
        gb = GSLCRepr(local_cliffords=[I, H, H], edges=[[1, 2], [0], [0]])
        gc = GSLCRepr(local_cliffords=[H, H, I], edges=[[2], [2], [0, 1]])
        self.assertEqual(ga, ga)
        self.assertEqual(ga, ga2)
        self.assertEqual(ga, gb)
        self.assertEqual(ga, gc)
        self.assertEqual(gb, gc)
        ga = GSLCRepr(local_cliffords=[I, I, I], edges=[[1, 2], [0], [0]])
        gb = GSLCRepr(local_cliffords=[I, Y, Z], edges=[[1, 2], [0], [0]])
        gc = GSLCRepr(local_cliffords=[X, X, I], edges=[[1, 2], [0], [0]])
        self.assertNotEqual(gslc2stab(ga), gslc2stab(gb))
        self.assertNotEqual(gslc2stab(ga), gslc2stab(gc))
        self.assertEqual(gslc2stab(gb), gslc2stab(gc))
        self.assertNotEqual(ga, gb)
        self.assertNotEqual(ga, gc)
        self.assertEqual(gb, gc)
        ga = GSLCRepr(local_cliffords=[H, I, I], edges=[[1, 2], [0], [0]])
        gb = GSLCRepr(local_cliffords=[I, I, H], edges=[[2], [2], [0, 1]])
        gc = GSLCRepr(local_cliffords=[I, H, I], edges=[[1], [0, 2], [1]])
        self.assertEqual(gslc2stab(ga), gslc2stab(gb))
        self.assertEqual(gslc2stab(ga), gslc2stab(gc))
        self.assertEqual(gslc2stab(gb), gslc2stab(gc))
        self.assertEqual(ga, gb)
        self.assertEqual(ga, gc)
        self.assertEqual(gb, gc)
        ga = GSLCRepr(local_cliffords=[I, I, X], edges=[[], [], []])
        gb = GSLCRepr(local_cliffords=[I, I, I], edges=[[], [], []])
        self.assertEqual(gslc2stab(ga), gslc2stab(gb))
        self.assertEqual(ga, gb)


class TestGSLC(TestDepQState, unittest.TestCase):
    """Unit tests for deprecated GSLCState class."""
    # DEPRECATED
    @disable_warn_deprecated
    def create_qstate(self, qubits, edges=None, local_cliffords=None):
        GSLCState(qubits, GSLCRepr(num_qubits=len(qubits), local_cliffords=local_cliffords, edges=edges))

    def test_CS_operation(self):
        """Test CS operation fails because it is not a Clifford."""
        with self.assertRaises(ValueError):
            super().test_CS_operation()

    def test_measure_gen_projective(self):
        """Test projective measurements fail because gmeasure is not defined."""
        with self.assertRaises(AttributeError):
            super().test_measure_gen_projective()

    def test_measure_gen_filter(self):
        """Test filter measurements fail because gmeasure is not defined."""
        with self.assertRaises(AttributeError):
            super().test_measure_gen_filter()

    def test_gmeasure_qubits(self):
        """Test gmeasure is not defined."""
        with self.assertRaises(AttributeError):
            super().test_gmeasure_qubits()

    def test_random_edge_cases_cliffords(self):
        """Test if some gslc correspond to the correct state after applying an two qubit operator"""
        # The cases here are edge cases that failed during development. Listed here as tests
        edge_cases = [
            ((0, 1), ns.CNOT, [[], []], [cliffords.CLIFF_I, cliffords.CLIFF_H]),
            ((2, 1), ns.CZ, [[1], [0], []], [cliffords.CLIFF_I, cliffords.CLIFF_I, cliffords.CLIFF_H]),
            ((1, 2), ns.CZ, [[1], [0], []], [cliffords.CLIFF_I, cliffords.CLIFF_I, cliffords.CLIFF_H]),
            ((2, 1), ns.CZ, [[1, 2], [0], [0]], [cliffords.CLIFF_KY, cliffords.CLIFF_HX, cliffords.CLIFF_H]),
            ((2, 0), ns.CZ, [[1, 2], [0, 2], [0, 1]], [cliffords.CLIFF_X, cliffords.CLIFF_KH, cliffords.CLIFF_KY]),
            ((2, 1), ns.CNOT, [[1], [0], []], [cliffords.CLIFF_I, cliffords.CLIFF_I, cliffords.CLIFF_H]),
            ((1, 2), ns.CNOT, [[1], [0], []], [cliffords.CLIFF_I, cliffords.CLIFF_I, cliffords.CLIFF_H]),
            ((2, 1), ns.CNOT, [[1, 2], [0], [0]], [cliffords.CLIFF_KY, cliffords.CLIFF_HX, cliffords.CLIFF_H]),
            ((2, 0), ns.CNOT, [[1, 2], [0, 2], [0, 1]], [cliffords.CLIFF_X, cliffords.CLIFF_KH, cliffords.CLIFF_KY]),
        ]
        for qubits, operation, init_edges, init_cliffords in edge_cases:
            qubits_ket = _build_ket(init_edges, init_cliffords)
            qform.set_qstate_formalism(qform.QFormalism.GSLC)
            qubits_gslc = qapi.create_qubits(len(init_cliffords))
            qapi.combine_qubits(qubits_gslc)
            qapi.assign_qstate(qubits_gslc, GSLCRepr(local_cliffords=init_cliffords, edges=init_edges))
            self.assertTrue(_is_same_state(qubits_ket, qubits_gslc))
            qapi.operate([qubits_ket[i] for i in qubits], operation)
            qapi.operate([qubits_gslc[i] for i in qubits], operation)
            self.assertTrue(_is_same_state(qubits_ket, qubits_gslc))

    def test_random_edge_cases_measurements(self):
        """Test if some gslc correspond to the correct state before and after measurement"""
        # The cases here are edge cases that failed during development. Listed here as tests
        edge_cases = [
            [1, ns.Z, [[1], [0, 2], [1]], [cliffords.CLIFF_I, cliffords.CLIFF_H, cliffords.CLIFF_I], 74882745],
            [1, ns.Y, [[2, 1], [0], [0]], [cliffords.CLIFF_I, cliffords.CLIFF_KHX, cliffords.CLIFF_KHZ], 141426907],
            [0, ns.Z, [[1], [0]], [cliffords.CLIFF_SY, cliffords.CLIFF_Z], 370338054],
            [0, ns.X, [[1], [0]], [cliffords.CLIFF_Y, cliffords.CLIFF_Z], 1465931193],
            [0, ns.Y, [[]], [cliffords.CLIFF_I], 2],
            [0, ns.Y, [[]], [cliffords.CLIFF_I], 4],
            [0, ns.Y, [[1], [0]], [cliffords.CLIFF_I, cliffords.CLIFF_I], 4],
            [0, ns.Y, [[1], [0]], [cliffords.CLIFF_H, cliffords.CLIFF_H], 1442877925],
            [0, ns.Y, [[1], [0]], [cliffords.CLIFF_I, cliffords.CLIFF_KY], 1442877925],
            [0, ns.Z, [[]], [cliffords.CLIFF_H], 0],
            [0, ns.Z, [[]], [cliffords.CLIFF_I], 0],
            [0, ns.Z, [[]], [cliffords.CLIFF_HKX], 0],
            [0, ns.Y, [[]], [cliffords.CLIFF_I], 2],
            [0, ns.Y, [[]], [cliffords.CLIFF_I], 4],
            [0, ns.Y, [[], []], [cliffords.CLIFF_I, cliffords.CLIFF_I], 2],
            [0, ns.Y, [[], []], [cliffords.CLIFF_I, cliffords.CLIFF_I], 4],
            [0, ns.Y, [[]], [cliffords.CLIFF_H], 2],
            [0, ns.Y, [[]], [cliffords.CLIFF_H], 2],
            [0, ns.Y, [[], []], [cliffords.CLIFF_H, cliffords.CLIFF_H], 1692412510],
            [1, ns.X, [[], []], [cliffords.CLIFF_H, cliffords.CLIFF_HY], 2042842779],
            [0, ns.X, [[], []], [cliffords.CLIFF_HY, cliffords.CLIFF_H], 1525965839],
            [1, ns.Y, [[], [2], [1]], [cliffords.CLIFF_KHY, cliffords.CLIFF_KH, cliffords.CLIFF_I], 862048137],
            [1, ns.X, [[2], [2], [1, 0]], [cliffords.CLIFF_SZ, cliffords.CLIFF_I, cliffords.CLIFF_I], 1770426639],
            [0, ns.Z, [[1, 2], [0], [0]], [cliffords.CLIFF_I, cliffords.CLIFF_I, cliffords.CLIFF_I], 4],
            [0, ns.Z, [[1, 2], [0], [0]], [cliffords.CLIFF_I, cliffords.CLIFF_I, cliffords.CLIFF_I], 2],
            [0, ns.Z, [[1], [0], []], [cliffords.CLIFF_Z, cliffords.CLIFF_H, cliffords.CLIFF_H], 532723995]
        ]
        for q_meas, observable, init_edges, init_cliffords, seed in edge_cases:
            qubits_ket = _build_ket(init_edges, init_cliffords)
            qform.set_qstate_formalism(qform.QFormalism.GSLC)
            qubits_gslc = qapi.create_qubits(len(init_cliffords))
            qapi.combine_qubits(qubits_gslc)
            qapi.assign_qstate(qubits_gslc, GSLCRepr(local_cliffords=init_cliffords, edges=init_edges))
            self.assertTrue(_is_same_state(qubits_ket, qubits_gslc))
            ket_ket = _normalize_ket(qubits_ket[0].qstate.ket)
            ket_gslc = _normalize_ket(qubits_gslc[0].qstate.ket)
            diff = ket_ket - ket_gslc
            self.assertTrue(np.allclose(diff, 0))
            qstate_ket = qubits_ket[q_meas].qstate
            _, meas_ket, prob_ket = qstate_ket.qrepr.measure(qstate_ket.indices_of([qubits_ket[q_meas]])[0], observable,
                                                             rng=CustomRNG(seed), modify=True)
            qstate_gslc = qubits_gslc[q_meas].qstate
            _, meas_gslc, prob_gslc = qstate_gslc.qrepr.measure(qstate_gslc.indices_of([qubits_gslc[q_meas]])[0], observable,
                                                                rng=CustomRNG(seed), modify=True)
            self.assertAlmostEqual(meas_ket, meas_gslc)
            self.assertAlmostEqual(prob_ket, prob_gslc)
            ket_ket = _normalize_ket(qubits_ket[0].qstate.ket)
            ket_gslc = _normalize_ket(qubits_gslc[0].qstate.ket)
            diff = ket_ket - ket_gslc
            self.assertTrue(np.allclose(diff, 0))

    @disable_warn_deprecated
    def test_stab_conversions(self):
        """Test for converting from some stabilizers"""
        # The cases here are edge cases that failed during development. Listed here as tests
        tests = [
            ([ns.H, ns.H], [[], []], [1], ns.X),
            ([ns.H * ns.Y, ns.Y], [[], []], [1], ns.H * ns.Y),
            ([ns.H * ns.Y, ns.S], [[], []], [1], ns.K),
            ([ns.I, ns.H, ns.I, ns.I], [[3], [2], [1, 3], [0, 2]], [3], ns.H * ns.K * ns.Z),
            ([ns.K, ns.H, ns.I], [[1], [0], []], [0, 2], ns.CZ),
            ([ns.S, ns.H, ns.S * ns.Z], [[2], [], [0]], [0], ns.K * ns.H * ns.Y),
            ([ns.I, ns.S * ns.Z, ns.I], [[1, 2], [0], [0]], [1], ns.K * ns.H * ns.Z),
            ([ns.Y, ns.I], [[], []], [1, 0], ns.CZ),
            ([ns.S, ns.S], [[], []], [0], ns.K * ns.H * ns.Y),
            ([ns.Z, ns.Z, ns.Y, ns.H * ns.Z], [[1, 3], [0], [], [0]], [1],
             ns.H * ns.K * ns.Y),
        ]
        for cliffs, edges, ind, op in tests:
            ns.qubits.set_qstate_formalism(ns.qubits.QFormalism.STAB)
            qubits = ns.qubits.create_qubits(len(cliffs))
            ns.qubits.combine_qubits(qubits)
            stab = qubits[0].qstate.stabilizer
            for q in qubits:
                ns.qubits.operate(q, ns.H)
            for i, edge in enumerate(edges):
                for j in edge:
                    if i < j:
                        ns.qubits.operate([qubits[i], qubits[j]], ns.CZ)
            for i, cliff_op in enumerate(cliffs):
                ns.qubits.operate(qubits[i], cliff_op)

            gslc = convert_to(stab, GSLCRepr)
            gslc_ket = _normalize_ket(_build_ket(gslc.edges, gslc.cliffords)[0].qstate.ket)
            stab_ket = _normalize_ket(qubits[0].qstate.ket)
            self.assertTrue(np.allclose(gslc_ket, stab_ket))
            qs = [qubits[i] for i in ind]
            ns.qubits.operate(qs, op)
            self.assertTrue(stab.is_valid)
            gslc = convert_to(stab, GSLCRepr)
            gslc_ket = _normalize_ket(_build_ket(gslc.edges, gslc.cliffords)[0].qstate.ket)
            stab_ket = _normalize_ket(qubits[0].qstate.ket)
            self.assertTrue(np.allclose(gslc_ket, stab_ket))

    def test_single_equal(self):
        """Test comparing gslc states for single qubits"""
        # 6 lists of 4 cliffords,
        # each list corresponding to one of the 6 possible single qubit states
        # and with what clifford they can be represented with
        # The cases here are edge cases that failed during development. Listed here as tests
        equals = [[cliffords.CLIFF_I, cliffords.CLIFF_X, cliffords.CLIFF_KY, cliffords.CLIFF_KZ],
                  [cliffords.CLIFF_Y, cliffords.CLIFF_Z, cliffords.CLIFF_K, cliffords.CLIFF_KX],
                  [cliffords.CLIFF_S, cliffords.CLIFF_SX, cliffords.CLIFF_KH, cliffords.CLIFF_KHX],
                  [cliffords.CLIFF_SY, cliffords.CLIFF_SZ, cliffords.CLIFF_KHY, cliffords.CLIFF_KHZ],
                  [cliffords.CLIFF_H, cliffords.CLIFF_HX, cliffords.CLIFF_HKY, cliffords.CLIFF_HKZ],
                  [cliffords.CLIFF_HY, cliffords.CLIFF_HZ, cliffords.CLIFF_HK, cliffords.CLIFF_HKX]]
        for equal in equals:
            for i in range(4):
                for j in range(4):
                    assert GSLCRepr(local_cliffords=[equal[i]]) == GSLCRepr(local_cliffords=[equal[j]])
        for eq1 in equals:
            for eq2 in equals:
                if eq1 != eq2:
                    for i in range(4):
                        for j in range(4):
                            assert GSLCRepr(local_cliffords=[eq1[i]]) != GSLCRepr(local_cliffords=[eq2[j]])

    @disable_warn_deprecated
    def test_mult_equal(self):
        """Test comparing gslc states with multiple qubits"""
        # The cases here are edge cases that failed during development. Listed here as tests
        I = cliffords.CLIFF_I
        H = cliffords.CLIFF_H
        X = cliffords.CLIFF_X
        Y = cliffords.CLIFF_Y
        Z = cliffords.CLIFF_Z
        ga = GSLCRepr(local_cliffords=[H, I, H], edges=[[1], [0, 2], [1]])
        ga2 = GSLCRepr(local_cliffords=[H, I, H], edges=[[1], [0, 2], [1]])
        gb = GSLCRepr(local_cliffords=[I, H, H], edges=[[1, 2], [0], [0]])
        gc = GSLCRepr(local_cliffords=[H, H, I], edges=[[2], [2], [0, 1]])
        self.assertEqual(ga, ga)
        self.assertEqual(ga, ga2)
        self.assertEqual(ga, gb)
        self.assertEqual(ga, gc)
        self.assertEqual(gb, gc)
        ga = GSLCRepr(local_cliffords=[I, I, I], edges=[[1, 2], [0], [0]])
        gb = GSLCRepr(local_cliffords=[I, Y, Z], edges=[[1, 2], [0], [0]])
        gc = GSLCRepr(local_cliffords=[X, X, I], edges=[[1, 2], [0], [0]])
        self.assertNotEqual(gslc2stab(ga), gslc2stab(gb))
        self.assertNotEqual(gslc2stab(ga), gslc2stab(gc))
        self.assertEqual(gslc2stab(gb), gslc2stab(gc))
        self.assertNotEqual(ga, gb)
        self.assertNotEqual(ga, gc)
        self.assertEqual(gb, gc)
        ga = GSLCRepr(local_cliffords=[H, I, I], edges=[[1, 2], [0], [0]])
        gb = GSLCRepr(local_cliffords=[I, I, H], edges=[[2], [2], [0, 1]])
        gc = GSLCRepr(local_cliffords=[I, H, I], edges=[[1], [0, 2], [1]])
        self.assertEqual(gslc2stab(ga), gslc2stab(gb))
        self.assertEqual(gslc2stab(ga), gslc2stab(gc))
        self.assertEqual(gslc2stab(gb), gslc2stab(gc))
        self.assertEqual(ga, gb)
        self.assertEqual(ga, gc)
        self.assertEqual(gb, gc)
        ga = GSLCRepr(local_cliffords=[I, I, X], edges=[[], [], []])
        gb = GSLCRepr(local_cliffords=[I, I, I], edges=[[], [], []])
        self.assertEqual(gslc2stab(ga), gslc2stab(gb))
        self.assertEqual(ga, gb)


if __name__ == '__main__':
    unittest.main()
