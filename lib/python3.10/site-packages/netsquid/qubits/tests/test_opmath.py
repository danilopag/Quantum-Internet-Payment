# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_opmath.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the opmath module.

"""
import unittest
import numpy as np
from netsquid.qubits.opmath import padded_matrix
import netsquid as ns


class TestOpmath(unittest.TestCase):
    """Unit tests for the opmath module.

    """

    def test_simple_cnot_padding(self):
        matrix = padded_matrix(ns.CNOT, [0, 1], 3, force_sparse=True)
        data = np.real_if_close(matrix.data)
        indices = np.real_if_close(matrix.indices)
        indptr = np.real_if_close(matrix.indptr)
        self.assertEqual(len(data), 8)
        self.assertTrue(np.allclose(data, np.array([1, 1, 1, 1, 1, 1, 1, 1])))
        self.assertTrue(np.allclose(indptr, [0, 1, 2, 3, 4, 5, 6, 7, 8]))
        self.assertTrue(np.allclose(indices, np.array([0, 1, 2, 3, 6, 7, 4, 5])))

        matrix = padded_matrix(ns.CNOT, [1, 0], 3, force_sparse=True)
        data = np.real_if_close(matrix.data)
        indices = np.real_if_close(matrix.indices)
        indptr = np.real_if_close(matrix.indptr)
        self.assertEqual(len(data), 8)
        self.assertTrue(np.allclose(data, np.array([1, 1, 1, 1, 1, 1, 1, 1])))
        self.assertTrue(np.allclose(indptr, [0, 1, 2, 3, 4, 5, 6, 7, 8]))
        self.assertTrue(np.allclose(indices, np.array([0, 1, 6, 7, 4, 5, 2, 3])))

        matrix = padded_matrix(ns.CNOT, [0, 2], 3, force_sparse=True)
        # matrix = sparse_kron_identity_middle(ns.CNOT.csr, 0, 2)
        data = np.real_if_close(matrix.data)
        indices = np.real_if_close(matrix.indices)
        indptr = np.real_if_close(matrix.indptr)
        self.assertEqual(len(data), 8)
        self.assertTrue(np.allclose(data, np.array([1, 1, 1, 1, 1, 1, 1, 1])))
        self.assertTrue(np.allclose(indptr, [0, 1, 2, 3, 4, 5, 6, 7, 8]))
        self.assertTrue(np.allclose(indices, np.array([0, 1, 2, 3, 5, 4, 7, 6])))

        matrix = padded_matrix(ns.CNOT, [2, 0], 3, force_sparse=True)
        data = np.real_if_close(matrix.data)
        indices = np.real_if_close(matrix.indices)
        indptr = np.real_if_close(matrix.indptr)
        self.assertEqual(len(data), 8)
        self.assertTrue(np.allclose(data, np.array([1, 1, 1, 1, 1, 1, 1, 1])))
        self.assertTrue(np.allclose(indptr, [0, 1, 2, 3, 4, 5, 6, 7, 8]))
        self.assertTrue(np.allclose(indices, np.array([0, 5, 2, 7, 4, 1, 6, 3])))

        matrix = padded_matrix(ns.CNOT, [1, 2], 3, force_sparse=True)
        data = np.real_if_close(matrix.data)
        indices = np.real_if_close(matrix.indices)
        indptr = np.real_if_close(matrix.indptr)
        self.assertEqual(len(data), 8)
        self.assertTrue(np.allclose(data, np.array([1, 1, 1, 1, 1, 1, 1, 1])))
        self.assertTrue(np.allclose(indptr, [0, 1, 2, 3, 4, 5, 6, 7, 8]))
        self.assertTrue(np.allclose(indices, np.array([0, 1, 3, 2, 4, 5, 7, 6])))

        matrix = padded_matrix(ns.CNOT, [2, 1], 3, force_sparse=True)
        data = np.real_if_close(matrix.data)
        indices = np.real_if_close(matrix.indices)
        indptr = np.real_if_close(matrix.indptr)
        self.assertEqual(len(data), 8)
        self.assertTrue(np.allclose(data, np.array([1, 1, 1, 1, 1, 1, 1, 1])))
        self.assertTrue(np.allclose(indptr, [0, 1, 2, 3, 4, 5, 6, 7, 8]))
        self.assertTrue(np.allclose(indices, np.array([0, 3, 2, 1, 4, 7, 6, 5])))

    def test_incorrect_padding(self):
        with self.assertRaises(ValueError):
            padded_matrix(ns.CNOT, [0, 2], num_qubits=-1)
        with self.assertRaises(ValueError):
            padded_matrix(ns.CNOT, [0, 2], num_qubits=1)
        with self.assertRaises(ValueError):
            padded_matrix(ns.CNOT, [0], num_qubits=2)
        with self.assertRaises(ValueError):
            padded_matrix(ns.H, [0, 2], num_qubits=1)
        with self.assertRaises(ValueError):
            padded_matrix(ns.H, [0, 2], num_qubits=3)


if __name__ == "__main__":
    unittest.main()
