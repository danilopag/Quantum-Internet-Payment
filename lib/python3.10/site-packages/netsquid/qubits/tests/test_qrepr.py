# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_qrepr.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import abc
import unittest
import numpy as np

from netsquid.qubits.qrepr import QRepr, convert_to, ConversionError, register_conversion, deregister_conversion
from netsquid.qubits.kettools import KetRepr
from netsquid.qubits.gslctools import GSLCRepr
from netsquid.qubits import qformalism as qform
from netsquid.qubits import qubitapi as qapi
from netsquid.qubits import ketstates as ks
from netsquid.qubits import ketutil as ku
from netsquid.qubits import operators as ops


class TestConversion(unittest.TestCase):
    """Test conversion between QRepr subclasses."""

    def setUp(self) -> None:
        qform.set_qstate_formalism(qform.QFormalism.KET)

    def test_identity_conversion(self):
        """Test conversion to the same representation is identical."""
        for formalism in qform.QFormalism:
            qrepr = formalism(num_qubits=1)
            self.assertEqual(qrepr, convert_to(qrepr, formalism))

    def test_non_qrepr_states(self):
        """Test expected errors when an attempt is made to convert invalid representations."""
        with self.assertRaises(TypeError):
            convert_to('a', qform.QFormalism.KET)
        with self.assertRaises(TypeError):
            convert_to(np.array([[0], [1]]), qform.QFormalism.KET)
        with self.assertRaises(TypeError):
            convert_to(qapi.create_qubits(1), float)
        with self.assertRaises(TypeError):
            convert_to(qapi.create_qubits(1), np.ndarray)

    def test_conversion_error(self):
        """Test unregistered conversion raise a ConversionError."""
        class TestRepr(KetRepr):
            pass
        testrepr = TestRepr(num_qubits=1)
        ketrepr = KetRepr(num_qubits=1)
        with self.assertRaises(ConversionError):
            convert_to(ketrepr, TestRepr)
        with self.assertRaises(ConversionError):
            convert_to(testrepr, KetRepr)
        register_conversion(TestRepr, KetRepr, lambda x: KetRepr(x.ket))
        with self.assertRaises(ConversionError):
            convert_to(ketrepr, TestRepr)
        self.assertEqual(ketrepr, convert_to(testrepr, KetRepr))
        register_conversion(KetRepr, TestRepr, lambda x: TestRepr(x.ket))
        self.assertEqual(testrepr, convert_to(ketrepr, TestRepr))
        deregister_conversion(TestRepr, KetRepr)
        with self.assertRaises(ConversionError):
            convert_to(testrepr, KetRepr)
        deregister_conversion(KetRepr, TestRepr)
        with self.assertRaises(ConversionError):
            convert_to(ketrepr, TestRepr)

    def test_none_conversion(self):
        """Test conversion using None states."""
        for formalism in qform.QFormalism:
            self.assertIsNone(convert_to(None, formalism))


class TestQRepr(metaclass=abc.ABCMeta):
    """Abstract base class for a test class of a ``QRepr`` qrepr.

    Defines test methods that check basic functionality of a QRepr instance.

    """

    @abc.abstractmethod
    def create_qrepr(self, num_qubits=None, **kwargs) -> QRepr:
        pass

    def test_init(self):
        """Test initialization is correct."""
        for i in range(1, 10):
            repr1 = self.create_qrepr(num_qubits=i)
            self.assertEqual(i, repr1.num_qubits)

    @abc.abstractmethod
    def test_assign_qrepr(self):
        pass

    def test_attributes(self):
        qrepr = self.create_qrepr(num_qubits=1)
        self.assertIsNotNone(type(qrepr).supports_universal)
        self.assertIsNotNone(type(qrepr).supports_mixed_states)
        qrepr.__deepcopy__()

    def test_create_in_basis(self):
        """Test creating in a particular basis."""
        qrepr = self.create_qrepr(num_qubits=1)
        qrepr_type = type(qrepr)
        qrepr_s0 = qrepr_type.create_in_basis([0])
        self.assertEqual(qrepr, qrepr_s0)
        qrepr.operate([0], ops.H, modify=True)
        qrepr_h0 = qrepr_type.create_in_basis([0], ops.X)
        self.assertEqual(qrepr, qrepr_h0)
        qrepr.operate([0], ops.S, modify=True)
        qrepr_y0 = qrepr_type.create_in_basis([0], ops.Y)
        self.assertEqual(qrepr, qrepr_y0)
        qrepr.operate([0], ops.Z, modify=True)
        qrepr_y1 = qrepr_type.create_in_basis([1], ops.Y)
        self.assertEqual(qrepr, qrepr_y1)
        qrepr.operate([0], ops.S.inv, modify=True)
        qrepr_x1 = qrepr_type.create_in_basis([1], ops.X)
        self.assertEqual(qrepr, qrepr_x1)
        qrepr.operate([0], ops.H, modify=True)
        qrepr_s1 = qrepr_type.create_in_basis([1], ops.Z)
        self.assertEqual(qrepr, qrepr_s1)

        with self.assertRaises(IndexError):
            qrepr_type.create_in_basis([2])
        with self.assertRaises(TypeError):
            qrepr_type.create_in_basis([0], ops.Z.arr)
        with self.assertRaises(ValueError):
            qrepr_type.create_in_basis([0], ops.S)
        with self.assertRaises(ValueError):
            qrepr_type.create_in_basis([0], ops.CNOT)
        with self.assertRaises(ValueError):
            qrepr_type.create_in_basis([])
        rot_op = ops.create_rotation_op(np.pi / 4)
        qrepr = self.create_qrepr(num_qubits=1)
        if qrepr_type.supports_universal:
            qrepr.operate([0], rot_op, modify=True)
            new_qrepr = qrepr_type.create_in_basis([0], rot_op * ops.Z * rot_op.inv)
            self.assertEqual(qrepr, new_qrepr)
        else:
            with self.assertRaises(NotImplementedError):
                qrepr_type.create_in_basis([5], ops.I)

    def test_measure(self):
        """Test expected failures for measurement."""
        repr1 = self.create_qrepr(num_qubits=2)
        with self.assertRaises(ValueError):
            repr1.measure(2)
        with self.assertRaises(TypeError):
            repr1.measure([0, 1])
        with self.assertRaises(ValueError):
            repr1.measure(-1)
        with self.assertRaises(ValueError):
            repr1.measure(0, observable=ops.S)
        with self.assertRaises(ValueError):
            repr1.measure(0, observable=ops.SWAP)

    def test_gmeasure(self):
        """Test expected failures for gmeasure."""
        repr1 = self.create_qrepr(num_qubits=2)
        if isinstance(repr1, GSLCRepr):
            return
        repr1, m, p = repr1.gmeasure(0, ops.Z)
        self.assertEqual(0, m)
        self.assertAlmostEqual(1., p)
        repr1, m_x, p = repr1.gmeasure(1, ops.X)
        self.assertAlmostEqual(.5, p)
        repr1, m, p = repr1.gmeasure([0, 1], ops.Z ^ ops.X)
        self.assertEqual(m_x, m)
        self.assertAlmostEqual(1., p)
        if not repr1.supports_universal:
            with self.assertRaises(RuntimeError):
                repr1.gmeasure(0, ops.Z.projectors)
            return
        repr1.gmeasure(0, tuple(ops.Z.projectors))
        repr1.gmeasure(0, list(ops.Z.projectors))
        repr1.gmeasure((0,), ops.Z.projectors)
        repr1.gmeasure([0], ops.Z.projectors)
        repr1.gmeasure([0, 1], (ops.X ^ ops.X).projectors)
        with self.assertRaises(ValueError):
            repr1.gmeasure([2], ops.Z.projectors)
        with self.assertRaises(ValueError):
            repr1.gmeasure([0, 1], ops.Z.projectors)
        with self.assertRaises(ValueError):
            repr1.gmeasure([-1], ops.Z.projectors)
        with self.assertRaises(RuntimeError):
            repr1.gmeasure([0], operators=ops.S)

    def test_merge_data(self):
        """Test merging data."""
        repr1 = self.create_qrepr(num_qubits=1)
        repr2 = self.create_qrepr(num_qubits=2)
        self.assertEqual(1, repr1.num_qubits)
        self.assertEqual(2, repr2.num_qubits)
        repr3, __ = repr1.smart_tensor(repr2)
        self.assertEqual(3, repr3.num_qubits)
        self.assertEqual(1, repr1.num_qubits)
        self.assertEqual(2, repr2.num_qubits)
        repr4, __ = repr2.smart_tensor(repr2)
        self.assertEqual(4, repr4.num_qubits)
        self.assertEqual(3, repr3.num_qubits)
        self.assertEqual(2, repr2.num_qubits)
        self.assertEqual(1, repr1.num_qubits)

    def test_operate(self):
        """Test operating."""
        repr12 = self.create_qrepr(num_qubits=2)
        repr1z2 = repr12.operate([0], ops.Z)
        self.assertEqual(repr12, repr1z2)
        self.assertIsNot(repr12, repr1z2)
        repr1z2z = repr12.operate([1], ops.Z)
        self.assertEqual(repr1z2z, repr1z2)
        self.assertEqual(repr1z2z, repr12)
        repr1x2 = repr12.operate([0], ops.X)
        self.assertNotEqual(repr1x2, repr12)
        repr_mod = repr12.operate([0], ops.X, modify=True)
        self.assertIs(repr_mod, repr12)
        with self.assertRaises(ValueError):
            repr12.operate([0, 1, 2], ops.X)
        with self.assertRaises(ValueError):
            repr12.operate([0], ops.CNOT)

    def test_xor(self):
        """Test the kronecker product operator."""
        repr1 = self.create_qrepr(num_qubits=1)
        repr2 = self.create_qrepr(num_qubits=2)
        repr4 = repr1 ^ repr2 ^ repr1
        self.assertEqual(4, repr4.num_qubits)
        ket = np.kron(ks.s00, ks.s00)
        dm = ku.ket2dm(ket)
        self.assertTrue(np.allclose(dm, repr4.reduced_dm()))

    def test_drop_qubit(self):
        """Test dropping qubits."""
        repr1 = self.create_qrepr(num_qubits=3)
        self.assertEqual(3, repr1.num_qubits)
        with self.assertRaises(ValueError):
            repr1.discard(3)
        repr2 = repr1.discard(1)
        self.assertEqual(3, repr1.num_qubits)
        self.assertEqual(2, repr2.num_qubits)
        repr3 = repr2.discard(1)
        self.assertEqual(3, repr1.num_qubits)
        self.assertEqual(2, repr2.num_qubits)
        self.assertEqual(1, repr3.num_qubits)
        # Dropping the last qubit of a qstate doesn't change the qstate
        repr4 = repr3.discard(0)
        self.assertEqual(0, repr4.num_qubits)

    def test_equality(self):
        repr1 = self.create_qrepr(num_qubits=1)
        repr2 = self.create_qrepr(num_qubits=2)
        repr3 = self.create_qrepr(num_qubits=1)
        self.assertEqual(repr1, repr1)
        self.assertEqual(repr1, repr3)
        self.assertEqual(repr3, repr1)
        self.assertNotEqual(repr1, repr2)
        self.assertNotEqual(repr2, repr1)
        self.assertNotEqual(repr2, repr3)
        self.assertNotEqual(repr3, repr2)

        class FakeQRepr:
            num_qubits = 1
        repr4 = FakeQRepr()
        self.assertNotEqual(repr1, repr4)
        self.assertNotEqual(repr4, repr1)
        self.assertNotEqual(repr3, repr4)
        self.assertNotEqual(repr4, repr3)

    def test_reduced_dm(self):
        """Test reduced_dm is implemented in the subclass."""
        repr1 = self.create_qrepr(num_qubits=1)
        self.assertTrue(np.allclose(repr1.reduced_dm(), np.asarray([[1, 0], [0, 0]])))
        repr2 = self.create_qrepr(num_qubits=2)
        repr2.operate([0], ops.H, modify=True)
        self.assertTrue(np.allclose(repr2.reduced_dm([0]), np.asarray([[1/2, 1/2], [1/2, 1/2]])))
        self.assertTrue(np.allclose(repr2.reduced_dm([1]), np.asarray([[1, 0], [0, 0]])))

    def test_measure_discard(self):
        qrepr = self.create_qrepr(num_qubits=2)
        self.assertEqual(2, qrepr.num_qubits)
        qrepr, m, p = qrepr.measure_discard(1)
        self.assertEqual(1, p)
        self.assertEqual(0, m)
        self.assertEqual(1, qrepr.num_qubits)

    def test_fidelity(self):
        qrepr = self.create_qrepr(num_qubits=2)
        self.assertEqual(qrepr.fidelity(qrepr), 1)
        with self.assertRaises(ValueError):
            qrepr.fidelity(self.create_qrepr(num_qubits=1))
