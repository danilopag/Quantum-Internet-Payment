# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: ketstates.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"""Defines some common ket state vectors.

"""
import numpy as np
from enum import IntEnum
__all__ = [
    "s0", "s1", "h0", "h1", "y0", "y1",
    "s00", "s01", "s10", "s11",
    "h00", "h01", "h10", "h11",
    "b00", "b01", "b10", "b11",
    "BellIndex", "bell_states",
]

# single qubit standard (computational) basis (evecs Z operator)

s0 = np.array([[1], [0]], dtype=complex)  # |0>
r""":math:`\vert 0\rangle`"""

s1 = np.array([[0], [1]], dtype=complex)  # |1>
r""":math:`\vert 1\rangle`"""

h0 = np.array([[1], [1]], dtype=complex) / np.sqrt(2)  # |+>
r""":math:`\vert +\rangle = \frac{1}{\sqrt{2}}\left(\vert 0\rangle + \vert 1\rangle \right)`"""

h1 = np.array([[1], [-1]], dtype=complex) / np.sqrt(2)  # |->
r""":math:`\vert -\rangle = \frac{1}{\sqrt{2}}\left(\vert 0\rangle - \vert 1\rangle \right)`"""

y0 = np.array([[1], [1j]], dtype=complex) / np.sqrt(2)  # |0_Y>
r""":math:`\vert 0_Y\rangle = \frac{1}{\sqrt{2}}\left(\vert 0\rangle + i\vert 1\rangle \right)`"""

y1 = np.array([[1], [-1j]], dtype=complex) / np.sqrt(2)  # |1_Y>
r""":math:`\vert 1_Y\rangle = \frac{1}{\sqrt{2}}\left(\vert 0\rangle - i\vert 1\rangle \right)`"""

# two qubits standard (computational) basis
s00 = np.kron(s0, s0)  # |00>
s01 = np.kron(s0, s1)  # |01>
s10 = np.kron(s1, s0)  # |10>
s11 = np.kron(s1, s1)  # |11>

# two qubits X basis states
h00 = np.kron(h0, h0)  # |++>
h01 = np.kron(h0, h1)  # |+->
h10 = np.kron(h1, h0)  # |-+>
h11 = np.kron(h1, h1)  # |-->

# two qubits Y basis states
y00 = np.kron(y0, y0)
y01 = np.kron(y0, y1)
y10 = np.kron(y1, y0)
y11 = np.kron(y1, y1)

# Bell (EPR) states
b00 = (s00 + s11) / np.sqrt(2)
r""":math:`\vert \beta_{00}\rangle = \frac{1}{\sqrt{2}}\left(\vert 00\rangle + \vert 11\rangle \right)`"""

b01 = (s01 + s10) / np.sqrt(2)
r""":math:`\vert \beta_{01}\rangle = \frac{1}{\sqrt{2}}\left(\vert 01\rangle + \vert 10\rangle \right)`"""

b10 = (s00 - s11) / np.sqrt(2)
r""":math:`\vert \beta_{10}\rangle = \frac{1}{\sqrt{2}}\left(\vert 00\rangle - \vert 11\rangle \right)`"""

b11 = (s01 - s10) / np.sqrt(2)
r""":math:`\vert \beta_{11}\rangle = \frac{1}{\sqrt{2}}\left(\vert 01\rangle - \vert 10\rangle \right)`"""


class BellIndex(IntEnum):
    r"""Indices corresponding to the four Bell states defined in :py:obj:`~netsquid.qubits.ketstates.bell_states`.

    Attributes
    ----------
    B00 : int
        The index corresponding to :math:`\frac{1}{\sqrt{2}} \left( \vert 00 \rangle + \vert 11 \rangle \right)`
    B01 : int
        The index corresponding to :math:`\frac{1}{\sqrt{2}} \left( \vert 01 \rangle + \vert 10 \rangle \right)`
    B11 : int
        The index corresponding to :math:`\frac{1}{\sqrt{2}} \left( \vert 01 \rangle - \vert 10 \rangle \right)`
    B10 : int
        The index corresponding to :math:`\frac{1}{\sqrt{2}} \left( \vert 00 \rangle - \vert 11 \rangle \right)`
    PHI_PLUS : int
        The index corresponding to :math:`\frac{1}{\sqrt{2}} \left( \vert 00 \rangle + \vert 11 \rangle \right)`.
        Identical to B00.
    PSI_PLUS : int
        The index corresponding to :math:`\frac{1}{\sqrt{2}} \left( \vert 01 \rangle + \vert 10 \rangle \right)`.
        Identical to B01.
    PSI_MINUS : int
        The index corresponding to :math:`\frac{1}{\sqrt{2}} \left( \vert 01 \rangle - \vert 10 \rangle \right)`.
        Identical to B11.
    PHI_MINUS : int
        The index corresponding to :math:`\frac{1}{\sqrt{2}} \left( \vert 00 \rangle - \vert 11 \rangle \right)`
        Identical to B10.


    Notes
    -----
    The values correspond to the measurement operators, and thus must always be the values 0, 1, 2 or 3.

    """
    B00 = 0  # |00> + |11>
    B01 = 1  # |01> + |10>
    B11 = 2  # |01> - |10>
    B10 = 3  # |00> - |11>
    PHI_PLUS = 0  # |00> + |11>
    PSI_PLUS = 1  # |01> + |10>
    PSI_MINUS = 2  # |01> - |10>
    PHI_MINUS = 3  # |00> - |11>


bell_states = {
    BellIndex.B00: b00,
    BellIndex.B01: b01,
    BellIndex.B10: b10,
    BellIndex.B11: b11
}
"""The dictionary of four Bell states, indexed using BellIndex."""
