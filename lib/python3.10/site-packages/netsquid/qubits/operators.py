# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: operators.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Defines the quantum ``Operator`` class and some common quantum operators.
This allows users to define operators in a convenient representation
while shielding them from the internal representation used for arithmetic,
which can vary between quantum state formalisms.

Examples
--------
Some of classes and functions in this module provide example code snippets.
These snippets should run unedited if you set up a Python
interpreter with the following imports:

>>> from netsquid.qubits.ketstates import s0, h1, b00
>>> from netsquid.qubits.operators import *
>>> import numpy as np

"""
import math
import numpy as np
from numbers import Number
from scipy import sparse
from scipy import linalg
import scipy.sparse.linalg as splinalg

from netsquid.qubits import sparseutil as sputil
from netsquid.util.cycache import LruCache
from netsquid.util.cymath import correct_global_phase
from netsquid.qubits.cliffords import Clifford
from netsquid.qubits import cliffords
from netsquid.qubits import ketstates as ks

__all__ = [
    "caching_enabled",
    "Operator",
    "create_rotation_op",
    "I", "X", "Y", "Z", "H", "K", "S", "T",
    "CX", "CNOT", "CCX", "TOFFOLI",
    "CZ", "CS", "SWAP",
    "Rx90", "Rx180", "Rx270",
    "Ry90", "Ry180", "Ry270",
    "Rz90", "Rz180", "Rz270",
    "BELL_PROJECTORS"
]

caching_enabled = True
"""bool: Whether caching of padded matrix operators is enabled."""


class Operator:
    """Class representing a quantum linear operator.

    Parameters
    ----------
    name : str
        Name for identification.
    matrix : array_like or :py:obj:`~netsquid.qubits.operators.Operator`
        Matrix representation of operator to create. If an
        :class:`~netsquid.qubits.operators.Operator`
        is specified, its matrix representation is used.
        If a :class:`scipy.sparse.spmatrix` is specified, the
        :attr:`~netsquid.qubits.operators.Operator.use_sparse` property is
        set to True (see also notes below).
    description : str, optional
        Description of operator.
        Default the empty string "".
    cacheable : bool, optional
        Whether padded representations of this operator should be cached.
        Default True.
    clifford : :obj:`~netsquid.qubits.cliffords.Clifford` or None, optional
        The clifford operation that corresponds to this operator.
        Used to perform operations more efficiently in the stabiliser formalisms
        Default None.

    Attributes
    ----------
    cacheable : bool
        Whether padded representations of this operator should be cached.

    Notes
    -----
        If the operator has :attr:`~netsquid.qubits.operators.Operator.use_sparse` set to True,
        it will avoid converting to or using a dense matrix representation whenever possible.
        In some cases this is unavoidable, and calling :attr:`~netsquid.qubits.operators.Operator.arr`
        will create a dense matrix representation that is stored for future calls.

        Some methods, such as :func:`~netsquid.qubits.opmath.padded_matrix` and
        :func:`~netsquid.qubits.stabtools.clifford_transform` are
        computationally expensive and can have their results cached. To take
        advantage of caching, :py:obj:`~netsquid.qubits.operators.Operator`\\s
        should be reused within simulations
        as much as possible. In other words, avoid dynamically creating single
        use operators where possible.

        The *Python operators* ``*``, ``+``, ``-``, ``/``, and ``^`` are
        overloaded, and will return a new operator. The ``^`` operator
        computes the tensor product of two :py:obj:`~netsquid.qubits.operators.Operator`\\s.

    Examples
    --------

    Constructing a new operator using a numpy array:

    >>> theta = np.pi/8
    >>> R = Operator("R", np.cos(theta) * I.arr - 1j * np.sin(theta) * X.arr)
    >>> print(R.name)
    R
    >>> print(R.arr)
    [[0.92387...+0.j         0.        -0.38268...j]
     [0.        -0.38268...j 0.92387...+0.j        ]]

    Using arithmetic operators to construct a new operator using existing operators:

    >>> Op = Y * (X + Z)/4j
    >>> print(Op.name)
    ((Y*(X+Z))/(0.00+4.00j))
    >>> print(Op.arr)
    [[-0.25-0.j  0.25+0.j]
     [ 0.25+0.j  0.25+0.j]]

    >>> theta = np.pi/8
    >>> R = np.cos(theta) * I - 1j * np.sin(theta) * X
    >>> print(R.name)
    (((0.92)*I)-((0.00+0.38j)*X))
    >>> print(R.arr)
    [[0.92387...+0.j         0.        -0.38268...j]
     [0.        -0.38268...j 0.92387...+0.j        ]]

    Note that the easiest way to create a rotation matrix is with
    the :py:obj:`~netsquid.qubits.operators.create_rotation_op` function.

    Using the tensor product operator ``^`` to construct a new operator:

    >>> Op = X ^ Z
    >>> print(Op.name)
    (X^Z)
    >>> print(Op.arr)
    [[ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]
     [ 0.+0.j -0.+0.j  0.+0.j -1.+0.j]
     [ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]
     [ 0.+0.j -1.+0.j  0.+0.j -0.+0.j]]

    To operate on qubit(s) use the qubitapi:

    >>> from netsquid.qubits.qubitapi import create_qubits, operate
    >>> q1, q2 = create_qubits(2)
    >>> operate(q1, H)
    >>> operate([q1, q2], CNOT)

    To measure a qubit using a Hermitian observable:

    >>> from netsquid.qubits.qubitapi import create_qubits, measure
    >>> q1, = create_qubits(1)
    >>> measure(q1, Z)
    (0, 1.0)
    >>> measure(q1, X)
    (..., 0.499...)

    """

    def __init__(self, name, matrix, description="", cacheable=True, clifford=None):
        self._description = description
        self.name = name
        self.cacheable = cacheable
        self._clifford = None
        self.clifford = clifford
        self._matrix = None
        self._spmatrix = None
        if isinstance(matrix, Operator):
            self._matrix = matrix._matrix
            self._spmatrix = matrix._spmatrix
            self._num_qubits = matrix._num_qubits
            self.use_sparse = matrix.use_sparse
        elif isinstance(matrix, np.ndarray) or isinstance(matrix, list):
            self._matrix = np.array(matrix, dtype=complex)
            self._num_qubits = int(math.log2(self._matrix.shape[0]))
            self.use_sparse = False
        elif isinstance(matrix, sparse.spmatrix):
            self._spmatrix = sparse.csr_matrix(matrix, dtype=complex)
            self._num_qubits = int(math.log2(self._spmatrix.shape[0]))
            self.use_sparse = True
        else:
            raise TypeError("Operator matrix is a {}, which is not a matrix or not supported".format(type(matrix)))
        self._caches = {}
        self._real = None
        self._unitary = None
        self._hermitian = None
        self._projective = None
        self._evals = None
        self._estates = None
        self._projectors = None
        self._controlled = None
        self._inverse = None
        self._complex_conj = None

    @property
    def name(self):
        """str: name of operator for identification."""
        return self._name

    @name.setter
    def name(self, identifier):
        if not isinstance(identifier, str) or len(identifier) == 0:
            raise TypeError("{} is invalid operator name. Should be string with length > 0".format(identifier))
        self._name = identifier

    @property
    def description(self):
        """str: description of operator."""
        return self._description

    @property
    def num_qubits(self):
        """int: number of qubits this operators acts on."""
        return self._num_qubits

    @property
    def use_sparse(self):
        """bool: whether to use a sparse matrix representation whenever possible."""
        return self._use_sparse

    @use_sparse.setter
    def use_sparse(self, value):
        if not isinstance(value, bool):
            raise TypeError("{} is not a bool".format(value))
        self._use_sparse = value

    def get_cache(self, cache_id):
        """Return a LRU (Least Recently Used) cache for the given id.

        If no cache exists a new one is created.

        Parameters
        ----------
        cache_id : any immutable
            Cache identifier.

        Returns
        -------
        :obj:`~netsquid.netsquid.cyutil.cycache.LruCache`
            Cache matching the id, otherwise a new empty cache.

        """
        return self._caches.setdefault(cache_id, LruCache())

    @property
    def is_clifford(self):
        """bool: True if this Operator has a Clifford operation defined"""
        return self._clifford is not None

    @property
    def clifford(self):
        """:obj:`~netsquid.qubits.cliffords.Clifford`: The Clifford operator equivalent to this operation"""
        return self._clifford

    @clifford.setter
    def clifford(self, clifford):
        """Set the Clifford operation of this operation.

        No checks are performed if the clifford is correct.

        Parameters
        ----------
        clifford: :obj:`~netsquid.qubits.cliffords.Clifford`:

        """
        if clifford is not None and not isinstance(clifford, Clifford):
            raise TypeError(f"'clifford' should be a {Clifford.__name__} not {type(clifford).__name__}")
        self._clifford = clifford

    @property
    def is_unitary(self):
        """bool: True if operator is unitary."""
        if self._unitary is None:
            if not self.use_sparse:
                if self._matrix.shape[0] != self._matrix.shape[1]:
                    self._unitary = False
                else:
                    dim = self._matrix.shape[0]
                    eye = np.eye(dim, dtype=complex)
                    matrixH = np.transpose(np.conjugate(self._matrix))
                    self._unitary = (np.allclose(matrixH @ self._matrix, eye) and
                                     np.allclose(self._matrix @ matrixH, eye))
            else:
                if self._spmatrix.shape[0] != self._spmatrix.shape[1]:
                    self._unitary = False
                else:
                    dim = self._spmatrix.shape[0]
                    eye = sparse.eye(dim, dtype=complex)
                    matrixH = sputil.sparse_fast_conj(self._spmatrix).transpose()
                    self._unitary = (sputil.sparse_allclose(matrixH @ self._spmatrix, eye) and
                                     sputil.sparse_allclose(self._spmatrix @ matrixH, eye))

        return self._unitary

    @property
    def is_hermitian(self):
        """bool: True if operator is hermitian."""
        if self._hermitian is None:
            if not self.use_sparse:
                matrixH = np.transpose(np.conjugate(self._matrix))
                self._hermitian = np.allclose(matrixH, self._matrix)
            else:
                matrixH = sputil.sparse_fast_conj(self._spmatrix).transpose()
                self._hermitian = sputil.sparse_allclose(matrixH, self._spmatrix)
        return self._hermitian

    @property
    def is_projective(self):
        """bool: True if operator is projective."""
        if self._projective is None:
            if not self.use_sparse:
                self._projective = np.allclose(self._matrix * self._matrix, self._matrix)
            else:
                self._projective = sputil.sparse_allclose(self._spmatrix * self._spmatrix, self._spmatrix)
        return self._projective

    @property
    def is_real(self):
        """bool: True if operator is purely real."""
        if self._real is None:
            if self.use_sparse:
                self._real = sputil.sparse_allreal(self._spmatrix)
            else:
                self._real = np.all(np.isreal(self._matrix))
        return self._real

    @property
    def arr(self):
        """:obj:`~numpy.array`: array representation of operator."""
        if self._matrix is None:
            self._matrix = self._spmatrix.toarray()
        return self._matrix

    @property
    def csr(self):
        """:obj:`~sparse.csr_matrix`: sparse matrix representation of operator."""
        if self._spmatrix is None:
            self._spmatrix = sparse.csr_matrix(self._matrix, dtype=complex)
        return self._spmatrix

    @property
    def ctrl(self):
        """Return a controlled version of this operator.

        Returns
        -------
        :obj:`~ns.qubits.operators.Operator`
            The controlled operator.

        Notes
        -----
            The controlled operator adopts the same ``cacheable`` state as this
            operator.

        Example
        -------
            Create a controlled ``T`` gate:

            >>> CT = T.ctrl
            >>> print(CT.name)
            CT
            >>> print(CT.arr)  # doctest: +SKIP
            [[ 1.+0.j      0.+0.j      0.+0.j      0.+0.j            ]
             [ 0.+0.j      1.+0.j      0.+0.j      0.+0.j            ]
             [ 0.+0.j      0.+0.j      1.+0.j      0.+0.j            ]
             [ 0.+0.j      0.+0.j      0.+0.j      0.707...+0.707...j]]

        """
        if self._controlled is None:
            self._controlled = Operator._create_controlled_op(operator=self, cacheable=self.cacheable)
        return self._controlled

    @property
    def inv(self):
        """Return an operator that is the inverse of this operator.

        Equivalent to the complex conjugate for unitary operators.

        If the operator is its own inverse then this operator is returned.

        Returns
        -------
        :obj:`~ns.qubits.operators.Operator`
            The inverse operator.

        Notes
        -----
            The returned operator adopts the same ``cacheable`` state as this
            operator.

            The inverse of the new inverse operator is this operator object.

        Example
        -------
            Create an rotation gate:

            >>> Ry90Inv = Ry90.inv
            >>> print(Ry90Inv.name)
            R_y(pi/2)^{-1}
            >>> np.allclose(Ry90.arr @ Ry90Inv.arr, np.eye(2))
            True

        """
        if self._inverse is None:
            name = "{}^{{-1}}".format(self.name)
            descr = "Inverse of: {}".format(self.description)
            cliff = None
            if self.is_clifford:
                cliff = self.clifford.dagger
            # arr = np.linalg.inv(self.arr)
            if self.use_sparse:
                matrix = splinalg.inv(sparse.csc_matrix(self._spmatrix))
                allclose = sputil.sparse_allclose(matrix, self._spmatrix)
            else:
                matrix = np.linalg.inv(self.arr)
                allclose = np.allclose(matrix, self.arr)
            if allclose:
                # self inverse
                self._inverse = self
            else:
                self._inverse = Operator(name=name, matrix=matrix, description=descr,
                                         cacheable=self.cacheable, clifford=cliff)
            self._inverse._inverse = self
            self._inverse._real = self._real
        return self._inverse

    @property
    def conj(self):
        """Return an operator that is the complex conjugate of this operator.

        If the operator is real then this operator is returned.

        Returns
        -------
        :obj:`~ns.qubits.operators.Operator`
            The complex conjugate operator.

        Notes
        -----
            The returned operator adopts the same ``cacheable`` state as this
            operator.

            The complex conjugate of the new operator is this operator object.

        Example
        -------
            Create an rotation gate:

            >>> Rz90Conj = Rz90.conj
            >>> print(Rz90Conj.name)
            R_z(pi/2)*

        """
        if self._complex_conj is None:
            if self.is_real:
                self._complex_conj = self
            else:
                if self.use_sparse:
                    matrix = sputil.sparse_fast_conj(self._spmatrix)
                else:
                    matrix = np.conj(self._matrix)
                name = "{}*".format(self.name)
                descr = "Complex conjugate of: {}".format(self.description)
                self._complex_conj = Operator(name=name, matrix=matrix, description=descr,
                                              cacheable=self.cacheable)
                self._complex_conj._complex_conj = self
        return self._complex_conj

    def _compute_eig(self):
        # Compute eigenvalues and eigenvectors
        # and store in descending eval order
        self._evals = []
        self._estates = []
        # NOTE sparse methods can't find all eigenvalues of a matrix, so using dense methods
        # TODO is expensive hermitian check worth it here?
        if self.is_hermitian:
            w, v = linalg.eigh(self.arr)
            # if self.use_sparse:
            #    w, v = splinalg.eigsh(self.csr)
        else:
            # if not self.use_sparse:
            w, v = linalg.eig(self.arr)
            # if self.use_sparse:
            #    w, v = splinalg.eigs(self.csr)
        for i in range(v.shape[1]):
            self._evals.append(w[i])
            eigenket = np.array(correct_global_phase(v[:, i]), dtype=complex)
            eigenket = np.reshape(eigenket, (len(eigenket), 1))
            self._estates.append(eigenket)
        if self.is_hermitian:
            self._evals = self._evals[::-1]
            self._estates = self._estates[::-1]
        else:
            # order in descending eval order
            order = np.array(self._evals).argsort()[::-1]
            self._evals = [self._evals[i] for i in order]
            self._estates = [self._estates[i] for i in order]

    @property
    def eigenkets(self):
        """list of :obj:`~numpy.array`: list of ket eigenstate vectors.

        Returned in descending order of eigenvalues.

        Notes
        -----
        Is only well-defined if all eigenvalues are unique.

        """
        if self._estates is None:
            self._compute_eig()
        return self._estates

    @property
    def eigenvals(self):
        """list of complex: list of eigenvalues.

        Returned in descending eigenvalue order.

        """
        if self._evals is None:
            self._compute_eig()
        return self._evals

    @property
    def projectors(self):
        """tuple of :py:obj:`~netsquid.qubits.operators.Operator`: decomposition into
        projectors assuming this operator is Hermitian.

        Returned in descending eigenvalue order.

        If the operator has degenerate eigenvalues they are collapsed to a single projector.

        Raises
        ------
        RuntimeError
            If operator is not Hermitian.

        """
        if self._projectors is None:
            if not self.is_hermitian:
                raise RuntimeError("Cannot compute projectors for non-Hermitian operator.")
            if self._estates is None:
                self._compute_eig()
            # Get multiplicity of eigenvalues
            eval_counter = {}
            for eval in self._evals:
                for key in eval_counter.keys():
                    if math.isclose(eval, key):
                        eval_counter[key] += 1
                        break
                else:
                    eval_counter[eval] = 1
            # Calculate the projectors
            projectors = []
            idx = 0
            p_name = 0
            for eval, multiplicity in eval_counter.items():
                _projector = None
                for i in range(idx, idx + multiplicity):
                    ket = self._estates[i]
                    if self.use_sparse:
                        # Compute sparse projection operators
                        ket = sparse.csr_matrix(ket)
                        ketH = sputil.sparse_fast_conj(ket).transpose()
                        mat = ket @ ketH
                    else:
                        ketH = np.conjugate(np.transpose(ket))
                        mat = np.matmul(ket, ketH)
                    if _projector is None:
                        _projector = mat
                    else:
                        _projector += mat
                idx += multiplicity
                projectors.append(Operator(f"P{p_name}", _projector))
                p_name += 1
            self._projectors = tuple(projectors)
        return self._projectors

    def __eq__(self, other):
        if not isinstance(other, Operator):
            raise TypeError
        if not self.num_qubits == other.num_qubits:
            return False
        if self.use_sparse or other.use_sparse:
            return sputil.sparse_allclose(self.csr, other.csr)
        else:
            return np.allclose(self.arr, other.arr)

    def __neq__(self, other):
        return not self.__eq__(other)

    def __add__(self, other):
        if isinstance(other, Operator):
            other_name = other.name
            if other.use_sparse or self.use_sparse:
                other = other.csr
            else:
                other = other.arr
        else:
            other_name = "?"
        return Operator(f"({self.name}+{other_name})",
                        (self.csr if self.use_sparse else self.arr) + other)

    def __radd__(self, other):
        if isinstance(other, Operator):
            other_name = other.name
            if other.use_sparse or self.use_sparse:
                other = other.csr
            else:
                other = other.arr
        else:
            other_name = "?"
        return Operator(f"({other_name}+{self.name})",
                        other + (self.csr if self.use_sparse else self.arr))

    def __sub__(self, other):
        if isinstance(other, Operator):
            other_name = other.name
            if other.use_sparse or self.use_sparse:
                other = other.csr
            else:
                other = other.arr
        else:
            other_name = "?"
        return Operator(f"({self.name}-{other_name})",
                        (self.csr if self.use_sparse else self.arr) - other)

    def __rsub__(self, other):
        if isinstance(other, Operator):
            other_name = other.name
            if other.use_sparse or self.use_sparse:
                other = other.csr
            else:
                other = other.arr
        else:
            other_name = "?"
        return Operator(f"({other_name}-{self.name})",
                        other - (self.csr if self.use_sparse else self.arr))

    def __mul__(self, other):
        circuit = None
        if isinstance(other, Operator):
            if self.is_clifford and other.is_clifford:
                circuit = self.clifford * other.clifford
            other_name = other.name
            if other.use_sparse or self.use_sparse:
                other = other.csr
            else:
                other = other.arr
        elif isinstance(other, Number):
            other_name = "({:.2f})".format(other)
        else:
            other_name = "?"
        if isinstance(other, sparse.spmatrix) or self.use_sparse:
            dot = self.csr.dot(other)
        else:
            dot = np.dot(self.arr, other)
        return Operator(f"({self.name}*{other_name})", dot, clifford=circuit)

    def __rmul__(self, other):
        clifford = None
        if isinstance(other, Operator):
            if self.is_clifford and other.is_clifford:
                clifford = other.clifford * self.clifford
            other_name = other.name
            if other.use_sparse or self.use_sparse:
                other = other.csr
            else:
                other = other.arr
        elif isinstance(other, Number):
            other_name = "({:.2f})".format(other)
        else:
            other_name = "?"
        if isinstance(other, sparse.spmatrix):
            dot = other.dot(self.csr)
        elif isinstance(other, np.ndarray):
            dot = np.dot(other, self.arr)
        elif self.use_sparse:
            dot = other * self.csr
        else:
            dot = other * self.arr
        return Operator(f"({other_name}*{self.name})", dot, clifford=clifford)

    def __truediv__(self, other):
        if isinstance(other, Operator):
            raise ValueError("Cannot divide an Operator with an Operator")
        else:
            return Operator("({}/({:.2f}))".format(self.name, other),
                            (self._spmatrix if self.use_sparse else self._matrix) / other)

    def __xor__(self, other):
        # tensor product
        clifford = None
        if isinstance(other, Operator):
            if self.is_clifford and other.is_clifford:
                clifford = self.clifford ^ other.clifford
            other_name = other.name
            if other.use_sparse or self.use_sparse:
                other = other.csr
            else:
                other = other.arr
        else:
            other_name = "?"
        if isinstance(other, sparse.spmatrix) or self.use_sparse:
            xor = sparse.kron(self.csr, other)
        else:
            xor = np.kron(self.arr, other)
        return Operator(f"({self.name}^{other_name})", xor, clifford=clifford)

    def __rxor__(self, other):
        # tensor product (reversed)
        circuit = None
        if isinstance(other, Operator):
            if self.is_clifford and other.is_clifford:
                circuit = other.clifford.copy()
                for indices, clifford in self.clifford:
                    new_indices = tuple(i + other.num_qubits for i in indices)
                    circuit.append((new_indices, clifford))
            other_name = other.name
            if other.use_sparse or self.use_sparse:
                other = other.csr
            else:
                other = other.arr
        else:
            other_name = "?"
        if isinstance(other, sparse.spmatrix) or self.use_sparse:
            xor = sparse.kron(other, self.csr)
        else:
            xor = np.kron(other, self.arr)
        return Operator(f"({other_name}^{self.name})", xor, clifford=circuit)

    def __repr__(self):
        mat = self.arr if not self.use_sparse else self.csr
        return "Operator({!r}, {!r})".format(self.name, mat)

    # def __str__(self):
    #    return "{}".format(np.around(np.real_if_close(self._spmatrix if self._spmatrix is not None else self._matrix),
    #                                 decimals=4))

    @classmethod
    def _create_controlled_op(cls, operator, cacheable=True):
        # Create a controlled gate for the specified operator
        name = "C{}".format(operator.name)
        description = "Controlled {} gate: q1 = control, q2 = target".format(operator.name)
        if not isinstance(operator, Operator):
            raise TypeError
        if operator.use_sparse:
            dim = operator._spmatrix.shape[0]
            eye_matrix = sparse.eye(dim, dtype=complex)
            control_matrix = sparse.block_diag([eye_matrix, operator._spmatrix])
        else:
            dim = operator.arr.shape[0]
            eye_matrix = np.eye(dim, dtype=complex)
            control_matrix = linalg.block_diag(eye_matrix, operator.arr)
        return cls(name, control_matrix, description=description, cacheable=cacheable)


def create_rotation_op(angle, rotation_axis=(1, 0, 0), conjugate=False,
                       name=None, cacheable=True):
    r"""Create a single-qubit rotation operator.

    The resulting operator rotates a single-qubit state by the specified
    ``angle`` around the ``rotation_axis`` on the Bloch sphere.

    Parameters
    ----------
    angle : float
        Rotation angle in radians.
    rotation_axis : tuple, list or np.array of float, optional
        Unit vector representing the rotation axis.
    conjugate : bool, optional
        Whether to complex conjugate the rotation matrix.
    name : str or None, optional
        Name for identification. If None, a default name is
        set based on the given rotation parameters.
    cacheable : bool, optional
        Whether padded representations of this operator should be cached.

    Returns
    -------
    :py:obj:`~netsquid.qubits.operators.Operator`
        Rotation operator.

    Notes
    -----
        ``rotation_axis`` will be normalized if it is not already.

        The rotation operator corresponds to

        .. math::

            R_{\hat{n}}(\theta) = \cos\left(\frac{\theta}{2}\right) I
            - i\, \sin\left(\frac{\theta}{2}\right)
            \left(n_x X + n_y Y + n_z Z \right)

        where :math:`\hat{n}` is the ``rotation_axis`` and :math:`\theta` is the ``angle``.

    Examples
    --------

        >>> Rx = create_rotation_op(np.pi/2, (1, 0, 0))
        >>> print(Rx.name)
        R_x[1.57]
        >>> print(Rx.description)
        Rotation of 1.57 rad about x axis
        >>> print(Rx.arr)
        [[0.70710678+0.j         0.        -0.70710678j]
         [0.        -0.70710678j 0.70710678+0.j        ]]

        >>> R = create_rotation_op(np.pi/4, (1, 1, 0), conjugate=True)
        >>> print(R.name)
        R_(0.71,0.71,0.00)[0.79]*
        >>> print(R.description)
        Complex conjugate of: Rotation of 0.79 rad about (0.71,0.71,0.00) axis
        >>> print(R.arr)
        [[ 0.92387953-0.j         -0.27059805+0.27059805j]
         [ 0.27059805+0.27059805j  0.92387953-0.j        ]]

    """
    raxis = np.array(rotation_axis, dtype=float)
    # normalize rotation axis if needed
    L2 = linalg.norm(raxis)
    if not math.isclose(L2, 1):
        raxis = np.array(raxis) / L2
    # calculate rotation matrix
    nsigma = raxis[0] * X.arr + raxis[1] * Y.arr + raxis[2] * Z.arr
    rot_matrix = np.cos(angle / 2) * I.arr - 1j * np.sin(angle / 2) * nsigma
    # set name and description
    if math.isclose(raxis[0], 1):
        axis_str = "x"
    elif math.isclose(raxis[1], 1):
        axis_str = "y"
    elif math.isclose(raxis[2], 1):
        axis_str = "z"
    else:
        axis_str = "(" + ",".join(['{:.2f}'.format(f) for f in raxis]) + ")"
    if name is None:
        name = "R_{}[{:.2f}]".format(axis_str, angle)
    description = "Rotation of {:.2f} rad about {} axis".format(angle, axis_str)
    R = Operator(name, rot_matrix, description=description, cacheable=cacheable)
    if conjugate:
        R = R.conj
    return R


def check_measurement_operators(meas_operators):
    """Check the validity of a list of a measurement operators.

    Checks for valid and consistent types and that the completeness relation is satisfied.
    Raises appropriate exception if input is invalid.

    Parameters
    ----------
    operators : list (or tuple) of :class:`~netsquid.qubits.operators.Operator`
        List of measurement operators with which to measure, or a single observable, i.e. an operator with valid projectors.

    Raises
    ------
    TypeError
        If not a valid list of operators.
    ValueError
        If the operators a are checked and don't satisfy the constraints.

    Notes
    -----
        Implemented using the dense matrix representation of the operators.

    """
    if not isinstance(meas_operators, (list, tuple)):
        raise TypeError("Not a list or tuple")
    for op in meas_operators:
        if not isinstance(op, Operator):
            raise TypeError("The listed operators should be of type Operator.")
    num_qubits = meas_operators[0].num_qubits
    for op in meas_operators[1:]:
        if op.num_qubits != num_qubits:
            raise ValueError("The operators do not all have the same size.")
    # TODO support also "use_sparse" functionality of Operator for efficiency
    total = sum(op.conj.arr @ op.arr for op in meas_operators)  # Note: Numpy advises to use sum here.
    if not np.allclose(total, np.eye(2 ** num_qubits)):
        raise ValueError("The measurement operators don't sum to the identity matrix.")


I = Operator("I", np.array([[1, 0], [0, 1]]), clifford=cliffords.CLIFF_I)
r""":math:`I = \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix}`"""

X = Operator("X", np.array([[0, 1], [1, 0]]), clifford=cliffords.CLIFF_X)
r""":math:`X = \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}`"""

Y = Operator("Y", np.array([[0, -1j], [1j, 0]]), clifford=cliffords.CLIFF_Y)
r""":math:`Y = \begin{bmatrix} 0 & -i \\ i & 0 \end{bmatrix}`"""

Z = Operator("Z", np.array([[1, 0], [0, -1]]), clifford=cliffords.CLIFF_Z)
r""":math:`Z = \begin{bmatrix} 1 & 0 \\ 0 & -1 \end{bmatrix}`"""

H = Operator("H", (X + Z) / np.sqrt(2), clifford=cliffords.CLIFF_H)
r""":math:`H = \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\ 1 & -1 \end{bmatrix}`"""

K = Operator("K", (Y + Z) / np.sqrt(2), clifford=cliffords.CLIFF_K)
r""":math:`K = \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & -i \\ i & -1 \end{bmatrix}`"""

S = Operator("S", np.array([[1, 0], [0, 1j]]), clifford=cliffords.CLIFF_S)
r""":math:`S = \begin{bmatrix} 1 & 0 \\ 0 & i \end{bmatrix}`"""

T = Operator("T", np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]]))
r""":math:`T = \begin{bmatrix} 1 & 0 \\ 0 & e^{i\pi/4} \end{bmatrix}`"""

CX = X.ctrl
r""":math:`\text{CX = CNOT} = \begin{bmatrix} I & \\ & X \end{bmatrix}`"""
CX.clifford = (cliffords.CLIFF_I ^ cliffords.CLIFF_H) * cliffords.CLIFF_CZ * (cliffords.CLIFF_I ^ cliffords.CLIFF_H)

CNOT = CX
# NOTE no need for a second docstring

CCX = CX.ctrl
r""":math:`\text{CCX = TOFFOLI} = \begin{bmatrix} I & \\ & CX \end{bmatrix}`"""

TOFFOLI = CNOT.ctrl
# NOTE no need for a second docstring

CZ = Z.ctrl
r""":math:`\text{CZ} = \begin{bmatrix} I & \\ & Z \end{bmatrix}`"""
CZ.clifford = cliffords.CLIFF_CZ

CS = S.ctrl
r""":math:`\text{CS} = \begin{bmatrix} I & \\ & S \end{bmatrix}`"""

SWAP = Operator("SWAP", np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]]),
                description="Swap gate", clifford=cliffords.CLIFF_SWAP)
r""":math:`\text{SWAP} = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}`

Note: qubit *swapping* is handled internally i.e. it is generally not necessary for a user to perform SWAP operations.

"""

Rx90 = create_rotation_op(np.pi / 2, rotation_axis=(1, 0, 0), name="R_x(pi/2)", cacheable=True)
Rx90.clifford = cliffords.CLIFF_KY
r""":math:`Rx90 = \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & -1j \\ -1j & 1 \end{bmatrix}`"""

Rx180 = create_rotation_op(np.pi, rotation_axis=(1, 0, 0), name="R_x(pi)", cacheable=True)
Rx180.clifford = cliffords.CLIFF_X
r""":math:`Rx180 = \begin{bmatrix} 0 & -1j \\ -1j & 0 \end{bmatrix}`"""

Rx270 = create_rotation_op(np.pi * 3 / 2, rotation_axis=(1, 0, 0), name="R_x(pi*3/2)", cacheable=True)
Rx270.clifford = cliffords.CLIFF_KZ
r""":math:`Rx270 = \frac{1}{\sqrt{2}} \begin{bmatrix} -1 & -1j \\ -1j & -1 \end{bmatrix}`"""

Ry90 = create_rotation_op(np.pi / 2, rotation_axis=(0, 1, 0), name="R_y(pi/2)", cacheable=True)
Ry90.clifford = cliffords.CLIFF_HZ
r""":math:`Ry90 = \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & -1 \\ 1 & 1 \end{bmatrix}`"""

Ry180 = create_rotation_op(np.pi, rotation_axis=(0, 1, 0), name="R_y(pi)", cacheable=True)
Ry180.clifford = cliffords.CLIFF_Y
r""":math:`Ry180 = \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix}`"""

Ry270 = create_rotation_op(np.pi * 3 / 2, rotation_axis=(0, 1, 0), name="R_y(pi*3/2)", cacheable=True)
Ry270.clifford = cliffords.CLIFF_HX
r""":math:`Ry270 = \frac{1}{\sqrt{2}} \begin{bmatrix} -1 & -1 \\ 1 & -1 \end{bmatrix}`"""

Rz90 = create_rotation_op(np.pi / 2, rotation_axis=(0, 0, 1), name="R_z(pi/2)", cacheable=True)
Rz90.clifford = cliffords.CLIFF_S
r""":math:`Rz90 = \frac{1}{\sqrt{2}} \begin{bmatrix} 1 - 1j & 0 \\ 0 & 1 + 1j \end{bmatrix}`"""

Rz180 = create_rotation_op(np.pi, rotation_axis=(0, 0, 1), name="R_z(pi)", cacheable=True)
Rz180.clifford = cliffords.CLIFF_Z
r"""\\( Rz180 = \\begin{bmatrix} -1j & 0 \\\\\\ 0 & 1j \\end{bmatrix} \\)"""

Rz270 = create_rotation_op(np.pi * 3 / 2, rotation_axis=(0, 0, 1), name="R_z(pi*3/2)", cacheable=True)
Rz270.clifford = cliffords.CLIFF_SZ
r""":math:`Rz270 = \frac{1}{\sqrt{2}} \begin{bmatrix} -1 - 1j & 0 \\ 0 & -1 + 1j \end{bmatrix}`"""


def _create_bell_projector(bell_index):
    # Create a bell projector for a certain instance of BellIndex
    ket = ks.bell_states[bell_index]
    projector = np.matmul(ket, np.conjugate(np.transpose(ket)))  # Too small for sparse
    return Operator(f"P_{bell_index.name}", projector)


BELL_PROJECTORS = tuple(_create_bell_projector(bell_index) for bell_index in ks.BellIndex)
r"""tuple: The projectors on the bell basis in the order of the BellIndex."""
