# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: qubit.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""The :obj:`~netsquid.qubits.qubit.Qubit` class that holds a single qubit
within a quantum state. Qubits are intended to be sent around the quantum
network. The held quantum state can be shared with other qubits, and can grow
or shrink as qubits are combined or split. The formalism used to implement
the quantum state, e.g. ket vectors or stabilizers, is in principle hidden from
the user.

"""


class Qubit:
    """Class that holds a single qubit within a (shared) quantum state.

    The `Qubit` instance is intended to stay persistent while the quantum state changes.

    Parameters
    ----------
    name : str
       Name for the qubit -- should be unique within the shared QState.

    Attributes
    ----------
    is_number_state : bool
        Whether qubit represents a number state e.g. the presence or absence
        of a photon. If so, a quantum channel may not actually discard the
        qubit when it is lost, but rather amplitude dampen it.

    Notes
    -----
        Because a *number state* qubit is intended to be amplitude dampened by a
        channel loss model, this setting will not work with stabilizer quantum
        states.

    """
    def __init__(self, name):
        self._name = name
        self._qstate = None
        self.is_number_state = False

    @property
    def name(self):
        """str: Name for the qubit."""
        return self._name

    @name.setter
    def name(self, value):
        self._name = value

    @property
    def qstate(self):
        """:obj:`~netsquid.qubits.qstate.QState`: (shared) quantum state of this qubit.

        Can be ``None`` if the qubit has not yet been initialized or it has been
        discarded.

        For most uses cases it is better to make use of the :mod:`~netsquid.qubits.qubitapi` module
        rather than accessing the quantum state directly.

        """
        return self._qstate

    @qstate.setter
    def qstate(self, value):
        self._qstate = value

    def combine(self, other_qubit):
        """Join the quantum state of this qubit with that of another.

        Parameters
        ----------
        other_qubit : :obj:`Qubit`
            The other qubit to combine with.

        Raises
        ------
        RuntimeError
            If either qubit is not holding a quantum state.

        Notes
        -----
            If the qubits already share the same quantum states then nothing
            is done.

        """
        if self._qstate is None or other_qubit._qstate is None:
            raise RuntimeError("Both qubits must be holding a quantum state (QState)")
        if self._qstate is not other_qubit._qstate:
            self._qstate.combine_qstate(other_qubit._qstate)

    def __repr__(self):
        return "Qubit({!r})".format(self.name)

    @property
    def _index(self):
        # Return the index of the held qubit in its quantum state.
        # Used only for unit testing.
        if self._qstate is not None:
            return self._qstate.indices[self.name]
        else:
            raise RuntimeError("Not holding a quantum state (QState)")
