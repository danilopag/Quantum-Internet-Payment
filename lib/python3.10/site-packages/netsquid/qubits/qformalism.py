# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: qformalism.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - Iñaki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Definition of the available quantum state formalisms and functions that manipulate them.

A *formalism* is an implementation (subclass) of a *quantum state representation* (:class:`~netsquid.qubits.qrepr.QRepr`)
that is used to represent the *quantum states* (:class:`~netsquid.qubits.qstate.QState`) shared by qubit objects (:class:`~netsquid.qubits.qubit.Qubit`).
While we sometimes use the terms *formalism* and *representation* interchangeably,
the latter more broadly refers to representations of quantum states that are not fixed to a :class:`~netsquid.qubits.qstate.QState` object.

The default formalism is :attr:`~netsquid.qubits.qformalism.QFormalism.KET`.

Overview
--------

When simulating a quantum state on a classical computer
there are different ways to represent this quantum state and perform operations on it.
In NetSquid these representations are implemented using five formalisms:

 - :attr:`~netsquid.qubits.qformalism.QFormalism.DM` corresponding to the :class:`~netsquid.qubits.dmtools.DenseDMRepr` representation,
 - :attr:`~netsquid.qubits.qformalism.QFormalism.SPARSEDM` corresponding to the :class:`~netsquid.qubits.sparsedmtools.SparseDMRepr` representation,
 - :attr:`~netsquid.qubits.qformalism.QFormalism.KET` corresponding to the :class:`~netsquid.qubits.kettools.KetRepr` representation,
 - :attr:`~netsquid.qubits.qformalism.QFormalism.STAB` corresponding to the :class:`~netsquid.qubits.stabtools.StabRepr` representation,
 - :attr:`~netsquid.qubits.qformalism.QFormalism.GSLC` corresponding to the :class:`~netsquid.qubits.gslctools.GSLCRepr` representation.

When deciding on a formalism it is useful to know what the advantages and disadvantages are of
each formalism.

Here is an overview to help you pick the right one.


.. list-table:: Formalisms
   :header-rows: 1
   :align: center

   * -
     - DM
     - SPARSEDM
     - KET
     - STAB
     - GSLC
   * - Universal
     - Yes
     - Yes
     - Yes
     - No
     - No
   * - Ensemble
     - Yes
     - Yes
     - No
     - No
     - No
   * - Memory
     - :math:`128 · 2^{2n}`
     - ~ :math:`128 · 2^{n}`
     - :math:`128 · 2^{n}`
     - :math:`2n^2 + n`
     - :math:`\\mathcal{O}(nd + n)`
   * - | Typical
       | max
       | #qubits
     - ~10-15
     - ~20-25
     - ~20-25
     - >1000
     - >1000
   * - | Operating
       | complexity
     - :math:`\\mathcal{O}(2^{3n})`
     -
     - :math:`\\mathcal{O}(2^{2n})`
     - :math:`\\mathcal{O}(n)`
     - | 1-qubit gates: :math:`{\\scriptstyle \\mathcal{O}(1)}`
       | 2-qubit gates: :math:`{\\scriptstyle \\mathcal{O}(d^2 + 1)}`
   * - | Meas.
       | complexity
     - :math:`\\mathcal{O}(2^{3n})`
     -
     - :math:`\\mathcal{O}(2^{2n})`
     - :math:`\\mathcal{O}(n^2)`
     - :math:`\\mathcal{O}(d^2 + 1)`


Here :math:`n` is the number of qubits in the quantum state.
:math:`d` is the average amount of edges per vertex in the graph state.
With a minimum of :math:`d=0`,
a maximum of :math:`d=n` and an average of :math:`d=\\mathcal{O}(\\log(n))`.

Ket state vectors (KET) and density matrices (DM and SPARSEDM) are capable of universal quantum computing.
Where density matrices also allow the simulation of mixed qubit states to simulate statistical ensembles
or situations where the exact state is not known.
The stabilizer tableau (STAB) and graph states with local Cliffords (GSLC) formalisms can only represent
stabilizer states.
These can be efficiently simulated classically,
however they can not be used for universal quantum computing.
In general GSLC is faster than STAB unless the state is highly entangled
and thus contains a lot of edges in the GSLC graph.

In summary:

- When dealing with ensembled quantum states and/or where noise should be applied/tracked as accurate as possible;
  then :attr:`~netsquid.qubits.qformalism.QFormalism.DM` or :attr:`~netsquid.qubits.qformalism.QFormalism.SPARSEDM` is the best option.
- When doing universal quantum computing where noises can be approximated or don't need to be tracked,
  then :attr:`~netsquid.qubits.qformalism.QFormalism.KET` is your best bet.
- When working with Stabilizer states; you have the choice between :attr:`~netsquid.qubits.qformalism.QFormalism.STAB`
  and :attr:`~netsquid.qubits.qformalism.QFormalism.GSLC`. GSLC is usually recommended
  unless working with highly entangled states where STAB shines a bit more.

The next sections will go more into technical details on each formalism.
The state :math:`|\\psi\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + i|11\\rangle)|-\\rangle`
is displayed at each formalism as example.

Ket state vector
================

For KET the probability amplitudes of the state :math:`|\\psi\\rangle` is saved in a vector.

:math:`\\begin{pmatrix}
\\frac{1}{2} \\\\ -\\frac{1}{2} \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ \\frac{1}{2}i \\\\ -\\frac{1}{2}i
\\end{pmatrix}`

Density matrix
==============

DM stores the density matrix :math:`\\rho = |\\psi\\rangle\\langle\\psi|` as a dense matrix.
SPARSEDM stores the density matrix as a sparse matrix in compressed sparse row format.

For a mixed state the density matrix is :math:`\\rho = \\sum\\limits_{i=1}^m p_i|\\psi_i\\rangle\\langle\\psi_i|`
where :math:`|\\psi_1\\rangle, \\dots, |\\psi_m\\rangle` are the pure states
with probabilities :math:`p_1, \\dots, p_m`.

:math:`\\rho = \\begin{pmatrix}
\\frac{1}{4} & -\\frac{1}{4} & 0 & 0 & 0 & 0 & -\\frac{1}{4}i & \\frac{1}{4}i \\\\
-\\frac{1}{4} & \\frac{1}{4} & 0 & 0 & 0 & 0 & \\frac{1}{4}i & -\\frac{1}{4}i \\\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\
\\frac{1}{4}i & -\\frac{1}{4}i & 0 & 0 & 0 & 0 & \\frac{1}{4} & -\\frac{1}{4} \\\\
-\\frac{1}{4}i & \\frac{1}{4}i & 0 & 0 & 0 & 0 & -\\frac{1}{4} & \\frac{1}{4} \\\\
\\end{pmatrix}`

Stabilizer tableau
==================

STAB is represented by the set of `n` generators that stabilizes :math:`|\\psi\\rangle`.
A generator `A` stabilizes :math:`|\\psi\\rangle` if :math:`A|\\psi\\rangle = |\\psi\\rangle`.
Where :math:`A = (-1)^pA_1 \\otimes \\dots \\otimes A_n`
with :math:`p \\in \\{0, 1\\}` and :math:`A_i \\in \\{I, X, Y, Z\\}`, :math:`0 < i \\leq n`.

These generators are saved in a stabilizer tableau:
:math:`\\begin{vmatrix}X & Z & P \\\\ \\end{vmatrix} =
\\begin{vmatrix}
x_{11} & \\dots & x_{1n} & z_{11} & \\dots & z_{1n} & p_1\\\\
\\vdots & \\ddots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots\\\\
x_{n1} & \\dots & x_{nn} & z_{n1} & \\dots & z_{nn} & p_n\\\\
\\end{vmatrix}`

where :math:`p_j, x_{ij}, z_{ij} \\in \\{0, 1\\}, 0 < i, j \\leq n`

This tableau represents the generators as
:math:`\\{(-1)^{p_j}\\bigotimes\\limits_{i=1}^nX^{x_{ij}}Z^{z_{ij}} | 0 < j \\leq n\\}`.

The example state :math:`|\\psi\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + i|11\\rangle)|-\\rangle`
is stabilized by the three generators
:math:`Y \\otimes X \\otimes I`, :math:`Z \\otimes Z \\otimes I` and :math:`-I \\otimes I \\otimes X`.

With the corresponding stabilizer tableau being:

:math:`\\begin{vmatrix}
1 & 1 & 0 & 1 & 0 & 0 & 0 \\\\
0 & 0 & 0 & 1 & 1 & 0 & 0 \\\\
0 & 0 & 1 & 0 & 0 & 0 & 1 \\\\
\\end{vmatrix}`

The tableau is not unique.
It represents the same state when swapping rows or when adding rows together (modulo 2).


Graph states with local Cliffords
=================================

GSLC is represented by a set of edges `E` and a list of `n` single qubit Cliffords `C` such that

:math:`\\bigotimes C \\prod\\limits_{(i, j) \\in E} Z_{ij}|+\\dots +\\rangle = |\\psi\\rangle`

where :math:`Z_{ij}` indicates a controlled `Z` gate between qubits `i` and `j`.

For the example state :math:`|\\psi\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + i|11\\rangle)|-\\rangle`
we have :math:`E = \\{(0, 1)\\}` and :math:`C=\\{S, H, Z\\}`.
This can be graphically represented in a graph as

.. graphviz::

   digraph gslc {
      S [shape=circle];
      H [shape=circle];
      Z [shape=circle];
      S -> H [arrowhead=none];
   }

Which corresponds to the circuit

.. aafig::
    :proportional:

           +---+       +---+
    |0> ---+ H +---o---+ S +---
           +---+   |   +---+
                   |
           +---+   |   +---+
    |0> ---+ H +---o---+ H +---
           +---+       +---+

           +---+       +---+
    |0> ---+ H +-------+ Z +---
           +---+       +---+

Adding new formalisms
=====================

To add new a formalism, one has to specify an implementation of the :class:`~netsquid.qubits.qrepr.QRepr` class.
This abstract base class defines the interface for a general quantum state representation.
Adding your own class to the :obj:`~netsquid.qubits.qformalism.QFormalism` dictionary is optional.
If it is added it will automaticaly be evaluated by the available formalism unit tests.

Finally, conversion methods can be added by using :meth:`~netsquid.qubits.qrepr.register_conversion`.

"""
import inspect
import typing
from scipy import sparse  # DEPRECATED
import numpy as np  # DEPRECATED
from netsquid.util.simlog import warn_deprecated  # DEPRECATED
from netsquid.qubits.qubit import Qubit
from netsquid.qubits.qstate import QState
from netsquid.qubits.qrepr import QRepr, convert_to
from netsquid.qubits.kettools import KetRepr
from netsquid.qubits.dmtools import DenseDMRepr
from netsquid.qubits.sparsedmtools import SparseDMRepr
from netsquid.qubits.stabtools import StabRepr
from netsquid.qubits.gslctools import GSLCRepr
from netsquid.qubits.ketutil import sample_ket_from_dm, ket2dm, ket2sparsedm  # DEPRECATED
from netsquid.qubits.stabtools import ket2stabilizer, Stabilizer  # DEPRECATED
from netsquid.qubits.gslcutil import gslc2ket, gslc2dm, gslc2stab, stab2gslc  # DEPRECATED
from netsquid.qubits.sparseutil import dm2sparsedm  # DEPRECATED
__all__ = [
    "QFormalism",
    "set_qstate_formalism",
    "get_qstate_formalism",
    "convert_qstate",
    "convert_qrepr",
]


class _MetaQFormalism(type):
    # Meta class to add properties, iteration and functionality to extend attributes
    #
    def _get_qreprs(cls):
        # Return all of the formalism attributes
        qreprs_attrs = inspect.getmembers(cls, lambda x: type(x) == type and issubclass(x, QRepr))
        return sorted(qreprs_attrs)

    @property
    def ensemble_formalisms(cls):
        return tuple((qrepr for formalism, qrepr in cls._get_qreprs() if qrepr.supports_mixed_states))

    @property
    def purestate_formalisms(cls):
        return tuple((qrepr for formalism, qrepr in cls._get_qreprs() if not qrepr.supports_mixed_states))

    @property
    def universal_formalisms(cls):
        return tuple((qrepr for formalism, qrepr in cls._get_qreprs() if qrepr.supports_universal))

    def __iter__(cls):
        for __, qrepr in cls._get_qreprs():
            yield qrepr

    def __len__(cls):
        return len(inspect.getmembers(cls, lambda x: type(x) == type and issubclass(x, QRepr)))

    def __setitem__(cls, key, value):
        if not key.isupper():
            raise ValueError("Key should be uppercase")
        if key in [name for name, __ in inspect.getmembers(cls)]:
            raise ValueError(f"Attribute name {key} already exists")
        if not issubclass(value, QRepr):
            raise TypeError("Formalism must be a subclass of QRepr.")
        setattr(cls, key, value)

    def __delitem__(cls, key):
        keys = [formalism for formalism, __ in cls._get_qreprs()]
        if key in keys:
            delattr(cls, key)


class QFormalism(metaclass=_MetaQFormalism):
    r"""Collection of the available quantum state formalisms.

    Can be extended with additional formalism attributes
    beyond the ones available by default.

    Attributes
    ----------
    KET : :class:`~netsquid.qubits.kettools.KetRepr`
        Quantum state formalism using pure ket vector states.
        Supports universal quantum computation.
        This is the default formalism.
    DM : :class:`~netsquid.qubits.dmtools.DenseDMRepr`
        Quantum state formalism using ensemble density matrix states
        represented by dense matrices.
        Supports universal quantum computation.
        Density matrices are versatile in terms of quantum operations,
        but scale worse in terms of memory and computation speed than
        ket vectors.
    SPARSEDM : :class:`~netsquid.qubits.sparsedmtools.SparseDMRepr`
        Quantum state formalism using ensemble density matrix states
        represented by sparse matrices (compressed sparse row format).
        Supports universal quantum computation.
        The sparse matrix representation scales better in terms of memory
        usage than the dense matrix representation of the DM formalism,
        and better or worse in terms of computation speed depending on the
        whether the state is very large or not.
    STAB : :class:`~netsquid.qubits.stabtools.StabRepr`
        Quantum state formalism using pure stabilizer states.
        Is limited to Clifford gate operations, and does thereby
        not support universal quantum computation.
        Stabilizer states have very efficient memory scaling, and can be
        used to simulate thousands of entangled qubits.
    GSLC : :class:`~netsquid.qubits.gslctools.GSLCRepr`
        Quantum state formalism using Graph States with Local Cliffords.
        GSLC is limited to Clifford gate operations, and does thereby
        not support universal quantum computation.
        GSLC states have very efficient memory scaling: :math:`O(nd)`.
        With :math:`n` the amount of qubits, and :math:`d` the amount of edges in the graph.
        Usually :math:`d = O(log(n))`.
        Can be used to simulate thousands of entangled qubits.
    ensemble_formalisms : tuple of :class:`~netsquid.qubits.qrepr.QRepr`
        All formalisms that support mixed states.
    purestate_formalisms : tuple of :class:`~netsquid.qubits.qrepr.QRepr`
        All formalisms that don't support mixed states.
    universal_formalisms : tuple of :class:`~netsquid.qubits.qrepr.QRepr`
        All formalisms that support universal quantum computation.

    Examples
    --------

    Formalisms can accessed as attributes:

    >>> from netsquid.qubits.qformalism import QFormalism
    >>> print(QFormalism.KET)
    <class 'netsquid.qubits.kettools.KetRepr'>

    It's possible to iterate over all formalisms:

    >>> for formalism in QFormalism:
    ...     print(formalism)
    <class 'netsquid.qubits.dmtools.DenseDMRepr'>
    <class 'netsquid.qubits.gslctools.GSLCRepr'>
    <class 'netsquid.qubits.kettools.KetRepr'>
    <class 'netsquid.qubits.sparsedmtools.SparseDMRepr'>
    <class 'netsquid.qubits.stabtools.StabRepr'>

    To add an extra formalism called ``MyQRepr`` you can do

    >>> QFormalism["MYREPR"] = MyQRepr  # doctest: +SKIP
    >>> QFormalism.MYREPR  # doctest: +SKIP
    <class 'MyQRepr'>

    To remove a formalism you can do

    >>> del QFormalism["MYREPR"]  # doctest: +SKIP
    >>> hasattr(QFormalism, "MYREPR")  # doctest: +SKIP
    False

    """
    KET = KetRepr
    DM = DenseDMRepr
    SPARSEDM = SparseDMRepr
    STAB = StabRepr
    GSLC = GSLCRepr


# The currently used quantum state formalism
_qstate_formalism = QFormalism.KET


def set_qstate_formalism(formalism: typing.Type[QRepr]) -> None:
    """Set the quantum state formalism to use.

    Parameters
    ----------
    formalism : :class:`~netsquid.qubits.qrepr.QRepr`
        Representation to use for the quantum state formalism.

    Raises
    ------
    TypeError
        If the specified formalism is not known.

    Example
    -------
    >>> from netsquid.qubits.qformalism import QFormalism, set_qstate_formalism
    ...
    >>> set_qstate_formalism(QFormalism.STAB)

    """
    global _qstate_formalism
    if not issubclass(formalism, QRepr):
        raise TypeError(f"{formalism} is not a subclass of QRepr")
    _qstate_formalism = formalism


def get_qstate_formalism() -> typing.Type[QRepr]:
    """Get the current representation being used for the quantum state formalism.

    Returns
    -------
    :class:`~netsquid.qubits.qrepr.QRepr`
        Representation currently in use as the quantum state formalism.

    """
    return _qstate_formalism


def convert_qstate(qubit: Qubit, formalism: typing.Type[QRepr] = None):
    """Convert the (shared) quantum state of a qubit to another formalism.

    Any other qubits sharing this quantum state will also have their quantum state
    converted.

    Parameters
    ----------
    qubit : :obj:`~netsquid.qubits.qubit.Qubit`
        Qubit that holding the (shared) quantum state to be converted.
    formalism : :obj:`~netsquid.qubits.qubitapi.QFormalism` or None, optional
        Formalism to convert the quantum state to. If None (default),
        the currently set formalism is used (recommended).

    Raises
    ------
    NotImplementedError
        If the necessary conversion has not been implemented e.g. conversion
        to a general stabilizer state.

    Notes
    -----
        If the qubit is not holding a quantum state (None) or its quantum state
        already matches the specified formalism, then nothing is done.

        When converting from an ensemble formalism to a pure state formalism a state is sampled if necessary.

    """
    if formalism is None:
        formalism = get_qstate_formalism()
    qs = qubit.qstate
    if qs is not None and not isinstance(qs.qrepr, formalism):
        qs.qrepr = convert_to(qs.qrepr, formalism)


def convert_qrepr(qrepr: QRepr, formalism: typing.Type[QRepr] = None) -> QRepr:
    """Convert a quantum state representation to another representation formalism.

    A *representation* differed from a :obj:`~netsquid.qubits.qstate.QState` in that it
    has no relation to :obj:`~netsquid.qubits.qubit.Qubit` objects, it simply describes a state.
    A representation can be used to create a shared quantum states for a given formalism.

    Parameters
    ----------
    qrepr : :class:`~netsquid.qubits.qrepr.QRepr`
        The representation to convert.
    formalism : type, optional
        The formalism to convert to. Uses the set formalism by default.

    Returns
    -------
    :class:`~netsquid.qubits.qrepr.QRepr`
        The representation in the specified formalism.

    """
    if formalism is None:
        formalism = get_qstate_formalism()
    return convert_to(qrepr, formalism)


# --- Deprecated code ---

class _DeprecatedTuple:
    # Tuple that warns against using it due to deprecation
    def __init__(self, value, msg, key):
        self._value = value
        self._msg = msg
        self._key = key

    def __getitem__(self, item):
        warn_deprecated(self._msg, self._key)
        return self._value.__getitem__(item)

    def __iter__(self):
        warn_deprecated(self._msg, self._key)
        return self._value.__iter__()


# DEPRECATED
ensemble_formalisms = _DeprecatedTuple(QFormalism.ensemble_formalisms,
                                       "The qformalism.ensemble_formalisms is deprecated. "
                                       "Use qformalism.QFormalism.ensemble_formalisms instead.",
                                       "qformalism.ensemble_formalisms")
purestate_formalisms = _DeprecatedTuple(QFormalism.purestate_formalisms,
                                        "The qformalism.purestate_formalisms is deprecated. "
                                        "Use qformalism.QFormalism.purestate_formalisms instead.",
                                        "qformalism.purestate_formalisms")
universal_formalisms = _DeprecatedTuple(QFormalism.universal_formalisms,
                                        "The qformalism.universal_formalisms is deprecated. "
                                        "Use qformalism.Qformalism.universal_formalisms instead.",
                                        "qformalism.universal_formalisms")


def get_formalism_of_qstate(qrepr: typing.Union[QRepr, QState]):
    # DEPRECATED
    warn_deprecated("The get_formalism_of_qstate function is deprecated. "
                    "qformalism.get_formalism_of_qstate")
    if qrepr is None:
        return None
    if isinstance(qrepr, QRepr):
        return type(qrepr)
    if isinstance(qrepr, QState):
        return get_formalism_of_qstate(qrepr.qrepr)
    # DEPRECATED until raise TypeError
    if isinstance(qrepr, Stabilizer):
        return QFormalism.STAB
    if isinstance(qrepr, GSLCRepr):
        return QFormalism.GSLC
    if isinstance(qrepr, list):
        qrepr = np.asarray(qrepr)
    if isinstance(qrepr, np.ndarray) and \
            ((len(qrepr.shape) == 2 and qrepr.shape[1] == 1) or
             (len(qrepr.shape) == 1 and qrepr.shape[0] > 1 and qrepr.shape[0] & (qrepr.shape[0] - 1) == 0)):
        # this last check checks if it's a power of 2
        return QFormalism.KET
    if isinstance(qrepr, np.ndarray) and len(qrepr.shape) == 2 and qrepr.shape[0] == qrepr.shape[1]:
        return QFormalism.DM
    if isinstance(qrepr, sparse.csr_matrix):
        return QFormalism.SPARSEDM
    raise TypeError(f"quantum state representation {qrepr} is not in a known formalism format")


def convert_qsrepr(qs_repr, num_qubits=None, formalism=None):
    # DEPRECATED
    # Convert a quantum state representation to another representation.
    # A *representation* differed from a :obj:`~netsquid.qubits.qstate.QState` in that it
    # has no relation to :obj:`~netsquid.qubits.qubit.Qubit` objects, it simply describes a state.
    # A representation can be used to create a shared quantum states for a given formalism.
    warn_deprecated("The qformalism.convert_qsrepr function is deprecated. "
                    "Use the qformalism.convert_qrepr instead.",
                    "qformalism.convert_qsrepr")
    if formalism is None:
        formalism = get_qstate_formalism()
    vdim = 1 << num_qubits
    if formalism == QFormalism.STAB:
        if isinstance(qs_repr, Stabilizer):
            pass
        elif isinstance(qs_repr, GSLCRepr):
            qs_repr = gslc2stab(qs_repr)
        elif isinstance(qs_repr, sparse.csr_matrix):
            qs_repr = ket2stabilizer(sample_ket_from_dm(qs_repr.toarray()))
        elif isinstance(qs_repr, np.ndarray) and qs_repr.shape == (vdim, vdim):
            qs_repr = ket2stabilizer(sample_ket_from_dm(qs_repr))
        elif isinstance(qs_repr, np.ndarray) and qs_repr.size == vdim:
            qs_repr = ket2stabilizer(qs_repr)
        else:
            raise ValueError(f"Cannot convert {qs_repr} to stabilizer state")
    elif formalism == QFormalism.KET:
        if isinstance(qs_repr, sparse.csr_matrix):
            qs_repr = sample_ket_from_dm(qs_repr.toarray())
        elif isinstance(qs_repr, Stabilizer):
            qs_repr = qs_repr.ket()
        elif isinstance(qs_repr, GSLCRepr):
            qs_repr = gslc2ket(qs_repr)
        elif isinstance(qs_repr, np.ndarray):
            if qs_repr.shape == (vdim, vdim):
                qs_repr = sample_ket_from_dm(qs_repr)
            elif qs_repr.size == vdim:
                if qs_repr.shape != (vdim, 1):
                    qs_repr = np.reshape(qs_repr, (vdim, 1))
            else:
                raise ValueError(f"Array {qs_repr} has incorrect size or shape")
        else:
            raise ValueError(f"Cannot convert {qs_repr} to ket vector")
    elif formalism == QFormalism.DM:
        if isinstance(qs_repr, Stabilizer):
            qs_repr = qs_repr.ket_projector()
        elif isinstance(qs_repr, GSLCRepr):
            qs_repr = gslc2dm(qs_repr)
        elif isinstance(qs_repr, np.ndarray):
            if qs_repr.size == vdim:
                if qs_repr.shape != (vdim, 1):
                    qs_repr = np.reshape(qs_repr, (vdim, 1))
                qs_repr = ket2dm(qs_repr)
            elif not qs_repr.shape == (vdim, vdim):
                raise ValueError(f"Array {qs_repr} has incorrect size or shape")
        elif isinstance(qs_repr, sparse.csr_matrix):
            qs_repr = qs_repr.toarray()
        else:
            raise ValueError(f"Cannot convert {qs_repr} to a density matrix")
    elif formalism == QFormalism.GSLC:
        if isinstance(qs_repr, np.ndarray) and qs_repr.shape == (vdim, vdim):
            ket = sample_ket_from_dm(qs_repr)
            qs_repr = ket2stabilizer(ket)
        elif isinstance(qs_repr, sparse.csr_matrix) and qs_repr.shape == (vdim, vdim):
            ket = sample_ket_from_dm(qs_repr.toarray())
            qs_repr = ket2stabilizer(ket)
        elif isinstance(qs_repr, np.ndarray) and qs_repr.size == vdim:
            qs_repr = ket2stabilizer(qs_repr)
        if isinstance(qs_repr, Stabilizer) and 2**qs_repr.num_qubits == vdim:
            qs_repr = stab2gslc(qs_repr)
        elif not isinstance(qs_repr, GSLCRepr) or 2**qs_repr.num_qubits != vdim:
            raise ValueError(f"Cannot convert {qs_repr} to Graph state")
    elif formalism == QFormalism.SPARSEDM:
        if isinstance(qs_repr, sparse.csr_matrix) and qs_repr.shape == (vdim, vdim):
            pass
        elif isinstance(qs_repr, np.ndarray) and qs_repr.shape == (vdim, vdim):
            qs_repr = dm2sparsedm(qs_repr)
        elif isinstance(qs_repr, np.ndarray) and qs_repr.size == vdim:
            # TODO: workaround because ket2sparsedm is bugged, unfortunately I don't know how to debug cython code
            # dm = ket2dm(qs_repr)
            # qs_repr = dm2sparsedm(dm)
            qs_repr = ket2sparsedm(qs_repr)
        # TODO: these two are obviously also suboptimal workarounds
        elif isinstance(qs_repr, Stabilizer):
            dm = qs_repr.ket_projector()
            qs_repr = dm2sparsedm(dm)
        elif isinstance(qs_repr, GSLCRepr):
            dm = gslc2dm(qs_repr)
            qs_repr = dm2sparsedm(dm)
        else:
            raise ValueError(f"Cannot convert {qs_repr} to SparseDM state")
    else:
        raise ValueError("Unknown formalism")
    return qs_repr
