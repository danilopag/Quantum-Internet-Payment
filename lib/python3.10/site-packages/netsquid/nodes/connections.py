# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: connections.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""
A Connection represents an abstract communication link between two remote locations.
It can may consist of sub-components such as classical or quantum channels.

"""
from netsquid.components.component import Component
from netsquid.components.channel import Channel
from abc import ABCMeta
__all__ = [
    "Connection",
    "DirectConnection",
]


class Connection(Component, metaclass=ABCMeta):
    """An abstract communication link between two remote locations.

    A connection is a :obj:`~netsquid.components.component.Component` that
    may consist of sub-components such as classical/and or quantum channels, etc.

    It defines two remote :obj:`~netsquid.components.component.Port`\\s named ``A`` and ``B``.

    Parameters
    ----------
    name : str
       Name of connection for identification and display purposes.

    Ports
    -----
    A
        Port for IO at remote location A.
    B
        Port for IO at remote location B.

    """

    def __init__(self, name):
        super().__init__(name)
        self.add_ports(["A", "B"])

    @property
    def port_A(self):
        """:obj:`~netsquid.components.component.Port`: port for IO at remote location A."""
        return self.ports["A"]

    @property
    def port_B(self):
        """:obj:`~netsquid.components.component.Port`: port for IO at remote location B."""
        return self.ports["B"]


class DirectConnection(Connection):
    """A two-way direct connection consisting of one-way channels in both directions.

    It is possible for either of the one-way channels to be unspecified, in which case
    attempted communication in that direction will do nothing.

    Parameters
    ----------
    name : str
       Name of connection for identification and display purposes.
    channel_AtoB : :obj:`~netsquid.components.channel.Channel` or None, optional
        One-way channel connecting end A to end B.
    channel_BtoA : :obj:`~netsquid.components.channel.Channel` or None, optional
        One-way channel connecting end B to end A.

    Ports
    -----
    A
        Port for IO at remote location A.
    B
        Port for IO at remote location B.

    Subcomponents
    -------------
    channel_AtoB
        One-way channel from node A to B.
    channel_BtoA
        One-way channel from node B to A.

    """
    _chanAtoB_name = "channel_AtoB"
    _chanBtoA_name = "channel_BtoA"

    def __init__(self, name, channel_AtoB=None, channel_BtoA=None):
        super().__init__(name)
        self.channel_AtoB = channel_AtoB
        self.channel_BtoA = channel_BtoA

    @property
    def channel_AtoB(self):
        """:obj:`~netsquid.components.channel.Channel` or None: one-way channel from node A to B."""
        return self.subcomponents.get(self._chanAtoB_name)

    @channel_AtoB.setter
    def channel_AtoB(self, channel):
        # Remove any previous channel
        self.rem_subcomponent(self._chanAtoB_name)
        if channel is None:
            return
        if not isinstance(channel, Channel):
            raise TypeError("{} is not a Channel".format(channel))
        else:
            # Add/replace with new channel
            self.add_subcomponent(channel, name=self._chanAtoB_name,
                                  forward_input=[("A", "send")],
                                  forward_output=[("B", "recv")])

    @property
    def channel_BtoA(self):
        """:obj:`~netsquid.components.channel.Channel` or None: one-way channel from node B to A."""
        return self.subcomponents.get(self._chanBtoA_name)

    @channel_BtoA.setter
    def channel_BtoA(self, channel):
        # Remove any previous channel
        self.rem_subcomponent(self._chanBtoA_name)
        if channel is None:
            return
        if not isinstance(channel, Channel):
            raise TypeError("{} is not a Channel".format(channel))
        else:
            # Add/replace with new channel
            self.add_subcomponent(channel, name=self._chanBtoA_name,
                                  forward_input=[("B", "send")],
                                  forward_output=[("A", "recv")])
