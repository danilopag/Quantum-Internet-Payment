# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: node.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""
A network node that holds and manages hardware subcomponents.


"""
import logging
from netsquid.components.component import Component
from netsquid.nodes.connections import Connection, DirectConnection
from netsquid.components.channel import Channel
from netsquid.components.qmemory import QuantumMemory
from netsquid.util.simlog import warn_deprecated
__all__ = [
    "Node",
]

logger = logging.getLogger(__name__)

# Counter for assigning unique IDs to nodes
_node_ID_counter = -1


class Node(Component):
    """A network node that holds and manages hardware subcomponents.

    A Node is a composite component: it manages a series of subcomponents
    such as quantum memories, detectors, etc.

    It's recommended to manage nodes in the :obj:`~netsquid.nodes.network.Network` component.
    This class helps setting up and managing Nodes and :obj:`~netsquid.nodes.connections.Connection`\\s between them.

    Parameters
    ----------
    name : str
        Name of node for display purposes.
    ID : int, optional
        Unique identifier for node e.g. its IP address.
    qmemory : :obj:`netsquid.components.qmemory.QuantumMemory` or None, optional
        The primary quantum memory component (or a derivative thereof) on this node.
    port_names : list of str or None, optional
        Names of additional ports to add to this component.

    """

    def __init__(self, name, ID=None, qmemory=None, port_names=None):
        super().__init__(name, port_names=port_names)
        if not isinstance(name, str):
            raise TypeError(f"Node name {name} is not a string")
        global _node_ID_counter
        if ID is None:
            _node_ID_counter += 1
            ID = _node_ID_counter
        elif not isinstance(ID, int):
            raise TypeError(f"Node ID {ID} is not an integer")
        self.name = name
        self.ID = ID
        self.cdata = {}
        self._qmemory_name = None  # Name of qmemory subcomponent
        if qmemory is not None:
            self.qmemory = qmemory

    @property
    def ID(self):
        """int: Identifier for node e.g. its IP address."""
        return self._id

    @ID.setter
    def ID(self, value):
        self._id = value

    @property
    def cdata(self):
        """dict: Locally held classical data."""
        return self._cdata

    @cdata.setter
    def cdata(self, value):
        self._cdata = value

    @staticmethod
    def connection_port_name(remote_ID, label=''):
        """Gives a conventional port name for a connection to a remote node.

        Parameters
        ----------
        remote_ID : int or str
            ID of remote node connection is to.
        label : str, optional
            Label for the connection.
            The purpose of labels is to distinguish multiple connections between the same two nodes.
            Default is no label (empty string).

        Returns
        -------
        str
            Port name for the connection following the fixed naming convention.

        """
        return f"conn|{remote_ID}|{label}"

    def connect_to(self, remote_node, connection, label='',
                   local_port_name=None, remote_port_name=None):
        """Connect to a remote node with a connection or a channel.

        This method will assign :obj:`~netsquid.components.component.Port`\\s on
        each node that *connect* to the connection's ports on both ends.
        By default these ports will use the standard port naming convention
        (see :meth:`Netsquid.nodes.node.Node.connection_port_name`).
        If the ports do not already exist they are added.

        For adding multiple connections between a single pair of nodes, use the parameter ``label`` to create
        additional ports with the standard naming convention, or use the parameters ``local_port_name`` and
        ``remote_port_name`` to use existing but unused ports or create new ports with these names.

        For convenience, if a one-way :obj:`~netsquid.components.channel.Channel` is given, it is wrapped
        within a new :obj:`~netsquid.nodes.connections.DirectConnection` component.
        In this case this node is the transmitter and the remote node the receiver. For two-way communication,
        wrap two :obj:`~netsquid.components.channel.Channel`s a in :obj:`~netsquid.nodes.connections.DirectConnection`
        first.

        Parameters
        ----------
        remote_node : :obj:`~netsquid.nodes.node.Node`
            Remote node to connect to.
        connection : :obj:`~netsquid.nodes.connections.Connection` or\
                     :obj:`~netsquid.components.channel.Channel`
            Linking component. Can be a connection or a channel. If it is the latter, the channel will be
            be made the subcomponent of a new :obj:`~netsquid.nodes.connections.DirectConnection` component.
        label : str, optional
            Label to use for this connection if the standard port naming convention is used
            (see :meth:`Netsquid.nodes.node.Node.connection_port_name`).
            The purpose of labels is to distinguish multiple connection between the same two nodes.
            Default is no label (empty string).
        local_port_name : str or None, optional
            Name of port to use on local node. If a port with this name does not exist one will be added.
            If it does exist it should not be connected. If None (default), a new port is added using the
            standard naming convention (see :meth:`Netsquid.nodes.node.Node.connection_port_name`).
        remote_port_name : str or None, optional
            Name of port to use on remote node. If a port with this name does not exist one will be added.
            If it does exist it should not be connected. If None (default), a new port is added using the
            standard naming convention (see :meth:`Netsquid.nodes.node.Node.connection_port_name`).

        Returns
        -------
        str
            Name of the connecting :obj:`~netsquid.components.component.Port` on this node.
        str
            Name of the connecting :obj:`~netsquid.components.component.Port` on the remote node.

        Raises
        ------
        :obj:`~netsquid.components.component.PortConnectError`
            If there is already a connection between two ports with the same name or ``label``.

        """
        if not isinstance(connection, (Channel, Connection)):
            raise TypeError("{} is not a Connection or Channel.".format(connection))
        if not isinstance(remote_node, Node):
            raise TypeError("{} is not a Node.".format(remote_node))
        local_port = self._get_port_for_remote_node(remote_node, label=label, port_name=local_port_name)
        remote_port = remote_node._get_port_for_remote_node(self, label=label, port_name=remote_port_name)
        if isinstance(connection, Channel):
            connection = DirectConnection("Connection[{}]", connection)
        local_port.connect(connection.ports["A"])
        remote_port.connect(connection.ports["B"])
        return local_port.name, remote_port.name

    def _get_port_for_remote_node(self, remote_node, label='', port_name=None):
        # Get or create a port corresponding to a link to a remote node
        if port_name is None:
            port_name = Node.connection_port_name(remote_node.ID, label=label)
        if port_name not in self.ports:
            return self.add_ports([port_name])[0]
        else:
            return self.ports[port_name]

    def get_conn_port(self, remote_ID, label=''):
        """Get the port for a connection to a remote node using the standard port naming convention.

        To add connection via ports that use the standard port naming convention use the
        :meth:`~netsquid.nodes.node.Node.connect_to` method.

        Parameters
        ----------
        remote_ID : int
            ID of remote node.
        label : str, optional
            Label used to distinguish the connection from other connections to the same node.
            Default is no label (empty string).

        Returns
        -------
        :obj:`~netsquid.components.component.Port` or None
            The local port connecting to the remote node. If no such port exists
            None is returned.

        """
        port_name = Node.connection_port_name(remote_ID, label=label)
        port = self.ports.get(port_name, None)
        if port is not None and port.is_connected:
            # NOTE should a forwarded port also be valid here?
            return port
        else:
            return None

    def reset(self, **kwargs):
        """Reset node.

        Resets all components and optionally clears any classical data.

        """
        super().reset()  # Resets all components and ports:
        if "clear_cdata" in kwargs:
            warn_deprecated("Clearing Node.cdata will soon always occur and this option is deprecated.",
                            "Node.reset.cdata")
            if kwargs["clear_cdata"]:
                return
        self.cdata = {}

    @property
    def qmemory(self):
        """The primary quantum memory, if present.

        Returns
        -------
        :obj:`~netsquid.components.qmemory.QuantumMemory` or None
            The primary quantum memory on this node.

        """
        try:
            return self.subcomponents.get(self._qmemory_name)
        except KeyError:
            self._qmemory_name = None
            return None

    @qmemory.setter
    def qmemory(self, qmemory):
        if qmemory is None:
            self._qmemory_name = None
        elif not isinstance(qmemory, QuantumMemory):
            raise TypeError("{} is not a QuantumMemory".format(qmemory))
        elif self._qmemory_name is None or qmemory is not self.subcomponents[self._qmemory_name]:
            self.add_subcomponent(qmemory)
            self._qmemory_name = qmemory.name

    def add_subcomponent(self, component, name=None, forward_input=None, forward_output=None, add_ports=False):
        # Docstring inherited from parent method
        if name is None:
            name = component.name
        super().add_subcomponent(component=component,
                                 name=name,
                                 forward_input=forward_input,
                                 forward_output=forward_output,
                                 add_ports=add_ports)
        if self._qmemory_name is None and isinstance(component, QuantumMemory):
            self._qmemory_name = name
