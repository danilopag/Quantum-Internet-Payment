# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_node.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the node module.

"""
import unittest
import numpy as np
import netsquid as ns
import pydynaa as pd
from netsquid.nodes.node import Node
from netsquid.nodes.connections import Connection, DirectConnection
from netsquid.qubits import qubitapi as qapi
from netsquid.components.component import Message, PortConnectError, Port
from netsquid.components.channel import Channel
from netsquid.components.qchannel import QuantumChannel
from netsquid.components.qmemory import QuantumMemory, MemPositionInUseError
from netsquid.components.qsource import QSource
from netsquid.components.qprocessor import QuantumProcessor
from netsquid.qubits.state_sampler import StateSampler


class TestNode(unittest.TestCase):
    """Unit tests for the node module.

    """

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        ns.sim_reset()
        self.god = pd.Entity()  # helper entity
        self.EVT_TICK = pd.EventType("Tick", "Test event for counting")

    def test_node_init(self):
        """Test Node initialization."""
        node_name = "TestNode"
        node_ID = 5
        qmem = QuantumMemory("QMem", 2)
        node = Node(node_name, node_ID, qmemory=qmem)
        self.assertEqual(node.name, node_name)
        self.assertEqual(node.ID, node_ID)
        self.assertEqual(node.qmemory, qmem)
        self.assertTrue(isinstance(node.cdata, dict))
        with self.assertRaises(TypeError):
            Node(name=node_name, ID="A")
        with self.assertRaises(TypeError):
            Node(name=5, ID=0)
        with self.assertRaises(TypeError):
            Node(name=node_name, ID=0, qmemory=5)

    def test_node_manage_qmemories(self):
        """Test management of qmemories."""
        node = Node("TestNode", 0)
        # Test management of memories
        self.assertEqual(len(node.subcomponents), 0)
        qmem1, qmem2 = QuantumMemory("Mem1", 2), QuantumMemory("Mem2", 3)
        # First quantum memory becomes primary memory
        node.add_subcomponent(qmem1)
        self.assertEqual(node.qmemory, qmem1)
        node.add_subcomponent(qmem2)
        self.assertEqual(node.qmemory, qmem1)
        self.assertEqual(node.qmemory.num_positions, 2)
        self.assertEqual(len(node.subcomponents), 2)
        self.assertEqual(sum([qmem in self._get_components_of_type(node, QuantumMemory)
                              for qmem in [qmem1, qmem2]]), 2)
        self.assertEqual(node.subcomponents[qmem1.name], qmem1)
        self.assertEqual(node.subcomponents[qmem2.name], qmem2)
        node.rem_subcomponent(qmem1.name)
        self.assertEqual(len(node.subcomponents), 1)
        self.assertEqual(self._get_components_of_type(node, QuantumMemory), [qmem2])

    @staticmethod
    def _get_components_of_type(node, cmpt_type):
        return [cmpt for __, cmpt in node.subcomponents.items() if isinstance(cmpt, cmpt_type)]

    def test_node_manage_components(self):
        """Test management of other components."""
        node = Node("TestNode", 0)
        # Test management of qcontroller and qsource
        self.assertEqual(len(self._get_components_of_type(node, QuantumProcessor)), 0)
        node.add_subcomponent(QuantumProcessor("QP", 3))
        self.assertEqual(len(self._get_components_of_type(node, QuantumProcessor)), 1)
        self.assertEqual(len(self._get_components_of_type(node, QSource)), 0)
        node.add_subcomponent(QSource("QS", state_sampler=StateSampler([np.array([1, 0])]), frequency=1, num_ports=1))

        self.assertEqual(len(self._get_components_of_type(node, QSource)), 1)

    def test_node_connect_to(self):
        """Test node connect_to method."""
        nodeA = Node("TestNodeA", 0)
        nodeB = Node("TestNodeB", 1)
        # Test connecting a general connection

        class TestConnection(Connection):
            pass

        conn1 = TestConnection("TestConn1")
        conn2 = TestConnection("TestConn2")
        self.assertEqual(len(nodeA.ports) + len(nodeB.ports), 0)
        nodeA.connect_to(nodeB, conn1)
        self.assertEqual(len(nodeA.ports), 1)
        self.assertEqual(len(nodeB.ports), 1)
        with self.assertRaises(PortConnectError):
            # Already a default connection
            nodeA.connect_to(nodeB, conn2)
        # Test connecting with a label
        nodeA.connect_to(nodeB, conn2, label="foo")
        self.assertEqual(len(nodeA.ports), 2)
        self.assertEqual(len(nodeB.ports), 2)
        # Test conn1 assigned properly
        portA_conn1 = nodeA.get_conn_port(nodeB.ID)
        portB_conn1 = nodeB.get_conn_port(nodeA.ID)
        self.assertIsInstance(portA_conn1, Port)
        self.assertIsInstance(portB_conn1, Port)
        self.assertEqual(portA_conn1.name,
                         nodeA.connection_port_name(nodeB.ID))
        self.assertEqual(portA_conn1,
                         nodeA.ports[nodeA.connection_port_name(nodeB.ID)])
        self.assertTrue(portA_conn1.is_connected)
        self.assertTrue(portB_conn1.is_connected)
        self.assertEqual(portA_conn1.connected_port.component, conn1)
        self.assertEqual(portB_conn1.connected_port.component, conn1)
        # Test conn2 also assigned properly
        portA_conn2 = nodeA.get_conn_port(nodeB.ID, label="foo")
        self.assertEqual(portA_conn2.connected_port.component, conn2)
        self.assertEqual(nodeA.get_conn_port(nodeB.ID, label="foo").connected_port.component, conn2)
        # Test wrong label returns None
        self.assertEqual(nodeA.get_conn_port(nodeB.ID, label="widget"), None)
        # Test assigning wrong component type
        with self.assertRaises(TypeError):
            nodeA.connect_to(nodeB, QuantumMemory("TestQM"))
        # Test conversion of channel to one-way direct connection
        chan1 = Channel("Ch1")
        nodeA.connect_to(nodeB, chan1, label="bar")
        portA_chan1 = nodeA.get_conn_port(nodeB.ID, label="bar")
        portB_chan1 = nodeB.get_conn_port(nodeA.ID, label="bar")
        self.assertTrue(portA_chan1.is_connected)
        self.assertTrue(portB_chan1.is_connected)
        self.assertIsInstance(portA_chan1.connected_port.component, DirectConnection)
        self.assertEqual(portA_chan1.connected_port.component, portB_chan1.connected_port.component)
        dconn = portA_chan1.connected_port.component
        self.assertEqual(dconn.channel_AtoB, chan1)
        self.assertEqual(dconn.channel_BtoA, None)
        # Test custom port naming
        conn3 = TestConnection("TestConn3")
        port_names = ("CustomPortA", "CustomPortB")
        self.assertEqual(
            nodeA.connect_to(nodeB, conn3, local_port_name="CustomPortA", remote_port_name="CustomPortB"),
            port_names)
        self.assertEqual(nodeA.ports[port_names[0]].connected_port, conn3.ports["A"])
        self.assertEqual(nodeB.ports[port_names[1]].connected_port, conn3.ports["B"])

    def test_node_manage_connections(self):
        """Test management of connections."""
        nodeA = Node("TestNodeA", 0)
        nodeB = Node("TestNodeB", 1)
        nodeC = Node("TestNodeC", 2)
        # Test management of channels
        self.assertEqual(len(nodeA.ports), 0)
        self.assertEqual(len(nodeA.subcomponents), 0)
        c1, c2, c3 = Channel("Ch1"), Channel("Ch2"), Channel("Ch3")
        qc1, qc2 = QuantumChannel("QCh1"), QuantumChannel("QCh2")
        nodeA.connect_to(nodeB, c1)
        nodeA.connect_to(nodeB, qc1, label="quantum")
        with self.assertRaises(PortConnectError):
            nodeA.connect_to(nodeB, c2)
        with self.assertRaises(PortConnectError):
            nodeA.connect_to(nodeB, qc2, label="quantum")
        nodeA.connect_to(nodeC, c3)
        self.assertEqual(len(nodeA.ports), 3)
        self.assertEqual(len(nodeB.ports), 2)
        self.assertEqual(len(nodeC.ports), 1)
        # Adding connections should not have added components
        self.assertEqual(len(nodeA.subcomponents), 0)
        self.assertEqual(len(nodeB.subcomponents), 0)
        self.assertEqual(len(nodeC.subcomponents), 0)
        # Check connecting ports created
        self.assertIsInstance(nodeA.get_conn_port(nodeB.ID), Port)
        self.assertIsInstance(nodeA.get_conn_port(nodeB.ID, label="quantum"), Port)
        self.assertIsInstance(nodeB.get_conn_port(nodeA.ID), Port)
        self.assertIsInstance(nodeB.get_conn_port(nodeA.ID, label="quantum"), Port)
        self.assertIsInstance(nodeA.get_conn_port(nodeC.ID), Port)
        self.assertIsInstance(nodeC.get_conn_port(nodeA.ID), Port)
        self.assertTrue(nodeA.get_conn_port(nodeC.ID, label="quantum") is None)
        self.assertTrue(nodeC.get_conn_port(nodeA.ID, label="quantum") is None)

    def test_node_use_qmemories(self):
        """Test use of quantum memories."""
        q1, q2, q3, q4 = qapi.create_qubits(4)
        node = Node("TestNode", 0)
        qmem1 = QuantumMemory("Mem1", 2)
        node.add_subcomponent(qmem1)
        self.assertFalse(node.qmemory.mem_positions[0].in_use)
        self.assertFalse(node.qmemory.mem_positions[1].in_use)
        self.assertEqual(len(node.qmemory.unused_positions), 2)
        node.qmemory.put([q1], positions=[0])
        self.assertTrue(node.qmemory.mem_positions[0].in_use)
        self.assertEqual(len(node.qmemory.unused_positions), 1)
        node.qmemory.put([q2], positions=[1])
        self.assertTrue(node.qmemory.mem_positions[1].in_use)
        self.assertEqual(len(node.qmemory.unused_positions), 0)
        with self.assertRaises(MemPositionInUseError):
            node.qmemory.put([q3], replace=False)
        self.assertEqual(node.qmemory.pop(positions=[1])[0], q2)
        self.assertFalse(node.qmemory.mem_positions[1].in_use)
        self.assertEqual(node.qmemory.pop(positions=[0])[0], q1)
        self.assertFalse(node.qmemory.mem_positions[0].in_use)
        # Check non-empty when using ready event
        mpos = 1
        node.qmemory.put([q1], positions=[mpos], ready_evtype=pd.EventType("TestEvent", ""))
        self.assertTrue(node.qmemory.mem_positions[mpos].in_use)

    def test_node_use_connections(self):
        """Test use of connections."""
        chan_delay = 10
        test_item = "cat"
        nodeA = Node("A", 0)
        nodeB = Node("B", 1)
        chanAB = Channel("A2B", delay=chan_delay)
        nodeA.connect_to(nodeB, chanAB)
        nodeA.get_conn_port(nodeB.ID).tx_output(Message(test_item))
        ns.sim_run()
        msg = nodeB.get_conn_port(nodeA.ID).rx_input()
        rx_items = msg.items
        self.assertEqual(len(rx_items), 1)
        self.assertEqual(rx_items[0], test_item)
        self.assertEqual(msg.meta["ch_delta_time"], chan_delay)
        self.assertEqual(ns.sim_time(), chan_delay)
        # TODO test optional put/get parameters

    def test_node_use_labeled_connections(self):
        """Test use of labeled connections."""
        chan_delay = 10
        q1, = qapi.create_qubits(1)
        nodeA = Node("A", 0)
        nodeB = Node("B", 1)
        qchanAB = QuantumChannel("A2B", delay=chan_delay)
        nodeA.connect_to(nodeB, qchanAB, label="quantum")
        nodeA.get_conn_port(nodeB.ID, label="quantum").tx_output(Message(q1))
        ns.sim_run()
        msg = nodeB.get_conn_port(nodeA.ID, label="quantum").rx_input()
        rx_qubits = msg.items
        self.assertEqual(len(rx_qubits), 1)
        self.assertEqual(rx_qubits[0], q1)
        self.assertEqual(msg.meta["ch_delta_time"], chan_delay)
        self.assertEqual(ns.sim_time(), chan_delay)
        # TODO test optional put/get parameters

    def test_node_reset(self):
        """Test reseting of a node."""
        node = Node("A", 0)
        node.cdata["foo"] = 5
        qmem = QuantumMemory("Mem1")
        node.add_subcomponent(qmem)
        q1, = qapi.create_qubits(1)
        node.qmemory.put([q1])
        self.assertEqual(len(node.qmemory.unused_positions), 0)
        self.assertTrue(len(node.cdata) > 0)
        # node.reset(clear_cdata=True)
        node.reset()
        self.assertEqual(len(node.qmemory.unused_positions), 1)
        self.assertEqual(len(node.cdata), 0)
        # TODO also test ports reset etc.


if __name__ == "__main__":
    unittest.main()
