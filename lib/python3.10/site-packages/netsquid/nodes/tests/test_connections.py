# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_connections.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the connections module.

"""
import unittest
import netsquid as ns
import pydynaa as pd
from netsquid.nodes.connections import Connection, DirectConnection
from netsquid.components.component import Message
from netsquid.components.channel import Channel


class TestConnections(unittest.TestCase):
    """Unit tests for the connections module.

    """

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        ns.sim_reset()
        self.god = pd.Entity()  # helper entity

    def test_Connection_init(self):
        """Test init of a general Connection."""
        class TestConnection(Connection):
            pass

        name = "TestConn"
        conn = TestConnection(name)
        self.assertEqual(conn.name, name)
        self.assertTrue(len(conn.ports), 2)
        self.assertTrue("A" in conn.ports)
        self.assertTrue("B" in conn.ports)
        self.assertNotEqual(conn.ports["A"], conn.ports["B"])
        self.assertEqual(conn.ports["A"], conn.port_A)
        self.assertEqual(conn.ports["B"], conn.port_B)

    def test_DirectConnection_init(self):
        """Test init of DirectConnection."""
        name = "TestConn"
        conn = DirectConnection(name)
        self.assertTrue("A" in conn.ports)
        self.assertTrue("B" in conn.ports)
        self.assertEqual(conn.channel_AtoB, None)
        self.assertEqual(conn.channel_BtoA, None)
        # Test init with channels
        chan1, chan2, chan3, chan4 = (Channel("Chan1", delay=1), Channel("Chan2", delay=1),
                                      Channel("Chan3", delay=2), Channel("Chan3", delay=2))
        conn = DirectConnection(name, chan1, chan2)
        self.assertEqual(conn.channel_AtoB, chan1)
        self.assertEqual(conn.channel_BtoA, chan2)
        conn.channel_BtoA = None
        conn.channel_AtoB = None
        self.assertEqual(conn.channel_AtoB, None)
        self.assertEqual(conn.channel_BtoA, None)
        conn.channel_AtoB = chan3
        conn.channel_BtoA = chan4
        self.assertEqual(conn.channel_AtoB, chan3)
        self.assertEqual(conn.channel_BtoA, chan4)
        # Test correct wiring
        self.assertEqual(["input"], list(conn.port_A.forwarded_ports.keys()))
        self.assertEqual(["input"], list(conn.port_B.forwarded_ports.keys()))
        self.assertEqual(conn.port_A.forwarded_ports["input"], conn.channel_AtoB.ports["send"])
        self.assertEqual(conn.port_B.forwarded_ports["input"], conn.channel_BtoA.ports["send"])
        self.assertEqual(conn.channel_AtoB.ports["recv"].forwarded_ports["output"], conn.port_B)
        self.assertEqual(conn.channel_BtoA.ports["recv"].forwarded_ports["output"], conn.port_A)
        # Test operation
        items1 = ["apple"]
        items2 = ["pear"]
        conn.port_A.tx_input(Message(items1))
        conn.port_B.tx_input(Message(items2))
        ns.sim_run()
        # Message should still be on output and sim stops after RX event
        msg1 = conn.port_B.rx_output()
        msg2 = conn.port_A.rx_output()
        self.assertEqual(msg1.items, items1)
        self.assertEqual(msg2.items, items2)


if __name__ == "__main__":
    unittest.main()
