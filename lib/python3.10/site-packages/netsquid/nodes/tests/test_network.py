# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_network.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the network module.

"""
import unittest

import netsquid as ns
from netsquid.nodes.node import Node
from netsquid.nodes.network import Network, NetworkError
from netsquid.components.qprocessor import QuantumProcessor
from netsquid.components.qmemory import QuantumMemory
from netsquid.components.channel import Channel
from netsquid.components.qchannel import QuantumChannel
from netsquid.nodes.connections import Connection, DirectConnection


class TestNetwork(unittest.TestCase):
    """Unit tests for the network module.

    """

    def setUp(self):
        """Sets up a new simulation environment for each test."""
        ns.sim_reset()

    def test_network_init(self):
        """Test initialisation of network"""
        network = Network("test_network")
        self.assertEqual(len(network.nodes), 0)
        self.assertEqual(len(network.subcomponents), 0)
        self.assertListEqual([node for node in network.nodes], [])
        network = Network("test_network", 4)
        self.assertListEqual([node for node in network.nodes], ["node0", "node1", "node2", "node3"])
        network = Network("test_network", nodes=["alice", "bob", "charlie", "eve"])
        self.assertEqual(len(network.nodes), 4)
        self.assertEqual(len(network.subcomponents), 4)
        self.assertListEqual([node for node in network.nodes], ["alice", "bob", "charlie", "eve"])

    def test_network_add_nodes(self):
        network = Network("test_network")
        network.add_nodes(nodes=4)
        self.assertEqual(len(network.nodes), 4)
        self.assertEqual(len(network.subcomponents), 4)
        self.assertListEqual([node for node in network.nodes], ["node0", "node1", "node2", "node3"])
        network = Network("test_network")
        network.add_nodes(nodes=["alice", "bob", "charlie", "eve"])
        self.assertEqual(len(network.nodes), 4)
        self.assertEqual(len(network.subcomponents), 4)
        self.assertListEqual([node for node in network.nodes], ["alice", "bob", "charlie", "eve"])

        def name_gen():
            for i in range(4):
                yield f"{i}edon"

        network = Network("test_network")
        network.add_nodes(nodes=name_gen())
        self.assertEqual(len(network.nodes), 4)
        self.assertEqual(len(network.subcomponents), 4)
        self.assertListEqual([node for node in network.nodes], ["0edon", "1edon", "2edon", "3edon"])
        network = Network("test_network")

        with self.assertRaises(TypeError):
            network.add_node(nodes=0)

        with self.assertRaises(TypeError):
            network.add_nodes(nodes=["0", 0])

        # with self.assertRaises(TypeError):
        #     network.nodes["node99"] = Node("node99")

    def test_get_connected_ports(self):
        network = Network("test_network")
        node_a, node_b = network.add_nodes(["node1", "node2"])
        network.add_connection("node1", "node2", delay=(4, 2))
        port_a, port_b = network.get_connected_ports(node_a, node_b)
        self.assertIn(port_a, node_a.ports)
        self.assertIn(port_b, node_b.ports)
        port_b, port_a = network.get_connected_ports(node_b, node_a)
        self.assertIn(port_a, node_a.ports)
        self.assertIn(port_b, node_b.ports)
        self.assertEqual(network.get_connected_ports(node_a, node_b, label="4"), (None, None))
        with self.assertRaises(KeyError):
            self.assertEqual(network.get_connected_ports("what node?", node_b, label="4"), (None, None))
        network.add_connection("node1", "node2", delay=(1, 2), label="test", port_name_node1="p1", port_name_node2="p2")
        port_a, port_b = network.get_connected_ports(node_a, node_b, label="test")
        self.assertEqual(port_a, "p1")
        self.assertEqual(port_b, "p2")
        self.assertIn(port_a, node_a.ports)
        self.assertIn(port_b, node_b.ports)
        port_b, port_a = network.get_connected_ports(node_b, node_a, label="test")
        self.assertEqual(port_a, "p1")
        self.assertEqual(port_b, "p2")
        self.assertIn(port_a, node_a.ports)
        self.assertIn(port_b, node_b.ports)

    def test_adding_connections(self):
        network = Network(name="test_network")
        network.add_node("Huey")
        network.add_node(Node("Dewey"))
        nodes = network.add_nodes(nodes=4)
        for node in nodes:
            node.add_subcomponent(QuantumProcessor("test_qproc"))
        nodes2 = network.add_nodes(nodes=("alice", "bob"))
        for node in nodes2:
            node.add_subcomponent(QuantumMemory("qmem"))
        network.add_nodes(nodes=[Node("carl", qmemory=QuantumMemory("mem_carl")),
                                 Node("evan", qmemory=QuantumProcessor("mem_evan"))])
        self.assertListEqual([node for node in network.nodes],
                             ["Huey", "Dewey", "node2", "node3", "node4", "node5", "alice", "bob", "carl", "evan"])
        self.assertEqual(network.get_node("node3").qmemory.name, "test_qproc")
        self.assertEqual(network.get_node("alice").qmemory.name, "qmem")
        self.assertIsInstance(network.get_node("node4").qmemory, QuantumProcessor)
        network.add_connection("node3", "node4",
                               connection=Connection("my_connection"))
        network.add_connection("alice", "bob",
                               channel_to=QuantumChannel("quantum_channel"),
                               label="quantum")
        network.add_connection("node2", "carl",
                               channel_to=QuantumChannel("quantum_channel"),
                               channel_from=Channel("Classical"), label="both")
        network.add_connection("alice", "bob", delay=4, bidirectional=True,
                               label="label1")
        network.add_connection("node3", "node5", delay=4, bidirectional=False,
                               label="label2")
        network.add_connection("node2", "carl", delay=(1, 4), label="label2")
        connections = list(network.connections.values())
        self.assertEqual(len(connections), 6)
        self.assertEqual(len(network.subcomponents), 16)
        self.assertEqual(type(connections[0]), Connection)
        self.assertEqual(connections[0].name, "my_connection")
        self.assertEqual(type(connections[1]), DirectConnection)
        self.assertEqual(connections[1].name, "conn|alice<->bob|quantum")
        self.assertEqual(type(connections[1].channel_AtoB), QuantumChannel)
        self.assertEqual(connections[1].channel_AtoB.name, "quantum_channel")
        self.assertIsNone(connections[1].channel_BtoA)
        self.assertEqual(type(connections[2]), DirectConnection)
        self.assertEqual(connections[2].name, "conn|node2<->carl|both")
        self.assertEqual(type(connections[2].channel_AtoB), QuantumChannel)
        self.assertEqual(connections[2].channel_AtoB.name, "quantum_channel")
        self.assertEqual(type(connections[2].channel_BtoA), Channel)
        self.assertEqual(connections[2].channel_BtoA.name, "Classical")
        self.assertEqual(type(connections[3]), DirectConnection)
        self.assertEqual(connections[3].name, "conn|alice<->bob|label1")
        self.assertEqual(type(connections[3].channel_AtoB), Channel)
        self.assertEqual(connections[3].channel_AtoB.models["delay_model"].delay, 4)
        self.assertEqual(type(connections[3].channel_BtoA), Channel)
        self.assertEqual(connections[3].channel_BtoA.models["delay_model"].delay, 4)
        self.assertEqual(type(connections[4]), DirectConnection)
        self.assertEqual(connections[4].name, "conn|node3<->node5|label2")
        self.assertEqual(type(connections[4].channel_AtoB), Channel)
        self.assertEqual(connections[4].channel_AtoB.models["delay_model"].delay, 4)
        self.assertIsNone(connections[4].channel_BtoA)
        self.assertEqual(type(connections[5]), DirectConnection)
        self.assertEqual(connections[5].name, "conn|node2<->carl|label2")
        self.assertEqual(type(connections[5].channel_AtoB), Channel)
        self.assertEqual(connections[5].channel_AtoB.models["delay_model"].delay, 1)
        self.assertEqual(type(connections[5].channel_BtoA), Channel)
        self.assertEqual(connections[5].channel_BtoA.models["delay_model"].delay, 4)

    def test_combining_networks(self):
        """Test for combining networks"""
        node1a = Node("node_1a")
        node1b = Node("node_1b")
        node2a = Node("node_2a")
        node2b = Node("node_2b")
        network1 = Network("network1", [node1a, node1b])
        network2 = Network("network2", [node2a, node2b])
        network1.add_connection(node1a, node1b, delay=4, bidirectional=True)
        port2a, port2b = network2.add_connection(node2a, node2b, delay=6, bidirectional=True)
        # Test that we can't add a connection between nodes of a different network
        with self.assertRaises(NetworkError):
            network1.add_connection(node1a, node2a, delay=8)
        # Checks on network layout before merge
        self.assertEqual(len(network1.nodes), 2)
        self.assertEqual(len(network1.connections), 1)
        self.assertEqual(len(network2.nodes), 2)
        self.assertEqual(len(network2.connections), 1)
        # Combine the networks and check layout after
        network1.combine(network2)
        self.assertEqual(len(network1.nodes), 4)
        self.assertEqual(len(network1.connections), 2)
        self.assertEqual(len(network2.nodes), 0)
        self.assertEqual(len(network2.connections), 0)
        # Test if we can still send things between the original ports
        node2a.ports[port2a].tx_output("HELLO b")
        node2b.ports[port2b].tx_output("HELLO a")
        ns.sim_run()
        self.assertEqual(ns.sim_time(), 6)
        self.assertListEqual(node2b.ports[port2b].rx_input().items, ["HELLO b"])
        self.assertListEqual(node2a.ports[port2a].rx_input().items, ["HELLO a"])
        # Should be able to add a connection. Do so and test if message arrives
        port3, port4 = network1.add_connection(node1a, node2a, delay=8, bidirectional=True)
        self.assertIsNotNone(network1.get_connection(node1a, node2a))
        self.assertEqual(len(network1.connections), 3)
        node1a.ports[port3].tx_output("HI 2!")
        node2a.ports[port4].tx_output("HI 1!")
        ns.sim_run()
        self.assertEqual(ns.sim_time(), 6 + 8)
        self.assertListEqual(node2a.ports[port4].rx_input().items, ["HI 2!"])
        self.assertListEqual(node1a.ports[port3].rx_input().items, ["HI 1!"])

    def test_get_connection(self):
        """Test getting a connection"""
        network = Network("network1")
        nodes = [Node(i) for i in ["a", "b", "c"]]
        network.add_nodes(nodes)
        node_a, node_b, node_c = nodes
        conn_ab = Connection('test_conn')
        conn_bc = Connection('test_conn')
        network.add_connection(node_a, node_b, connection=conn_ab, label='abc')
        network.add_connection(node_a, node_b, delay=2, label='other')
        network.add_connection(node_b, node_c, connection=conn_bc)
        self.assertEqual(conn_ab, network.get_connection(node_a, node_b, 'abc'))
        self.assertEqual(conn_ab, network.get_connection(node_b, node_a, 'abc'))
        self.assertIsNone(network.get_connection(node_a, node_b))
        self.assertNotEqual(conn_ab, network.get_connection(node_a, node_b, 'other'))
        self.assertEqual(conn_bc, network.get_connection(node_b, node_c))
        self.assertEqual(conn_bc, network.get_connection(node_c, node_b))
        self.assertIsNone(network.get_connection(node_b, node_c, label='abc'))

    def test_remove_connection(self):
        """Test removing a connection from a network"""
        network = Network("network1")
        nodes = [Node(i) for i in ["a", "b", "c"]]
        network.add_nodes(nodes)
        node_a, node_b, node_c = nodes
        port_ab, port_ba = network.add_connection(node_a, node_b, delay=2, bidirectional=True)
        port_ac, port_ca = network.add_connection(node_a, node_c,
                                                  connection=DirectConnection('test_conn', Channel('ac')),
                                                  label='abc')
        port_bc, port_cb = network.add_connection(node_b, node_c,
                                                  connection=DirectConnection('test_conn', Channel('bc')),
                                                  label='v1')
        port_bc2, port_cb2 = network.add_connection(node_b, node_c,
                                                    connection=DirectConnection('test_conn', Channel('bc2')),
                                                    label='v2')
        conn_ab = network.get_connection(node_a, node_b)
        conn_ac = network.get_connection(node_a, node_c, label='abc')
        conn_cb = network.get_connection(node_c, node_b, label='v1')
        conn_cb2 = network.get_connection(node_b, node_c, label='v2')
        network.remove_connection(conn_ab)
        self.assertIsNone(conn_ab.supercomponent)
        self.assertIs(conn_ac.supercomponent, network)
        self.assertIs(conn_cb.supercomponent, network)
        self.assertIs(conn_cb2.supercomponent, network)
        node_a.ports[port_ab].tx_output("HELLO b")
        ns.sim_run()
        self.assertIsNone(node_b.ports[port_ba].rx_input())
        network.remove_connection(conn_ac)
        self.assertIsNone(conn_ac.supercomponent)
        self.assertIs(conn_cb.supercomponent, network)
        self.assertIs(conn_cb2.supercomponent, network)
        node_a.ports[port_ac].tx_output("HELLO c")
        ns.sim_run()
        self.assertIsNone(node_c.ports[port_ca].rx_input())
        network.remove_connection(network.connection_name(node_b.name, node_c.name, 'v1'))
        self.assertIsNone(conn_cb.supercomponent)
        self.assertIs(conn_cb2.supercomponent, network)
        node_b.ports[port_bc].tx_output("HELLO c")
        ns.sim_run()
        self.assertIsNone(node_c.ports[port_cb].rx_input())
        # The node order changes the connection name, so this shouldn't work
        network.remove_connection(network.connection_name(node_c.name, node_b.name, 'v2'))
        self.assertEqual(conn_cb2.supercomponent, network)
        node_b.ports[port_bc2].tx_output("HELLO c")
        ns.sim_run()
        self.assertEqual("HELLO c", node_c.ports[port_cb2].rx_input().items[0])

    def test_remove_node(self):
        """Test removing a node from a network"""
        network = Network("network1")
        nodes = [Node(i) for i in ["a", "b", "c"]]
        network.add_nodes(nodes)
        node_a, node_b, node_c = nodes
        port_a, port_b = network.add_connection(node_a, node_b, delay=2, bidirectional=True)
        network.add_connection(node_a, node_c, delay=2)
        port_cb, port_bc = network.add_connection(node_c, node_b, delay=2)
        conn_ab = network.get_connection(node_a, node_b)
        conn_ac = network.get_connection(node_a, node_c)
        conn_cb = network.get_connection(node_c, node_b)
        network.remove_node(node_a)
        self.assertIsNone(conn_ab.supercomponent)
        self.assertIsNone(conn_ac.supercomponent)
        self.assertIs(conn_cb.supercomponent, network)
        self.assertIsNone(node_a.supercomponent)
        node_a.ports[port_a].tx_output("HELLO b")
        ns.sim_run()
        self.assertIsNone(node_b.ports[port_b].rx_input())
        network.remove_node('b')
        self.assertIsNone(conn_cb.supercomponent)
        self.assertIsNone(node_b.supercomponent)
        node_b.ports[port_bc].tx_output('HELLO c')
        ns.sim_run()
        self.assertIsNone(node_c.ports[port_cb].rx_input())


if __name__ == '__main__':
    unittest.main()
