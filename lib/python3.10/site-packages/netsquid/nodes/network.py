# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: network.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt
"""This module provides the Network composite component,
a class for managing the :obj:`~netsquid.nodes.node.Node`\\s
and :obj:`~netsquid.nodes.connection.Connection`\\s in a network.

"""
from netsquid.components.channel import Channel
from netsquid.components.component import Component
from netsquid.nodes.connections import Connection, DirectConnection
from netsquid.nodes.node import Node


class Network(Component):
    """A component to help create and manage networks of nodes and connections.

    A network is a composite component: it manages the :class:`~netsquid.nodes.node.Node`\\s and
    :class:`~netsquid.nodes.connection.Connection`\\s of a network.

    When connecting nodes using a connection component new ports are added to each nodes that
    are used to *connect* to either end of the connection.

    Parameters
    ----------
    name : :obj:`str`
        Name of the network for display purposes.
    nodes : :obj:`int` or iterable of :obj:`str` or iterable of :obj:`~netsquid.nodes.node.Node`
        The nodes to add.

        - If ``nodes`` is an integer then this many are added to the network.
        - If an item in this iterable is a string it will create a new node with the string as name.
        - If an item in this iterable is a :obj:`~netsquid.nodes.node.Node` then this node will be added.

    Examples
    --------

    >>> import netsquid as ns
    >>> from netsquid.nodes import Network
    ...
    >>> network = Network(name="test_network")

    Nodes can be added in multiple ways:

    >>> from netsquid.nodes import Node
    >>> from netsquid.components import  QuantumMemory, QuantumProcessor
    ...
    >>> network.add_node("Huey")
    >>> network.add_node(Node("Dewey"))
    >>> nodes = network.add_nodes(nodes=4)
    >>> for node in nodes:
    ...     node.add_subcomponent(QuantumProcessor("test_qproc"))
    >>> nodes2 = network.add_nodes(nodes=("alice", "bob"))
    >>> for node in nodes2:
    ...     node.add_subcomponent(QuantumMemory("qmem"))
    >>> network.add_nodes(nodes=[Node("carl", qmemory=QuantumMemory("mem_carl")),
    ...                          Node("evan", qmemory=QuantumProcessor("mem_evan"))])
    >>> for node in network.nodes.values():
    ...     print(node.name, node.qmemory)
    Huey None
    Dewey None
    node2 QuantumProcessor(name='test_qproc')
    node3 QuantumProcessor(name='test_qproc')
    node4 QuantumProcessor(name='test_qproc')
    node5 QuantumProcessor(name='test_qproc')
    alice QuantumMemory(name='qmem')
    bob QuantumMemory(name='qmem')
    carl QuantumMemory(name='mem_carl')
    evan QuantumProcessor(name='mem_evan')

    Adding connections can also be done in a number of ways

    >>> from netsquid.components import QuantumChannel, Channel
    >>> from netsquid.nodes.connections import Connection
    ...
    >>> network.add_connection("node3", "node4",
    ...                        connection=Connection("my_connection"))
    >>> network.add_connection("alice", "bob",
    ...                        channel_to=QuantumChannel("quantum_channel"),
    ...                        label="quantum")
    >>> network.add_connection("node2", "carl",
    ...                        channel_to=QuantumChannel("quantum_channel"),
    ...                        channel_from=Channel("Classical"), label="both")
    >>> network.add_connection("alice", "bob", delay=4, bidirectional=True,
    ...                        label="label1")
    >>> network.add_connection("node3", "node5", delay=4, bidirectional=False,
    ...                        label="label2")
    >>> network.add_connection("node2", "carl", delay=(1, 4), label="label2")
    >>> for conn in network.connections.values():
    ...     print(conn)
    Connection(name='my_connection')
    DirectConnection(name='conn|alice<->bob|quantum')
    DirectConnection(name='conn|node2<->carl|both')
    DirectConnection(name='conn|alice<->bob|label1')
    DirectConnection(name='conn|node3<->node5|label2')
    DirectConnection(name='conn|node2<->carl|label2')

    The ports names that are used for the connection between nodes can be retrieved easily.
    We can now send messages across the network.

    >>> port_2, port_c = network.get_connected_ports("node2", "carl", label="label2")
    >>> node_2 = network.get_node("node2")
    >>> node_c = network.get_node("carl")
    >>> handler_2 = lambda m: print(f"Node2 received {m} at {ns.sim_time()}!")
    >>> handler_c = lambda m: print(f"Carl received {m} at {ns.sim_time()}!")
    >>> node_2.ports[port_2].bind_input_handler(handler_2)
    >>> node_c.ports[port_c].bind_input_handler(handler_c)
    >>> node_2.ports[port_2].tx_output("Hi Carl!")
    >>> node_c.ports[port_c].tx_output("Hi Two!")
    >>> x = ns.sim_run()
    Carl received Message(items=['Hi Carl!'], header=None, ch_delta_time=1.0) at 1.0!
    Node2 received Message(items=['Hi Two!'], header=None, ch_delta_time=4.0) at 4.0!

    """

    def __init__(self, name, nodes=None):
        super().__init__(name=name)
        if nodes is not None:
            self.add_nodes(nodes)
        self._node_connection_port_names = {}

    @property
    def nodes(self):
        """Return all nodes in this network

        Returns
        -------
        :obj:`~netsquid.util.constrainedmap.ConstrainedMapView`
            A Mapping with every :obj:`~netsquid.nodes.node.Node` of this network

        """
        return self.subcomponents.filter_by_type(Node)

    @property
    def connections(self):
        """Return all connections in this network

        Returns
        -------
        :obj:`~netsquid.util.constrainedmap.ConstrainedMapView`
            A Mapping with every :obj:`~netsquid.nodes.connections.Connection` of this network

        """
        return self.subcomponents.filter_by_type(Connection)

    def add_nodes(self, nodes):
        """Add multiple nodes to this network

        Parameters
        ----------
        nodes : :obj:`int` or iterable of (:obj:`str` or :class:`~netsquid.nodes.node.Node`)
            The nodes to add.

            - If nodes is an integer then `nodes` amount of Nodes are added to the network.
            - If an item in this iterable is a string it will create a new Node with the string as name
            - If an item in this iterable is a :obj:`~netsquid.nodes.node.Node` then this Node will be added

        Returns
        -------
        list of :class:`~netsquid.nodes.node.Node`:
            The nodes that were added.

        """
        if isinstance(nodes, int):
            num_nodes = len(self.nodes)
            nodes = map(lambda i: f"node{i + num_nodes}", range(nodes))
        nodes_new = [self.add_node(node) for node in nodes]
        return nodes_new

    def add_node(self, node):
        """Add a node to this network.

        Parameters
        ----------
        node : :obj:`~netsquid.nodes.node.Node` or :obj:`str`
            A node object or node name to add.

        Returns
        -------
        :class:`~netsquid.nodes.node.Node`
            The node that was added.

        """
        if isinstance(node, str):
            node = Node(name=node)
        if not isinstance(node, Node):
            raise TypeError("parameter 'node' is not a Node")
        if self is node.supercomponent or node.name in self.subcomponents:
            raise ValueError("Node already in network")
        self.add_subcomponent(node)
        return node

    def get_node(self, name):
        """Get a node of this network

        Parameters
        ----------
        name : :obj:`str` or :obj:`~netsquid.nodes.node.Node`
            name of the Node to get.
            Optionally it also accepts a :obj:`~netsquid.nodes.node.Node`.
            When a Node is given it will check if this Node belongs to the network, and throws an error if it is not.

        Returns
        -------
        :obj:`~netsquid.nodes.node.Node`
            The node in this network with the given name

        Examples
        --------
        To get a list of nodes

        >>> network = Network("My_Network")
        >>> network.add_nodes(5)
        >>> names = ["node0", "node4", "node3", "node2"]
        >>> nodes = [network.get_node(name) for name in names]
        >>> print(nodes)
        [Node(name='node0'), Node(name='node4'), Node(name='node3'), Node(name='node2')]

        """
        if isinstance(name, Node):
            if name.supercomponent != self:
                raise NetworkError("Node is not part of this network")
            name = name.name
        if name not in self.subcomponents:
            raise KeyError(f"No node stored with key {name} in network")
        if not isinstance(self.subcomponents[name], Node):
            raise ValueError(f"Subcomponent {name} is not a Node")
        return self.subcomponents[name]

    def remove_node(self, node):
        """Remove a node and all its connections from this network

        Parameters
        ----------
        node : str or :obj:`~netsquid.nodes.nodes.Node`
            The key of the node to be removed, or the node itself.

        """
        if isinstance(node, str):
            node = self.subcomponents[node]
        if not isinstance(node, Node):
            raise TypeError(f"{node} is not a Node")
        for port in node.ports.values():
            if port._output_link and isinstance(port._output_link.component, Connection):
                self.remove_connection(port._output_link.component)
        self.rem_subcomponent(node.name)

    def add_connection(self, node1, node2, connection=None,
                       channel_to=None, channel_from=None,
                       delay=None, bidirectional=None,
                       label='', port_name_node1=None, port_name_node2=None):
        """Add a connection to the network

        Connects two nodes in the network.

        Parameters
        ----------
        node1 : :obj:`~netsquid.nodes.node.Node` or str
            First node to connect
        node2 : :obj:`~netsquid.nodes.node.Node` or str
            Second node to connect
        connection : :obj:`~netsquid.nodes.connections.Connection`, optional
            The connection that will be placed between the two nodes
        channel_to : :obj:`~netsquid.components.channel.Channel`, optional
            The channel to be placed from `node1` to `node2`.
            Ignored if `connection` parameter is given
        channel_from : :obj:`~netsquid.components.channel.Channel`, optional
            The channel to be placed from `node2` to `node1`.
            Ignored if `connection` parameter is given
        delay : :obj:`int` or :obj:`float` or :obj:`tuple` or :obj:`list`, optional
            If a single number this is the delay between `node1` and `node2`.
            A regular :obj:`~netsquid.components.channel.Channel` will be placed from `node1` to `node2` with this delay.
            If a tuple or list then will place two :obj:`~netsquid.components.channel.Channel`
            between `node1` and `node2` with delays of `delay[0]` and `delay[1]` respectively.
            Ignored if `connection`, `channel_to` or `channel_from` parameter is given.
        bidirectional : :obj:`bool`, optional
            If true, will also add a :obj:`~netsquid.components.channel.Channel` from `node2` to `node1` with given delay.
            Only used when ``delay`` is a number.
        label : :obj:`str`, optional
            Label to add to the channel, connection and port names.
            Used to be able to uniquely define connections between two nodes.
            Default is no label (empty string).
        port_name_node1 : :obj:`str`, optional
            Custom port name to use for `node1`.
            If none given a default name will be created using the label
        port_name_node2 : :obj:`str`, optional
            Custom port name to use for `node2`.
            If none given a default name will be created using the label

        Returns
        -------
        str
            Name of the connecting :obj:`~netsquid.components.component.Port` on `node1`.
        str
            Name of the connecting :obj:`~netsquid.components.component.Port` on `node2`.

        Notes
        -----
        Must provide at least one of `connection`, `channel_to`, `channel_from` or `delay`.

        """
        node1 = self.get_node(node1)
        node2 = self.get_node(node2)
        if node1 is node2:
            raise NetworkError("Can not connect a node to itself")
        connection_name = Network.connection_name(node1.name, node2.name, label)
        if connection is None:
            if channel_to is None and channel_from is None:
                if delay is None:
                    raise ValueError("Need to define at least one parameter of "
                                     "`connection`, `channel_to`, `channel_from` or `delay`")
                if isinstance(delay, (int, float)):
                    if bidirectional:
                        delay = (delay, delay)
                    else:
                        delay = (delay, None)
                if delay[0] is not None:
                    channel_to = Channel(f"channel[{node1.name}-->{node2.name}|{label}", delay=delay[0])
                if delay[1] is not None:
                    channel_from = Channel(f"channel[{node2.name}-->{node1.name}|{label}", delay=delay[1])
            connection = DirectConnection(connection_name, channel_AtoB=channel_to, channel_BtoA=channel_from)
        elif not isinstance(connection, Connection):
            raise TypeError(f"{connection} is not a Connection or Channel.")
        if connection.name in self.subcomponents:
            raise ValueError(f"Component with name {connection.name} already exists in this network")
        self.add_subcomponent(connection, connection_name)
        if port_name_node1 is None:
            port_name_node1 = Node.connection_port_name(node2.ID, label=label)
        if port_name_node2 is None:
            port_name_node2 = Node.connection_port_name(node1.ID, label=label)
        if port_name_node1 in node1.ports:
            port1 = node1.ports[port_name_node1]
        else:
            port1 = node1.add_ports([port_name_node1])[0]
        if port_name_node2 in node2.ports:
            port2 = node2.ports[port_name_node2]
        else:
            port2 = node2.add_ports([port_name_node2])[0]
        port1.connect(connection.ports["A"])
        port2.connect(connection.ports["B"])
        self._node_connection_port_names[f"{node1.ID}|{node2.ID}|{label}"] = port_name_node1, port_name_node2
        return port_name_node1, port_name_node2

    def get_connection(self, node1, node2, label=''):
        """Get a connection between two nodes of this network

        Parameters
        ----------
        node1 : :obj:`str` or :obj:`~netsquid.nodes.node.Node`
            First connected Node
        node2 : :obj:`str` or :obj:`~netsquid.nodes.node.Node`
            Second connected Node
        label: :obj:`str`, optional
            The label that was used when creating a connection between the nodes
            Default is no label (empty string)

        Returns
        -------
        :obj:`~netsquid.nodes.connections.Connection` or None
            The connection between the two nodes with the given label, or None if none exists
        """
        node1 = self.get_node(node1)
        node2 = self.get_node(node2)
        conn_name = Network.connection_name(node1.name, node2.name, label)
        if conn_name not in self.subcomponents:
            conn_name = Network.connection_name(node2.name, node1.name, label)
        return self.subcomponents.get(conn_name, None)

    def remove_connection(self, connection):
        """Removes a connection of this network

        Parameters
        ----------
        connection : str or :obj:`~netsquid.nodes.connections.Connection`
            The key of the connection to be removed, or the connection it self.

        Raises
        ------
        TypeError
            If the connection isn't a str or :obj:`~netsquid.nodes.connections.Connection`.

        Notes
        -----
        Doesn't raise any error if the connection wasn't part of this network.

        """
        if isinstance(connection, str):
            connection_name = connection
        elif isinstance(connection, Connection):
            # Search in subcomponents since we don't know the label
            for connection_name, component in self.subcomponents.items():
                if component == connection:
                    break
            else:
                return
        else:
            raise TypeError
        self.rem_subcomponent(connection_name)

    @staticmethod
    def connection_name(name1, name2, label=''):
        """Gives a conventional connection name for a connection between two nodes

        Parameters
        ----------
        name1 : :obj:`str`
            Name of the first node
        name2 : :obj:`str`
            Name of the second node
        label : obj:`str`, optional
            Label for the connection.
            The purpose of labels is to distinguish multiple connections between the same two nodes.
            Default is no label (empty string)

        Returns
        -------
        :obj:`str`
            Name of this connection
        """
        return f"conn|{name1}<->{name2}|{label}"

    def get_connected_ports(self, node1, node2, label=''):
        """Get the port names that connect these two nodes.

        If there is no connection present then None is returned
        for both port names.

        Parameters
        ----------
        node1 : :obj:`str` or :obj:`~netsquid.nodes.node.Node`
            First node
        node2 : :obj:`str` or :obj:`~netsquid.nodes.node.Node`
            Second node
        label : :obj:`str`, optional
            Label that was used when connecting these nodes.
            Default is not label (empty string)

        Returns
        -------
        str or None
            Name of the connecting :obj:`~netsquid.components.component.Port` on ``node1``,
            or None if no connection present.
        str or None
            Name of the connecting :obj:`~netsquid.components.component.Port` on ``node2``,
            or None if no connection present.

        """
        node1 = self.get_node(node1)
        node2 = self.get_node(node2)
        ports = self._node_connection_port_names.get(f"{node1.ID}|{node2.ID}|{label}", None)
        if ports is None:
            ports = self._node_connection_port_names.get(f"{node2.ID}|{node1.ID}|{label}", (None, None))[::-1]
        return ports

    def combine(self, other):
        """Combine two networks, adding all nodes of the other network to this network

        Moves ALL subcomponents of the other network to this one.
        The other network is left empty (no nodes, no connections)

        Parameters
        ----------
        other: :obj:`~netsquid.nodes.network.Network`
            The nodes and connections of the other network to add to this network

        """
        for key, sub in other.subcomponents.items():
            if key in self.subcomponents:
                raise NetworkError(f"Component with {key} already exists in this network")
            self.subcomponents.internal_add(key, value=sub, mutable=False)
            sub._supercomponent = self
        keys = [key for key in other.subcomponents.keys()]
        for key in keys:
            other.subcomponents.internal_del(key)


class NetworkError(Exception):
    """Error associated with a network"""
    pass
