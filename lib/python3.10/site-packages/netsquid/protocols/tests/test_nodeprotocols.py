# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_nodeprotocols.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the dataprotocols module.

"""
import unittest
from netsquid.util.simtools import sim_reset, sim_time, sim_run
import pydynaa as pydynaa
from netsquid.nodes.node import Node
from netsquid.protocols.protocol import Signals
from netsquid.protocols.nodeprotocols import TimedNodeProtocol, DataNodeProtocol
from netsquid.protocols.nodeprotocols import NodeProtocol, LocalProtocol


class ExampleTimedProtocol(TimedNodeProtocol):
    def exec_protocol(self):
        self.node.cdata.setdefault("time", []).append(sim_time())


class TestLocalProtocol(unittest.TestCase):
    """Unit tests for the LocalProtocol.

    """

    def setUp(self):
        sim_reset()
        self.helper = pydynaa.Entity()  # helper entity
        self.node = Node(name="TestNode", ID=0)

    def test_locality(self):
        class ConnectedNodeProtocol(NodeProtocol):
            @property
            def is_connected(self):
                return True

        class MultiLocalProtocol(LocalProtocol):
            def __init__(self, nodes, protocols):
                super().__init__(nodes)
                i = 0
                for protocol in protocols:
                    self.add_subprotocol(protocol, name=i)
                    i += 1

            @property
            def is_connected(self):
                return True

        node1 = Node("1")
        node2 = Node("2")
        node3 = Node("3")
        node4 = Node("4")
        p1 = ConnectedNodeProtocol(node1)
        p2 = ConnectedNodeProtocol(node2)
        p3 = ConnectedNodeProtocol(node3)
        p4 = ConnectedNodeProtocol(node4)
        m12 = MultiLocalProtocol({"1": node1, "2": node2}, [p1, p2])
        m23 = MultiLocalProtocol({"1": node2, "2": node3}, [p2, p3])
        m123 = MultiLocalProtocol({"1": node1, "2": node2, "3": node3}, [p1, p2, p3])
        m12m3 = MultiLocalProtocol({"1": node1, "2": node2, "3": node3}, [m12, p3])
        m12m2 = MultiLocalProtocol({"1": node1, "2": node2}, [m12, p2])
        m12m23 = MultiLocalProtocol({"1": node1, "2": node2, "3": node3}, [m12, m23])
        self.assertEqual(len(m123.nodes), 3)
        self.assertEqual(len(m12m3.nodes), 3)
        self.assertEqual(len(m12m2.nodes), 2)
        self.assertEqual(len(m12m23.nodes), 3)
        self.assertEqual(len(p4.nodes), 1)
        self.assertFalse(p1.can_signal_to(p2))
        self.assertTrue(m12.can_signal_to(p2))
        self.assertTrue(p2.can_signal_to(m12))
        self.assertTrue(p2.can_signal_to(m123))
        self.assertTrue(p2.can_signal_to(m12m3))
        self.assertTrue(p2.can_signal_to(m12m2))
        self.assertTrue(p2.can_signal_to(m12m23))
        self.assertFalse(p3.can_signal_to(m12))
        self.assertTrue(p3.can_signal_to(m123))
        self.assertTrue(p3.can_signal_to(m12m3))
        self.assertFalse(p3.can_signal_to(m12m2))
        self.assertTrue(p3.can_signal_to(m12m23))

    def test_signal_elsewhere_created(self):
        """Test if a local protocol can still listen to expressions that were created elsewhere"""

        class ConnectedNodeProtocol(NodeProtocol):
            @property
            def is_connected(self):
                return True

        class P1(ConnectedNodeProtocol):

            def run(self):
                yield self.await_timer(20)
                self.send_signal(Signals.SUCCESS, 4)
                yield self.await_timer(40)

        class P2(ConnectedNodeProtocol):
            def __init__(self, node, protocol, start_expression):
                super().__init__(node)
                self.protocol = protocol
                self.start_expression = start_expression

            def start(self):
                super().start()
                self.protocol.start()
                return self

            def run(self):
                cond1 = self.start_expression
                cond2 = self.await_timer(10)
                for i in range(10):
                    expression = yield cond1 | cond2
                    if expression.first_term.value:
                        source_prot = expression.first_term.atomic_source
                        signal_result = source_prot.get_signal_by_event(expression.triggered_events[0], self)
                        assert signal_result.result == 4
                        return
                assert False

        node = Node("A")
        p1 = P1(node)
        p2 = P2(node, p1, ConnectedNodeProtocol(node).await_signal(p1, Signals.SUCCESS))
        p2.start()
        sim_run()
        self.assertFalse(p2.is_running)
        sim_reset()
        p1 = P1(node)
        p3 = P2(Node("B"), p1, ConnectedNodeProtocol(node).await_signal(p1, Signals.SUCCESS))
        p3.start()
        with self.assertRaises(RuntimeError):
            sim_run()
        sim_reset()
        p1 = P1(node)
        p3 = P2(node, p1, ConnectedNodeProtocol(Node("B")).await_signal(p1, Signals.SUCCESS))
        p3.start()
        sim_run()


class DNProtocol1(DataNodeProtocol):
    pass


class DNProtocol2(DataNodeProtocol):
    def __init__(self, node, port_name):
        super().__init__(node, port_name)
        self.state = 0
        self.message = None

    def process_data(self, message):
        self.message = message
        self.state = 1
        yield self.await_timer(5)
        self.message = None
        self.state = 2
        return True

    def post_process_data(self, message):
        self.message = message
        self.state = 3
        yield self.await_timer(10)
        self.message = None
        self.state = 4
        return 4


class TestDataNodeProtocol(unittest.TestCase):

    def setUp(self):
        sim_reset()
        self.helper = pydynaa.Entity()  # helper entity

    def test_init(self):
        with self.assertRaises(TypeError):
            DNProtocol1(Node("test"), "port_name")

        node = Node("test")
        protocol = DNProtocol2(node, "port_name")
        self.assertIn("port_name", node.ports)
        self.assertEqual(protocol.port_name, "port_name")
        protocol.port_name = "other_port_name"
        self.assertIn("other_port_name", node.ports)
        self.assertEqual(protocol.port_name, "other_port_name")
        self.assertEqual(protocol.state, 0)
        status = [False, False]

        def busy_received(event):
            status[0] = True

        def ready_received(event):
            status[1] = True

        self.helper._wait_once(pydynaa.EventHandler(busy_received), entity=protocol,
                               event_type=protocol.signals[Signals.BUSY])
        self.helper._wait_once(pydynaa.EventHandler(ready_received), entity=protocol,
                               event_type=protocol.signals[Signals.READY])

        protocol.start()
        self.assertEqual(protocol.state, 0)
        self.assertFalse(status[0])
        self.assertFalse(status[1])
        sim_run()
        self.assertEqual(protocol.state, 0)
        node.ports[protocol.port_name].tx_input("message")
        sim_run(1)
        self.assertEqual(protocol.state, 1)
        self.assertTrue(status[0])
        self.assertFalse(status[1])
        self.assertEqual(protocol.message.items, ['message'])
        sim_run(6)
        self.assertEqual(protocol.state, 3)
        self.assertFalse(status[1])
        self.assertEqual(protocol.message.items, ['message'])
        sim_run()
        self.assertEqual(protocol.state, 4)
        self.assertTrue(status[1])
        self.assertIsNone(protocol.message)
        self.assertEqual(protocol.get_signal_result(Signals.READY), 4)


class TestTimedNodeProtocol(unittest.TestCase):
    """Unit tests for the TimedProtocol.

    """

    def setUp(self):
        sim_reset()
        self.helper = pydynaa.Entity()  # helper entity
        self.node = Node(name="TestNode", ID=0)

    def test_init(self):
        """Test initialization of TimedProtocol."""
        # Test empty case
        time_step = 2
        start_time = 5
        tprotocol = ExampleTimedProtocol(self.node, time_step=time_step, start_time=start_time)
        with self.assertRaises(ValueError):
            tprotocol.time_step = 0
        with self.assertRaises(ValueError):
            tprotocol.start_time = -1
        self.assertEqual(tprotocol.node, self.node)
        self.assertEqual(tprotocol.time_step, time_step)
        self.assertEqual(tprotocol.start_time, start_time)
        # Test not automatically started
        self.assertFalse(tprotocol.is_running)
        sim_run(10)
        self.assertTrue("time" not in self.node.cdata)
        self.assertFalse(tprotocol.is_running)

    def test_running(self):
        """Test running of TimedProtocol."""
        time_step = 2
        start_time = 5
        tprotocol = ExampleTimedProtocol(time_step=time_step, start_time=start_time, node=self.node)
        tprotocol.start()
        self.assertTrue(tprotocol.is_running)
        sim_run(10)
        self.assertTrue("time" in self.node.cdata)
        self.assertEqual(len(self.node.cdata["time"]), 3)
        for i in range(3):
            self.assertAlmostEqual(self.node.cdata["time"][i], start_time + i * time_step)


if __name__ == "__main__":
    unittest.main()
