# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_serviceprotocol.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the serviceprotocol module.

"""
import unittest
from collections import namedtuple

from pydynaa.core import Entity, EventHandler

import netsquid as ns
from netsquid.protocols import ServiceError
from netsquid.protocols.serviceprotocol import ServiceProtocol
from netsquid.nodes.node import Node

__all__ = [
    'TestServiceProtocol'
]


class SVProtocol(ServiceProtocol):
    """Protocol used for testing.

    """
    req_create = namedtuple("req_create", ['num_qubits'])
    req_write = namedtuple("req_write", ['num_qubits'])
    res_ok = namedtuple("res_ok", ['states'])

    def __init__(self, node, name=None):
        super(SVProtocol, self).__init__(node=node, name=name)
        self.register_request(self.req_create, self.handler)
        self.register_request(self.req_write, self.handler)
        self.register_response(self.res_ok)
        self.test_id = None
        self.test_handler = None
        self.test_value = None

    def handler(self, request):
        """Set the test_handler attribute to check for execution.

        """
        self.test_handler = request.num_qubits

    def handle_request(self, request, identifier):
        """Set the test_value and test_id attributes to check for execution.

        """
        super().handle_request(request, identifier)
        self.test_value = request
        self.test_id = identifier


class TestServiceProtocol(unittest.TestCase):
    """Test the serviceprotocol methods.

    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.node = Node("TestNode")

    def test_init(self):
        """Test registration of requests and responses was successful.

        """
        proto = SVProtocol(self.node)
        self.assertEqual(2, len(proto.request_types))
        self.assertEqual(proto.req_create, proto.request_types["req_create"])
        self.assertEqual(proto.req_write, proto.request_types["req_write"])
        self.assertEqual(1, len(proto.response_types))
        self.assertEqual(proto.res_ok, proto.response_types['res_ok'])

    def test_wrong_type(self):
        """Test the request and response types have to be types.

        """
        class SVProtocolReq(SVProtocol):
            req_fail = 1

        proto = SVProtocolReq(self.node)
        with self.assertRaises(ValueError):
            proto.register_request(proto.req_fail, proto.handler)

        class SVProtocolRes(SVProtocol):
            res_fail = (1,)

        proto = SVProtocolRes(self.node)
        with self.assertRaises(ValueError):
            proto.register_response(proto.res_fail)

    def test_wrong_handler(self):
        """Test handlers should be callable or an error is raised.

        """
        proto = SVProtocol(self.node)
        with self.assertRaises(ServiceError):
            proto.register_request(proto.req_create, 3)

    def test_put_request(self):
        """Test put requests are handled correctly or raise an error.

        """
        proto = SVProtocol(self.node)
        req = proto.req_create(3)
        proto.put(req)
        self.assertEqual(req, proto.test_value)
        self.assertEqual(proto.get_name(req), proto.test_id)
        with self.assertRaises(KeyError):
            proto.put(3)
        with self.assertRaises(KeyError):
            proto.put(proto.res_ok([1, 2]))

    def test_handle_request(self):
        """Test handlers are executed if they are a function.

        """
        proto = SVProtocol(self.node)
        req = proto.req_create(3)
        proto.put(req)
        self.assertEqual(3, proto.test_handler)

        def generator(request):
            yield

        proto.register_request(proto.req_create, generator, name='generator')
        with self.assertRaises(NotImplementedError):
            proto.put(req, name='generator')

    def test_response(self):
        """Test signals are properly send as response.

        """
        class Responder(SVProtocol):

            def handle_request(self, request, identifier):
                response = self.res_ok(request.num_qubits)
                self.send_response(response)
        proto = Responder(self.node)
        entity = Entity()

        def change_testvalue(event=None):
            proto.test_value = 123
        handler = EventHandler(change_testvalue)
        eventtype = proto.signals[proto.get_name(proto.res_ok)]
        entity._wait_once(handler, proto, eventtype)
        proto.put(proto.req_create(3))
        self.assertNotEqual(123, proto.test_value)
        ns.sim_run()
        self.assertEqual(123, proto.test_value)
        with self.assertRaises(KeyError):
            proto.send_response(3)
        proto.send_response(proto.res_ok(3), name=proto.get_name(proto.res_ok))
        with self.assertRaises(KeyError):
            proto.send_response(proto.res_ok(3), name='unknown_name')
        proto.register_response(namedtuple('fail_res', []), name='incorrect_name')
        with self.assertRaises(ServiceError):
            proto.send_response(proto.res_ok(3), name='incorrect_name')

    def test_nonunique_names(self):
        """Test names should be unique or an error is raised.

        """
        proto = SVProtocol(self.node)
        proto.register_request(proto.req_create, proto.handler, name='new_create')
        with self.assertRaises(ServiceError):
            proto.register_request(proto.req_create, proto.handler, name='new_create')
        with self.assertRaises(ServiceError):
            proto.register_request(namedtuple('new_req', []), proto.handler, name='new_create')
        proto.register_response(proto.res_ok, name='new_ok')
        with self.assertRaises(ServiceError):
            proto.register_response(proto.res_ok, name='new_ok')
        with self.assertRaises(ServiceError):
            proto.register_response(namedtuple('new_res', []), name='new_ok')

    def test_get_name(self):
        """Test names are correct for classes and instances.

        """
        self.assertEqual('req_create', ServiceProtocol.get_name(SVProtocol.req_create))
        request = SVProtocol.req_create(3)
        self.assertEqual('req_create', ServiceProtocol.get_name(request))


if __name__ == "__main__":
    unittest.main()
