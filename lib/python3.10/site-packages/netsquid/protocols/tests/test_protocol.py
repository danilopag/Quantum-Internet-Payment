# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: test_protocol.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Unit tests for the protocol module.

"""
import unittest
import functools
import operator
import abc

import pydynaa as pd
from netsquid.components.qmemory import QuantumMemory
from pydynaa import EventHandler, EventType, Entity, EventExpression
from netsquid.util.simtools import sim_reset, sim_run, sim_time
from netsquid.protocols.protocol import Protocol, Signals
from netsquid.components.component import Component, Message
from netsquid.components import instructions as instr
from netsquid.qubits import qubitapi as qapi
from netsquid.components.qprogram import QuantumProgram, QuantumProgramError
from netsquid.components.qprocessor import QuantumProcessor, PhysicalInstruction


class ConnectedProtocol(Protocol, metaclass=abc.ABCMeta):

    def __init__(self, name=None):
        super().__init__(name)
        self.add_signal("STATUS0")
        self.add_signal("STATUS1")
        self.add_signal("STATUS2")
        self.add_signal("STATUS3")
        self.add_signal("STATUS4")
        self.add_signal("STATUS5")

    @property
    def is_connected(self):
        return True


class MyTestProtocol(ConnectedProtocol):

    def __init__(self, node_A=None, generator=None):
        super().__init__()
        self.node_A = node_A
        self.generator = generator

    def start(self):
        return super().start()

    def run(self):
        if self.generator:
            return self.generator
        else:
            yield self.await_timer(5)


class SleepProtocol(ConnectedProtocol):

    def __init__(self, delay=5):
        self.delay = delay
        super().__init__("Sleep" + str(delay))

    def start(self):
        return super().start()

    def run(self):
        yield self.await_timer(self.delay)


class StatusProtocol(ConnectedProtocol):

    def run(self):
        self.send_signal("STATUS1", 1)
        yield self.await_timer(3)
        self.send_signal("STATUS2", 2)
        yield self.await_timer(3)
        self.send_signal("STATUS3", 3)


class SubProtocol(ConnectedProtocol):

    def __init__(self):
        super().__init__()
        self.protocol1 = SleepProtocol()
        self.protocol2 = StatusProtocol()

    def start(self):
        self.protocol1.start()
        self.protocol2.start()
        return super().start()

    def run(self):
        self.send_signal("STATUS1")
        yield self.await_signal(self.protocol2, "STATUS1")
        self.send_signal("STATUS2")
        yield self.await_signal(self.protocol1)
        self.send_signal("STATUS3")
        yield self.await_signal(self.protocol2, "STATUS3")
        self.send_signal("STATUS4")


def setup_forwarding_ports(amount=10):
    parent_component = Component(str(0), port_names=["in", "out"])
    prev_component = parent_component
    components = []
    for i in range(amount):
        c = Component(str(i + 1))
        in_port, out_port = c.add_ports(["in", "out"])
        components.append(c)
        c.add_subcomponent(prev_component)
        prev_component.ports["out"].forward_output(out_port)
        in_port.forward_input(prev_component.ports["in"])
        prev_component = c
    return parent_component, prev_component, components


class TestProtocol(unittest.TestCase):
    """Unit tests for the protocol module

    """

    def setUp(self):
        sim_reset()
        self.helper = pd.Entity()
        self.ready = {}

    def schedule_ready(self, label, protocol):
        self.ready[label] = False

        def set_ready(event):
            self.ready[label] = True

        event_type = protocol.signals.get(label)
        if event_type is not None:
            self.helper._wait_once(EventHandler(set_ready), entity=protocol,
                                   event_type=event_type)

    def is_ready(self, status):
        return self.ready[status] if status in self.ready else False

    def test_init(self):
        p = MyTestProtocol()
        with self.assertRaises(ValueError):
            p.add_signal("STATUS1")
        self.assertFalse(p.is_running)
        self.assertEqual(p.start(), p)
        self.assertTrue(p.is_running)
        sim_run()
        self.assertFalse(p.is_running)

    def test_run(self):
        p = SleepProtocol()
        self.assertFalse(p.is_running)
        p.start()
        self.assertTrue(p.is_running)
        sim_run(3)
        self.assertTrue(p.is_running)
        sim_run()
        self.assertFalse(p.is_running)

    def test_results(self):
        p = StatusProtocol()

        self.schedule_ready("STATUS1", p)
        self.schedule_ready("STATUS2", p)
        self.schedule_ready("STATUS3", p)

        self.assertFalse(self.is_ready("STATUS1"))
        self.assertFalse(self.is_ready("STATUS2"))
        self.assertFalse(self.is_ready("STATUS3"))
        self.assertEqual(p.get_signal_result("STATUS1"), None)
        self.assertEqual(p.get_signal_result("STATUS2"), None)
        self.assertEqual(p.get_signal_result("STATUS3"), None)
        p.start()
        self.assertFalse(self.is_ready("STATUS1"))
        self.assertFalse(self.is_ready("STATUS2"))
        self.assertFalse(self.is_ready("STATUS3"))
        self.assertEqual(p.get_signal_result("STATUS1"), 1)
        self.assertEqual(p.get_signal_result("STATUS2"), None)
        self.assertEqual(p.get_signal_result("STATUS3"), None)
        sim_run(3)
        self.assertTrue(self.is_ready("STATUS1"))
        self.assertFalse(self.is_ready("STATUS2"))
        self.assertFalse(self.is_ready("STATUS3"))
        self.assertEqual(p.get_signal_result("STATUS1"), 1)
        self.assertEqual(p.get_signal_result("STATUS2"), None)
        self.assertEqual(p.get_signal_result("STATUS3"), None)
        sim_run(6)
        self.assertTrue(self.is_ready("STATUS1"))
        self.assertTrue(self.is_ready("STATUS2"))
        self.assertFalse(self.is_ready("STATUS3"))
        self.assertEqual(p.get_signal_result("STATUS1"), 1)
        self.assertEqual(p.get_signal_result("STATUS2"), 2)
        self.assertEqual(p.get_signal_result("STATUS3"), None)
        sim_run()
        self.assertTrue(self.is_ready("STATUS1"))
        self.assertTrue(self.is_ready("STATUS2"))
        self.assertTrue(self.is_ready("STATUS3"))
        self.assertEqual(p.get_signal_result("STATUS1"), 1)
        self.assertEqual(p.get_signal_result("STATUS2"), 2)
        self.assertEqual(p.get_signal_result("STATUS3"), 3)
        self.assertFalse(p.is_running)

        with self.assertRaises(KeyError):
            self.assertEqual(p.get_signal_result("STATUS13"), 3)

    def test_await_protocol(self):
        p = SubProtocol()
        self.schedule_ready("STATUS1", p)
        self.schedule_ready("STATUS2", p)
        self.schedule_ready("STATUS3", p)
        self.schedule_ready("STATUS4", p)

        p.start()
        self.assertFalse(self.is_ready("STATUS1"))
        self.assertFalse(self.is_ready("STATUS2"))
        self.assertFalse(self.is_ready("STATUS3"))
        self.assertFalse(self.is_ready("STATUS4"))
        sim_run(1)
        self.assertTrue(self.is_ready("STATUS1"))
        self.assertTrue(self.is_ready("STATUS2"))
        self.assertFalse(self.is_ready("STATUS3"))
        self.assertFalse(self.is_ready("STATUS4"))
        sim_run(4)
        self.assertTrue(self.is_ready("STATUS1"))
        self.assertTrue(self.is_ready("STATUS2"))
        self.assertFalse(self.is_ready("STATUS3"))
        self.assertFalse(self.is_ready("STATUS4"))
        sim_run(6)
        self.assertTrue(self.is_ready("STATUS1"))
        self.assertTrue(self.is_ready("STATUS2"))
        self.assertTrue(self.is_ready("STATUS3"))
        self.assertFalse(self.is_ready("STATUS4"))
        sim_run()
        self.assertFalse(p.is_running)
        self.assertFalse(p.protocol1.is_running)
        self.assertFalse(p.protocol2.is_running)
        self.assertTrue(self.is_ready("STATUS1"))
        self.assertTrue(self.is_ready("STATUS2"))
        self.assertTrue(self.is_ready("STATUS3"))
        self.assertTrue(self.is_ready("STATUS4"))

    def test_await_memory_positions(self):
        """Test waiting for memorypositions."""
        class MemoryProtocol(ConnectedProtocol):

            def __init__(self, name=None):
                super().__init__(name)
                self.qmemory = QuantumMemory('test_memory', num_positions=5)

            def run(self):
                busy_evexpr = self.await_mempos_busy_toggle(self.qmemory, [1, 2])
                in_use_evexpr = self.await_mempos_in_use_toggle(self.qmemory, [0, 2])
                evexpr = busy_evexpr | in_use_evexpr
                while True:
                    res = yield evexpr.copy()
                    self.send_signal("STATUS1", res)
        p = MemoryProtocol().start()
        for status in [True, False, True]:
            p.qmemory.mem_positions[0].busy = status
            sim_run()
            self.assertIsNone(p.get_signal_result("STATUS1"))
        for status in [True, False, True]:
            p.qmemory.mem_positions[1].busy = status
            sim_run()
            evexpr = p.get_signal_result("STATUS1")
            self.assertIsNotNone(evexpr)
            self.assertTrue(evexpr.first_term.first_term.value)
        for status in [True, False, True]:
            p.qmemory.mem_positions[2].busy = status
            sim_run()
            evexpr = p.get_signal_result("STATUS1")
            self.assertIsNotNone(evexpr)
            self.assertTrue(evexpr.first_term.second_term.value)
        for status in [True, False, True]:
            p.qmemory.mem_positions[0].in_use = status
            sim_run()
            evexpr = p.get_signal_result("STATUS1")
            self.assertIsNotNone(evexpr)
            self.assertTrue(evexpr.second_term.first_term.value)
        for status in [True, False, True]:
            p.qmemory.mem_positions[2].in_use = status
            sim_run()
            evexpr = p.get_signal_result("STATUS1")
            self.assertIsNotNone(evexpr)
            self.assertTrue(evexpr.second_term.second_term.value)
        with self.assertRaises(TypeError):
            p.await_mempos_busy_toggle('qmemory', [0])
        with self.assertRaises(IndexError):
            p.await_mempos_busy_toggle(p.qmemory, [5])
        with self.assertRaises(TypeError):
            p.await_mempos_in_use_toggle('qmemory', [0])
        with self.assertRaises(IndexError):
            p.await_mempos_in_use_toggle(p.qmemory, [5])

    def test_and(self):
        class AndProtocol(ConnectedProtocol):
            def __init__(self):
                super().__init__()
                self.protocol1 = SleepProtocol()
                self.protocol2 = StatusProtocol()
                self.cur_time = 0

            def start(self):
                self.protocol1.start()
                self.protocol2.start()
                super().start()

            def run(self):
                expr1 = self.await_signal(self.protocol2, "STATUS2")
                expr3 = expr1 & self.await_timer(5) & self.await_timer(4)
                self.send_signal("STATUS0", 0)
                yield expr3
                self.cur_time = sim_time()
                assert self.protocol2.get_signal_result("STATUS2") == 2
                self.send_signal("STATUS1", 1)
                yield self.await_timer(8)
                self.cur_time = sim_time()
                self.send_signal("STATUS2", 2)
                expr4 = expr1 & self.await_timer(5)
                assert self.protocol2.get_signal_result("STATUS2") == 2
                yield expr4
                assert self.protocol2.get_signal_result("STATUS2") == "Test_String"
                self.cur_time = sim_time()
                self.send_signal("STATUS3", 3)

        p = AndProtocol()
        self.schedule_ready("STATUS1", p)
        self.schedule_ready("STATUS2", p)
        self.schedule_ready("STATUS3", p)
        self.schedule_ready("STATUS4", p)
        p.start()
        sim_run(2)
        self.assertEqual(p.cur_time, 0)
        self.assertEqual(p.get_signal_result("STATUS0"), 0)
        sim_run(4)
        self.assertEqual(p.cur_time, 0)
        self.assertEqual(p.get_signal_result("STATUS0"), 0)
        self.assertFalse(self.is_ready("STATUS1"))
        sim_run(6)
        self.assertEqual(p.cur_time, 5)
        self.assertEqual(p.get_signal_result("STATUS1"), 1)
        self.assertTrue(self.is_ready("STATUS1"))
        sim_run(14)
        self.assertEqual(p.cur_time, 13)
        self.assertEqual(p.get_signal_result("STATUS2"), 2)
        self.assertTrue(self.is_ready("STATUS2"))
        p.protocol2.send_signal("STATUS2", "Test_String")
        sim_run()
        self.assertFalse(p.is_running)
        sim_reset()
        x = None & p.await_timer(4)
        y = p.await_timer(4) & None
        self.assertIsInstance(x, EventExpression)
        self.assertIsInstance(y, EventExpression)

    def test_simultaneous_signal(self):
        """Test if signals sent simultaneously can be retrieved separately."""
        class SimSignalProtocol(Protocol):

            def __init__(self):
                super().__init__()
                self.signal_label = 'test_label'
                self.add_signal(self.signal_label)

            def run(self):
                self.send_signal(signal_label=self.signal_label, result=0)
                evexpr_1 = yield self.await_signal(self, self.signal_label)
                self.send_signal(signal_label=self.signal_label, result=1)
                evexpr_2 = yield self.await_signal(self, self.signal_label)
                evt_1 = evexpr_1.triggered_events[0]
                evt_2 = evexpr_2.triggered_events[0]
                assert evt_1 != evt_2
                assert self.get_signal_by_event(evt_1).result == 0
                assert self.get_signal_by_event(evt_2).result == 1
                assert self.get_signal_result(self.signal_label, self) == 1
                yield self.await_timer(1)
                self.send_signal(signal_label=self.signal_label, result=2)
                evexpr_3 = yield self.await_signal(self, self.signal_label)
                evt_3 = evexpr_3.triggered_events[0]
                assert self.get_signal_by_event(evt_1) is None
                assert self.get_signal_by_event(evt_2) is None
                assert self.get_signal_by_event(evt_3).result == 2
                assert self.get_signal_result(self.signal_label) == 2

        p = SimSignalProtocol()
        p.start()
        sim_run()

    def test_faulty_and(self):
        p = StatusProtocol()
        with self.assertRaises(TypeError):
            True & p.await_timer(4)

        with self.assertRaises(TypeError):
            p.await_timer(4) & True

    def test_or(self):
        class OrProtocol(ConnectedProtocol):
            def __init__(self):
                super().__init__()
                self.protocol1 = SleepProtocol()
                self.protocol2 = StatusProtocol()
                self.cur_time = 0

            def start(self):
                self.protocol1.start()
                self.protocol2.start()
                super().start()

            def run(self):
                expr1 = self.await_signal(self.protocol2, "STATUS2")
                expr3 = expr1 | self.await_timer(5) | self.await_timer(40)
                yield expr3
                self.cur_time = sim_time()
                assert self.protocol2.get_signal_result("STATUS2") == 2
                self.send_signal("STATUS1", 1)
                yield self.await_timer(8)
                self.send_signal("STATUS2", 2)
                expr4 = expr1 | self.await_timer(2)
                yield expr4
                assert self.protocol2.get_signal_result("STATUS2") == 2
                self.send_signal("STATUS3", 3)

        p = OrProtocol()
        self.schedule_ready("STATUS1", p)
        self.schedule_ready("STATUS2", p)
        self.schedule_ready("STATUS3", p)
        self.schedule_ready("STATUS4", p)
        p.start()
        sim_run(4)
        self.assertEqual(p.get_signal_result("STATUS1"), 1)
        self.assertEqual(p.get_signal_result("STATUS3"), None)
        self.assertTrue(self.is_ready("STATUS1"))
        self.assertEqual(p.cur_time, 3)
        sim_run(6)
        self.assertEqual(p.get_signal_result("STATUS1"), 1)
        self.assertTrue(self.is_ready("STATUS1"))
        sim_run(60)
        self.assertEqual(p.get_signal_result("STATUS2"), 2)
        self.assertEqual(p.get_signal_result("STATUS3"), 3)
        self.assertFalse(p.is_running)
        self.assertTrue(self.is_ready("STATUS2"))
        sim_run()
        self.assertEqual(p.get_signal_result("STATUS3"), 3)
        self.assertFalse(p.is_running)
        self.assertTrue(self.is_ready("STATUS2"))
        sim_reset()
        x = None | p.await_timer(4)
        y = p.await_timer(4) | None
        self.assertIsInstance(x, EventExpression)
        self.assertIsInstance(y, EventExpression)

    def test_faulty_or(self):
        p = StatusProtocol()
        with self.assertRaises(TypeError):
            True | p.await_timer(4)

        with self.assertRaises(TypeError):
            p.await_timer(4) | True

    def test_or_events(self):
        """Test if chaining await_events with or is correct"""
        event_type1 = EventType("type1", "type1 triggered")
        event_type2 = EventType("type2", "type2 triggered")
        event_type3 = EventType("type3", "type3 triggered")

        class ProtocolTest(Protocol):

            def __init__(self):
                self.done_1 = False
                self.done_2 = False
                self.done_3 = False
                super().__init__()

            def run(self):
                expr1 = EventExpression(event_type=event_type1)
                expr2 = EventExpression(event_type=event_type2)
                expr3 = EventExpression(event_type=event_type3)
                expression = expr1 | expr2 | expr3
                while True:
                    yield expression
                    # TODO, readd
                    # if x is not None:
                    #     self.done_1 = True
                    #     # expression.remove_condition(expr1)  # TODO, readd this
                    # if y is not None:
                    #     self.done_2 = True
                    # if z is not None:
                    #     self.done_3 = True
                    #     # expression.remove_condition(expr3) # TODO, readd this

        p = ProtocolTest()
        god = Entity()
        god._schedule_now(event_type3)
        god._schedule_now(event_type2)
        god._schedule_now(event_type1)
        p.start()
        sim_run()
        # TODO, readd
        # self.assertTrue(p.done_1)
        # self.assertTrue(p.done_2)
        # self.assertTrue(p.done_3)

    def test_and_events(self):
        """Test if chaining await_events with and is correct"""
        event_type1 = EventType("type1", "type1 triggered")
        event_type2 = EventType("type2", "type2 triggered")
        event_type3 = EventType("type3", "type3 triggered")

        class ProtocolTest(Protocol):

            def __init__(self):
                self.done_1 = False
                self.done_2 = False
                self.done_3 = False
                super().__init__()

            def run(self):
                expr1 = EventExpression(event_type=event_type1)
                expr2 = EventExpression(event_type=event_type2)
                expr3 = EventExpression(event_type=event_type3)
                expression = expr1 & expr2 & expr3
                while True:
                    yield expression
                    # TODO, readd
                    # assert isinstance(a, tuple)
                    # x, y, z = a
                    # if x is not None:
                    #     self.done_1 = True
                    #     # expression.remove_condition(expr1) # TODO, readd when available
                    # if y is not None:
                    #     self.done_2 = True
                    # if z is not None:
                    #     self.done_3 = True
                    #     # expression.remove_condition(expr3) # TODO, readd when available

        p = ProtocolTest()
        god = Entity()
        god._schedule_now(event_type3)
        god._schedule_now(event_type2)
        god._schedule_now(event_type1)
        p.start()
        sim_run()
        # TODO, uncomment
        # self.assertTrue(p.done_1)
        # self.assertTrue(p.done_2)
        # self.assertTrue(p.done_3)

    def test_and_never_true_simultaneously(self):
        """Checks behaviour when one expression in an AND turns True and False again before the other becomes True

        """

        # current behaviour is that the AND expression does turn True,
        # even though both expressions are never true at the same time
        class Protocol1(ConnectedProtocol):
            def run(self):
                self.send_signal("STATUS1")
                yield self.await_timer(1)
                self.send_signal("STATUS2")
                yield self.await_timer(1)
                self.send_signal("STATUS3")

        class Protocol2(ConnectedProtocol):
            def run(self):
                p1 = Protocol1()
                p1.start()
                self.send_signal("STATUS1")
                yield self.await_timer(3) & self.await_signal(p1, "STATUS2")
                self.send_signal("STATUS2", 2)
                # Should it ever get here?

        p2 = Protocol2()
        p2.start()
        sim_run()
        self.assertFalse(p2.is_running)
        self.assertEqual(p2.get_signal_result("STATUS2"), 2)

    @unittest.skipIf(True, "_get_triggered_conditions is private, rewrite this test when resources are available")
    def test_set_condition(self):
        """Test on the behaviour of the SetCondition, or wait_on_conditions"""

        class SetProtocol(ConnectedProtocol):

            def __init__(self, delays):
                super().__init__()
                self.protocols = []
                for delay in delays:
                    self.protocols.append(SleepProtocol(delay))
                self.cur_time = 0

            def start(self):
                for protocol in self.protocols:
                    protocol.start()
                super().start()

            def run(self):
                conditions = [self.await_signal(protocol) for protocol in self.protocols]
                condition = functools.reduce(operator.or_, conditions)
                y = None
                while condition:
                    y = yield condition
                    true_conditions = condition._get_triggered_conditions()
                    assert len(true_conditions) == 1
                    for cond in conditions:
                        if cond in true_conditions:
                            self.send_signal(Signals.BUSY, cond.sender.name)
                    condition = condition._remove_triggered_conditions()
                assert y is not None

        p = SetProtocol([1, 2, 3])
        p.start()
        sim_run(1.5)
        self.assertEqual(p.get_signal_result(Signals.BUSY), "Sleep1")
        sim_run(2.5)
        self.assertEqual(p.get_signal_result(Signals.BUSY), "Sleep2")
        sim_run(3.5)
        self.assertEqual(p.get_signal_result(Signals.BUSY), "Sleep3")
        self.assertFalse(p.is_running)

        sim_reset()

        p = SetProtocol([3, 2, 1, 2])
        p.start()
        sim_run(1.5)
        self.assertEqual(p.get_signal_result(Signals.BUSY), "Sleep1")
        sim_run(2.5)
        self.assertEqual(p.get_signal_result(Signals.BUSY), "Sleep2")
        sim_run(3.5)
        self.assertEqual(p.get_signal_result(Signals.BUSY), "Sleep3")
        self.assertFalse(p.is_running)

        sim_reset()

        p = SetProtocol([3, 1, 2])
        p.start()
        sim_run(1.5)
        self.assertEqual(p.get_signal_result(Signals.BUSY), "Sleep1")
        sim_run(2.5)
        self.assertEqual(p.get_signal_result(Signals.BUSY), "Sleep2")
        sim_run(3.5)
        self.assertEqual(p.get_signal_result(Signals.BUSY), "Sleep3")
        self.assertFalse(p.is_running)

        sim_reset()

        p = SetProtocol([2, 3, 1])
        p.start()
        sim_run(1.5)
        self.assertEqual(p.get_signal_result(Signals.BUSY), "Sleep1")
        sim_run(2.5)
        self.assertEqual(p.get_signal_result(Signals.BUSY), "Sleep2")
        sim_run(3.5)
        self.assertEqual(p.get_signal_result(Signals.BUSY), "Sleep3")
        self.assertFalse(p.is_running)

    @unittest.skipIf(True, "_is_triggered is private, rewrite this test when resources are available")
    def test_condition_turned_true(self):
        """Test on when other conditions become true while a SetCondition was busy running a block"""

        class SetProtocol(ConnectedProtocol):
            def __init__(self, event_types, delays):
                self.event_types = event_types
                self.delays = delays
                super().__init__()

            def run(self):
                n = len(self.event_types)
                conditions = [EventExpression(event_type=event_type) for event_type in self.event_types[:n]]
                conditions += [self.await_evexpr(pd.EventExpression(event_type=event_type))
                               for event_type in self.event_types[n:]]
                conditions += [self.await_timer(delay) for delay in self.delays]
                condition = functools.reduce(operator.or_, conditions)
                total_triggered_conditions = 0
                while condition.size > 0:
                    yield condition
                    triggered_conditions = condition._get_triggered_conditions(True)

                    total_triggered_conditions += len(triggered_conditions)
                    if conditions[0] in triggered_conditions:
                        assert conditions[0]._is_triggered
                        yield self.await_timer(3000)
                    condition = condition._remove_triggered_conditions()
                return 8

        delays = [5, 3, 9, 1, 3, 20, 34, 234]
        event_types = [(EventType(str(i), str(i)), i + 10) for i in range(40)]
        first_type = EventType("FIRST", "First type")
        god = Entity()
        for (event_type, i) in event_types:
            god._schedule_after(i, event_type)

        event_types = [first_type] + [event_type[0] for event_type in event_types]
        p = SetProtocol(event_types, delays)
        p.start()
        god._schedule_after(0.5, first_type)
        sim_run()
        self.assertEqual(p.get_signal_result(Signals.FINISHED), None)
        self.assertTrue(p.is_running)

    def test_yield_twice(self):
        """Test yielding twice on the same expression"""

        class YieldTwiceProtocol(ConnectedProtocol):

            def __init__(self, protocol):
                super().__init__("YieldTwiceProtocol")
                self.add_signal("DONE")
                self.protocol = protocol

            def run(self):
                self.protocol.start()
                status_cond = self.await_signal(self.protocol)
                yield status_cond
                assert sim_time() == 9
                yield status_cond
                assert sim_time() == 18
                self.protocol.reset()
                yield status_cond
                assert sim_time() == 27
                return 5

        sp = SleepProtocol(9)
        p = YieldTwiceProtocol(sp)
        p.start()
        sim_run()
        self.assertTrue(p.is_running)
        self.assertEqual(sim_time(), 9)
        sp.reset()
        sim_run()

        self.assertEqual(p.get_signal_result(Signals.FINISHED), 5)

    def test_return_from_protocol(self):
        """Test if the right values are returned for protocols"""

        class TestProtocol1(ConnectedProtocol):

            def run(self):
                self.send_signal("STATUS0", 0)
                yield self.await_timer(1)
                self.send_signal("STATUS1", 1)
                self.send_signal("STATUS2", 2)
                yield self.await_timer(1)
                self.send_signal("STATUS0", 3)
                self.send_signal("STATUS3", 3)
                yield self.await_timer(1)
                self.send_signal("STATUS4", 4)
                return 5

        class TestProtocol2(ConnectedProtocol):
            def run(self):
                self.send_signal("STATUS0", 0)
                yield self.await_timer(4)
                self.send_signal("STATUS1", 1)

        class ReturnProtocol(ConnectedProtocol):
            def run(self):
                p1 = TestProtocol1()
                p1.start()
                yield self.await_signal(p1, "STATUS0")
                z = p1.get_signal_result("STATUS0")
                assert z == 0
                assert p1.get_signal_result("STATUS0") == 0
                assert sim_time() == 0
                yield self.await_signal(p1, "STATUS3")
                assert sim_time() == 2
                assert p1.get_signal_result("STATUS0") == 3
                assert p1.get_signal_result("STATUS1") == 1
                assert p1.get_signal_result("STATUS2") == 2
                p2 = TestProtocol2()
                p2.start()
                yield self.await_signal(p1) & self.await_signal(p2, "STATUS1")
                assert p1.get_signal_result(Signals.FINISHED) == 5
                assert p2.get_signal_result("STATUS1") == 1
                assert sim_time() == 6
                p1.reset()
                p2.reset()
                expr2 = self.await_signal(p2, "STATUS1")
                yield self.await_signal(p1, "STATUS2") | expr2
                assert p1.get_signal_result("STATUS2") == 2
                assert p2.get_signal_result("STATUS1") is None
                assert sim_time() == 7
                yield expr2
                assert p2.get_signal_result("STATUS1") == 1
                assert sim_time() == 10
                yield self.await_timer(8e5)
                return 5

        p = ReturnProtocol()
        p.start()
        sim_run(400)

        self.assertTrue(p.is_running)
        self.assertIsNone(p.get_signal_result(Signals.FINISHED))
        sim_run()
        self.assertFalse(p.is_running)
        self.assertEqual(p.get_signal_result(Signals.FINISHED), 5)

    def test_start_subprotocols(self):

        class ParentProtocol(ConnectedProtocol):
            def __init__(self, subprotocols):
                super().__init__()
                for i in subprotocols:
                    self.add_subprotocol(i)

        subprotocols = [SleepProtocol(i) for i in range(10)]
        parent_protocol = ParentProtocol(subprotocols)
        parent_protocol.start()
        self.assertTrue(parent_protocol.is_running)
        for i in subprotocols:
            self.assertTrue(i.is_running)

    def test_start_subprotocols_custom_run(self):

        class ParentProtocol(ConnectedProtocol):
            def __init__(self, subprotocols):
                super().__init__()
                j = 0
                for i in subprotocols:
                    self.add_subprotocol(i, j)
                    j += 1

            def run(self):
                for i in self.subprotocols.values():
                    i.start()
                    yield self.await_signal(i)

        subprotocols = [SleepProtocol(i) for i in range(10)]
        parent_protocol = ParentProtocol(subprotocols)
        parent_protocol.start()
        self.assertTrue(parent_protocol.is_running)
        for i in range(10):
            sim_run(duration=i)
            for j in range(10):
                if i == j:
                    self.assertTrue(subprotocols[j].is_running)
                else:
                    self.assertFalse(subprotocols[j].is_running)
        sim_run()
        self.assertFalse(parent_protocol.is_running)
        self.assertEqual(sim_time(), 45)


class TestProtocolPort(unittest.TestCase):
    """Unit tests for protocols using ports

    """

    def setUp(self):
        sim_reset()

    def test_port_input(self):
        comp_first, comp_last, _ = setup_forwarding_ports(10)

        class PortProtocol(ConnectedProtocol):
            def __init__(self, port):
                super().__init__()
                self.port = port
                self.done = False

            def run(self):
                yield self.await_port_input(self.port)
                x = self.port.rx_input()
                assert x is not None, x
                assert x.items[0] == "HI"
                self.done = True

        p = PortProtocol(comp_first.ports["in"])
        p.start()
        sim_run(1)
        self.assertFalse(p.done)
        comp_last.ports["in"].tx_input("HI")
        self.assertFalse(p.done)
        sim_run()
        self.assertTrue(p.done)

    def test_port_output(self):
        comp_first, comp_last, _ = setup_forwarding_ports(10)

        class PortProtocol(ConnectedProtocol):
            def __init__(self, port):
                super().__init__()
                self.port = port
                self.done = False

            def run(self):
                yield self.await_port_output(self.port)
                x = self.port.rx_output()
                assert x is not None, x
                assert x.items[0] == "HI"
                self.done = True

        p = PortProtocol(comp_last.ports["out"])
        p.start()
        sim_run()
        self.assertFalse(p.done)
        comp_first.ports["out"].tx_output("HI")
        self.assertFalse(p.done)
        sim_run()
        self.assertTrue(p.done)

    def test_port_pass_through_output(self):
        """Test if forwarding ports schedule an event when port is listening to output"""
        parent_component, last_component, components = setup_forwarding_ports(10)
        parent_component.ports["out"].tx_output("HI")
        x = last_component.ports["out"].rx_output()
        self.assertEqual(x.items, ["HI"])
        stats = sim_run()
        self.assertEqual(stats.data["events_triggered"], 1)

        class PortProtocol(ConnectedProtocol):
            def __init__(self, port):
                super().__init__()
                self.port = port
                self.done = False

            def run(self):
                yield self.await_port_output(self.port)
                self.done = True

        pp = PortProtocol(components[5].ports["out"])
        pp.start()
        parent_component.ports["out"].tx_output("HI")
        stats = sim_run()
        self.assertTrue(pp.done)
        self.assertEqual(stats.data["events_triggered"], 3)

        class PortProtocol(ConnectedProtocol):
            def __init__(self, port):
                super().__init__()
                self.port = port
                self.done = False

            def run(self):
                y = yield self.await_port_output(self.port)
                assert y.value is True, y
                self.done = True

        pp = PortProtocol(components[5].ports["out"])
        pp.start()
        parent_component.ports["out"].tx_output("HI")
        stats = sim_run()
        self.assertTrue(pp.done)
        self.assertEqual(stats.data["events_triggered"], 3)

    def test_port_pass_through_input(self):
        """Test if forwarding ports schedule an event when port is listening to input"""
        parent_component, last_component, components = setup_forwarding_ports(10)
        parent_component.ports["in"].tx_input("HI")
        x = parent_component.ports["in"].rx_input()
        self.assertEqual(x.items, ["HI"])
        stats = sim_run()
        self.assertEqual(stats.data["events_triggered"], 1)

        class PortProtocol(ConnectedProtocol):
            def __init__(self, port):
                super().__init__()
                self.port = port
                self.done = False

            def run(self):
                yield self.await_port_input(self.port)
                self.done = True

        pp = PortProtocol(components[5].ports["in"])
        pp.start()
        last_component.ports["in"].tx_input("HI")
        stats = sim_run()
        self.assertTrue(pp.done)
        self.assertEqual(stats.data["events_triggered"], 3)

        class PortProtocol(ConnectedProtocol):
            def __init__(self, port):
                super().__init__()
                self.port = port
                self.done = False

            def run(self):
                y = yield self.await_port_input(self.port)
                assert y.value is True, y
                self.done = True

        pp = PortProtocol(components[5].ports["in"])
        pp.start()
        last_component.ports["in"].tx_input("HI")
        stats = sim_run()
        self.assertTrue(pp.done)
        self.assertEqual(stats.data["events_triggered"], 3)

    def test_passthrough_with_filters(self):
        """Test if forwarding ports correctly schedule when meta filters correspond to message"""
        parent_component, last_component, components = setup_forwarding_ports(10)

        parent_component.ports["in"].tx_input(Message("HI", header=1, other_meta=5))
        x = last_component.ports["in"].rx_input(other_meta=4)
        self.assertIsNone(x)
        x = parent_component.ports["in"].rx_input(other_meta=5)
        self.assertEqual(x.items, ["HI"])
        x = parent_component.ports["in"].rx_input(other_meta=5)
        self.assertIsNone(x)
        stats = sim_run()
        self.assertEqual(stats.data["events_triggered"], 1)

    def test_passthrough_with_filters_input(self):
        parent_component, last_component, components = setup_forwarding_ports(10)

        class PortProtocolInput(ConnectedProtocol):
            def __init__(self, port):
                super().__init__()
                self.port = port
                self.done = False

            def run(self):
                y = yield self.await_port_input(self.port)
                assert self.port.query_meta_input(other_meta=5) is False
                assert self.port.query_meta_input(other_meta=4) is True
                assert self.port.query_meta_input(header=1) is True
                assert y.value is True
                y = yield self.await_port_input(self.port)
                assert self.port.query_meta_input(other_meta=5) is True
                assert self.port.query_meta_input(header=1, other_meta=5) is True
                assert self.port.query_meta_input(header=2, other_meta=5) is False
                assert self.port.query_meta_input(header=2, other_meta=2) is True
                assert self.port.query_meta_input(other_meta=4) is False
                assert self.port.query_meta_input(header=4) is False
                assert y.value is True, y
                self.done = True

        pp = PortProtocolInput(components[5].ports["in"])
        pp.start()
        last_component.ports["in"].tx_input(Message("HI", header=1, other_meta=4))
        stats = sim_run()
        self.assertFalse(pp.done)
        self.assertEqual(stats.data["events_triggered"], 2)
        sim_run(1)
        last_component.ports["in"].tx_input(Message("HI", header=1, other_meta=5))
        last_component.ports["in"].tx_input(Message("HI", header=2, other_meta=2))
        stats = sim_run()
        self.assertTrue(pp.done)
        self.assertEqual(stats.data["events_triggered"], 4)

    def test_passthrough_with_filters_output(self):
        parent_component, last_component, components = setup_forwarding_ports(10)

        class PortProtocolOutput(ConnectedProtocol):
            def __init__(self, port):
                super().__init__()
                self.port = port
                self.done = False

            def run(self):
                y = yield self.await_port_output(self.port)
                assert self.port.query_meta_output(other_meta=5) is False
                assert self.port.query_meta_output(other_meta=4) is True
                assert self.port.query_meta_output(header=1) is True
                assert y.value is True
                y = yield self.await_port_output(self.port)
                assert self.port.query_meta_output(other_meta=5) is True
                assert self.port.query_meta_output(header=1, other_meta=5) is True
                assert self.port.query_meta_output(header=2, other_meta=5) is False
                assert self.port.query_meta_output(header=2, other_meta=2) is True
                assert self.port.query_meta_output(other_meta=4) is False
                assert self.port.query_meta_output(header=4) is False
                assert y.value is True, y
                self.done = True

        pp = PortProtocolOutput(components[5].ports["out"])
        pp.start()
        parent_component.ports["out"].tx_output(Message("HI", header=1, other_meta=4))
        stats = sim_run()
        self.assertFalse(pp.done)
        self.assertEqual(stats.data["events_triggered"], 2)
        sim_run(1)
        parent_component.ports["out"].tx_output(Message("HI", header=1, other_meta=5))
        parent_component.ports["out"].tx_output(Message("HI", header=2, other_meta=2))
        stats = sim_run()
        self.assertTrue(pp.done)
        self.assertEqual(stats.data["events_triggered"], 4)

    def test_pass_through_parallel_protocols(self):
        """Test if when passing through messages that it doesn't affect other (unrelated) programs"""
        p_component, _, components = setup_forwarding_ports(10)

        class PortProtocol(ConnectedProtocol):
            def __init__(self, port, **meta_filters):
                super().__init__()
                self.port = port
                self.done = False
                self.meta_filters = meta_filters

            def run(self):
                msg = False
                y = None
                while msg is False:
                    y = yield self.await_port_output(self.port)
                    msg = self.port.query_meta_output(**self.meta_filters)
                assert y.value is True, y
                self.done = True

        pp1 = PortProtocol(components[5].ports["out"], header=1)
        pp2 = PortProtocol(components[5].ports["out"], header=2)
        pp1.start()
        pp2.start()
        p_component.ports["out"].tx_output(Message("Elephant", header=1, other_meta=5))
        sim_run()
        self.assertTrue(pp1.done)
        self.assertFalse(pp2.done)

    def test_multiple_listeners(self):
        """Test if multiple listeners to the same meta register correctly"""
        p_component, _, components = setup_forwarding_ports(10)

        class PortProtocol(ConnectedProtocol):
            def __init__(self, port, **meta_filters):
                super().__init__()
                self.port = port
                self.done = False
                self.meta_filters = meta_filters

            def run(self):
                y = yield self.await_port_output(self.port)
                assert y.value is True, y
                self.done = True

        port = components[5].ports["out"]
        pp1 = PortProtocol(port, header=1)
        pp2 = PortProtocol(port, header=1)
        pp1.start()
        pp2.start()
        p_component.ports["out"].tx_output(Message("Elephant", header=1, other_meta=5))
        sim_run()
        self.assertTrue(pp1.done)
        self.assertTrue(pp2.done)

    def test_listeners_in_non_atomic_ee(self):
        """Test if ports correctly stop listening when in a non-atomic event expression"""
        p_component, _, components = setup_forwarding_ports(10)

        class PortProtocol(ConnectedProtocol):
            def __init__(self, port):
                super().__init__()
                self.port = port
                self.done = False

            def run(self):
                expr1 = self.await_port_output(self.port)
                expr2 = self.await_port_output(self.port)
                y = yield expr1 | expr2
                msg1 = self.port.rx_output(header=1)
                msg2 = self.port.rx_output(header=2)
                assert (msg1, msg2) == (None, None)
                assert self.port.query_meta_output(header=1) is True
                assert self.port.query_meta_output(header=2) is False
                assert isinstance(y, EventExpression)
                assert y.type == y.OR
                yield self.await_timer(40)
                self.done = True

        port = components[5].ports["out"]
        pp = PortProtocol(port)
        pp.start()
        p_component.ports["out"].tx_output(Message("Elephant", header=1, other_meta=5))
        sim_run()
        self.assertTrue(pp.done)

    def test_start_after_send(self):
        """Test if protocol still receives message even if the message was send before protocol was started"""
        p_component, _, components = setup_forwarding_ports(10)

        class PortProtocol(Protocol):
            def __init__(self, port1, port2):
                super().__init__()
                self.port1 = port1
                self.port2 = port2
                self.done = False

            def run(self):
                expr1 = self.await_port_output(self.port1)
                expr2 = self.await_port_output(self.port2)
                yield expr1 | expr2
                self.done = True

        p = PortProtocol(components[5].ports["out"], components[4].ports["out"])
        p_component.ports["out"].tx_output(Message("Hi", header=1, other_meta=5))
        p.start()
        sim_run()
        self.assertFalse(p.done)


class SuccessProgram(QuantumProgram):
    default_num_qubits = 2

    def program(self):
        q1, q2 = self.get_qubit_indices(2)
        self.apply(instr.INSTR_X, q1)
        self.apply(instr.INSTR_CNOT, [q1, q2])
        self.apply(instr.INSTR_SIGNAL)
        self.apply(instr.INSTR_MEASURE, q1, output_key="m1")
        self.apply(instr.INSTR_MEASURE, q2, output_key="m2")
        # Specify a custom program that implements same gates:
        self.output["A"] = 1
        yield self.run()


class FailProgram(QuantumProgram):
    default_num_qubits = 2

    def program(self):
        yield self.run()
        raise QuantumProgramError("Program failed!")


class ProgramProtocol(Protocol):

    def __init__(self, processor, program, await_done=True, await_fail=False):
        super().__init__("program_protocol")
        self.processor = processor
        self.program = program
        self.done = False
        self.await_done = await_done
        self.await_fail = await_fail

    def run(self):
        self.processor.execute_program(self.program, qubit_mapping=[0, 2])
        yield self.await_program(self.processor, await_done=self.await_done, await_fail=self.await_fail)
        if self.program.output['last'] is not None:
            assert self.program.output['A'] == 1
        self.done = True


class TestAwaitProgram(unittest.TestCase):

    def setUp(self):
        sim_reset()
        self.processor = QuantumProcessor("TestQPD", num_positions=3, phys_instructions=[
            PhysicalInstruction(instr.INSTR_X, duration=1, topology=[0, 1, 2]),
            PhysicalInstruction(instr.INSTR_CNOT, duration=2),
            PhysicalInstruction(instr.INSTR_SIGNAL, duration=0.1, topology=[()]),
            PhysicalInstruction(instr.INSTR_MEASURE, duration=3)],
        )
        self.processor.put(qapi.create_qubits(2), [0, 2])

    def tearDown(self):
        self.processor.reset()
        sim_reset()

    def test_await_program_success(self):
        """Test if can successfully yield on program"""
        prot_success = ProgramProtocol(self.processor, SuccessProgram())
        prot_success.start()
        self.assertFalse(prot_success.done)
        sim_run()
        self.assertTrue(prot_success.done)
        sim_reset()
        prot_fail = ProgramProtocol(self.processor, FailProgram())
        prot_fail.start()
        self.assertFalse(prot_fail.done)
        sim_run()
        self.assertFalse(prot_fail.done)
        prot_both = ProgramProtocol(self.processor, SuccessProgram() + FailProgram())
        prot_both.start()
        self.assertFalse(prot_both.done)
        sim_run()
        self.assertFalse(prot_both.done)

    def test_await_program_fail(self):
        prot_success = ProgramProtocol(self.processor, SuccessProgram(), await_done=False, await_fail=True)
        prot_success.start()
        self.assertFalse(prot_success.done)
        sim_run()
        self.assertFalse(prot_success.done)
        sim_reset()
        prot_fail = ProgramProtocol(self.processor, FailProgram(), await_done=False, await_fail=True)
        prot_fail.start()
        self.assertFalse(prot_fail.done)
        sim_run()
        self.assertTrue(prot_fail.done)
        prot_both = ProgramProtocol(self.processor, SuccessProgram() + FailProgram(), await_done=False, await_fail=True)
        prot_both.start()
        self.assertFalse(prot_both.done)
        sim_run()
        self.assertTrue(prot_both.done)

    def test_await_program_success_or_fail(self):
        prot_success = ProgramProtocol(self.processor, SuccessProgram(), await_done=True, await_fail=True)
        prot_success.start()
        self.assertFalse(prot_success.done)
        sim_run()
        self.assertTrue(prot_success.done)
        sim_reset()
        prot_fail = ProgramProtocol(self.processor, FailProgram(), await_done=True, await_fail=True)
        prot_fail.start()
        self.assertFalse(prot_fail.done)
        sim_run()
        self.assertTrue(prot_fail.done)
        prot_both = ProgramProtocol(self.processor, SuccessProgram() + FailProgram(), await_done=True, await_fail=True)
        prot_both.start()
        self.assertFalse(prot_both.done)
        sim_run()
        self.assertTrue(prot_both.done)

    def test_await_program_success_nor_fail(self):
        prot = ProgramProtocol(self.processor, SuccessProgram(), await_done=False, await_fail=False)
        with self.assertRaises(ValueError):
            prot.start()


if __name__ == "__main__":
    unittest.main()
