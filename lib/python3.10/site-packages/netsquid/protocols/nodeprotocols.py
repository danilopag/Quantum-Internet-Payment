# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: nodeprotocols.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Defines protocols that run on a single or multiple nodes.

"""
import abc
import types
from collections.abc import Mapping
from netsquid.protocols.protocol import Protocol, Signals
from netsquid.nodes.node import Node
from netsquid.util.constrainedmap import ConstrainedMap, ValueConstraint

__all__ = [
    "LocalProtocol",
    "NodeProtocol",
    "DataNodeProtocol",
    "TimedNodeProtocol",
]


class LocalProtocol(Protocol, metaclass=abc.ABCMeta):
    """Protocol that runs locally on one or more nodes.

    Parameters
    ----------
    nodes : dict or list or None, optional
        If dict, (Name, Node) pairs to specify and set for this protocol per key. If list,
        only the node names are specified, and None values are set.
        Specified node should be set to non-None value before starting the protocol.
    name : str or None, optional
        Name of protocol. If None, the name of the class is used.
    max_nodes : int, optional
        Maximum number of nodes that may be specified. If less than 1 (default) there is no maximum.

    """

    def __init__(self, nodes=None, name=None, max_nodes=-1):
        super().__init__(name)
        if not isinstance(max_nodes, int):
            raise TypeError("max_nodes must be an integer")
        self._max_nodes = max_nodes
        # Define nodes map
        unique_node_constraint = ValueConstraint(
            constraint_function=self._check_node_unique,
            error_message="Nodes in nodes map must be unique.")
        self._nodes = ConstrainedMap(global_constraints=[unique_node_constraint])
        # Specify node names and set if applicable
        if nodes is not None:
            if isinstance(nodes, Mapping):
                for name, node in nodes.items():
                    self.specify_node(name)
                    if node is not None:
                        self.nodes[name] = node
            else:
                for name in nodes:
                    self.specify_node(name)

    def _check_node_unique(self, node):
        # Constraint function
        return node is None or node not in self.nodes.values()

    @property
    def nodes(self):
        """:obj:`~netsquid.util.constrainedmap.ConstrainedMap`: nodes local to this protocol."""
        return self._nodes

    @property
    def max_nodes(self):
        """int: maximum number of nodes this local protocol can run on."""
        return self._max_nodes

    def specify_node(self, name):
        """Specify a node required by this protocol.

        The protocol cannot start until all specified nodes are set.

        Parameters
        ----------
        name : str
            Key to index the node with.

        Raises
        ------
        RuntimeError
            If specifying this node will exceed the maximum number of nodes
            :attr:`~netsquid.protocols.nodeprotocols.LocalProtocol.max_nodes`.

        """
        if 0 < self._max_nodes < len(self.nodes) + 1:
            raise RuntimeError("")
        if name not in self.nodes:
            self.nodes.internal_add(name, value=None, value_type=Node)

    @property
    def is_connected(self):
        """Whether protocol has been properly configured and can be started.

        Requires that all specified nodes have been set (are not None).

        Returns
        -------
        bool
            True if protocol is fully and correctly connected, otherwise False.

        """
        return None not in self.nodes.values()

    def can_signal_to(self, protocol):
        """Whether this protocol can send a signal to another protocol.

        A local protocol can only signal to another local protocol if they have
        one or more nodes in common.
        A local protocol can always signal to a standard (non-local) protocol.

        Parameters
        ----------
        protocol : :class:`~netsquid.protocols.protocol.Protocol`
            Protocol queried as to whether this protocol can send a signal to.

        Returns
        -------
        bool
            Whether this protocol can signal to the other protocol.

        """
        if isinstance(protocol, LocalProtocol):
            self_num_nodes = len(self.nodes)
            other_num_nodes = len(protocol.nodes)
            if self_num_nodes == 0 or other_num_nodes == 0:
                return False
            elif self_num_nodes == 1 and other_num_nodes == 1:
                return next(iter(self.nodes.values())) == next(iter(protocol.nodes.values()))
            elif self_num_nodes == 1:
                return next(iter(self.nodes.values())) in protocol.nodes.values()
            elif other_num_nodes == 1:
                return next(iter(protocol.nodes.values())) in self.nodes.values()
            else:
                return not set(self.nodes.values()).isdisjoint(set(protocol.nodes.values()))
            # if not self.is_connected or not protocol.is_connected:
            #    raise RuntimeError("Nodes must be connected to check if they can signal")
        else:
            return True

    def __repr__(self):
        # return "LocalProtocol({}, {!r})".format(list(self.nodes.keys()), self.name)
        return f"{type(self).__name__}({list(self.nodes.keys())}, {repr(self.name)})"


class NodeProtocol(LocalProtocol, metaclass=abc.ABCMeta):
    """Protocol that runs on one node.

    Parameters
    ----------
    node : :class:`~netsquid.nodes.node.Node` or None, optional
        Node this protocol runs on. If None, a node should be set later before starting
        this protocol.
    name : str or None, optional
        Name of protocol. If None, the name of the class is used.

    """

    def __init__(self, node=None, name=None):
        super().__init__(nodes={"node": node}, name=name, max_nodes=1)

    @property
    def node(self):
        """:class:`~netsquid.nodes.node.Node`: single node this protocol is running on."""
        return self.nodes["node"]

    @node.setter
    def node(self, node):
        if node is not self.nodes["node"]:
            self.nodes["node"] = node

    def __repr__(self):
        # return "NodeProtocol({}, {})".format(self.node, self.name)
        return f"{type(self).__name__}({repr(self.node)}, {repr(self.name)})"


class DataNodeProtocol(NodeProtocol, metaclass=abc.ABCMeta):
    """Protocol class tailored towards processing received data.

    Subclass to form specific protocols.
    Overwrite process_data() to process the message received at the given port.
    Overwrite post_process_data() to post process the message

    Parameters
    ----------
    node : :class:`~netsquid.nodes.node.Node`
        Node this protocol runs on.
    port_name : str
        Name of the port where the to be processed data is send to.
        Will create the port if it does not yet exist
    name : str or None, optional
        Name of protocol. If None, the name of the class is used.

    Signals
    -------
    - :obj:`~netsquid.protocols.protocol.Signals`.BUSY
        Signalled when protocol has received data and starts processing them.
    - :obj:`~netsquid.protocols.protocol.Signals`.READY
        Signalled when data is processed and post_processed.
        Value of this signal is de value returned by post_process_data

    """

    def __init__(self, node, port_name, name=None):
        super().__init__(node=node, name=name)
        self.port_name = port_name

    @property
    def port_name(self):
        """str: The name of the port this protocol is listening to."""
        return self._port_name

    @port_name.setter
    def port_name(self, value):
        """str: Set the name of the port this protocol is listening to.
        Will create the port if it does not exist"""
        if value is not None and self.node is not None and value not in self.node.ports:
            self.node.add_ports([value])
        self._port_name = value

    def run(self):
        if self.node is None or self._port_name is None:
            raise ValueError("Node and port name need to be set for a node protocol")
        while True:
            yield self.await_port_input(self.node.ports[self._port_name])
            message = self.node.ports[self._port_name].rx_input()
            self.send_signal(Signals.BUSY)
            res = self.process_data(message)
            if isinstance(res, types.GeneratorType):
                res = yield from res
            if res is True:
                res = self.post_process_data(message)
                if isinstance(res, types.GeneratorType):
                    res = yield from res
                self.send_signal(Signals.READY, res)
            elif res is not False:
                self.send_signal(Signals.READY, res)

    @abc.abstractmethod
    def process_data(self, message):
        """Process the available data.

        This method should be overridden by subclasses of DataNodeProtocol

        Parameters
        ----------
        message : :obj:`~netsquid.components.component.Message`
            The message received on the port to be processed

        Returns
        -------
        True
            If data was successfully processed and can be post processed
        False
            If more messages need to received until it can be post processed
        Any
            Anything else and the post process will be skipped.
            The returned value will be signalled with a Signals.READY

        Notes
        -----
        This method can also be a generator yielding on :obj:`~pydynaa.core.EventExpression`
        """
        return True

    @abc.abstractmethod
    def post_process_data(self, message):
        """Perform any post processing, once processing is otherwise done.

        To be overwritten

        Parameters
        ----------
        message : :obj:`~netsquid.components.component.Message`
            The message received on the port to be processed

        Returns
        -------
        object
            The data to be signalled with a Signals.READY signal when post processing is done

        Notes
        -----
        This method can also be a generator yielding on :obj:`~pydynaa.core.EventExpression`
        """
        pass


class TimedNodeProtocol(NodeProtocol, metaclass=abc.ABCMeta):
    """Protocol that will execute at specific time intervals until stopped.

    Parameters
    ----------
    node : :obj:`netsquid.nodes.node.Node`
        Node where this timed protocol will be run.
    time_step : float
        Time period to wait between protocol executions.
    start_time : float, optional
        Offset when first to start. Default is zero.

    """

    def __init__(self, node, time_step, start_time=0):
        super().__init__(node=node)
        self.time_step = time_step
        self.start_time = start_time

    @property
    def time_step(self):
        """float: time period to wait between protocol executions."""
        return self._time_step

    @time_step.setter
    def time_step(self, value):
        if value <= 0:
            raise ValueError("Time step should be greater than zero, not {}".format(value))
        self._time_step = value

    @property
    def start_time(self):
        """float: offset when first to start."""
        return self._start_time

    @start_time.setter
    def start_time(self, value):
        if value < 0:
            raise ValueError("Time step should be greater than or equal to zero, not {}".format(value))
        self._start_time = value

    def run(self):
        yield self.await_timer(self.start_time)
        while True:
            self.exec_protocol()
            yield self.await_timer(self.time_step)

    @abc.abstractmethod
    def exec_protocol(self):
        """Execute the timed protocol at a time interval.

        """
        pass
