# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# File: serviceprotocol.py
# 
# This file is part of the NetSquid package (https://netsquid.org).
# It is subject to the NetSquid Software End User License Conditions.
# A copy of these conditions can be found in the LICENSE.md file of this package.
# 
# NetSquid Authors
# ================
# 
# NetSquid is being developed within [Quantum Internet division](https://qutech.nl/research-engineering/quantum-internet/) at QuTech.
# QuTech is a collaboration between TNO and the TUDelft.
# 
# Active authors (alphabetical):
# 
# - Tim Coopmans (scientific contributor)
# - Chris Elenbaas (software developer)
# - David Elkouss (scientific supervisor)
# - Rob Knegjens (tech lead, software architect)
# - IÃ±aki Martin Soroa (software developer)
# - Julio de Oliveira Filho (software architect)
# - Ariana Torres Knoop (HPC contributor)
# - Stephanie Wehner (scientific supervisor)
# 
# Past authors (alphabetical):
# 
# - Axel Dahlberg (scientific contributor)
# - Damian Podareanu (HPC contributor)
# - Walter de Jong (HPC contributor)
# - Loek Nijsten (software developer)
# - Martijn Papendrecht (software developer)
# - Filip Rozpedek (scientific contributor)
# - Matt Skrzypczyk (software contributor)
# - Leon Wubben (software developer)
# 
# The simulation engine of NetSquid depends on the pyDynAA package,
# which is developed at TNO by Julio de Oliveira Filho, Rob Knegjens, Coen van Leeuwen, and Joost Adriaanse.
# 
# Ariana Torres Knoop, Walter de Jong and Damian Podareanu from SURFsara have contributed towards the optimization and parallelization of NetSquid.
# 
# Hana Jirovska and Chris Elenbaas have built Python packages for MacOS.
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file uses NumPy style docstrings: https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt

"""Defines a base class for service protocols.

"""
import abc
import types
from netsquid.protocols.nodeprotocols import NodeProtocol
from netsquid.util.constrainedmap import ConstrainedMap, ValueConstraint

__all__ = [
    'ServiceProtocol',
    'ServiceError'
]


class ServiceProtocol(NodeProtocol, metaclass=abc.ABCMeta):
    """Extends a node protocol with an interface for service requests and responses.

    A service protocol runs on a single node and has predefined requests and responses.
    A request or response type must be registered with a unique name.
    Via the :meth:`~netsquid.protocols.serviceprotocol.put` method a request can be submitted to the protocol.
    Only requests that are registered will be handled by the protocol.
    If the request is registered, it is handled by
    the :meth:`~netsquid.protocols.serviceprotocol.handle_request` method.

    When a request has finished the protocol is expected to return a response
    using :meth:`~netsquid.protocols.serviceprotocol.send_response`.
    This response should match one of the registered response types.
    The response is send as a signal, where the the name of the response type is used as signal label.

    Parameters
    ----------
    node : :class:`~netsquid.nodes.node.Node`
        The node this protocol is running on
    name : str, optional
        The name of this protocol

    Examples
    --------
    >>> from netsquid.protocols import ServiceProtocol
    >>> from netsquid.nodes import Node
    >>> from collections import namedtuple
    ...
    >>> class Service(ServiceProtocol):
    ...     req_write = namedtuple('req_write', ['content'])
    ...     res_ok = namedtuple('res_ok', ['content'])
    ...
    ...     def __init__(self, node, name=None):
    ...         super().__init__(node=node, name=name)
    ...         self.register_request(self.req_write, self.write)
    ...         self.register_response(self.res_ok)
    ...
    ...     def write(self, req):
    ...         # We will just print for now
    ...         print(req)
    ...         res = self.res_ok('Done')
    ...         self.send_response(res)
    ...
    >>> service = Service(Node("Alice"))
    >>> request = Service.req_write(content='Hello, world!')
    >>> service.put(request)
    req_write(content='Hello, world!')

    It is also possible to re-use the same request or response type.
    Unique names are used to differentiate between them.

    >>> service.register_request(service.req_write, lambda x: print(x._fields), name='print')
    >>> service.request_types
    ConstrainedMap({'req_write': <class '__main__.req_write'>, 'print': <class '__main__.req_write'>})
    >>> service.put(request, name='print')
    ('content',)


    See the `simple link example <../api_examples/netsquid.examples.simple_link.html>`_ for a full example.

    """

    def __init__(self, node, name=None):
        super().__init__(node=node, name=name)
        callable_constraint = ValueConstraint(callable, error_message="Handlers should be callable.")
        self._req_handlers = ConstrainedMap(global_constraints=[callable_constraint])
        type_constraint = ValueConstraint(
            lambda x: isinstance(x, type),
            error_message="Request and response types should be of type 'type'.")
        self._req_types = ConstrainedMap(global_constraints=[type_constraint])
        self._res_types = ConstrainedMap(global_constraints=[type_constraint])

    @staticmethod
    def get_name(obj):
        """Return the name of a class or object.

        Parameters
        ----------
        obj :
            Any object or class.

        Returns
        -------
        str
            The name representing the class or object.

        """
        if type(obj) == type:
            return obj.__name__
        else:
            return type(obj).__name__

    @property
    def request_types(self):
        """:class:`~netsquid.util.constrainedmap.ConstrainedMap`: map of the available service requests."""
        return self._req_types

    @property
    def response_types(self):
        """:class:`~netsquid.util.constrainedmap.ConstrainedMap`: map of the available service responses."""
        return self._res_types

    @property
    def request_handlers(self):
        """:class:`~netsquid.util.constrainedmap.ConstrainedMap`: map of handler callbacks of registered requests."""
        return self._req_handlers

    def register_response(self, res_type, name=None):
        """Register a response for this service.

        Parameters
        ----------
        res_type :
            The class representing the response.
        name : str or None, optional
            The identifier to use when sending a signal.
            If None (default) uses
            :meth:`~netsquid.protocols.serviceprotocol.ServiceProtocol.get_name` of the request.

        Raises
        ------
        ServiceError
            If the name has already been registered.

        """
        if name is None:
            name = self.get_name(res_type)
        if name in self._res_types:
            raise ServiceError(f"Name '{name}' has already been registered, cannot register it again.")
        self.add_signal(name)
        self._res_types.internal_add(name, res_type, mutable=False)

    def register_request(self, req_type, handler, name=None):
        """Register a request for this service.

        Parameters
        ----------
        req_type :
            The class representing the request.
        handler : callable
            The function used to respond to the request.
        name : str or None, optional
            An identifier for this request.
            If None (default) uses
            :meth:`~netsquid.protocols.serviceprotocol.ServiceProtocol.get_name` of the request.

        Raises
        ------
        ServiceError
            If the name is already registered.

        """
        if name is None:
            name = self.get_name(req_type)
        if name in self._req_types:
            raise ServiceError(f"Name '{name}' is already registered, cannot register it again.")
        self._req_handlers.internal_add(name, handler, mutable=False)
        self._req_types.internal_add(name, req_type, mutable=False)

    def put(self, request, name=None):
        """Put a request to the service.

        Parameters
        ----------
        request :
            A request instance.
        name : str or None, optional
            The identifier for the handler.
            If None (default), uses the
            :meth:`~netsquid.protocols.serviceprotocol.ServiceProtocol.get_name` of the request.

        Returns
        -------
        object
            The value returned by :meth:`~netsquid.protocols.serviceprotocol.ServiceProtocol.handle_request`.

        Raises
        ------
        ServiceError
            If the name doesn't match to the request type.

        """
        if name is None:
            name = self.get_name(request)
        if self._req_types[name] is not type(request):
            raise ServiceError(f"Name '{name}' doesn't match with request type {type(request)}.")
        return self.handle_request(request, name)

    def handle_request(self, request, name):
        """Handle the request to be run by the service.

        Runs the request handler if it is not a generator.
        See the `simple link example <../api_examples/netsquid.examples.simple_link.html>`_ for an example of how
        to implement generators.

        Parameters
        ----------
        request : :class:`collections.namedtuple` or object
            The object representing the request.
        name : str
            The identifier for this request.

        Returns
        -------
        object
            The object returned by the request handler.

        Raises
        ------
        NotImplementedError
            If the handler is a generator

        Notes
        -----
        This method is called after :meth:`~netsquid.protocols.serviceprotocol.ServiceProtocol.put` which
        does the type checking etc.
        Objects returned here are passed to :meth:`~netsquid.protocols.serviceprotocol.ServiceProtocol.put` and allow
        the user to return information available at the time of putting the request,
        like a unique identifier or estimated time of completion.

        """
        handler = self._req_handlers[name]
        result = handler(request)
        if isinstance(result, types.GeneratorType):
            raise NotImplementedError("The default ServiceProtocol can't handle generators.")
        return result

    def send_response(self, response, name=None):
        """Send a response via a signal.

        Parameters
        ----------
        response : :class:`collections.namedtuple` or object
            The response instance.
        name : str or None, optional
            The identifier used for this response.
            Default :meth:`~netsquid.protocols.serviceprotocol.ServiceProtocol.get_name` of the request.

        Raises
        ------
        ServiceError
            If the name doesn't match to the request type.

        """
        if name is None:
            name = self.get_name(response)
        if self._res_types[name] is not type(response):
            raise ServiceError(f"Name '{name}; doesn't match with the registered request type {type(response)}")
        self.send_signal(name, result=response)


class ServiceError(Exception):
    """An error associated to service protocols.

    """
    pass
