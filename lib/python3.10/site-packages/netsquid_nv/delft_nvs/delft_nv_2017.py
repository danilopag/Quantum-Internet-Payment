"""
Parameters for the NV center devices
used in "Entanglement distillation between solid-state quantum network nodes"
(http://doi.org/10.1126/science.aan0070).
This work was published in 2017.
"""

from netsquid_nv.nv_parameter_set import NVParameterSet
import numpy as np
from netsquid_nv.delft_nvs.delft_nv_2019 import NVParameterSet2019


def compute_tau_in_fidelity(delta_w, characteristic_number_of_attempts):
    r"""
    Computes the decay parameter :math:`\tau` from the coupling strength
    :math:`\delta\omega` and the characteristic number of attempts :math:`N_{1/e}`,
    i.e. the number of entangling attempts until a carbon nuclear spin, which was
    initialized in the |+>-state, has decreased in fidelity to :math:`1/2 + 1/e`.

    This method inverts the function

    ..math::

        F(\tau) = 1/2 + 1/e

    where :math:`F(\tau)` is given by in eq.(3.2) in ' Towards quantum networks
    of single spins: analysis of a quantum memory with an optical interface in
    diamond' by Blok et al. (DOI: 10.1039/C5FD00113G).

    Note
    ----
    A related function for equatorial Bloch vector length instead of fidelity
    is used in `Dephasing mechanisms of diamond-based
    nuclear-spin memories for quantum networks` by Kalb et al.
    (DOI: 10.1103/PhysRevA.97.062330).

    Parameters
    ----------
    delta_w : float
        Coupling strength (in Hz)
    characteristic_number_of_attempts : float
        :math:`N_{1/e}`
    """

    outcome = 2 / np.exp(1.)
    outcome = outcome ** (1 / characteristic_number_of_attempts)
    outcome = 2 * outcome - 1
    outcome = np.log(outcome) / np.log(np.exp(1))
    outcome = -2. * outcome / (delta_w**2)
    return np.sqrt(outcome)


class NVParameterSet2017(NVParameterSet):
    """
    Parameters for the NV center devices
    used in "Entanglement distillation between solid-state quantum network nodes"
    (http://doi.org/10.1126/science.aan0070).
    """
    # suppl. material p. 2
    magnetic_field_node_A = 418.248  # [G]
    magnetic_field_node_B = 413.980  # [G]

    visibility = 0.72  # p.7 suppl material

    photon_emission_delay = 7. * 10**3  # [nanoseconds] p. 7 suppl. material

    # Per entangling attempt, 3.4 mrad of interferometric drift is observed (suppl material p.5)
    # For 50 entangling attempts, the phase phase thus difts by 50 * 3.4 = ???

    std_electron_electron_phase_drift = 0.
    # 0.073 * np.pi * np.sqrt(2)  #24 * np.pi / 180  # [radians], p. 7 suppl material

    std_electron_photon_phase_drift = std_electron_electron_phase_drift * 180 / (np.pi) * 1 / np.sqrt(2.)

    zero_phonon_prob_without_cavity = 0.03  # suppl material p. 4
    zero_phonon_prob_with_cavity = NVParameterSet2019.p_zero_phonon(cavity=True)

    hyperfine_coupling_parallel_node_A = -2 * np.pi * 30
    hyperfine_coupling_parallel_node_B = 2 * np.pi * 33

    hyperfine_coupling_perpendicular_node_A = 2 * np.pi * 88
    hyperfine_coupling_perpendicular_node_B = 2 * np.pi * 35

    #def delta_w(hyperfine_coupling_parallel, hyperfine_coupling_perpendicular):
    #    """
    #    See
    #    https://journals.aps.org/pra/abstract/10.1103/PhysRevA.97.062330 p. 2-3
    #    for definitions.
    #    """
    #
    #    w_0 = ???
    #
    #    w_pm_1 = np.sqrt( (w_0 - hyperfine_coupling_parallel) ** 2 \
    #                + hyperfine_coupling_perpendicular ** 2)
    #
    #    return np.abs(w_0 - w_pm_1)

    time_window = 40.  # [nanoseconds] p. 3 suppl material

    # p.18 suppl material
    total_detection_eff_detector_1 = 0.0008
    total_detection_eff_detector_2 = 0.0004
    average_detection_efficiency = \
        (total_detection_eff_detector_1 + total_detection_eff_detector_2) / 2
    total_detection_eff = average_detection_efficiency

    real_detection_eff = NVParameterSet2019.real_detection_eff
    p_double_exc = NVParameterSet2019.p_double_exc
    collection_eff_in_case_no_cavity_no_conversion = \
        (total_detection_eff /
         (NVParameterSet2019.p_photon_not_lost *
          zero_phonon_prob_without_cavity *
          real_detection_eff))
    collection_eff_with_conversion = collection_eff_in_case_no_cavity_no_conversion * 0.3

    prob_detect_excl_transmission_no_conversion_no_cavities = \
        zero_phonon_prob_without_cavity * \
        collection_eff_in_case_no_cavity_no_conversion * \
        real_detection_eff

    prob_detect_excl_transmission_with_conversion_with_cavities = \
        zero_phonon_prob_with_cavity * \
        collection_eff_with_conversion *\
        real_detection_eff

    prob_dark_count = 2.5 * 10 ** (-6)

    dark_count_rate = -1 * np.log(1 - prob_dark_count) * 10 ** 9 / time_window

    # The paper uses the values
    #   * delta_w = 2 * pi * 22.4 kHz for node A
    #   * delta_w = 2 * pi * 26.6 kHz for node B
    # so we just take the average
    delta_w = (22.4 + 26.6) / 2
    delta_w_in_Hz = 2. * np.pi * delta_w * 10 ** 3

    # The paper mentions 1/e values of 273 (node A) and 272 (node B)
    # so we just take the average
    characteristic_number_of_attempts = (273 + 272) / 2

    _tau_decay = \
        compute_tau_in_fidelity(
            delta_w=delta_w_in_Hz,
            characteristic_number_of_attempts=characteristic_number_of_attempts)
    tau_decay_in_nanoseconds = _tau_decay * 10 ** 9
    tau_decay = tau_decay_in_nanoseconds
    # NOTE: this tau_decay is much larger and thus worse than the value 52nanoseconds
    # as reported in 'Dephasing mechanisms of diamond-based nuclear-spin
    # memories for quantum networks' by Kalb et al.
    # although it is much closer to the 390 nanoseconds as reported in
    # ' Towards quantum networks of single spins: analysis of a quantum
    # memory with an optical interface in diamond' by Blok et al. (DOI: 10.1039/C5FD00113G).

    # the probability of nuclear dephasing
    # is a function of the product of tau_decay
    # and the coupling strength delta_w, with
    # some constant factors. See also
    # netsquid_nv.nv_state_delivery_model.prob_nuclear_dephasing_during_entgen_attempt
    product_tau_decay_delta_w = delta_w_in_Hz * tau_decay_in_nanoseconds * 10 ** (-9)

    coherent_phase = 0.5 * np.pi
    p_fail_class_corr = 0.01
    initial_nuclear_phase = 24.0 * np.pi / 180

    #############
    # Gate noise
    #############

    # P. 18 supple material: note that (p. 6 suppl material) the noise is modelled
    # by applying a random two-qubit Pauli with probability 2 x p_{gate} = 2 x 0.0163
    # since mapping the electron spin state onto the carbon involves *two*
    # applications of a two-qubit gate, one on each node
    ec_gate_depolar_prob = 0.0163

    # p. 2 suppl material
    prob_error_0_node_A = 1 - 0.9379
    prob_error_0_node_B = 1 - 0.8985
    prob_error_0 = (prob_error_0_node_A + prob_error_0_node_B) / 2

    prob_error_1_node_A = 1 - 0.9932
    prob_error_1_node_B = 1 - 0.9962
    prob_error_1 = (prob_error_1_node_A + prob_error_1_node_B) / 2

    ec_gate_duration_nodeA = 12 * 21.772 * 10 ** 3  # [nanoseconds] p. 17 suppl material

    ec_gate_duration_nodeB = 34 * 12.812 * 10 ** 3

    qmem_config_params_nodeA = None

    electron_init_depolar_prob = NVParameterSet2019.electron_init_depolar_prob
    carbon_init_depolar_prob = NVParameterSet2019.carbon_init_depolar_prob
    electron_single_qubit_depolar_prob = NVParameterSet2019.electron_single_qubit_depolar_prob
    carbon_z_rot_depolar_prob = NVParameterSet2019.carbon_z_rot_depolar_prob
    electron_T1 = NVParameterSet2019.electron_T1
    electron_T2 = NVParameterSet2019.electron_T2
    carbon_T1 = NVParameterSet2019.carbon_T1
    carbon_T2 = NVParameterSet2019.carbon_T2

    p_loss_lengths_with_conversion = NVParameterSet2019.p_loss_lengths_with_conversion
    p_loss_lengths_no_conversion = NVParameterSet2019.p_loss_lengths_no_conversion
