"""
2019 Feb 25

In this script, we compute the noise parameter of the electron-carbon \\sqrt(X)-rotation gate,
which has matrix
:math:`|0><0|_e \\otimes R_X(-\\pi/2) + |1><1|_e \\otimes \\otimes R_X(\\pi/2)`
where the left qubit is the electron and the right qubit the carbon nuclear spin.

We test its noise parameter by simulating the circuit in http://doi.org/10.1126/science.aan0070
( "Entanglement distillation between solid-state quantum network nodes", Kalb et al., 2016)
to verify that the fidelity of the state that the circuit outputs is 0.96 (which is the
value found in the article).

"""

import numpy as np
from netsquid_nv.quantumMemoryDevice import NVCommunicationDevice
from netsquid.components.qprogram import QuantumProgram
from netsquid_physlayer.qProgramLibrary import move_using_CXDirections
from netsquid.components.instructions import INSTR_INIT, INSTR_ROT_Y, INSTR_ROT_Z, INSTR_CXDIR
import netsquid.qubits.qubitapi as qapi
import netsquid as ns
from netsquid_netconf.util.config_paths import ConfigPathStorage
from netsquid.qubits.ketstates import b11

CONFIG_FILE = ConfigPathStorage.QPD_NV_NOCAV_NOCONV


class LocalEntanglingProgram(QuantumProgram):
    """
    The circuit from fig. 2A in http://doi.org/10.1126/science.aan0070.
    """
    default_num_qubits = 2
    move_function = move_using_CXDirections

    def program(self):
        electron, carbon = self.get_qubit_indices(2)
        for qubit in [electron, carbon]:
            self.apply(INSTR_INIT, qubit)

        # the orange part
        q_program = self
        q_program.move_function(control=electron,
                                target=carbon)
        # In the original circuit, there is also a measurement:
        #self.apply(INSTR_MEASURE, electron, inplace=False, output_key="m")
        # However, since we have found that the fidelity of the state
        # that comes out of this circuit depends on the measurement outcome,
        # we do not measure. Now calling NetSquid's fidelity function will
        # take the partial trace, so that we get the fidelity that is already
        # averaged over all possible measurement outcomes.
        yield self.run()

        # the purple part
        self.apply(INSTR_INIT, electron)
        self.apply(INSTR_ROT_Y, electron, angle=-np.pi / 2)
        self.apply(INSTR_ROT_Z, carbon, angle=-np.pi / 2)
        self.apply(INSTR_CXDIR, [electron, carbon], angle=np.pi / 2)
        self.apply(INSTR_ROT_Z, carbon, angle=np.pi / 2)
        yield self.run()


def peek_state(qproc, reference_ket):
    qubits = qproc.peek(positions=[0, 1])
    fid = qapi.fidelity(qubits=qubits, reference_ket=reference_ket)
    print("\n| Using the noise models specified in {},".format(CONFIG_FILE))
    print("| the fidelity of the post-circuit state is {}, which should be approximately 0.96".format(fid))
    print("|\taccording to \"Entanglement distillation between... \", Kalb et al., 2016")
    print("| (NOTE that when performing this computation, the electron-T2 should be set to")
    print("| the T2-time used with dynamical decoupling, which is >1 second).\n")


if __name__ == "__main__":

    ns.set_qstate_formalism(ns.QFormalism.DM)
    qproc = NVCommunicationDevice(name="QProcessor",
                                  num_positions=2,
                                  # config_file=None)
                                  config_file=CONFIG_FILE)
    electron_pos, carbon_pos = 0, 1
    qubits = qapi.create_qubits(2)
    qproc.put(qubits=qubits, positions=[electron_pos, carbon_pos])

    qproc.set_program_done_callback(callback=peek_state,
                                    qproc=qproc,
                                    reference_ket=b11)
    qproc.execute_program(LocalEntanglingProgram(), qubit_mapping=[electron_pos, carbon_pos])

    ns.sim_run()
