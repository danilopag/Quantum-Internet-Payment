#
# Function to efficiently compute the quotients of Bessel functions
#
#


import numpy as np

__all__ = [
    'bessel_quotient',
]


def bessel_quotient(v, x, eps):
    """
    Computes the quotient of I_{v+1}(x) / I_{v}(x).
    Uses algorithm described in 'Computation of Modified Bessel Functions and Their Ratios' D.E. Amos (1974)

    Parameters
    ----------
    v : float
    x : float
    eps : float
        The precision
    """

    def _init_approx(v, x):
        # eq. (20a)
        approx = x / (v + (1 / 2) + np.sqrt((v + (3 / 2)) ** 2 + x ** 2))

        return approx

    def _recursion(v, x, r_num, r_denom):
        # eq. (20b)
        R = r_num / r_denom

        r_ret = x / (v + 1 + np.sqrt((v + 1) ** 2 + x ** 2 * R))

        return r_ret

    def _error(v, x, r_curr, r_prev):
        # eq. after Figure 1
        d = 1 / ((2 * (v + 1) / x) + r_prev)

        err = np.abs(d - r_curr) / r_curr

        return err

    if v < 0:
        raise ValueError("v needs to be non-negative")
    if x < 0:
        raise ValueError("x needs to be non-negative")
    if eps <= 0:
        raise ValueError("eps needs to be positive")
    if x == 0:
        return 0

    # Inital values
    err = eps + 1
    m = 1
    prev_diag = [_init_approx(v, x)]

    while err > eps:

        curr_diag = [_init_approx((v + m), x)]

        for i in range(m):
            curr_diag.append(_recursion((v + m - 1 - i), x, curr_diag[i], prev_diag[i]))

        err = _error(v, x, curr_diag[-1], curr_diag[-2])

        prev_diag = curr_diag

        m += 1

    return curr_diag[-1]
