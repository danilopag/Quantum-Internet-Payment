from netsquid.components.models.qerrormodels import QuantumErrorModel
from netsquid.qubits.qubitapi import apply_pauli_noise
from netsquid_physlayer.heralded_connection import HeraldedConnection
from netsquid.components import INSTR_EMIT

from netsquid_nv.state_delivery_sampler_factory import NVStateDeliverySamplerFactory
import netsquid_nv.nv_state_delivery_model as nv_model
from netsquid_magic.magic_distributor import SingleClickMagicDistributor


class MultiTimesDephasingNoiseModel(QuantumErrorModel):
    """
    A noise model that effectively applies multiple applications
    of dephasing in Z with a fixed probability.
    """

    def __init__(self, prob_of_dephasing):
        self.prob_of_dephasing = prob_of_dephasing

    def noise_operation(self, qubits, number_of_applications):
        # The probability of not-dephasing after a single
        # application of dephasing ...
        prob_single = 1. - self.prob_of_dephasing

        # ... and after multiple applications:
        prob_multiple = (1. + (2. * prob_single - 1) ** number_of_applications) / 2.

        # apply dephasing in Z
        for qubit in qubits:
            apply_pauli_noise(qubit, (prob_multiple, 0., 0., 1. - prob_multiple))


class NVSingleClickMagicDistributor(SingleClickMagicDistributor):
    """Magic distributor, tailored to entanglement generation using the
    electron spins in nitrogen-vacancy centers in diamond. Ensures that
    after entanglement generation which took `n` attempts up to and including
    success, a noise channel is applied to the nuclear spins which is equivalent
    to a dephasing noise channel which is applied `n` times to the nuclear spins.
    In addition, an initial amount of dephasing is applied, independent of the number
    of attempts until success. The probabilities of these individual dephasing channels
    are computed using methods in `netsquid_nv.nv_state_delivery_model` and parameters
    to these methods are extracted from the nodes and components specified to the
    NVSingleClickMagicDistributor upon initialization.

    Parameters
    ----------
    nodes : list of :obj:`~netsquid.nodes.node.Node`
        List of nodes for which entanglement can be produced.
    electron_memory_positions : dict str: int
        Dictionary which maps qmemory names to memory position at the node's quantum memory.
        If equals "default", then it is assumed that for
        all nodes, the electron memory position is 0.
    component: :obj:`~netsquid.components.component.Component` or None
        Component from which physical parameters will be extracted. If None,
        then parameters will not be extracted from component but from the specified
        nodes.
    length_A: float or None (optional)
        Length [km] of fiber on "A" side of heralded connection. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        Cannot be None if heralded_connection is None.
    length_B: float or None (optional)
        Length [km] of fiber on "B" side of heralded connection. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        Cannot be None if heralded_connection is None.
    """

    DEFAULT_ELECTRON_POSITION = 0
    SIDES = ["A", "B"]  # Names of ports of heralded connection, used to keep the two sides apart
    DEFAULT_VALUES = {"p_loss_init_A": 0, "p_loss_length_A": .25, "p_loss_init_B": 0, "p_loss_length_B": .25,
                      "detector_efficiency": 1, "dark_count_probability": 0, "visibility": 1, "p_fail_class_corr": 0,
                      "coherent_phase": 0, "p_double_exc": 0, "std_electron_electron_phase_drift": 0,
                      "speed_of_light_A": 200000, "speed_of_light_B": 200000}

    def __init__(self, nodes, electron_memory_positions="default", heralded_connection=None, length_A=None,
                 length_B=None, p_loss_init_A=None, p_loss_init_B=None, p_loss_length_A=None, p_loss_length_B=None,
                 detector_efficiency=None, dark_count_probability=None, visibility=None, p_fail_class_corr=None,
                 coherent_phase=None, p_double_exc=None, std_electron_electron_phase_drift=None, **kwargs):
        if heralded_connection is not None and not isinstance(heralded_connection, HeraldedConnection):
            raise ValueError("Magic distributor must read properties from a HeraldedConnection")

        kwargs.update({"length_A": length_A, "length_B": length_B, "p_loss_init_A": p_loss_init_A,
                       "p_loss_length_A": p_loss_length_A, "p_loss_init_B": p_loss_init_B,
                       "p_loss_length_B": p_loss_length_B, "detector_efficiency": detector_efficiency,
                       "dark_count_probability": dark_count_probability, "visibility": visibility,
                       "p_fail_class_corr": p_fail_class_corr, "coherent_phase": coherent_phase,
                       "p_double_exc": p_double_exc,
                       "std_electron_electron_phase_drift": std_electron_electron_phase_drift})
        kwargs_not_none = {key: value for (key, value) in kwargs.items() if value is not None}

        super().__init__(nodes=nodes, heralded_connection=heralded_connection, **kwargs_not_none)

        # overwrite the state delivery sampler factory from SingleClickMagicDistributor
        self.delivery_sampler_factory = [NVStateDeliverySamplerFactory()]

        if len(set([node.ID for node in nodes])) != len(nodes):
            raise ValueError("IDs of nodes are not unique")

        if electron_memory_positions == "default":
            electron_memory_positions = \
                {node.qmemory: NVSingleClickMagicDistributor.DEFAULT_ELECTRON_POSITION for node in nodes}

        for pos in electron_memory_positions.values():
            if not isinstance(pos, int):
                raise TypeError("Memory position should be of type int")
        self._electron_memory_positions = electron_memory_positions
        self._compute_cycle_time()

    def _read_params_from_nodes_or_component(self):
        delivery_parameters = super()._read_params_from_nodes_or_component()
        delivery_parameters.update(self._read_nv_params_from_node())
        delivery_parameters.update(self._read_emission_instruction_duration())

        return delivery_parameters

    def _read_nv_params_from_node(self):
        nv_params = {}
        for parameter in ["std_electron_electron_phase_drift", "p_double_exc", "delta_w",
                          "tau_decay", "p_fail_class_corr"]:
            try:
                params_temp = [node.qmemory.properties[parameter] for node in self.nodes[0]]
                if params_temp[0] != params_temp[1]:
                    raise NotImplementedError("NV Centers must have same {}.".format(parameter))
                nv_params[parameter] = params_temp[0]
            except KeyError:
                pass

        return nv_params

    def _read_emission_instruction_duration(self):
        nv_params = {}
        try:
            emission_durations = \
                [node.qmemory.get_instruction_duration(INSTR_EMIT, [0, node.qmemory.emission_position]) for node in self.nodes[0]]
            if emission_durations[0] != emission_durations[1]:
                raise NotImplementedError("Asymmetric emission durations are not yet supported.")
            nv_params["emission_duration"] = emission_durations[0]
        except AttributeError:
            nv_params["emission_duration"] = 0

        return nv_params

    def _get_node_by_id(self, node_id):
        # The attribute `nodes` contains lists of nodes.
        # If this MagicDistributor is not merged, then it is
        # a list of a single element, e.g. [[node_A, node_B]]
        # if the MagicDistributor serves two nodes.
        # If it has been merged, and contains e.g. three initial
        # MagicDistributors, then it contains three lists of nodes,
        # for example [[node_A, node_B], [node_A, node_C], [node_B, node_D]].
        # We flatten this list because all we want to obtain is the
        # Node object given its identifier.
        all_nodes = [node for node_list in self.nodes for node in node_list]
        for node in all_nodes:
            if node_id == node.ID:
                return node
        raise ValueError("Node ID {} unknown".format(node_id))

    def add_delivery(self, memory_positions, alpha=None, **kwargs):
        for node_id, memory_position in memory_positions.items():
            node = self._get_node_by_id(node_id)
            qmemory = node.qmemory
            if memory_position != self._electron_memory_positions[qmemory]:
                raise ValueError("NV can only generate entanglement with the electron spins")
        if alpha is None:
            alpha = self.fixed_delivery_parameters[0]["alpha"]
        try:
            cycle_time = kwargs["cycle_time"]
            del kwargs["cycle_time"]
        except KeyError:
            cycle_time = self.fixed_delivery_parameters[0]["cycle_time"]

        return super().add_delivery(memory_positions=memory_positions,
                                    alpha=alpha,
                                    cycle_time=cycle_time,
                                    **kwargs)

    def _get_nuclear_qubits(self, qmemory):
        """Get all nuclear spin qubits at a node.

        Parameters
        ----------
        node : :obj:`~netsquid.nodes.node.Node`

        Returns
        -------
        list of :obj:`~netsquid.qubits.qubit.Qubit`
        """
        electron_memory_position = self._electron_memory_positions[qmemory]

        # get memory positions at which nuclear qubits live
        all_memory_positions = set(range(qmemory.num_positions))
        used_positions = set(all_memory_positions) - set(qmemory.unused_positions)
        nuclear_positions = used_positions - set([electron_memory_position])

        # extract nuclear qubits from the memory positions
        nuclear_qubits = []
        for position in nuclear_positions:
            qubits = qmemory.peek(position)
            assert(len(qubits) == 1)
            qubit = qubits[0]
            nuclear_qubits.append(qubit)

        return nuclear_qubits

    @staticmethod
    def _get_number_of_attempts(delivery):
        try:
            cycle_time = delivery.parameters["cycle_time"]
        except KeyError:
            raise ValueError("Received no parameter 'cycle_time', neither when the magic" +
                             "distributor was initialized or when 'add_delivery' was called.")
        return int(delivery.sample.delivery_duration / cycle_time)

    def _apply_noise(self, delivery, quantum_memory, positions):
        """
        Ignores the `positions` argument.
        """

        # get all qubits that are not the involved memory positions_of_connections
        nuclear_qubits = self._get_nuclear_qubits(qmemory=quantum_memory)

        # apply dephasing noise to the nuclear spins
        self._apply_initial_dephasing_noise(nuclear_qubits=nuclear_qubits,
                                            delivery=delivery)
        self._apply_induced_dephasing_noise(nuclear_qubits=nuclear_qubits,
                                            delivery=delivery)

    def _apply_induced_dephasing_noise(self, nuclear_qubits, delivery):
        p_deph = nv_model.prob_nuclear_dephasing_during_entgen_attempt(**delivery.parameters)

        error_model = MultiTimesDephasingNoiseModel(prob_of_dephasing=p_deph)
        number_of_attempts = NVSingleClickMagicDistributor._get_number_of_attempts(delivery)
        error_model.noise_operation(
            qubits=nuclear_qubits,
            number_of_applications=number_of_attempts)

    def _apply_initial_dephasing_noise(self, nuclear_qubits, delivery):
        p_initial_deph = nv_model.prob_of_initial_nuclear_dephasing(**delivery.parameters)
        error_model = MultiTimesDephasingNoiseModel(prob_of_dephasing=p_initial_deph)
        error_model.noise_operation(
            qubits=nuclear_qubits,
            number_of_applications=1)

    def _compute_cycle_time(self):
        """Computes cycle time, which depends on other parameters.
        Should be called after all other parameters are set."""

        params = self.fixed_delivery_parameters[0]
        # calculate travel times
        travel_durations = {side: params[f"length_{side}"] / params[f"speed_of_light_{side}"] * 1E9
                            for side in self.SIDES}

        cycle_times = {side: 2 * travel_durations[side] + params["emission_duration"] for side in self.SIDES}
        self.fixed_delivery_parameters[0]["cycle_time"] = max(cycle_times.values())
