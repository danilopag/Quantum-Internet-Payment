from netsquid_simulationtools.parameter_set import Parameter, ParameterSet
from netsquid_nv.nv_state_delivery_model import prob_nuclear_dephasing_during_entgen_attempt
import numpy as np


def _gaussian_dephasing_fn(x):
    return 0.5 * (1. + np.exp(-0.5 * x ** 2))


def _inverse_gaussian_dephasing_fn(x):
    if x == 0.5:
        return np.inf
    elif x == 1.:
        return 0.
    else:
        return np.sqrt(-2. * np.log(2 * x - 1))


def _coherence_time_prob_fn(x):
    return np.exp(-1. / x)


def _inverse_coherence_time_prob_fn(x):
    if x == 1.:
        return np.inf
    elif x == 0.:
        return 0
    else:
        return - 1. / np.log(x)


def compute_product_tau_decay_delta_w_from_dephasing_prob(prob_deph, alpha):
    r"""Inverse of
    :fn:`~netsquid_nv.nv_state_delivery_model.prob_nuclear_dephasing_during_entgen_attempt`.

    Parameters
    ----------
    prob_deph :
        Probability of dephasing of a nuclear spin during a single entanglement
        generation attempt with the electron spin.
    alpha : float
        Bright state parameter

    Returns
    -------
    float
        Product of :math:`\tau` and :math:`\Delta \omega`.
    """
    log_content = 1 - (2 * prob_deph / (1 - alpha))
    return np.sqrt(-2 * np.log(log_content))


def compute_dephasing_prob_from_nodephasing_number(nodephasing_number):
    r"""Equivalent of
    :fn:`~netsquid_nv.nv_state_delivery_model.prob_nuclear_dephasing_during_entgen_attempt`,
    but in this case not the product of :math:`\tau` and :math:`\delta \omega` is specified,
    but instead one gives the "nondephasing number" :math:`N_{1/e}`, i.e. the number of entanglement attempts
    on the electron spins that make a nuclear qubit in the :math:`|+\rangle\langle+|` state
    reduce its Bloch sphere length from 1 to :math:`1/e` (where `e` is the natural constant).

    Parameters
    ----------
    nondephasing_number : float

    Returns
    -------
    float
        Dephasing probability of a carbon nuclear spin during a single entanglement
        generation attempt.

    Notes
    -----
    This function returns the probability :math:`p` for which the Bloch vector length of
    :math:`|+\rangle\langle +|` after `n` applications of the single-qubit dephasing channel,
    :math:`(1 - 2p)^n`, equals `1/e`.
    """
    return (1 - np.exp(-1 / nodephasing_number)) / 2


def compute_product_tau_decay_delta_w_from_nodephasing_number(nodephasing_number, alpha):
    r"""Equivalent of
    :fn:`~netsquid_nv.nv_parameter_set.compute_product_tau_decay_delta_w_from_dephasing_prob`
    where now the number :math:`N_{1/e}` is used as input, which is the number of entanglement
    attempts after which the Bloch vector length of :math:`|+\rangle\langle +|` has decreased
    to :math:`1/e`.

    Parameters
    ----------
    nondephasing_number : float
    alpha : float
        Bright state parameter

    Returns
    -------
    float
        Product of :math:`\tau` and :math:`\Delta \omega`.
    """
    prob_deph = compute_dephasing_prob_from_nodephasing_number(nodephasing_number)
    return compute_product_tau_decay_delta_w_from_dephasing_prob(
        prob_deph=prob_deph,
        alpha=alpha)


def compute_nodephasing_number_from_dephasing_probability(prob_deph):
    """Inverse of
    :fn:`~netsquid_nv.nv_parameter_set.compute_dephasing_prob_from_nodephasing_number`.
    """
    return -1 / np.log(1 - 2 * prob_deph)


class NVParameterSet(ParameterSet):

    _REQUIRED_PARAMETERS = [

        Parameter(name="visibility",
                  units=None,
                  perfect_value=1.,
                  type=float,
                  convert_to_prob_fn=lambda x: x,
                  convert_from_prob_fn=lambda x: x),

        # The probability of no dark counts at all
        # is computed as `exp(-1. * dark_count_rate * time_window)`
        # and hence the probability of having at least a single dark count
        # equals 1 minus this number.
        Parameter(name="prob_dark_count",
                  units=None,
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=lambda x: 1 - x,
                  convert_from_prob_fn=lambda x: 1 - x),

        # The standard deviation of the phase on the produced state
        # caused by drift on the interferometer is turned into a
        # dephasing map with the following probability of no-dephasing:
        # `0.5 * (1 + exp(-0.5 * std_phase ** 2))`
        Parameter(name="std_electron_electron_phase_drift",
                  units="radians",
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=_gaussian_dephasing_fn,
                  convert_from_prob_fn=_inverse_gaussian_dephasing_fn),

        Parameter(name="p_double_exc",
                  units=None,
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=lambda x: 1 - x,
                  convert_from_prob_fn=lambda x: 1 - x),

        Parameter(name="photon_emission_delay",
                  units="ns",
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=None,
                  convert_from_prob_fn=None),

        # The probability of the carbon memory qubit
        # *not* dephasing is given by
        #  1 / 2 * (1 + np.exp(-(some_constant_factor * delta_w * tau_decay) ** 2 / 2))
        Parameter(name="product_tau_decay_delta_w",
                  units="None, product of delta_w (units:Hz, i.e. without factor 1/2pi)" +
                  " & tau_decay (units:seconds)",
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=lambda x: 1 - prob_nuclear_dephasing_during_entgen_attempt(alpha=0.5, delta_w=1, tau_decay=x),
                  convert_from_prob_fn=lambda x: compute_product_tau_decay_delta_w_from_dephasing_prob(1 - x, alpha=0.5)),

        Parameter(name="electron_init_depolar_prob",
                  units=None,
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=lambda x: 1 - x,
                  convert_from_prob_fn=lambda x: 1 - x),

        Parameter(name="electron_single_qubit_depolar_prob",
                  units=None,
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=lambda x: 1 - x,
                  convert_from_prob_fn=lambda x: 1 - x),

        Parameter(name="prob_error_0",
                  units=None,
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=lambda x: 1 - x,
                  convert_from_prob_fn=lambda x: 1 - x),

        Parameter(name="prob_error_1",
                  units=None,
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=lambda x: 1 - x,
                  convert_from_prob_fn=lambda x: 1 - x),

        Parameter(name="carbon_init_depolar_prob",
                  units=None,
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=lambda x: 1 - x,
                  convert_from_prob_fn=lambda x: 1 - x),

        Parameter(name="carbon_z_rot_depolar_prob",
                  units=None,
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=lambda x: 1 - x,
                  convert_from_prob_fn=lambda x: 1 - x),

        Parameter(name="ec_gate_depolar_prob",
                  units=None,
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=lambda x: 1 - x,
                  convert_from_prob_fn=lambda x: 1 - x),

        Parameter(name="electron_T1",
                  units="nanoseconds",
                  perfect_value=np.inf,
                  type=float,
                  convert_to_prob_fn=_coherence_time_prob_fn,
                  convert_from_prob_fn=_inverse_coherence_time_prob_fn),

        Parameter(name="electron_T2",
                  units="nanoseconds",
                  perfect_value=np.inf,
                  type=float,
                  convert_to_prob_fn=_coherence_time_prob_fn,
                  convert_from_prob_fn=_inverse_coherence_time_prob_fn),

        Parameter(name="carbon_T1",
                  units="nanoseconds",
                  perfect_value=np.inf,
                  type=float,
                  convert_to_prob_fn=_coherence_time_prob_fn,
                  convert_from_prob_fn=_inverse_coherence_time_prob_fn),

        Parameter(name="carbon_T2",
                  units="nanoseconds",
                  perfect_value=np.inf,
                  type=float,
                  convert_to_prob_fn=_coherence_time_prob_fn,
                  convert_from_prob_fn=_inverse_coherence_time_prob_fn),

        # The transmissionless detection efficiency is the product of THREE probabilities:
        # - the probability that a photon is emitted from the electron spin into
        #   the zero-phonon-line
        # - the probability that the photon is collected into the fibre
        # - the probability that the detector clicks, given that a photon entered it
        # The transmittivity (i.e. the probability that the photon survives the
        # travelling through the fibre) is explicitly NOT included in this number
        # since the transmittivity is dependent on the length of the fibre.
        Parameter(name="prob_detect_excl_transmission_with_conversion_with_cavities",
                  units=None,
                  perfect_value=1.,
                  type=float,
                  convert_to_prob_fn=lambda x: x,
                  convert_from_prob_fn=lambda x: x),

        Parameter(name="prob_detect_excl_transmission_no_conversion_no_cavities",
                  units=None,
                  perfect_value=1.,
                  type=float,
                  convert_to_prob_fn=lambda x: x,
                  convert_from_prob_fn=lambda x: x),

        Parameter(name="coherent_phase",
                  units="radians",
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=None,
                  convert_from_prob_fn=None),

        Parameter(name="p_fail_class_corr",
                  units=None,
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=lambda x: x,
                  convert_from_prob_fn=lambda x: x),

        Parameter(name="initial_nuclear_phase",
                  units="radians",
                  perfect_value=0.,
                  type=float,
                  convert_to_prob_fn=_gaussian_dephasing_fn,
                  convert_from_prob_fn=_inverse_gaussian_dephasing_fn),

        # the probability that a photon is lost in the fibre
        Parameter(name="p_loss_lengths_with_conversion",
                  units="dB/km",
                  perfect_value=0.,
                  type=float,
                  # we assume that the transmittivity in the fibre
                  # as given and that it cannot be improved.
                  # We thus set the functions for conversion
                  # to a 'probability of no-error' and back to None
                  convert_to_prob_fn=None,
                  convert_from_prob_fn=None),

        Parameter(name="p_loss_lengths_no_conversion",
                  units="dB/km",
                  perfect_value=0.,
                  type=float,
                  # we assume that the transmittivity in the fibre
                  # as given and that it cannot be improved.
                  # We thus set the functions for conversion
                  # to a 'probability of no-error' and back to None
                  convert_to_prob_fn=None,
                  convert_from_prob_fn=None)]
