import numpy as np
import netsquid as ns
from netsquid.qubits.state_sampler import StateSampler
from netsquid.qubits.ketstates import BellIndex
from netsquid.qubits.qubit import Qubit
from netsquid.qubits.qubitapi import dephase
from netsquid_magic.state_delivery_sampler import SingleClickDeliverySamplerFactory

"""
The model from
http://doi.org/10.1126/science.aan0070
"""


def nv_single_click_state_sampler(
        alpha, length_A, length_B, p_loss_length_A, p_loss_length_B, p_loss_init_A, p_loss_init_B, detector_efficiency,
        visibility=1, dark_count_probability=0, p_fail_class_corr=0, coherent_phase=0, p_double_exc=0,
        std_electron_electron_phase_drift=0, **kwargs):
    r"""
    Parameters
    ----------
    coherent_phase : float
        In the absence of all other noise, this sampler produces the state
        :math:`|01\rangle + e^{i\cdot \text{coherent_phase}} |10\rangle`.
    std_interferometric_drift : float
        Standard deviation of the total phase difference between the incoming
        photons [radians]. Will be applied as dephasing noise.

    Returns
    -------
    list of two DMState objects
    """
    sampler, success_probability = SingleClickDeliverySamplerFactory._get_single_click_state_sampler(
        alpha=alpha, length_A=length_A, length_B=length_B, p_loss_length_A=p_loss_length_A,
        p_loss_length_B=p_loss_length_B, p_loss_init_A=p_loss_init_A, p_loss_init_B=p_loss_init_B,
        detector_efficiency=detector_efficiency, visibility=visibility, dark_count_probability=dark_count_probability,
        p_fail_class_corr=p_fail_class_corr, coherent_phase=coherent_phase
    )

    dm_states = sampler.states

    for i, dm in enumerate(dm_states):

        #################################################
        # Applying additional noise to the density matrix
        #################################################

        # putting the density matrix onto two freshly generated qubits
        qubits = [Qubit("A"), Qubit("B")]
        ns.qubits.qubitapi.assign_qstate(qubits, dm)

        # apply noise due to double excitation;
        # apply Z-transformation to both qubits, each with probability p_double_exc/2
        for qubit in qubits:
            dephase(qubit, p_double_exc / 2.)

        # Noise due to phase instability

        tp = 0  # time since phase stabilization

        # We assume that on average, the interferometer does not drift
        avg_electron_electron_phase_drift = 0

        p = 0.5 * (1. - np.exp(0.5 * (-1. * (avg_electron_electron_phase_drift * tp) ** 2 - std_electron_electron_phase_drift ** 2)))
        dephase(qubits[0], p)

        dm_states[i] = qubit.qstate.dm

    return StateSampler(qreprs=dm_states, probabilities=[0.5, 0.5],
                        labels=[BellIndex.PSI_PLUS, BellIndex.PSI_MINUS]), success_probability


def prob_nuclear_dephasing_during_entgen_attempt(alpha, delta_w=0, tau_decay=0, **kwargs):
    r"""
    Parameters
    ----------
    alpha : float
        Bright state population.
    delta_w : float
        Coupling strength. Note: usually specified as :math:`XXX / (2 \pi) ` kiloHertz,
        but this input parameter should be specified in Hz, without the factor :math:`1/(2\pi)`.
    tau_decay : float
        Decay constant (seconds).

    Copied from
    `netsquid_physlayer.easynoise.NV_PhotonEmissionNoiseModel._calculate_dephasing_nuclear`.
    """
    return (1 - alpha) / 2 * (1 - np.exp(-(delta_w * tau_decay) ** 2 / 2))


def prob_of_initial_nuclear_dephasing(initial_nuclear_phase=0, **kwargs):
    """
    Parameters
    ----------
    initial_nuclear_phase : float
        [radians]
    """
    return 0.5 * (1 - np.exp(-1 * (initial_nuclear_phase ** 2)))
