##############################################################################################################
#                                                                                                            #
# A ServiceInterface is used to define and interface of a service, i.e. what messages can be submitted to    #
# the service and what messages can be expected to be returned. The ServiceInterface is also used to         #
# handle protocols implementing the service and their "magic" version. A magic protocol is a non-local       #
# protocol which sheets the simulation by for example not simulating all attempts to generate entanglement.  #
#                                                                                                            #
# For examples on how to use service, service protocols and magic, see the folder `netsquid_magic/examples`. #
#                                                                                                            #
##############################################################################################################

import abc
import inspect

from netsquid.protocols import Protocol  # DataNodeProtocol
from netsquid_magic.magic import MagicProtocol

__all__ = [
    "ServiceProtocol",
    "ServiceInterface",
]


class ServiceProtocol(Protocol, metaclass=abc.ABCMeta):
    """
    An abstract class for a service protocol. Any request from a user of this protocol implementing a certain service
    should be handled by the `put`-method.

    It is intended that a service protocol is used together with a service interface which passes requests from a
    user to the service protocol using the `put`-method. The service protocol can respond to the user, using the
    `react`-method.
    """

    @property
    def service_interface(self):
        return getattr(self, "_service_interface", None)

    @abc.abstractmethod
    def put(self, request):
        """
        Should be overridden to define the behaviour of this service protocol.

        :param request: any
            Will be of one of the types in the property request_types of the corresponding service interface
        """
        pass

    def react(self, msg):
        """
        Used by internally by the magic protocol to communicate back to the user of the protocol.
        Should not be subclassed.

        :param msg: any
            Will be of one of the types in the property reaction_types of the corresponding service interface
        """
        service_interface = self.service_interface
        if service_interface is None:
            raise RuntimeError("This service protocol does not have a service."
                               "To make use of a service protocol you need to add it to a service,"
                               "using :obj:`netsquid_magic.services.ServiceInterface.add_protocol`")
        if not isinstance(service_interface, ServiceInterface):
            raise RuntimeError("self.service is not an instance of a subclass of ServiceInterface, "
                               "but rather of type {}."
                               .format(type(service_interface)))
        service_interface.react(msg)


class ServiceInterface(metaclass=abc.ABCMeta):
    def __init__(self, node, magic=False, protocol=None, magic_protocol=None, reaction_handler=None):
        """
        An abstract class that represents a service interface.  Accepts requests of the correct type and passes them
        on to either a service protocol or a magic protocol, depending on whether the service interface was
        initialized with the flag `magic` set to True or False.

        Even though a service can be non-local the ServiceInterfaces here will be local objects, one for each
        node part of the service. The service either hold different instances of ServiceProtocols or the same
        instance of a MagicProtocol.

        Thus the service can be realized by protocols running locally at nodes, performing a full simulation
        of those protocols (relying possibly on even lower level services). Alternatively, to run a simulation
        with less detail, there may also be ''magic'' services that generate the desired behaviour by cheating
        using non-local actions.

        The recommended mode of writing a service is to always also provide a ''magic'' version with the same
        behaviour. Conventions to be used are

        :param node: `obj`:netsquid.nodes.node.Node`
            The node of this service interface
        :param magic: bool
            Whether to use magic or not
        :param protocol: None or :obj:`netsquid_magic.services.ServiceProtocols`
            A service protocol if it should be used.
        :param magic_protocol: None or :obj:`netsquid_magic.magic.MagicProtocol`
            A magic protocol if it should be used.
        :param reaction_handler: function
            A function to be called when the service responds to the user.
        """
        self._node = node
        # Protocol running (if not magic) at the node implementing this service of this service interface
        self._protocol = None

        # Magic protocol running (if magic) at the node implementing this service of this service interface
        self._magic_protocol = None

        # Handlers that the node provide when the service wants to poll/reply
        self._reaction_handler = None

        # Service is currently running
        self._is_running = False

        # Whether magic should be used or not
        self._magic = magic

        if protocol is not None:
            self.add_protocol(protocol)

        if magic_protocol is not None:
            self.add_magic_protocol(magic_protocol)

        if reaction_handler is not None:
            self.add_reaction_handler(reaction_handler)

    @property
    def is_running(self):
        """
        Is the service running or not
        """
        return self._is_running

    @property
    def is_magic(self):
        """
        Is magic being used or not
        """
        return self._magic

    @property
    def node(self):
        """
        The node of this service interface
        """
        return self._node

    @property
    @abc.abstractmethod
    def request_types(self):
        """
        Defines the allowed types of request messages to this service interface
        Any subclass should set this as a class attributes.
        """
        pass

    @property
    @abc.abstractmethod
    def reaction_types(self):
        """
        Defines the allowed types of request messages from this service interface
        Any subclass should set this as a class attributes.
        """
        pass

    def add_protocol(self, protocol):
        """
        Adds a service protocol which implements the service of this service interface

        Parameters
        ----------
        :param protocol: :obj:`netsquid_magic.services.ServiceProtocol`
            Service protocol to be added.
        """

        if not isinstance(protocol, ServiceProtocol):
            raise TypeError("The argument protocol is not of an instance of ServiceProtocol "
                            "or a subclass thereof but rather of type {}".format(type(protocol)))

        self._protocol = protocol
        # Add this service to the service protocol such that it can react
        self._protocol._service_interface = self

    def add_magic_protocol(self, protocol):
        """
        Adds a magic protocol which implements the service of this service interface

        Parameters
        ----------
        :param protocol: :obj:`netsquid_magic.services.ServiceProtocol`
            Service protocol to be added.
        """

        if not isinstance(protocol, MagicProtocol):
            raise TypeError("The argument protocol is not of an instance of ServiceProtocol "
                            "or a subclass thereof but rather of type {}".format(type(protocol)))

        self._magic_protocol = protocol
        # Add this service to the service protocol such that it can react
        self._magic_protocol.service_interfaces[self.node.ID] = self

    def add_reaction_handler(self, reaction_handler):
        """
        Adds a reaction handler to be called when the service of this request reply/polls.

        Parameters
        ----------
        :param reaction_handler: function
            Reaction handler to be added.
        """

        # Check if the reaction_handler is callable and takes at least one argument
        if not callable(reaction_handler):
            raise TypeError("reaction_handler needs to be callable")
        num_args = len(inspect.getfullargspec(reaction_handler).args)
        if not num_args > 0:
            raise ValueError("reaction_handler needs to take at least one argument")

        self._reaction_handler = reaction_handler

    def put(self, request):
        """
        User exposed method for submitting a request to be processed

        :param request: object
            Should be an instance of one of the types in self.request_types
        :return: None
        """
        # Check if the request is of the supported type
        if not self._valid_request(request):
            raise ValueError("Request {} is not a valid request for this service.".format(request))

        if self.is_magic:
            # Give the request to the magic protocol for this node
            return self._magic_put(request)
        else:
            # Give the request to the service protocol for this node
            return self._put(request)

    def _put(self, request):
        """
        Internal method to give the request to the service protocol
        """
        # Check if there actually is a service protocol set
        if self._protocol is None:
            raise RuntimeError("There is no service protocol set")

        # Give the request to the service protocol for this node
        return self._protocol.put(request)

    def _magic_put(self, request):
        """
        Internal method to give the request to the magic protocol
        """
        # Check if there actually is a magic protocol set
        if self._magic_protocol is None:
            raise RuntimeError("There is no magic protocol set")

        # Give the request to the magic protocol for this node
        return self._magic_protocol.put_from(self.node.ID, request)

    def _valid_request(self, msg):
        """
        Internal method to check if the request is of the correct type and form
        """
        for msg_type in self.request_types:
            if isinstance(msg, msg_type) and self._custom_check_request(msg):
                return True
        return False

    def react(self, msg):
        """
        This method will be exposed to any service protocol or magic protocol of this service interface
        to allow them to communicate to a user of this service.
        """
        if not self._valid_reaction(msg):
            raise ValueError("Message {} is not a valid reaction message for this service.".format(msg))

        # Give the request to the service protocol for this node
        if self._reaction_handler is None:
            return
        self._reaction_handler(msg)

    def _valid_reaction(self, msg):
        """
        Internal method to check if the reaction is of the correct type and form
        """
        for msg_type in self.reaction_types:
            if isinstance(msg, msg_type) and self._custom_check_reaction(msg):
                return True
        return False

    def start(self):
        """
        Start the service.
        """
        if self.is_running:
            return

        if self.is_magic:
            if self._magic_protocol is not None:
                if not self._magic_protocol.is_running:
                    self._magic_protocol.start()

            self._magic_start()
        else:
            if self._protocol is not None:
                self._protocol.start()

            self._custom_start()

        self._is_running = True

    def stop(self):
        """
        Stop the service.
        """
        if not self.is_running:
            return

        if self.is_magic:
            if self._magic_protocol is not None:
                self._magic_protocol.stop()

            self._magic_stop()
        else:
            if self._protocol is not None:
                self._protocol.stop()

            self._custom_stop()

        self._is_running = False

    def _custom_check_request(self, msg):
        """
        Override this method to have custom checks of the msg being given to the service,
        additionally to the check of the messages type.

        Should return True if the messages is accepted.
        :param msg:
        :return:
        """
        return True

    def _custom_check_reaction(self, msg):
        """
        Override this method to have custom checks of the msg being given from the service,
        additionally to the check of the messages type.

        Should return True if the messages is accepted.
        :param msg:
        :return:
        """
        return True

    def _custom_start(self):
        """
        Meant to be overridden if the service needs to do something when starting (non-magic)
        """
        pass

    def _custom_stop(self):
        """
        Meant to be overridden if the service needs to do something when stopping (non-magic)
        """
        pass

    def _magic_start(self):
        """
        Meant to be overridden if the service needs to do something when starting (when using magic)
        """
        pass

    def _magic_stop(self):
        """
        Meant to be overridden if the service needs to do something when stopping (when using magic)
        """
        pass
