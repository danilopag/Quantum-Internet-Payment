#################################################################################################
#                                                                                               #
# This defines the service interface of the link layer and provides a magic link layer protocol #
# For details about this interface and specific header fields see the paper:                    #
#                 A Link Layer Protocol for Quantum Networks                                    #
#                 https://arxiv.org/abs/1903.09778                                              #
#                                                                                               #
#################################################################################################

import abc
import random
from collections import namedtuple, OrderedDict, defaultdict

from qlink_interface import (
    ReqCreateAndKeep,
    ReqMeasureDirectly,
    ReqRemoteStatePrep,
    ReqReceive,
    ReqStopReceive,
    ResCreateAndKeep,
    ResMeasureDirectly,
    ResRemoteStatePrep,
    ResError,
    ErrorCode,
    MeasurementBasis,
    RandomBasis,
)

from pydynaa import EventHandler
from netsquid_magic.sleeper import Sleeper
from netsquid_magic.services import ServiceInterface
from netsquid_magic.magic_distributor import MagicDistributor
from netsquid_magic.magic import MagicProtocol
from netsquid.util.simtools import sim_time
from netsquid.qubits import qubitapi as qapi
from netsquid.qubits import operators as ops
from netsquid.util.simlog import logger
from netsquid.components.qprocessor import QuantumProcessor


# The service interface for the link layer
class LinkLayerService(ServiceInterface):
    request_types = [
        ReqCreateAndKeep,
        ReqMeasureDirectly,
        ReqRemoteStatePrep,
        ReqReceive,
        ReqStopReceive,
    ]
    reaction_types = [
        ResCreateAndKeep,
        ResMeasureDirectly,
        ResRemoteStatePrep,
        ResError,
    ]


# The translation unit is used to convert request parameters (e.g. minimum_fidelity) to hardware parameters (e.g. alpha)
class TranslationUnit(metaclass=abc.ABCMeta):
    def __call__(self, request, **fixed_parameters):
        return self.request_to_parameters(request, **fixed_parameters)

    @abc.abstractmethod
    def request_to_parameters(self, request, **fixed_parameters):
        return {}


# Translation unit for single-click schemes
# Simply maps minimum fidelity to (1 - alpha) and uses
# t_cycle if request is of type M and otherwise uses full_cycle as the cycle_time
class SingleClickTranslationUnit(TranslationUnit):
    def request_to_parameters(self, request, **fixed_parameters):
        t_cycle = fixed_parameters.get("t_cycle", 0)
        full_cycle = fixed_parameters.get("full_cycle", t_cycle)
        if isinstance(request, ReqMeasureDirectly):
            cycle_time = t_cycle
        else:
            cycle_time = full_cycle
        alpha = 1 - request.minimum_fidelity

        return {"cycle_time": cycle_time, "alpha": alpha}


# A magic link layer protocol
# Requests from both nodes are handled in FIFO order
# Currently requests never time out and type R requests are not implemented
# To see how to use the magic protocol through a service see netsquid_magic/examples/link_layer_example.py
class MagicLinkLayerProtocol(MagicProtocol):
    def __init__(self, nodes, magic_distributor, translation_unit):
        if not len(nodes) == 2:
            raise ValueError("A magic link layer protocol requires two nodes, not {}".format(len(nodes)))
        super().__init__(nodes=nodes)

        self._assert_has_q_processor(nodes=nodes)

        if not isinstance(magic_distributor, MagicDistributor):
            raise TypeError("Magic distributor should be an instance of "
                            "`netsquid_magic.magic_distributor.MagicDistributor` or a subclass thereof")
        self._magic_distributor = magic_distributor

        if not isinstance(translation_unit, TranslationUnit):
            raise TypeError("Translation unit should be an instance of "
                            "`netsquid_magic.link_layer.TranslationUnit` or a subclass thereof")
        self._translation_unit = translation_unit

        self._requests_in_queue = OrderedDict()
        self._requests_in_process = {}

        self._magic_distributor.add_callback(self._handle_delivery)

        self._queue_item_class = namedtuple("QueueItems",
                                            ["node_id", "request", "pairs_left", "create_id", "pairs_in_process"])

        self._next_create_ids = {node.ID: 0 for node in self.nodes}

        self._next_sequence_number = 0

        # TODO Currently the magic link layer protocol can only generate one pair at a time
        # Support for multiple pairs at a time is essentially there, except that in `_handle_next`
        # we only look at the head of the queue. So multiple pairs in a single request can be multiplexed
        # but not multiple requests.
        self._max_multiplex_capacity = 1

        # Observables to use for different random basis choices
        self._measurement_observables = {MeasurementBasis.X: ops.X,
                                         MeasurementBasis.Y: ops.Y,
                                         MeasurementBasis.Z: ops.Z,
                                         MeasurementBasis.ZPLUSX: (ops.Z + ops.X) / 2,
                                         MeasurementBasis.ZMINUSX: (ops.Z + ops.X) / 2}

        # Handlers for the type of requests
        self._request_handlers = {
            ReqCreateAndKeep: self._handle_create_request,
            ReqMeasureDirectly: self._handle_create_request,
            ReqRemoteStatePrep: self._handle_create_request,
            ReqReceive: self._handle_recv_request,
            ReqStopReceive: self._handle_stop_recv_request,
        }

        # Keep track of the rules for receiving EPR pairs
        self._recv_rules = defaultdict(set)

        # Event handler for waiting for memory to become free and calling _handle_next again
        self._handle_next_handler = EventHandler(lambda Event: self._handle_next())

        # Sleeper to wait for next interesting event
        self._sleeper = Sleeper()

    @staticmethod
    def _assert_has_q_processor(nodes):
        for node in nodes:
            if not isinstance(node.qmemory, QuantumProcessor):
                raise TypeError(f"Node {node.name} does not have a QuantumProcessor, but node.qmem is of type {type(node.qmemory)}")

    @property
    def capacity(self):
        """
        The capacity of the protocol,
        i.e. max number of pairs to process in parallel minus current number of pairs being processed.
        """
        return self._max_multiplex_capacity - len(self._requests_in_process)

    def put_from(self, node_id, request):
        """
        Submit a entanglement generation request to this protocol.

        :param node_id: int
            Node ID of the node submitting the request
        :param request: :obj:`netsquid_magic.link_layer.LinkLayerCreate`
        """
        node_ids = [node.ID for node in self.nodes]
        if request.remote_node_id not in node_ids:
            raise ValueError("Node with ID {} is not part of this magic protocol".format(request.remote_node_id))
        return self._request_handlers[type(request)](node_id=node_id, request=request)

    def _handle_create_request(self, node_id, request):
        if type(request) not in [ReqCreateAndKeep, ReqMeasureDirectly]:
            raise NotImplementedError("This magic link layer protocol cannot yet handle requests "
                                      "of type {}.".format(type(request)))
        if request.max_time != 0:
            raise NotImplementedError("This magic link layer protocol cannot yet handle requests that should timeout")
        create_id = self._get_create_id(node_id)
        self._add_to_request_queue(node_id, request, request.number, create_id)
        logger.info("Got new request {}".format(request))
        self._handle_next()
        return create_id

    def _handle_recv_request(self, node_id, request):
        rule = request.remote_node_id, request.purpose_id
        self._recv_rules[node_id].add(rule)

    def _handle_stop_recv_request(self, node_id, request):
        rule = request.remote_node_id, request.purpose_id
        self._recv_rules[node_id].remove(rule)

    def _get_create_id(self, node_id):
        """
        Returns a create ID response message to the node
        """
        create_id = self._next_create_ids[node_id]
        self._next_create_ids[node_id] += 1

        return create_id

    def _get_next_sequence_number(self):
        """
        Get the next sequence number to be used for the ok message
        """
        sequence_number = self._next_sequence_number
        self._next_sequence_number += 1
        return sequence_number

    def _handle_next(self):
        """
        Handle the request in the head of the queue if there is such and we can
        """
        logger.debug("Handling next request in queue")
        if self.capacity == 0:
            logger.info("Currently no capacity for further entanglement generation")
            self._defer_handle_next()
            return

        queue_item = self._peek_from_request_queue()
        if queue_item is not None:
            if (queue_item.pairs_left - queue_item.pairs_in_process) <= 0:
                logger.info("No pairs left for the request at the head of the queue")
                return

            parameters = self._translation_unit(queue_item.request,
                                                **self._magic_distributor.fixed_delivery_parameters[0])
            memory_positions = self._get_unused_memory_positions()
            if memory_positions is None:
                logger.debug("At least on node is out of memory or processor is busy")
                self._defer_handle_next()
                return

            event = self._magic_distributor.add_delivery(memory_positions=memory_positions, **parameters)

            self._add_to_requests_in_process(event, queue_item)

            self._handle_next()

    def _defer_handle_next(self):
        self._wait_once(
            handler=self._handle_next_handler,
            expression=self._sleeper.sleep(),
        )

    def _get_unused_memory_positions(self):
        """
        Get unused memory position for both nodes.
        If either node is out of memory, None will be returned
        """
        memory_positions = {}
        # First check if there are available qubits
        for node in self.nodes:
            qmemory = node.qmemory
            if qmemory.busy:
                return None
            unused_positions = qmemory.unused_positions
            if len(unused_positions) == 0:
                return None

        # Reserve qubits
        for node in self.nodes:
            qmemory = node.qmemory
            unused_positions = qmemory.unused_positions
            position = unused_positions[0]
            memory_positions[node.ID] = position
            self._reserve_memory_position(qmemory, position)

        return memory_positions

    @staticmethod
    def _reserve_memory_position(qmemory, memory_position):
        """
        Reserves the given memory position of the given quantum memory

        :param qmemory: :obj:`netsquid.components.qprocessor.QuantumProcessor`
        :param memory_position: int
        """
        qmemory.mem_positions[memory_position].in_use = True

    def _add_to_request_queue(self, node_id, request, pairs_left, create_id):
        """
        Add a new request to the back of the queue
        """
        if self._is_valid_request(node_id=node_id, request=request):
            queue_item = self._queue_item_class(node_id, request, pairs_left, create_id, pairs_in_process=0)
            key = node_id, create_id
            self._requests_in_queue[key] = queue_item
        else:
            response = ResError(
                create_id=create_id,
                error_code=ErrorCode.REJECTED,
            )
            self.react_to(node_id, response)

    def _is_valid_request(self, node_id, request):
        remote_rule = node_id, request.purpose_id
        return remote_rule in self._recv_rules[request.remote_node_id]

    def _pop_from_request_queue(self, key=None):
        """
        Pop a request (default first) from the queue
        """
        if len(self._requests_in_queue) == 0:
            return None
        else:
            if key is None:
                _, queue_item = self._requests_in_queue.popitem(last=False)
            else:
                queue_item = self._requests_in_queue.pop(key)
            return queue_item

    def _peek_from_request_queue(self, key=None):
        """
        Peek a request (default first) from the queue
        """
        if len(self._requests_in_queue) == 0:
            return None
        else:
            if key is None:
                key = next(iter(self._requests_in_queue))
            return self._requests_in_queue[key]

    def _add_to_requests_in_process(self, event, queue_item):
        """
        Add a request to those that are currently in process
        Queue item are stored by their corresponding event when
        they will be delivered.
        """
        self._requests_in_process[event] = queue_item
        self._increment_pairs_in_process(queue_item.node_id, queue_item.create_id)

    def _pop_from_requests_in_process(self, event):
        """
        Pop a request to those that are currently in process
        Queue item are stored by their corresponding event when
        they will be delivered.
        """
        queue_item = self._requests_in_process.pop(event)
        self._decrement_pairs_in_process(queue_item.node_id, queue_item.create_id)
        return queue_item

    def _decrement_pairs_left(self, node_id, create_id):
        """
        Decrement number of pairs left for the given create ID
        """
        pairs_left = self._add_to_queue_item_value(node_id, create_id, "pairs_left", to_add=-1)
        if pairs_left <= 0:
            self._pop_from_request_queue(key=(node_id, create_id))

    def _decrement_pairs_in_process(self, node_id, create_id):
        """
        Decrement number of pairs in process for the given create ID
        """
        self._add_to_queue_item_value(node_id, create_id, "pairs_in_process", to_add=-1)

    def _increment_pairs_in_process(self, node_id, create_id):
        """
        Increment number of pairs in process for the given create ID
        """
        self._add_to_queue_item_value(node_id, create_id, "pairs_in_process", to_add=+1)

    def _add_to_queue_item_value(self, node_id, create_id, field_name, to_add):
        """
        Helper function used by `_decrement_pairs_left`, `_decrement_pairs_in_process` and `_increment_pairs_in_process`
        to update information of a queue item
        """
        key = node_id, create_id
        queue_item = self._requests_in_queue[key]
        old_value = getattr(queue_item, field_name)
        new_value = old_value + to_add
        field_value = {field_name: old_value + to_add}
        updated_queue_item = queue_item._replace(**field_value)
        self._requests_in_queue[key] = updated_queue_item

        return new_value

    @staticmethod
    def _sample_basis_choice(random_basis_set, probability_dist_spec):
        """
        Samples the random basis, given the specified basis set and probability distribution.

        :param random_basis_set: :class:`qlink_interface.RandomBasis`
        :param probability_dist_spec: list of ints
        :return: list of ints
        """
        # Possibly chose a random operator to perform before the measurement
        if not isinstance(random_basis_set, RandomBasis):
            random_basis_set = RandomBasis(random_basis_set)
        if random_basis_set == RandomBasis.NONE:
            # Measure in Z
            basis = MeasurementBasis.Z
        elif random_basis_set == RandomBasis.XZ:
            # Measure in X or Z
            weights = [probability_dist_spec[0], 1 - probability_dist_spec[0]]
            basis = random.choices([MeasurementBasis.X, MeasurementBasis.Z], weights)[0]
        elif random_basis_set == RandomBasis.XYZ:
            # Measure in X, Y or Z
            weights = [probability_dist_spec[0], probability_dist_spec[1],
                       1 - probability_dist_spec[0] - probability_dist_spec[1]]
            basis = random.choices([MeasurementBasis.X, MeasurementBasis.Y, MeasurementBasis.Z], weights)[0]
        elif random_basis_set == RandomBasis.CHSH:
            # Measure in (Z + X)/2 or (Z - X)/2
            weights = [probability_dist_spec[0], 1 - probability_dist_spec[0]]
            basis = random.choices([MeasurementBasis.ZPLUSX, MeasurementBasis.ZMINUSX], weights)[0]
        else:
            raise ValueError("Unsupported random basis choice {}".format(random_basis_set))

        return basis

    @staticmethod
    def _construct_rotation_operator(rot_angles_spec):
        """
        Constructs the rotation operator to be used before measuring the qubit.
        Returns None if no rotation should be performed.
        """
        if all([rot_angle == 0 for rot_angle in rot_angles_spec]):
            # Don't perform any rotation
            return None

        else:
            rot_axes = [(1, 0, 0), (0, 1, 0), (1, 0, 0)]
            rotation_operator = ops.I
            for rot_angle, rot_axis in zip(reversed(rot_angles_spec), rot_axes):
                rotation_operator *= ops.create_rotation_op(rot_angle, rot_axis)

            return rotation_operator

    def _measure_qubit(self, node, request, memory_position):
        """
        Measures the qubit part of an entangled pair, in the case of type M request,
        possible with a random basis and or rotation
        """
        if node.ID == request.remote_node_id:
            random_basis = request.random_basis_remote
            rotation_X1 = request.x_rotation_angle_remote_1
            rotation_Y = request.y_rotation_angle_remote
            rotation_X2 = request.x_rotation_angle_remote_2
            probability_dist1 = request.probability_distribution_parameter_remote_1
            probability_dist2 = request.probability_distribution_parameter_remote_2

        else:
            random_basis = request.random_basis_local
            rotation_X1 = request.x_rotation_angle_local_1
            rotation_Y = request.y_rotation_angle_local
            rotation_X2 = request.x_rotation_angle_local_2
            probability_dist1 = request.probability_distribution_parameter_local_1
            probability_dist2 = request.probability_distribution_parameter_local_2

        # Sample the basis to use
        probability_dist_spec = [probability_dist1, probability_dist2]
        basis = self._sample_basis_choice(random_basis_set=random_basis, probability_dist_spec=probability_dist_spec)

        # Pop the qubit from memory
        [qubit] = node.qmemory.pop(memory_position)

        # Perform any rotation before the measurement
        rot_angles_spec = [rotation_X1, rotation_Y, rotation_X2]
        rotation_operator = self._construct_rotation_operator(rot_angles_spec=rot_angles_spec)
        if rotation_operator is not None:
            qapi.operate(qubit, rotation_operator)

        # Measure the qubit
        observable = self._measurement_observables[basis]
        outcome, _ = qapi.measure(qubit, observable=observable)
        return outcome, basis

    def _get_bell_state(self, midpoint_outcome):
        return self._magic_distributor.get_bell_state(midpoint_outcome=midpoint_outcome)

    def _handle_delivery(self, event):
        """
        Handles the completion of an entanglement generation.
        Updates the requests, number of pairs left etc,
        measures the qubits in case of type M and returns the corresponding OK message
        """
        logger.info("Handling delivery of entanglement")
        try:
            queue_item = self._pop_from_requests_in_process(event)
        except KeyError:
            # This indicates that this delivery event is not the "reference" delivery event returned by add_delivery
            # of the magic distributor. Since the below operations only need to be executed once, we can skip this.
            return
        request = queue_item.request
        node_id = queue_item.node_id
        create_id = queue_item.create_id
        memory_positions = self._magic_distributor.peek_delivery(event).memory_positions

        # Decrement remaining pairs
        self._decrement_pairs_left(node_id=node_id, create_id=create_id)

        # Get Bell state from outcome
        midpoint_outcome = self._magic_distributor.get_label(event)
        bell_state = self._get_bell_state(midpoint_outcome=midpoint_outcome)

        # Create response messages and measure qubits if type M or R
        sequence_number = self._get_next_sequence_number()
        messages = {}
        for node in self.nodes:
            if node.ID != request.remote_node_id:
                directionality_flag = 0
            else:
                directionality_flag = 1

            # Get the ID of the other node
            for remote_node in self.nodes:
                if remote_node.ID != node.ID:
                    remote_node_id = remote_node.ID
                    break
            else:
                raise RuntimeError("Could not get the remote node ID")

            memory_position = memory_positions[node.ID][0]
            if isinstance(request, ReqCreateAndKeep):
                msg = ResCreateAndKeep(
                    create_id=create_id,
                    logical_qubit_id=memory_position,
                    directionality_flag=directionality_flag,
                    sequence_number=sequence_number,
                    purpose_id=request.purpose_id,
                    remote_node_id=remote_node_id,
                    goodness=request.minimum_fidelity,
                    time_of_goodness=sim_time(),
                    bell_state=bell_state,
                )
            elif isinstance(request, ReqMeasureDirectly):
                measurement_outcome, measurement_basis = self._measure_qubit(node, request, memory_position)
                msg = ResMeasureDirectly(
                    create_id=create_id,
                    measurement_outcome=measurement_outcome,
                    measurement_basis=measurement_basis,
                    directionality_flag=directionality_flag,
                    sequence_number=sequence_number,
                    purpose_id=request.purpose_id,
                    remote_node_id=remote_node_id,
                    goodness=request.minimum_fidelity,
                    bell_state=bell_state,
                )
            else:
                raise NotADirectoryError("Requests of type other than K or M is not yet supported")
            messages[node.ID] = msg

        # Handle next before replying to users
        # This is to avoid the user effectively calling _handle_next before us
        self._handle_next()

        # Respond to the user
        for node in self.nodes:
            self.react_to(node.ID, messages[node.ID])


class MagicLinkLayerProtocolWithSignaling(MagicLinkLayerProtocol):
    """Version of the magic link-layer protocol which uses signalling to communicate."""

    Result = namedtuple("result", ["node_id", "msg"])

    def __init__(self, nodes, magic_distributor, translation_unit):
        super().__init__(nodes=nodes, magic_distributor=magic_distributor, translation_unit=translation_unit)
        for node in nodes:
            # enable the protocol to sent the required signals (required for react_to method)
            self.add_signal("react_to_{}".format(node.ID))

    def react_to(self, node_id, msg):
        """Send a signal (netsquid protocol feature). Overwritten from the original magic link-layer protocol.

        The label of the sent signal is 'react_to_*' with * = node_id.
        The result of the sent signal is a namedtuple named 'result' with result.node_id = node_id and result.msg = msg.

        Parameters
        ----------
        node_id: int
            ID of node to which the signal is directed (although other nodes may also able to receive it).
        msg: str
            Message that is to be communicated.

        """
        self.send_signal(signal_label="react_to_{}".format(node_id), result=self.Result(node_id, msg))
