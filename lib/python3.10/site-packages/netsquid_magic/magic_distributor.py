import itertools
import logging
import warnings
from dataclasses import dataclass

from collections import namedtuple
from copy import copy, deepcopy

from netsquid import BellIndex
from netsquid.components import INSTR_EMIT, INSTR_INIT
from netsquid_physlayer.detectors import BSMOutcome
from netsquid_physlayer.heralded_connection import HeraldedConnection

import netsquid as ns
from netsquid.components.component import Message
from netsquid.nodes.node import Node
from netsquid.qubits.qubitapi import create_qubits, assign_qstate

import pydynaa

from netsquid_magic.state_delivery_sampler import (
    PerfectStateSamplerFactory,
    SingleClickDeliverySamplerFactory,
    DoubleClickDeliverySamplerFactory,
    DepolariseStateSamplerFactory,
    DepolariseWithFailureStateSamplerFactory,
    BitflipStateSamplerFactory
)

_Delivery = namedtuple("Delivery", ["sample", "memory_positions", "ports", "parameters"])


@dataclass
class _NodeDelivery:
    """Holds information about magic delivery at a specific node."""
    delivery: _Delivery
    node_id: int
    qubits: dict  # keys: int (node IDs), values: qubits to be delivered at node.


class MagicDistributor(pydynaa.Entity):
    """
    Distributes states into memories and connects two or more nodes.

    It now supports:
    (1) adding delivery which is called by only one of the nodes (done through :meth:`add_delivery`),
    (2) adding delivery only after both involved nodes filed the request for creating bipartite two-qubit entanglement
        (request filed through :meth:`add_pair_request`), and
    (3) merging two Magic Distributors together (this can be chained to achieve merging of more MDs).

    Adding delivery
    ---------------

    Either make use of :meth:`add_delivery` if only of of the nodes calls the MagicDistributor at a time,
    or use :meth:`add_pair_request` to submit a request for bipartite two-qubit entanglement.
    Note that the method `add_pair_request` currently supports only two-qubit entaglement. The Magic Distributor waits
    for request from both involved nodes and then calls `add_delivery` once.

    Example usage for adding delivery:

    Say there is a (very simplified) Magic Distributor `md` setup with a placeholder delivery_sampler_factory
    and two nodes A and B. It will be used to show two different approaches to adding delivery.

    .. code-block:: python

        nodeA = Node("nodeA", 0, qmemory=QuantumMemory(name="A", num_positions=20), port_names=["ENT_LABEL"])
        nodeB = Node("nodeB", 1, qmemory=QuantumMemory(name="B", num_positions=20), port_names=["ENT_LABEL"])

        md = MagicDistributor(delivery_sampler_factory=FakeDeliverySamplerFactory, nodes=[nodeA, nodeB])

        # This is how memory positions could look, i.e. the dictionary would be {0: 2, 1: 3}
        memory_positions = {nodeA.ID: 2, nodeB.ID: 3}
        parameters = {"cycle_time": 42}

        # Adding delivery by only one node
        md.add_delivery(memory_positions=memory_positions, **parameters)

        # The same delivery (line 57) would be achieved by the following lines
        md.add_pair_request(senderID=0, remoteID=1, pos_sender=2, delivery_params=parameters)  # request from A
        md.add_pair_request(senderID=1, remoteID=0, pos_sender=3, delivery_params=parameters)  # request from B

        # since now both nodes A and B submitted the request, `add_delivery` with the same parameters as in line 57
        # would be called internally

    Merging functionality
    ---------------------

    Two magic distributors can be merged with :meth:`merge_magic_distributor`. Even after merging, most information is
    kept separate (such that fixed delivery parameters can be different for original magic distributors). There is
    an "md_index" that refers to the position of the original MD within the chain and can be used to retrieve the
    relevant properties of magic distributor.

    Note: Currently, even if magic distributors are merged, :meth:`add_delivery` is supported only for nodes originating
    from the same magic distributor. (See the example usage for illustration of this.)

    Example usage for merging magic distributors:

    Say there are four nodes (nodeA, nodeB, nodeC, nodeD) that are initialised outside of this piece of example code.
    The node IDs are 0, 1, 2, 3 respectively.

    .. code-block:: python
        # create two magic distributors
        md = MagicDistributor(FakeDeliverySamplerFactoryA, [nodeA, nodeB])
        other_md = MagicDistributor(FakeDeliverySamplerFactoryB, [nodeC, nodeD])

        # merge magic distributor "other_md" into "md" (the "self" MD is the leftmost one in the created chain)
        md.merge_magic_distributor(other_md)

        # md now holds two delivery sampler factories and four nodes
        # notice the nested list of nodes which serves for knowing the length of original magic distributors
        print(md.delivery_sampler_factory)
        >> [FakeDeliverySamplerFactoryA, FakeDeliverySamplerFactoryB]
        print(md.nodes)
        >> [[nodeA, nodeB], [nodeC, nodeD]]

        # calling add delivery only works for either nodeA and nodeB, or nodeC and nodeD
        md.add_delivery({0: 1, 1: 2}, "cycle_time"=10)  # only calls delivery on nodeA and nodeB
    """

    STATE_DEL_EVTYPE = ns.EventType("STATE_DELIVERED", "State is put in memory")
    LABEL_DEL_EVTYPE = ns.EventType("LABEL_DELIVERED", "Label is put on port")

    def __init__(self, delivery_sampler_factory, nodes, component=None, state_delay=0, label_delay=0,
                 num_qubits_per_memory=1, custom_labels=None, skip_rounds=True, **kwargs):
        """
        Magic distributor of states.

        Note that to allow merging of magic distributors, all variables are internally stored as lists or dictionaries.
        To see more of the reasoning behind chosen data structures, see :meth:`merge_magic_distributor`.

        Parameters
        ----------
        delivery_sampler_factory: :class:`~.state_delivery_sampler.IStateDeliverySamplerFactory`.
            The state delivery sampler factory
        nodes : list of :obj:`~netsquid.nodes.node.Node`
            List of nodes for which entanglement can be produced.
        component : :obj:`~netsquid.components.component.Component` or None
            Component from which physical parameters will be extracted.
            If None, parameters will be extracted from the specified nodes.
        state_delay : dict or float or int (default 0)
            The times [ns] from the success until when the states should be put in the memory of each node.
            If a dict, keys should be node IDs (int) and items should be delays for respective nodes (int or float).
            If int or float, this is the state delay used for every node.
        label_delay : dict or float or int (default 0)
            The times [ns] from adding the state in memory until when the labels (measurement outcomes) should be put on
            the port of each node.
            If a dict, keys should be node IDs (int) and items should be delays for respective nodes (int or float).
            If int or float, this is the label delay used for every node.
        custom_labels : list of labels (default None)
            Custom labels for heralded success in the HeraldedStateDeliverySamplerFactory.
        skip_rounds : bool
            If True, then only sample from states that are not None and skip rounds which failed.
            If False, also sample from None and schedule fails.
            Can be changed through :meth:`~.set_skip_rounds`
        """
        self.delivery_sampler_factory = [delivery_sampler_factory]
        self._nodes = [nodes]
        self._component = [component]
        self._qmemories = [self.get_qmemories_from_nodes()]

        # How long after the success to add the state to the memories
        if isinstance(state_delay, int) or isinstance(state_delay, float):
            state_delay = {node.ID: state_delay for node in nodes}
        elif not isinstance(state_delay, dict):
            raise TypeError("state_delay must be dict, int or float, not {}.".format(type(state_delay)))
        if not {node_id for node_id in state_delay} == {node.ID for node in nodes}:
            raise ValueError("state delay was not specified for all nodes.")
        self._state_delay = [state_delay]

        # How long after adding the state to memory to add the label to the port
        if isinstance(label_delay, int) or isinstance(label_delay, float):
            label_delay = {node.ID: label_delay for node in nodes}
        elif not isinstance(label_delay, dict):
            raise TypeError("label_delay must be dict, int or float, not {}.".format(type(label_delay)))
        if not {node_id for node_id in label_delay} == {node.ID for node in nodes}:
            raise ValueError("Label delay was not specified for all nodes.")
        self._label_delay = [label_delay]

        # Number of qubits that will be distributed per memory
        self._num_qubits_per_memory = [num_qubits_per_memory]

        self._current_delivery_id = -1

        self.fixed_delivery_parameters = {}
        self.fixed_delivery_parameters.update(self._read_params_from_nodes_or_component())
        # check if some parameters are both extracted from nodes or component and manually defined in the constructor
        intersect = set(self.fixed_delivery_parameters.keys()).intersection(*kwargs.keys())
        if len(intersect) > 0:
            logging.warning("Parameters {} extracted from nodes or component are overwritten by parameters given "
                            "directly to the constructor.".format(intersect))
        self.fixed_delivery_parameters.update(kwargs)

        # Add custom labels to fixed_delivery_parameters (if provided)
        if custom_labels is not None:
            self.fixed_delivery_parameters.update({"custom_labels": custom_labels})
        self.fixed_delivery_parameters = [self.fixed_delivery_parameters]

        # Set behaviour for skipping rounds when sampling
        self._skip_rounds = [skip_rounds]

        # Updates the delays (self._state_delay and self._label_delay) if these are set in fixed_delivery_parameters
        self._update_delays()

        self._callbacks = [[]]  # every MD has a list of callbacks
        self._state_node_deliveries = {}  # keys = state events, values = DeliverySample objects
        self._label_node_deliveries = {}  # keys = label events, values = DeliverySample objects
        self._evhandler = pydynaa.EventHandler(self._handle_node_delivery)
        self.start()

        # Used for the functionality of adding requests
        self._last_label = None
        self._pending_requests = []

        # Used for functionality of separate delivery for each node
        self._state_events_of_same_delivery = {}  # state event: set of all state events of same delivery

    def get_qmemories_from_nodes(self):
        """
        Specifies the memories of the nodes in which the state will be magically put.

        Note: this method can be called only when the magic distributor has not yet been merged.

        Returns
        -------
        dict
            A dictionary of which the keys are the unique node ID's and the corresponding
            values are the memories in which the state should be put.
        """
        if len(self.nodes) > 1:
            raise ValueError("Function get_qmemories_from_nodes can only be called on MD that is not merged yet")

        qmemories = {}
        for node in list(itertools.chain(*self.nodes)):
            if isinstance(node, Node):
                qmemory = node.qmemory
                if qmemory is None:
                    raise ValueError("Node has no memory")
                qmemories[node.ID] = qmemory
            else:
                raise NotImplementedError
        return qmemories

    def _read_params_from_nodes_or_component(self):
        """
        Specifies how to extract parameters to pass to the delivery sampler factory
        from the given nodes and/or component.

        Returns
        -------
        dict
            A dictionary with the parameters where the keys should correspond to the
            keyword arguments of the 'create_state_delivery_sampler' method of the
            delivery sampler factory.
        """
        return {}

    def _update_delays(self):
        """
        Update the state and label delay if these are set in fixed_delivery_parameters

        To compute the delays in a different way, subclass and override this method. Note that the delay are stored in a list.
        """
        for i in range(len(self.fixed_delivery_parameters)):
            if "state_delay" in self.fixed_delivery_parameters[i]:
                state_delay = self.fixed_delivery_parameters[i]["state_delay"]
                if isinstance(state_delay, int) or isinstance(state_delay, float):
                    self._state_delay[i] = {node.ID: state_delay for node in self.nodes[i]}
                elif isinstance(state_delay, dict):
                    self._state_delay[i].update(state_delay)
                else:
                    raise TypeError("state_delay must be dict, int or float, not {}.".format(type(state_delay)))
            if "label_delay" in self.fixed_delivery_parameters[i]:
                label_delay = self.fixed_delivery_parameters[i]["label_delay"]
                if isinstance(label_delay, int) or isinstance(label_delay, float):
                    self._label_delay[i] = {node.ID: label_delay for node in self.nodes[i]}
                elif isinstance(label_delay, dict):
                    self._label_delay[i].update(label_delay)
                else:
                    raise TypeError("label_delay must be dict, int or float, not {}.".format(type(label_delay)))

    @property
    def nodes(self):
        """
        Nodes are kept in a list of lists.
        In case the magic distributor has not been merged, access the nodes through `self.nodes[0]`.
        """
        return self._nodes

    @property
    def component(self):
        """
        Component(s) are kept in a list.
        In case the magic distributor has not been merged, access the component through `self.component[0]`.
        """
        return self._component

    def start(self):
        self._wait(self._evhandler, entity=self, event_type=self.STATE_DEL_EVTYPE)
        self._wait(self._evhandler, entity=self, event_type=self.LABEL_DEL_EVTYPE)

    def stop(self):
        self._dismiss(self._evhandler, entity=self, event_type=self.STATE_DEL_EVTYPE)
        self._dismiss(self._evhandler, entity=self, event_type=self.LABEL_DEL_EVTYPE)

    def reset(self):
        # reset pending requests and last label
        self._pending_requests = []
        self._last_label = None

        # reset the event handler
        self.stop()
        self.start()

    def add_delivery(self, memory_positions, ports=None, md_index=0, **kwargs):
        """
        Called by only one of the nodes.

        Parameters
        ----------
        memory_positions : dict with keys = node IDs and values = memory positions
        ports : dict (optional) with keys = node IDs and values = port names
            Specifies where the labels should be put.
            If ``None`` (default) then the labels are not put on a port, but can still be accessed by
            :meth:`~.MagicDistributor.get_label` through the event returned from :meth:`~.MagicDistributor.add_delivery`
            Note: if dict with some values None, label will still be delivered for all entries with value not None
        md_index : int (default 0 for when magic distributor has not been merged yet)
            This index specifies at which positions the parameters for adding delivery are. In case of a merged MD,
            it is a position of the original Magic Distributor in the chain.
        kwargs : additional args that will be passed on to
            :obj:`~netsquid_magic.state_delivery_sampler.DeliverySampler`.sample

        Returns
        -------
        :obj:`~pydynaa.core.Event`
            One of the scheduled events (there is a different event for each node, but only one of them is returned).
            This event can be used subsequently in other methods such as :meth:`~MagicDistributor.peek_delivery`
            and :meth:`~MagicDistributor.abort_delivery`

        """
        # Check all nodes originate from the same magic distributor
        for nodeID in memory_positions.keys():
            if not any(node.ID == nodeID for node in self.nodes[md_index]):
                raise ValueError("Not all nodes refer to the same parameters, they have varying md_index")

        # Check that delivery is added to all quantum memories in the magic distributor
        if len(memory_positions) != len(self._qmemories[md_index]):
            raise ValueError("More memory positions_of_connections provided than QMemories found in the connection")

        for nodeID in memory_positions.keys():
            if type(memory_positions[nodeID]) == int:
                # Wrap in a list in order to check its length and later assign the qstate consistently
                memory_positions[nodeID] = [memory_positions[nodeID]]
            if len(memory_positions[nodeID]) != self._num_qubits_per_memory[md_index]:
                raise ValueError("Number of given memory positions and specified number of qubits do not match")

        # Make sure the nodes have the specified ports
        self._assert_nodes_have_ports(ports, md_index=md_index)

        # add the delivery
        parameters = {}
        parameters.update(self.fixed_delivery_parameters[md_index])
        parameters.update(kwargs)
        parameters['md_index'] = md_index
        delivery_sampler = self.delivery_sampler_factory[md_index].create_state_delivery_sampler(**parameters)
        delivery = _Delivery(
            sample=delivery_sampler.sample(skip_rounds=self._skip_rounds),
            memory_positions=memory_positions,
            ports=ports,
            parameters=parameters,
        )

        event = self._schedule_state_delivery_events(delivery)
        return event

    def add_pair_request(self, senderID, remoteID, pos_sender, port_sender=None, delivery_params=None):
        """
        Files a request to generate (bipartite) entanglement.
        Once both nodes have filed a request, :meth:`add_pair_delivery` is called to actually produce the entanglement.

        Parameters
        ----------
        senderID : int
            Node ID of the calling node.
        remoteID : int
            ID of the other node with whom entanglement should be generated.
        pos_sender : int
            Memory position of the calling node where the entanglement should be stored
        port_sender : str (optional)
            Name of port at which the calling node wants to receive message with label.
            If set to ``None`` the ports will be set to ``None`` when passed to the magic distributor
            and the labels of the delivery will then not be put on a port.
        delivery_params : dict with keys = str and value = Any
            Parameters which are passed on to the `add_delivery` function of the MagicDistributor.
        """
        request = _EntGenRequest(senderID=senderID,
                                 remoteID=remoteID,
                                 pos_sender=pos_sender,
                                 port_sender=port_sender,
                                 delivery_params=delivery_params)

        # check if request matches other request:
        matching_request = self._matches_existing_request(request)
        # ...and act accordingly
        if matching_request is None:
            self._pending_requests.append(request)
        else:
            # delete the request from the list of pending requests
            self._pending_requests.remove(matching_request)

            # ensure the magic distributor performs the delivery
            event = self._add_pair_delivery(request, matching_request)
            self._last_label = self.get_label(event=event)

    def merge_magic_distributor(self, other):
        """
        Merges two magic distributors together. The data is combined into lists, lists of lists, or dictionaries as
        explained below.

        Note: merging magic distributors causes its history to be cleared. State and label deliveries data are kept,
        but the method :meth:`reset` is called which clears `_pending_requests` and resets `_last_label`. The
        `_current_delivery_id` is also reset as we don't know which MD has more recent information.

        Parameters
        ----------
        other : :obj:`~netsquid_magic.magic_distributor.MagicDistributor`

        """
        if not isinstance(other, MagicDistributor):
            raise TypeError("Parameter `other` should be a MagicDistributor")

        # one value per MD, thus kept in a list
        self.delivery_sampler_factory += other.delivery_sampler_factory
        self._component += other.component
        self._state_delay += other._state_delay
        self._label_delay += other._label_delay
        self._num_qubits_per_memory += other._num_qubits_per_memory
        self._skip_rounds += other._skip_rounds

        # (possibly) list of values per MD, thus kept in a list of lists
        self._nodes += other.nodes
        self._callbacks += other._callbacks

        # dictionaries with no duplicate keys (delivery has unique id in simulation run), dicts are updated
        self._state_node_deliveries.update(other._state_node_deliveries)
        self._label_node_deliveries.update(other._label_node_deliveries)

        # qmemories kept in list of dicts separate for easier checking of length of original magic distributors
        self._qmemories += other._qmemories

        # dictionary with possible duplicate key values, thus kept in a list of dicts
        self.fixed_delivery_parameters += other.fixed_delivery_parameters

        self._current_delivery_id = -1  # Note: reset because we cannot know which MD has more recent information
        self.reset()

    def add_callback(self, callback, md_index=0):
        """
        Parameters
        ----------
        callback : callback function with delivery_id as argument
        md_index : int (default 0 for when magic distributor has not been merged yet)
            Index of original magic distributor and its callbacks.

        Notes
        -----
        Each callback gets called at every individual node delivery. Thus, for every time
        :meth:`~MagicDistributor.add_delivery` is called, each callback is called once for each node in
        :prop:`~MagicDistributor.nodes`.

        """
        self._callbacks[md_index].append(callback)

    def clear_all_callbacks(self):
        """Removes all set callback functions."""
        self._callbacks = [[]]

    def set_skip_rounds(self, skip, md_index=0):
        """
        Function to change the behaviour of skipping rounds during sampling.

        Parameters
        ----------
        skip : Boolean
            If True, then only sample from states that are not None and skip rounds which failed.
            If False, also sample from None and schedule fails.
        md_index : int (default 0 for when magic distributor has not been merged yet)
            Index of original magic distributor and its skip_rounds property.
        """
        self._skip_rounds[md_index] = skip

    def get_label(self, event=None):
        """
        Function that either returns the last assigned label when successfully calling `add_pair_request`
        (when event is None) or a label of delivery of specified event.
        """
        if event is None:
            return self._last_label

        delivery = self.peek_delivery(event)
        if delivery is None:
            return None
        return delivery.sample.label

    def peek_node_delivery(self, event):
        """Returns node delivery of specified event without removing it from the dictionary."""
        if event.type == self.STATE_DEL_EVTYPE:
            return self._state_node_deliveries.get(event, None)
        elif event.type == self.LABEL_DEL_EVTYPE:
            return self._label_node_deliveries.get(event, None)
        else:
            raise TypeError("Unknown event of type {}".format(event.type))

    def peek_delivery(self, event):
        """Returns delivery of specified event without removing it from the dictionary."""
        return self.peek_node_delivery(event).delivery

    def abort_delivery(self, event):
        """Removes delivery of specified event. If it is a state event, delivery of all state events (there is one
        event for each node) corresponding to the same delivery is removed."""
        if event.type == self.STATE_DEL_EVTYPE:
            for event_of_same_delivery in self._state_events_of_same_delivery:
                if event_of_same_delivery != event:
                    self._pop_state_delivery(event_of_same_delivery)
            return self._pop_state_delivery(event)
        elif event.type == self.LABEL_DEL_EVTYPE:
            return self._pop_label_delivery(event)
        else:
            raise TypeError("Unknown event of type {}".format(event.type))

    def abort_all_delivery(self):
        """Removes all deliveries."""
        event_list = copy(self._state_node_deliveries)
        for event in event_list:
            self._pop_state_delivery(event)
        self._pending_requests.clear()

    def _handle_node_delivery(self, event):
        """Depending on the event (delivery of state or label), the state is put on memory or label is put on ports."""
        node_delivery = self.peek_node_delivery(event)
        if node_delivery is None:
            # delivery was aborted
            return
        if event.type == self.STATE_DEL_EVTYPE:
            self._handle_state_delivery(
                node_delivery=node_delivery,
                event=event,
            )

        elif event.type == self.LABEL_DEL_EVTYPE:
            self._handle_label_delivery(
                node_delivery=node_delivery,
                event=event,
            )

        else:
            raise TypeError("Unknown event type {}".format(event.type))

    def _handle_state_delivery(self, node_delivery, event):
        # let the calling node know that a state was created, only perform callbacks for that original MD
        delivery = node_delivery.delivery
        md_index = delivery.parameters['md_index']  # extract md_index from delivery information
        qmemory = self._qmemories[md_index][node_delivery.node_id]
        memory_positions = delivery.memory_positions[node_delivery.node_id]

        # deliver the quantum state at the quantum memory
        qmemory.put(qubits=node_delivery.qubits, positions=memory_positions, replace=True, check_positions=True)

        # apply noise to the delivered quantum state
        self._apply_noise(delivery=delivery, quantum_memory=qmemory, positions=list(range(qmemory.num_positions)))

        for callback in self._callbacks[delivery.parameters['md_index']]:
            callback(event=event)

        self._schedule_label_delivery_event(node_delivery=node_delivery)

        # ensure the same delivery will not be performed multiple times
        self._pop_state_delivery(event)

    def _handle_label_delivery(self, node_delivery, event):
        self._add_message_with_label(node_delivery=node_delivery)

        # ensure the same delivery will not be performed multiple times
        self._pop_label_delivery(event)

    def _matches_existing_request(self, request):
        """Function that determines whether there is an existing matching request and returns it if yes."""
        for other_request in self._pending_requests:
            if request.matches(other_request):
                return other_request
        return None

    def _add_pair_delivery(self, requestA, requestB):
        """Function that combines information from both requests and calls :meth:`add_delivery`."""
        # determine the correct ordering of memory positions
        memory_positions = {r.senderID: r.pos_sender for r in [requestA, requestB]}

        # do the same for ports, but set to None if no ports are specified (so that port delivery is skipped)
        if requestA.port_sender is None or requestB.port_sender is None:
            ports = None
        else:
            ports = {r.senderID: r.port_sender for r in [requestA, requestB]}

        # NOTE: currently only works when both requests have same parameters
        if requestA.delivery_params != requestB.delivery_params:
            raise ValueError("Different requests for magic must pass same parameters.")
        delivery_params = requestA.delivery_params

        return self.add_delivery(memory_positions=memory_positions, ports=ports, **delivery_params)

    def _assert_nodes_have_ports(self, ports, md_index=0):
        """Asserts that the nodes have the specified ports.

        Parameters
        ----------
        ports : dict (optional) with node IDs as keys and port names as values
            Note: if dict has some values None, label will still be delivered for all entries with value not None
        md_index : int (default 0 for when magic distributor has not been merged yet)
            Index of relevant magic distributor whose nodes should be checked.
        """
        if ports is None:
            return
        for node in self.nodes[md_index]:  # check nodes from relevant MD
            port = ports[node.ID]
            if port not in node.ports:
                raise ValueError("Node {} does not have port {}".format(node.name, port))

    def _schedule_state_delivery_events(self, delivery):
        """Schedules the deliveries of the state and label."""
        md_index = delivery.parameters['md_index']  # extract md_index from delivery information
        state_events = []
        qubits = self._create_entangled_qubits(delivery)

        for node in self.nodes[md_index]:
            node_delivery = _NodeDelivery(delivery=delivery, node_id=node.ID, qubits=qubits[node.ID])

            # set the memory positions at which a quantum state is delivered to "in use"
            for memory_position in delivery.memory_positions[node.ID]:
                self._qmemories[md_index][node.ID].mem_positions[memory_position].in_use = True

            # Schedule the delivery of the state
            # taking state delay of the original magic distributor this delivery applies to
            total_state_delay = self._get_total_state_delay(node_delivery=node_delivery)

            state_event = self._schedule_after(total_state_delay, self.STATE_DEL_EVTYPE)
            self._state_node_deliveries[state_event] = node_delivery
            state_events.append(state_event)

        # we choose one of the state events to use as reference for the delivery (does not really matter which one)
        state_event = state_events[0]
        # we store which other state events correspond to the same delivery as the reference state event
        self._state_events_of_same_delivery[state_event] = state_events

        return state_event

    def _get_total_state_delay(self, node_delivery):
        md_index = node_delivery.delivery.parameters['md_index']  # extract md_index from delivery information
        return node_delivery.delivery.sample.delivery_duration + self._state_delay[md_index][node_delivery.node_id]

    def _create_entangled_qubits(self, delivery):
        md_index = delivery.parameters['md_index']  # extract md_index from delivery information

        qubits = {}
        for node in self.nodes[md_index]:
            qubits[node.ID] = create_qubits(self._num_qubits_per_memory[md_index])

        # put the state onto the qubits
        ordered_qubits = []
        [ordered_qubits.extend(qubits[node.ID]) for node in self.nodes[md_index]]
        if delivery.sample.state is not None:
            assign_qstate(ordered_qubits, delivery.sample.state)

        # TODO: decide what to put on memory if failed / state=None
        return qubits

    def _schedule_label_delivery_event(self, node_delivery):
        """Schedules delivery of the label."""
        # taking label delay of the original magic distributor this delivery applies to
        md_index = node_delivery.delivery.parameters['md_index']  # extract md_index from delivery information
        label_delay = self._label_delay[md_index][node_delivery.node_id]
        label_event = self._schedule_after(label_delay, self.LABEL_DEL_EVTYPE)
        self._label_node_deliveries[label_event] = node_delivery

        return label_event

    def _pop_state_delivery(self, event):
        """Removes state delivery event from dictionary."""
        return self._state_node_deliveries.pop(event, None)

    def _pop_label_delivery(self, event):
        """Removes label delivery event from dictionary."""
        return self._label_node_deliveries.pop(event, None)

    def _apply_noise(self, delivery, quantum_memory, positions):
        """
        Apply noise to e.g. carbon qubits.
        Meant to be overwritten.
        """
        pass

    def _add_message_with_label(self, node_delivery):
        """Add message with classical label to port on node."""
        delivery = node_delivery.delivery
        if delivery.ports is None:
            return
        # create the message
        logging.info('Now adding a message with label at time {}'.format(ns.sim_time()))
        port = delivery.ports[node_delivery.node_id]
        if port is not None:
            message = self._create_label_message(label=delivery.sample.label)
            node = self._get_node_from_id(node_delivery.node_id, delivery.parameters['md_index'])
            node.ports[port].tx_input(message)

    def _get_node_from_id(self, node_id, md_index=0):
        """Get specific node given its ID and the position of its Magic Distributor.

        Parameters
        ----------
        node_id : int
            ID of the node that should be retrieved.
        md_index : int (default 0 for when magic distributor has not been merged yet)
            Index of relevant magic distributor which holds the node.
        """
        [node] = [n for n in self.nodes[md_index] if n.ID == node_id]
        return node

    @staticmethod
    def _create_label_message(label):
        """Overwrite this method if you want to customize your messages (e.g. add metadata)."""
        return Message(items=label)

    def get_bell_state(self, midpoint_outcome):
        return BellIndex.PHI_PLUS


class PerfectStateMagicDistributor(MagicDistributor):
    def __init__(self, nodes, **kwargs):
        super().__init__(delivery_sampler_factory=PerfectStateSamplerFactory(), nodes=nodes, **kwargs)


class DepolariseMagicDistributor(MagicDistributor):
    """
    Distributes (noisy) EPR pairs to 2 connected nodes, using samplers created
    by a :class:`~.state_delivery_sampler.DepolariseStateSamplerFactory`.
    """

    def __init__(self, nodes, prob_max_mixed, **kwargs):
        """
        Parameters
        ----------
        nodes : list of :obj:`~netsquid.nodes.node.Node`
            Pair of nodes to which noisy EPR pairs will be distributed.
        prob_max_mixed : float
            Probability that instead of a perfect EPR pair,
            the maximally mixed state is distributed.
        """
        self.prob_max_mixed = prob_max_mixed
        super().__init__(delivery_sampler_factory=DepolariseStateSamplerFactory(), nodes=nodes, **kwargs)

    def add_delivery(self, memory_positions, **kwargs):
        return super().add_delivery(memory_positions=memory_positions, prob_max_mixed=self.prob_max_mixed, **kwargs)


class DepolariseWithFailureMagicDistributor(MagicDistributor):
    """
    Distributes (noisy) EPR pairs to 2 connected nodes, using samplers created
    by a :class:`~.state_delivery_sampler.DepolariseWithFailureStateSamplerFactory`.
    """

    def __init__(self, nodes, prob_max_mixed, prob_success, **kwargs):
        """
        Parameters
        ----------
        nodes : list of :obj:`~netsquid.nodes.node.Node`
            Pair of nodes to which noisy EPR pairs will be distributed.
        prob_max_mixed : float
            Fraction of maximally mixed state in the mixture.
        prob_success : float
            Probability of successfully sampling.
        """
        self.prob_max_mixed = prob_max_mixed
        self.prob_success = prob_success
        super().__init__(delivery_sampler_factory=DepolariseWithFailureStateSamplerFactory(),
                         nodes=nodes, **kwargs)

    def add_delivery(self, memory_positions, **kwargs):
        return super().add_delivery(memory_positions=memory_positions, prob_max_mixed=self.prob_max_mixed,
                                    prob_success=self.prob_success, **kwargs)


class BitflipMagicDistributor(MagicDistributor):
    """
    Distributes (noisy) EPR pairs to 2 connected nodes, using samplers created
    by a :class:`~.state_delivery_sampler.BitflipStateSamplerFactory`.
    """

    def __init__(self, nodes, flip_prob, **kwargs):
        """
        Parameters
        ----------
        nodes : list of :obj:`~netsquid.nodes.node.Node`
            Pair of nodes to which noisy EPR pairs will be distributed.
        flip_prob : float
            Probability that instead of a perfectly correlated EPR pair,
            a perfectly anti-correlated pair is distributed.
        """
        self.flip_prob = flip_prob
        super().__init__(delivery_sampler_factory=BitflipStateSamplerFactory(), nodes=nodes, **kwargs)

    def add_delivery(self, memory_positions, **kwargs):
        return super().add_delivery(memory_positions=memory_positions, flip_prob=self.flip_prob, **kwargs)


class HeraldedConnectionMagicDistributor(MagicDistributor):
    """
    Magic distributor for nodes that are connected by a heralded connection.
    """
    def __init__(self, delivery_sampler_factory, nodes, **kwargs):
        super().__init__(delivery_sampler_factory=delivery_sampler_factory, nodes=nodes, **kwargs)

    @staticmethod
    def _get_parameters_from_heralded_connection(heralded_connection):
        """Read parameters from a heralded connection component.

        Parameters
        ----------
        heralded_connection : :class:`netsquid-physlayer.heraldedGeneration.HeraldedConnection

        Returns
        -------
        dictionary with parameter values

        """
        if heralded_connection is None:
            return {}

        assert isinstance(heralded_connection, HeraldedConnection)
        bsmdet = heralded_connection.subcomponents["BSMDet"]
        quantum_channel_A = heralded_connection.subcomponents["QCh_A"]
        quantum_channel_B = heralded_connection.subcomponents["QCh_B"]
        length_A = quantum_channel_A.properties["length"]
        length_B = quantum_channel_B.properties["length"]
        speed_of_light_A = quantum_channel_A.models["delay_model"].properties["c"]
        speed_of_light_B = quantum_channel_B.models["delay_model"].properties["c"]
        p_loss_length_A = quantum_channel_A.models["quantum_loss_model"].p_loss_length
        p_loss_length_B = quantum_channel_B.models["quantum_loss_model"].p_loss_length
        p_loss_init_A = quantum_channel_A.models["quantum_loss_model"].p_loss_init
        p_loss_init_B = quantum_channel_B.models["quantum_loss_model"].p_loss_init

        return {
            "length_A": length_A,
            "length_B": length_B,
            "p_loss_length_A": p_loss_length_A,
            "p_loss_length_B": p_loss_length_B,
            "p_loss_init_A": p_loss_init_A,
            "p_loss_init_B": p_loss_init_B,
            "speed_of_light_A": speed_of_light_A,
            "speed_of_light_B": speed_of_light_B,
            "dark_count_probability": bsmdet.p_dark,
            "detector_efficiency": bsmdet.det_eff,
            "visibility": bsmdet.visibility,
            "num_resolving": bsmdet.num_resolving
        }

    @staticmethod
    def _create_label_message(label):
        # label is of form ('success', bell_index)
        return Message(items=BSMOutcome(success=True, bell_index=label[1]), id="qdetector")


class SingleClickMagicDistributor(HeraldedConnectionMagicDistributor):
    """Magic distributor for when using a single-click protocol.

    Parameters
    ----------
    nodes : list of :obj:`~netsquid.nodes.node.Node`
        List of nodes for which entanglement can be produced.
        Node on "A" side of heralded connection should be listed first.
    heralded_connection : :obj:`~netsquid_physlayer.heraldedGeneration.HeraldedConnection` or None (optional)
        Heralded connection which magic is supposed to replace. Used to extract delivery parameters.
        Parameters extracted from the connection are overwritten by the other parameters given in this constructor
        (if they are not None), a warning is given when this happens.
    length_A: float or None (optional)
        Length [km] of fiber on "A" side of heralded connection. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        Cannot be None if heralded_connection is None.
    length_B: float or None (optional)
        Length [km] of fiber on "B" side of heralded connection. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        Cannot be None if heralded_connection is None.
    p_loss_init_A: float or None (optional)
        Probability that photons are lost when entering connection on "A" side.
        Includes collection efficiency of emission from memory. Defaults to None.
        If None, the parameter is obtained from p_loss_init_A of heralded_connection and collection_efficiency
        property of memory on side "A".
        If this fails, the default value 0 will be used.
    p_loss_length_A: float or None (optional)
        Attenuation coefficient [dB/km] of fiber between "A" and midpoint. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        If this fails, the default value 0.25 will be used.
    p_loss_init_B: float or None (optional)
        Probability that photons are lost when entering connection on "B" side.
        Includes collection efficiency of emission from memory. Defaults to None.
        If None, the parameter is obtained from heralded_connection and collection_efficiency
        property of memory on side "B".
        If this fails, the default value 0 will be used.
    p_loss_length_B: float or None (optional)
        Attenuation coefficient [dB/km] of fiber between "B" and midpoint. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        If this fails, the default value 0.25 will be used.
    detector_efficiency: float or None (optional)
        Probability that the presence of a photon leads to a detection event. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        If this fails, the default value 1 will be used.
    dark_count_probability: float or None (optional)
        Dark-count probability per detection. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        If this fails, the default value 0 will be used.
    visibility: float or None (optional)
        Hong-Ou-Mandel visibility of photons that are being interfered (measure of photon indistinguishability).
        Defaults to None. If None, the parameter is obtained from heralded_connection.
        If this fails, the default value 1 will be used.
    num_resolving : bool or None (optional)
        Determines whether photon-number-resolving detectors are used for the Bell-state measurement. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        If this fails, the default value False will be used.

    """

    DEFAULT_VALUES = {"p_loss_init_A": 0, "p_loss_length_A": .25, "p_loss_init_B": 0, "p_loss_length_B": .25,
                      "detector_efficiency": 1, "dark_count_probability": 0, "visibility": 1, "num_resolving": False}

    def __init__(self, nodes, heralded_connection=None, length_A=None, length_B=None, p_loss_init_A=None,
                 p_loss_length_A=None, p_loss_init_B=None, p_loss_length_B=None, detector_efficiency=None,
                 dark_count_probability=None, visibility=None, num_resolving=None, **kwargs):

        if heralded_connection is not None and not isinstance(heralded_connection, HeraldedConnection):
            raise ValueError("Magic distributor must read properties from a HeraldedConnection")

        kwargs.update({"length_A": length_A, "length_B": length_B, "p_loss_init_A": p_loss_init_A,
                       "p_loss_length_A": p_loss_length_A, "p_loss_init_B": p_loss_init_B,
                       "p_loss_length_B": p_loss_length_B, "detector_efficiency": detector_efficiency,
                       "dark_count_probability": dark_count_probability, "visibility": visibility,
                       "num_resolving": num_resolving})
        kwargs_not_none = {key: value for (key, value) in kwargs.items() if value is not None}

        super().__init__(delivery_sampler_factory=SingleClickDeliverySamplerFactory(),
                         nodes=nodes, component=heralded_connection, **kwargs_not_none)

    def add_delivery(self, memory_positions, alpha=None, cycle_time=None, **kwargs):
        return super().add_delivery(memory_positions=memory_positions, alpha=alpha, cycle_time=cycle_time, **kwargs)

    def get_bell_state(self, midpoint_outcome):
        try:
            status, label = midpoint_outcome
        except ValueError:
            raise ValueError("Unknown midpoint outcome {}".format(midpoint_outcome))
        if status != 'success':
            raise ValueError("Unknown midpoint outcome {}".format(midpoint_outcome))
        if label == 0:
            return BellIndex.PSI_PLUS
        else:
            return BellIndex.PSI_MINUS

    def _read_params_from_nodes_or_component(self):
        params = deepcopy(self.DEFAULT_VALUES)
        [heralded_connection] = self._component

        params.update(self._get_parameters_from_heralded_connection(heralded_connection))
        params.update(self._read_bright_state_parameter_from_nodes())

        try:
            collection_efficiencies = [node.qmemory.properties["collection_efficiency"] for node in self.nodes[0]]
            if collection_efficiencies[0] != collection_efficiencies[1]:
                raise NotImplementedError("Quantum processors must currently have same collection efficiency.")
            params["p_loss_init_A"] = 1 - (1 - params["p_loss_init_A"]) * collection_efficiencies[0]
            params["p_loss_init_B"] = 1 - (1 - params["p_loss_init_B"]) * collection_efficiencies[0]
        except KeyError:
            pass

        return params

    def _read_bright_state_parameter_from_nodes(self):
        """Retrieve the bright state parameter from nodes of the magic distributor.

        To clarify the origin of the alpha parameter, see below a simplified schematic of two nodes that the magic
        distributor holds. To determine the bright state parameter, we take `alpha_A` from the left node and `alpha_B`
        from the right node.

        .. code-block:: text

                      Node L          HeraldedConnection         Node R
                o-----------------o                        o-----------------o
                |     Params:     |   o===== .... =====o   |     Params:     |
            < B >     alpha_A ->  < A >                < B >     alpha_A ->  < A >
                |  <- alpha_B     |   o===== .... =====o   |  <- alpha_B     |
                o-----------------o                        o-----------------o

        """
        try:
            # note that self.nodes[0] retrieves the list of nodes for this MD (see more in merging of MagicDistributor)
            alpha_A = self.nodes[0][0].properties["alpha_A"]  # node on "A" side of the connection is listed first
            alpha_B = self.nodes[0][1].properties["alpha_B"]
            if alpha_A != alpha_B:
                raise NotImplementedError("Magic distributor does not work for asymmetric links yet.")
            return {"alpha": alpha_A}
        except KeyError:
            return {}


class DoubleClickMagicDistributor(HeraldedConnectionMagicDistributor):
    """Magic distributor for when using a double-click protocol.

    Parameters
    ----------
    nodes : list of :obj:`~netsquid.nodes.node.Node`
        List of nodes for which entanglement can be produced.
        Node on "A" side of heralded connection should be listed first.
    heralded_connection : :obj:`~netsquid_physlayer.heraldedGeneration.HeraldedConnection` or None (optional)
        Heralded connection which magic is supposed to replace. Used to extract delivery parameters.
        Parameters extracted from the connection are overwritten by the other parameters given in this constructor
        (if they are not None), a warning is given when this happens.
    cycle_time: int or None (optional)
        Duration [ns] of each round of entanglement distribution.
        Will be calculated based on other parameters if None.
    length_A: float or None (optional)
        Length [km] of fiber on "A" side of heralded connection. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        Cannot be None if heralded_connection is None.
    length_B: float or None (optional)
        Length [km] of fiber on "B" side of heralded connection. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        Cannot be None if heralded_connection is None.
    p_loss_init_A: float or None (optional)
        Probability that photons are lost when entering connection on "A" side.
        Includes collection efficiency of emission from memory. Defaults to None.
        If None, the parameter is obtained from p_loss_init_A of heralded_connection and collection_efficiency
        property of memory on side "A".
        If this fails, the default value 0 will be used.
    p_loss_length_A: float or None (optional)
        Attenuation coefficient [dB/km] of fiber between "A" and midpoint. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        If this fails, the default value 0.25 will be used.
    speed_of_light_A: float or None (optional)
        Speed of light [km/s] in fiber on "A" side of heralded connection. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        If this fails, the default value 200,000 will be used.
    p_loss_init_B: float or None (optional)
        Probability that photons are lost when entering connection on "B" side.
        Includes collection efficiency of emission from memory. Defaults to None.
        If None, the parameter is obtained from heralded_connection and collection_efficiency
        property of memory on side "B".
        If this fails, the default value 0 will be used.
    p_loss_length_B: float or None (optional)
        Attenuation coefficient [dB/km] of fiber between "B" and midpoint. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        If this fails, the default value 0.25 will be used.
    speed_of_light_B: float or None (optional)
        Speed of light [km/s] in fiber on "B" side of heralded connection. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
       If this fails, the default value 200,000 will be used.
    dark_count_probability: float or None (optional)
        Dark-count probability per detection. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        If this fails, the default value 0 will be used.
    detector_efficiency: float or None (optional)
        Probability that the presence of a photon leads to a detection event. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        If this fails, the default value 1 will be used.
    visibility: float or None (optional)
        Hong-Ou-Mandel visibility of photons that are being interfered (measure of photon indistinguishability).
        Defaults to None. If None, the parameter is obtained from heralded_connection.
        If this fails, the default value 1 will be used.
    num_resolving : bool or None (optional)
        Determines whether photon-number-resolving detectors are used for the Bell-state measurement. Defaults to None.
        If None, the parameter is obtained from heralded_connection.
        If this fails, the default value False will be used.
    num_multiplexing_modes : int (optional)
        Number of modes used for multiplexing, i.e. how often entanglement generation is attempted per round.
    emission_fidelity_A : float or None (optional)
        Fidelity of state shared between photon and memory qubit on "A" side to
        :meth:`~netsquid.qubits.ketstates.BellIndex.PHI_PLUS` Bell state directly after emission. Defaults to None.
        If None, an attempt is made to obtain "emission_fidelity" from the properties of the memory on the "A" side.
        If this fails, the default value 1 will be used.
    emission_fidelity_B : float or None (optional)
        Fidelity of state shared between photon and memory qubit on "B" side to
        :meth:`~netsquid.qubits.ketstates.BellIndex.PHI_PLUS` Bell state directly after emission. Defaults to None.
        If None, an attempt is made to obtain "emission_fidelity" from the properties of the memory on the "B" side.
        If this fails, the default value 1 will be used.
    emission_duration_A : float or None (optional)
        Time in nanoseconds it takes the memory on the "A" side to emit a photon that is entangled with a memory qubit.
        Defaults to None. If None, an attempt is made to get the instruction durations of
        :obj:`~netsquid.components.instructions.INSTR_INIT` and :obj:`~netsquid.components.instructions.INSTR_EMIT`
        on the memory on the "A" side. The sum of these durations is used as emission duration.
        If this fails, the default value 0 will be used.
    emission_duration_B : float or None (optional)
        Time in nanoseconds it takes the memory on the "B" side to emit a photon that is entangled with a memory qubit.
        Defaults to None. If None, an attempt is made to get the instruction durations of
        :obj:`~netsquid.components.instructions.INSTR_INIT` and :obj:`~netsquid.components.instructions.INSTR_EMIT`
        on the memory on the "B" side. The sum of these durations is used as emission duration.
        If this fails, the default value 0 will be used.

    Note
    ----
    Currently only works when the entanglement generation is completely symmetric between sides "A" and "B".

    """

    DEFAULT_VALUES = {"p_loss_init_A": 0, "p_loss_length_A": .25, "speed_of_light_A": 200000,
                      "p_loss_init_B": 0, "p_loss_length_B": .25, "speed_of_light_B": 200000,
                      "dark_count_probability": 0, "detector_efficiency": 1, "num_resolving": False, "visibility": 1,
                      "emission_fidelity_A": 1, "emission_fidelity_B": 1,
                      "emission_duration_A": 0, "emission_duration_B": 0,
                      "num_multiplexing_modes": 1}

    SIDES = ["A", "B"]  # Names of ports of heralded connection, used to keep the two sides apart

    def __init__(self, nodes, heralded_connection=None, cycle_time=None,
                 length_A=None, length_B=None, p_loss_init_A=None, p_loss_length_A=None, speed_of_light_A=None,
                 p_loss_init_B=None, p_loss_length_B=None, speed_of_light_B=None, dark_count_probability=None,
                 detector_efficiency=None, visibility=None, num_resolving=None, num_multiplexing_modes=None, emission_fidelity_A=None,
                 emission_fidelity_B=None, emission_duration_A=None, emission_duration_B=None):

        if heralded_connection is not None and not isinstance(heralded_connection, HeraldedConnection):
            raise ValueError("Magic distributor must read properties from a HeraldedConnection")

        try:
            node_dict_from_connections = \
                {side: heralded_connection.ports[side].connected_port.component for side in self.SIDES}
            if node_dict_from_connections != self.node_dict:
                raise RuntimeError("Node that is connected to 'A' port of heralded connection was not listed first"
                                   "in 'nodes' argument.")
        except AttributeError:
            pass

        kwargs = {"length_A": length_A, "length_B": length_B, "p_loss_init_A": p_loss_init_A,
                  "p_loss_length_A": p_loss_length_A, "speed_of_light_A": speed_of_light_A,
                  "p_loss_init_B": p_loss_init_B, "p_loss_length_B": p_loss_length_B,
                  "speed_of_light_B": speed_of_light_B, "dark_count_probability": dark_count_probability,
                  "detector_efficiency": detector_efficiency, "visibility": visibility, "num_resolving": num_resolving,
                  "num_multiplexing_modes": num_multiplexing_modes, "emission_fidelity_A": emission_fidelity_A,
                  "emission_fidelity_B": emission_fidelity_B, "emission_duration_A": emission_duration_A,
                  "emission_duration_B": emission_duration_B}

        kwargs_not_none = {key: value for (key, value) in kwargs.items() if value is not None}

        if heralded_connection is None and (length_A is None or length_B is None):
            raise ValueError("If heralded_connection is None, "
                             "both length_A and length_B need to be given a numerical value.")

        super().__init__(delivery_sampler_factory=DoubleClickDeliverySamplerFactory(), nodes=nodes,
                         component=heralded_connection, cycle_time=cycle_time, **kwargs_not_none)

    def get_bell_state(self, midpoint_outcome):
        try:
            status, label = midpoint_outcome
        except ValueError:
            raise ValueError("Unknown midpoint outcome {}".format(midpoint_outcome))
        if status != 'success':
            raise ValueError("Unknown midpoint outcome {}".format(midpoint_outcome))
        if isinstance(label, BellIndex):
            return label
        elif label == 0:
            return BellIndex.PSI_PLUS
        else:
            return BellIndex.PSI_MINUS

    @property
    def node_dict(self):
        return dict(zip(self.SIDES, self.nodes[0]))

    def _read_params_from_nodes_or_component(self):

        params = deepcopy(self.DEFAULT_VALUES)
        [heralded_connection] = self._component

        params.update(self._get_parameters_from_heralded_connection(heralded_connection))

        qmemories = {side: self.node_dict[side].qmemory for side in self.SIDES}

        try:
            emission_durations = \
                {side: (qmemories[side].get_instruction_duration(INSTR_EMIT, [0, qmemories[side].emission_position]) +
                        qmemories[side].get_instruction_duration(INSTR_INIT, [0]))
                 for side in self.SIDES}
        except AttributeError:
            emission_durations = {side: 0 for side in self.SIDES}

        try:
            emission_fidelities = {side: qmemories[side].properties["emission_fidelity"] for side in self.SIDES}
        except KeyError:
            warnings.warn("Could not determine emission fidelities, using 1 instead.")
            emission_fidelities = {side: 1 for side in self.SIDES}
        params.update({"emission_duration_A": emission_durations["A"],
                       "emission_duration_B": emission_durations["B"],
                       "emission_fidelity_A": emission_fidelities["A"],
                       "emission_fidelity_B": emission_fidelities["B"]})
        for side in self.SIDES:
            try:
                collection_efficiency = qmemories[side].properties["collection_efficiency"]
                params[f"p_loss_init_{side}"] = 1 - (1 - params[f"p_loss_init_{side}"]) * collection_efficiency
            except KeyError:
                pass
        try:
            num_modes = [node.qmemory.properties["num_multiplexing_modes"] for node in self.nodes[0]]
        except KeyError:
            num_modes = [1, 1]
        params["num_multiplexing_modes"] = min(num_modes)

        return params

    def _update_parameters(self):
        """Calculate parameters which are functions of other parameters.
        Should be called after all other parameters are set."""

        params = self.fixed_delivery_parameters[0]

        # calculate travel times
        travel_durations = {side: params[f"length_{side}"] / params[f"speed_of_light_{side}"] * 1E9
                            for side in self.SIDES}

        # calculate cycle time (only if it was not specified explicitely in the init)
        if params["cycle_time"] is None:
            cycle_times = {side: 2 * travel_durations[side] + params[f"emission_duration_{side}"] for side in self.SIDES}
            params["cycle_time"] = max(cycle_times.values())

        # update state and label delay
        time_of_BSM = max([params[f"emission_duration_{side}"] + travel_durations[side]
                           for side in self.SIDES])
        params["state_delay"] = {self.node_dict[side].ID: time_of_BSM - travel_durations[side]
                                 for side in self.SIDES}
        params["label_delay"] = {self.node_dict[side].ID: 2 * travel_durations[side] for side in self.SIDES}

    def _update_delays(self):

        # update/calculate parameters before delays are updated
        self._update_parameters()

        super()._update_delays()


class _EntGenRequest:
    """
    Class that represents a "request" to generate entanglement by a node with another node;
    this class is only used internally by the :obj:`~netsquid_magic.magic_distributor.MagicDistributor`
    in order to find whether two nodes have both requested to generate entanglement with one another.
    """

    def __init__(self, senderID, remoteID, pos_sender, port_sender, delivery_params=None):
        """
        Parameters
        ----------
        senderID : int
        remoteID : int
        pos_sender : int
        port_sender : str
        delivery_params : dict with keys=str and value=Any
        """
        assert(senderID != remoteID)
        self.senderID = senderID
        self.remoteID = remoteID
        self.pos_sender = pos_sender
        self.port_sender = port_sender
        if delivery_params is None:
            self.delivery_params = {}
        else:
            self.delivery_params = delivery_params

    def __eq__(self, other):
        return (self.senderID == other.senderID and
                self.remoteID == other.remoteID and
                self.pos_sender == other.pos_sender and
                self.port_sender == other.port_sender)

    def __neq__(self, other):
        return not (self == other)

    def matches(self, other):
        """
        Checks whether there is a matching _EntGenRequest from the other node.

        Parameters
        ----------
        other: :obj:`~netsquid_magic.magic_distributor._EntGenRequest`
        """
        return self.senderID == other.remoteID and self.remoteID == other.senderID
