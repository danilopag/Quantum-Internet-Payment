import unittest
import netsquid as ns
from netsquid.components.qprogram import QuantumProgram
import netsquid.components.instructions as ins
from netsquid.components.qprocessor import QuantumProcessor, PhysicalInstruction
from netsquid.qubits.ketstates import BellIndex
import netsquid.qubits.operators as ops
import netsquid.qubits.qubitapi as qapi
import netsquid_nv.rotated_bell_measurement as rbm


def get_noiseless_nv_quantum_processor(electron_position, carbon_positions):
    phys_instructions = []
    phys_instructions.append(PhysicalInstruction(ins.INSTR_INIT, duration=0))
    phys_instructions.append(PhysicalInstruction(ins.INSTR_ROT_Z, duration=0))

    for instr in [ins.INSTR_X, ins.INSTR_Y, ins.INSTR_Z, ins.INSTR_ROT_X, ins.INSTR_ROT_Y, ins.INSTR_ROT_Z, ins.INSTR_H]:
        phys_instructions.append(PhysicalInstruction(instr, duration=0, topology=[electron_position]))

    electron_carbon_topologies = [(electron_position, carbon_pos) for carbon_pos in carbon_positions]
    phys_instructions.append(PhysicalInstruction(ins.INSTR_CXDIR, duration=0, topology=electron_carbon_topologies))

    phys_instructions.append(PhysicalInstruction(ins.INSTR_MEASURE, duration=0, topology=[electron_position]))

    return QuantumProcessor(name='noiseless_nv_quantum_processor',
                            num_positions=1 + len(carbon_positions),
                            phys_instructions=phys_instructions)


def add_bell_pair_to_quantum_processor(qprocessor, bell_index, positions):
    qubits = qapi.create_qubits(2)
    qprocessor.put(qubits=qubits, positions=positions)
    [qa] = qprocessor.peek(positions=positions[0])
    [qb] = qprocessor.peek(positions=positions[1])
    qapi.operate(qubits=[qa], operator=ops.H)
    qapi.operate(qubits=[qa, qb], operator=ops.CNOT)
    bellindex2operator = {BellIndex.PHI_PLUS: ops.I,
                          BellIndex.PSI_PLUS: ops.X,
                          BellIndex.PHI_MINUS: ops.Z,
                          BellIndex.PSI_MINUS: ops.Y}
    qapi.operate(qubits=[qa], operator=bellindex2operator[bell_index])


def add_rotated_bell_pair_to_quantum_processor(qprocessor, bell_index, electron_position, carbon_position):
    positions = [electron_position, carbon_position]
    add_bell_pair_to_quantum_processor(qprocessor, bell_index, positions)
    # apply a Hadamard to the carbon because that qubit
    # lives in a rotated basis
    [q_carbon] = qprocessor.peek(positions=[carbon_position])
    qapi.operate(q_carbon, ops.H)


class TestNVRotatedBellStateMeasurement(unittest.TestCase):

    class NVBSMProgram(QuantumProgram):

        def program(self):
            electron_position, carbon_position = self.get_qubit_indices(2)
            rbm.apply_rotated_bell_state_measurement(
                qprogram=self,
                electron_position=electron_position,
                carbon_position=carbon_position)
            yield self.run()

    def test_outcome(self):
        ns.set_qstate_formalism(ns.QFormalism.DM)

        electron_position = 0
        carbon_positions = [1, 2]
        qmemory = get_noiseless_nv_quantum_processor(electron_position=electron_position,
                                                     carbon_positions=carbon_positions)

        for bell_index in [0, 1, 2, 3]:
            ns.sim_reset()
            qmemory.reset()

            # put the physical qubits in the quantum memories
            add_rotated_bell_pair_to_quantum_processor(qprocessor=qmemory,
                                                       bell_index=bell_index,
                                                       electron_position=electron_position,
                                                       carbon_position=carbon_positions[0])

            # run the circuit
            qprogram = self.NVBSMProgram()
            qmemory.execute_program(qprogram,
                                    qubit_mapping=[electron_position, carbon_positions[0]])
            qmemory.set_program_done_callback(callback=self._check_outcome,
                                              qprogram=qprogram,
                                              qmemory=qmemory,
                                              expected_outcome=bell_index)
            ns.sim_run()

    def _check_outcome(self, qprogram, qmemory, expected_outcome):
        [q_carbon] = qmemory.peek(positions=[1])
        computed_outcome = rbm.convert_rotated_bell_state_circuit_outcomes_to_bell_index(qprogram=qprogram)
        self.assertEqual(expected_outcome, computed_outcome)


if __name__ == "__main__":
    unittest.main()
