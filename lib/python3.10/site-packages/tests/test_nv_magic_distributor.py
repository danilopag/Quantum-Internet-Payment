import copy
import unittest
import pytest
import netsquid as ns
from netsquid.qubits.ketstates import h0, h1
import netsquid.qubits.qubitapi as qapi
from netsquid.components.qprocessor import QuantumProcessor
from netsquid.nodes.node import Node
import numpy as np
from netsquid_nv.magic_distributor import NVSingleClickMagicDistributor
from netsquid_nv.nv_center import NVQuantumProcessor
from netsquid_physlayer.heralded_connection import HeraldedConnection

nv_params = {'carbon_T1': 36000000000000.0,
             'carbon_T2': 1000000000.0,
             'carbon_init_depolar_prob': 0.006000000000000005,
             'carbon_z_rot_depolar_prob': 0.0013333333333333333,
             'coherent_phase': 0.0,
             'ec_gate_depolar_prob': 0.02,
             'electron_T1': 3600000000000.0,
             'electron_T2': 1460000000.0,
             'electron_init_depolar_prob': 0.02,
             'electron_single_qubit_depolar_prob': 0.0,
             'initial_nuclear_phase': 0.0,
             'p_double_exc': 0.06,
             'p_fail_class_corr': 0.0,
             'photon_emission_delay': 3800.0,
             'prob_dark_count': 2.4999999737040923e-08,
             'prob_error_0': 0.050000000000000044,
             'prob_error_1': 0.0050000000000000044,
             'tau_decay': 0.5346179939670399,
             'delta_w': 0.1,
             'std_electron_electron_phase_drift': 0.3490658503988659,
             'visibility': 0.9,
             'num_positions': 2
             }


class NVNode(Node):
    def __init__(self, name, electron_init_depolar_prob, electron_single_qubit_depolar_prob,
                 prob_error_0, prob_error_1, carbon_init_depolar_prob, carbon_z_rot_depolar_prob,
                 ec_gate_depolar_prob, electron_T1, electron_T2, carbon_T1, carbon_T2, coherent_phase,
                 initial_nuclear_phase, p_double_exc, p_fail_class_corr, photon_emission_delay, prob_dark_count,
                 tau_decay, delta_w, std_electron_electron_phase_drift, visibility, num_positions,
                 use_magical_swap=False, port_names=None, alpha_A=None, alpha_B=None, **kwargs):

        qprocessor = NVQuantumProcessor(
            name="nvprocessor", num_positions=num_positions,
            electron_init_depolar_prob=electron_init_depolar_prob,
            electron_single_qubit_depolar_prob=electron_single_qubit_depolar_prob,
            prob_error_0=prob_error_0,
            prob_error_1=prob_error_1,
            carbon_init_depolar_prob=carbon_init_depolar_prob,
            carbon_z_rot_depolar_prob=carbon_z_rot_depolar_prob,
            ec_gate_depolar_prob=ec_gate_depolar_prob,
            electron_T1=electron_T1,
            electron_T2=electron_T2,
            carbon_T1=carbon_T1,
            carbon_T2=carbon_T2,
            coherent_phase=coherent_phase,
            initial_nuclear_phase=initial_nuclear_phase,
            p_double_exc=p_double_exc,
            p_fail_class_corr=p_fail_class_corr,
            photon_emission_delay=photon_emission_delay,
            prob_dark_count=prob_dark_count,
            tau_decay=tau_decay,
            delta_w=delta_w,
            std_electron_electron_phase_drift=std_electron_electron_phase_drift,
            visibility=visibility,
            alpha_A=alpha_A,
            alpha_B=alpha_B,
            use_magical_swap=use_magical_swap)

        super().__init__(name=name, qmemory=qprocessor, port_names=port_names)


class TestNVSingleClickMagicDistributor(unittest.TestCase):

    def setUp(self):

        # initialize a network of two nodes
        qmemory_a = QuantumProcessor("qmem_a", num_positions=10)
        qmemory_b = QuantumProcessor("qmem_b", num_positions=10)
        self.node_a = Node("A", ID=23, qmemory=qmemory_a)
        self.node_b = Node("B", ID=42, qmemory=qmemory_b)
        self.distance = 25  # length needs to be set for single-click MD when there is no heralded connection

    def test_nuclear_noise_application(self):

        for ket in [h0, h1]:

            # add qubits
            qmemory_a = self.node_a.qmemory
            qmemory_a.put(qapi.create_qubits(1), positions=1)
            qmemory_a.put(qapi.create_qubits(1), positions=2)

            class _NVSingleClickMagicDistributor(NVSingleClickMagicDistributor):

                def _apply_induced_dephasing_noise(self, nuclear_qubits, delivery):
                    for qubit in nuclear_qubits:
                        qapi.assign_qstate([qubit], ket)

                def _apply_initial_dephasing_noise(self, nuclear_qubits, delivery):
                    pass

            # initialize NVSingleClickMagicDistributor and magically generate a state
            # between the electron spins
            distributor = _NVSingleClickMagicDistributor(nodes=[self.node_a, self.node_b],
                                                         length_A=self.distance, length_B=self.distance)
            electron_pos = 0
            memory_positions = {self.node_a.ID: electron_pos,
                                self.node_b.ID: electron_pos}
            other_parameters = {"length_A": 10,
                                "length_B": 10,
                                "p_loss_length_A": 0,
                                "p_loss_length_B": 0,
                                "p_loss_init_A": 0,
                                "p_loss_init_B": 0,
                                "detector_efficiency": 1}
            distributor.add_delivery(memory_positions=memory_positions,
                                     alpha=0.1,
                                     cycle_time=53,
                                     **other_parameters)
            ns.sim_run()

            # peek to see if the electron spins are now entangled
            [electron_qubit_a] = self.node_a.qmemory.peek(0)
            [electron_qubit_b] = self.node_b.qmemory.peek(0)
            self.assertTrue(electron_qubit_a.qstate == electron_qubit_b.qstate)

            # peek to see if we get the noise was applied indeed
            for qmemory in [self.node_a.qmemory, self.node_b.qmemory]:
                for position in [1, 2]:
                    [nuclear_qubit] = qmemory_a.peek(1)
                    self.assertTrue(np.isclose(
                        qapi.fidelity(nuclear_qubit, ket), 1))


def _setup_nv_magic_distributor(nv_params_start, nv_params_end):
    nodes = [NVNode(name="start_node", **nv_params_start), NVNode(name="end_node", **nv_params_end)]
    heralded_connection = HeraldedConnection(name="heralded_connection", length_A=10, length_B=15)

    return NVSingleClickMagicDistributor(nodes=nodes, heralded_connection=heralded_connection)


def test_setting_parameters_node():
    magic_distributor = _setup_nv_magic_distributor(nv_params_start=nv_params, nv_params_end=nv_params)

    for parameter in ["std_electron_electron_phase_drift", "p_double_exc", "delta_w",
                      "tau_decay", "p_fail_class_corr"]:
        assert magic_distributor.fixed_delivery_parameters[0][parameter] == nv_params[parameter]
    assert magic_distributor.fixed_delivery_parameters[0]["emission_duration"] == nv_params["photon_emission_delay"]


def test_different_node_parameters_leads_to_failure():
    nv_params_change_delta_w = copy.deepcopy(nv_params)
    nv_params_change_delta_w["delta_w"] = 0.2

    with pytest.raises(NotImplementedError):
        _setup_nv_magic_distributor(nv_params_start=nv_params, nv_params_end=nv_params_change_delta_w)

    nv_params_change_emission_duration = copy.deepcopy(nv_params)
    nv_params_change_emission_duration["photon_emission_delay"] = 3500.

    with pytest.raises(NotImplementedError):
        _setup_nv_magic_distributor(nv_params_start=nv_params, nv_params_end=nv_params_change_emission_duration)


def test_cycle_time():
    magic_distributor = _setup_nv_magic_distributor(nv_params_start=nv_params, nv_params_end=nv_params)
    cycle_time = 15 * 1E9 / 200000 * 2 + nv_params["photon_emission_delay"]  # 15 km divided by the speed of light * 2
    assert cycle_time == magic_distributor.fixed_delivery_parameters[0]["cycle_time"]


if __name__ == "__main__":
    unittest.main()
