import numpy as np
import unittest
import netsquid as ns
from netsquid.components.qprogram import QuantumProgram
import netsquid.components.instructions as ins
import netsquid.qubits.ketstates as ks
import netsquid.qubits.operators as ops
import netsquid.qubits.qubitapi as qapi
from netsquid_nv.move_circuits import reverse_move_using_CXDirections
from tests.test_rotated_measurement import get_noiseless_nv_quantum_processor


class TestMoveCircuit(unittest.TestCase):

    class ReverseMoveUsingCXDirectionsProgram(QuantumProgram):

        def program(self):
            electron_position, carbon_position = self.get_qubit_indices(2)
            self.apply(ins.INSTR_INIT, electron_position)
            reverse_move_using_CXDirections(qprogram=self,
                                            control_position=electron_position,
                                            target_position=carbon_position)
            yield self.run()

    def setUp(self):
        ns.sim_reset()
        electron_position = 0
        carbon_position = 1
        self.qmemory = get_noiseless_nv_quantum_processor(electron_position=electron_position,
                                                          carbon_positions=[carbon_position])
        qubits = qapi.create_qubits(2)
        self.qmemory.put(qubits=qubits,
                         positions=[electron_position, carbon_position])
        self.qprogram = TestMoveCircuit.ReverseMoveUsingCXDirectionsProgram()

    def assert_state_of_electron(self, state):
        [q_electron] = self.qmemory.peek(positions=[0])
        self.assertTrue(np.isclose(qapi.fidelity(q_electron, state), 1.0))

    def test_zero_state(self):
        r"""Set electron to :math:`|0\rangle` and carbon to :math:`|0\rangle`;
            after the reversed move, we expect the electron to be in
            :math:`H|0\rangle = |+\rangle"""
        self.qmemory.set_program_done_callback(
            callback=self.assert_state_of_electron,
            state=ks.h0)

    def test_one_state(self):
        r"""Set electron to :math:`|0\rangle` and carbon to :math:`|1\rangle`;
            after the reversed move, we expect the electron to be in
            :math:`H|1\rangle = |-\rangle"""
        [carbon_qubit] = self.qmemory.peek(positions=[1])
        qapi.operate(qubits=[carbon_qubit], operator=ops.X)
        self.qmemory.set_program_done_callback(
            callback=self.assert_state_of_electron,
            state=ks.h1)

    def test_plus_state(self):
        r"""Set electron to :math:`|0\rangle` and carbon to :math:`|+\rangle`;
            after the reversed move, we expect the electron to be in
            :math:`H|+\rangle = |0\rangle"""
        [carbon_qubit] = self.qmemory.peek(positions=[1])
        qapi.operate(qubits=[carbon_qubit], operator=ops.H)
        self.qmemory.set_program_done_callback(
            callback=self.assert_state_of_electron,
            state=ks.s0)

    def test_minus_state(self):
        r"""Set electron to :math:`|0\rangle` and carbon to :math:`|+\rangle`;
            after the reversed move, we expect the electron to be in
            :math:`H|-\rangle = |1\rangle"""
        [carbon_qubit] = self.qmemory.peek(positions=[1])
        qapi.operate(qubits=[carbon_qubit], operator=ops.X)
        qapi.operate(qubits=[carbon_qubit], operator=ops.H)
        self.qmemory.set_program_done_callback(
            callback=self.assert_state_of_electron,
            state=ks.s1)

    def tearDown(self):
        self.qmemory.execute_program(self.qprogram, qubit_mapping=[0, 1])
        ns.sim_run()
